webpackJsonp([0],[
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Random utility functions used in the UI-Router code
 *
 * These functions are exported, but are subject to change without notice.
 *
 * @preferred
 * @module common
 */
/** for typedoc */
var predicates_1 = __webpack_require__(1);
var hof_1 = __webpack_require__(2);
var coreservices_1 = __webpack_require__(3);
var w = typeof window === 'undefined' ? {} : window;
var angular = w.angular || {};
exports.fromJson = angular.fromJson || JSON.parse.bind(JSON);
exports.toJson = angular.toJson || JSON.stringify.bind(JSON);
exports.copy = angular.copy || _copy;
exports.forEach = angular.forEach || _forEach;
exports.extend = Object.assign || _extend;
exports.equals = angular.equals || _equals;
function identity(x) { return x; }
exports.identity = identity;
function noop() { }
exports.noop = noop;
/**
 * Builds proxy functions on the `to` object which pass through to the `from` object.
 *
 * For each key in `fnNames`, creates a proxy function on the `to` object.
 * The proxy function calls the real function on the `from` object.
 *
 *
 * #### Example:
 * This example creates an new class instance whose functions are prebound to the new'd object.
 * ```js
 * class Foo {
 *   constructor(data) {
 *     // Binds all functions from Foo.prototype to 'this',
 *     // then copies them to 'this'
 *     bindFunctions(Foo.prototype, this, this);
 *     this.data = data;
 *   }
 *
 *   log() {
 *     console.log(this.data);
 *   }
 * }
 *
 * let myFoo = new Foo([1,2,3]);
 * var logit = myFoo.log;
 * logit(); // logs [1, 2, 3] from the myFoo 'this' instance
 * ```
 *
 * #### Example:
 * This example creates a bound version of a service function, and copies it to another object
 * ```
 *
 * var SomeService = {
 *   this.data = [3, 4, 5];
 *   this.log = function() {
 *     console.log(this.data);
 *   }
 * }
 *
 * // Constructor fn
 * function OtherThing() {
 *   // Binds all functions from SomeService to SomeService,
 *   // then copies them to 'this'
 *   bindFunctions(SomeService, this, SomeService);
 * }
 *
 * let myOtherThing = new OtherThing();
 * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'
 * ```
 *
 * @param source A function that returns the source object which contains the original functions to be bound
 * @param target A function that returns the target object which will receive the bound functions
 * @param bind A function that returns the object which the functions will be bound to
 * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)
 * @param latebind If true, the binding of the function is delayed until the first time it's invoked
 */
function createProxyFunctions(source, target, bind, fnNames, latebind) {
    if (latebind === void 0) { latebind = false; }
    var bindFunction = function (fnName) {
        return source()[fnName].bind(bind());
    };
    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {
        target[fnName] = bindFunction(fnName);
        return target[fnName].apply(null, arguments);
    }; };
    fnNames = fnNames || Object.keys(source());
    return fnNames.reduce(function (acc, name) {
        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);
        return acc;
    }, target);
}
exports.createProxyFunctions = createProxyFunctions;
/**
 * prototypal inheritance helper.
 * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it
 */
exports.inherit = function (parent, extra) {
    return exports.extend(Object.create(parent), extra);
};
/**
 * Given an arguments object, converts the arguments at index idx and above to an array.
 * This is similar to es6 rest parameters.
 *
 * Optionally, the argument at index idx may itself already be an array.
 *
 * For example,
 * given either:
 *        arguments = [ obj, "foo", "bar" ]
 * or:
 *        arguments = [ obj, ["foo", "bar"] ]
 * then:
 *        restArgs(arguments, 1) == ["foo", "bar"]
 *
 * This allows functions like pick() to be implemented such that it allows either a bunch
 * of string arguments (like es6 rest parameters), or a single array of strings:
 *
 * given:
 *        var obj = { foo: 1, bar: 2, baz: 3 };
 * then:
 *        pick(obj, "foo", "bar");   // returns { foo: 1, bar: 2 }
 *        pick(obj, ["foo", "bar"]); // returns { foo: 1, bar: 2 }
 */
var restArgs = function (args, idx) {
    if (idx === void 0) { idx = 0; }
    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));
};
/** Given an array, returns true if the object is found in the array, (using indexOf) */
exports.inArray = hof_1.curry(_inArray);
function _inArray(array, obj) {
    return array.indexOf(obj) !== -1;
}
exports._inArray = _inArray;
/**
 * Given an array, and an item, if the item is found in the array, it removes it (in-place).
 * The same array is returned
 */
exports.removeFrom = hof_1.curry(_removeFrom);
function _removeFrom(array, obj) {
    var idx = array.indexOf(obj);
    if (idx >= 0)
        array.splice(idx, 1);
    return array;
}
exports._removeFrom = _removeFrom;
/** pushes a values to an array and returns the value */
exports.pushTo = hof_1.curry(_pushTo);
function _pushTo(arr, val) {
    return (arr.push(val), val);
}
exports._pushTo = _pushTo;
/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */
exports.deregAll = function (functions) {
    return functions.slice().forEach(function (fn) {
        typeof fn === 'function' && fn();
        exports.removeFrom(functions, fn);
    });
};
/**
 * Applies a set of defaults to an options object.  The options object is filtered
 * to only those properties of the objects in the defaultsList.
 * Earlier objects in the defaultsList take precedence when applying defaults.
 */
function defaults(opts) {
    var defaultsList = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        defaultsList[_i - 1] = arguments[_i];
    }
    var _defaultsList = defaultsList.concat({}).reverse();
    var defaultVals = exports.extend.apply(null, _defaultsList);
    return exports.extend({}, defaultVals, pick(opts || {}, Object.keys(defaultVals)));
}
exports.defaults = defaults;
/** Reduce function that merges each element of the list into a single object, using extend */
exports.mergeR = function (memo, item) { return exports.extend(memo, item); };
/**
 * Finds the common ancestor path between two states.
 *
 * @param {Object} first The first state.
 * @param {Object} second The second state.
 * @return {Array} Returns an array of state names in descending order, not including the root.
 */
function ancestors(first, second) {
    var path = [];
    for (var n in first.path) {
        if (first.path[n] !== second.path[n])
            break;
        path.push(first.path[n]);
    }
    return path;
}
exports.ancestors = ancestors;
/**
 * Return a copy of the object only containing the whitelisted properties.
 *
 * #### Example:
 * ```
 * var foo = { a: 1, b: 2, c: 3 };
 * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }
 * ```
 * @param obj the source object
 * @param propNames an Array of strings, which are the whitelisted property names
 */
function pick(obj, propNames) {
    var objCopy = {};
    for (var prop_1 in obj) {
        if (propNames.indexOf(prop_1) !== -1) {
            objCopy[prop_1] = obj[prop_1];
        }
    }
    return objCopy;
}
exports.pick = pick;
/**
 * Return a copy of the object omitting the blacklisted properties.
 *
 * @example
 * ```
 *
 * var foo = { a: 1, b: 2, c: 3 };
 * var ab = omit(foo, ['a', 'b']); // { c: 3 }
 * ```
 * @param obj the source object
 * @param propNames an Array of strings, which are the blacklisted property names
 */
function omit(obj, propNames) {
    return Object.keys(obj)
        .filter(hof_1.not(exports.inArray(propNames)))
        .reduce(function (acc, key) { return (acc[key] = obj[key], acc); }, {});
}
exports.omit = omit;
/**
 * Maps an array, or object to a property (by name)
 */
function pluck(collection, propName) {
    return map(collection, hof_1.prop(propName));
}
exports.pluck = pluck;
/** Filters an Array or an Object's properties based on a predicate */
function filter(collection, callback) {
    var arr = predicates_1.isArray(collection), result = arr ? [] : {};
    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };
    exports.forEach(collection, function (item, i) {
        if (callback(item, i))
            accept(item, i);
    });
    return result;
}
exports.filter = filter;
/** Finds an object from an array, or a property of an object, that matches a predicate */
function find(collection, callback) {
    var result;
    exports.forEach(collection, function (item, i) {
        if (result)
            return;
        if (callback(item, i))
            result = item;
    });
    return result;
}
exports.find = find;
/** Given an object, returns a new object, where each property is transformed by the callback function */
exports.mapObj = map;
/** Maps an array or object properties using a callback function */
function map(collection, callback) {
    var result = predicates_1.isArray(collection) ? [] : {};
    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });
    return result;
}
exports.map = map;
/**
 * Given an object, return its enumerable property values
 *
 * @example
 * ```
 *
 * let foo = { a: 1, b: 2, c: 3 }
 * let vals = values(foo); // [ 1, 2, 3 ]
 * ```
 */
exports.values = function (obj) {
    return Object.keys(obj).map(function (key) { return obj[key]; });
};
/**
 * Reduce function that returns true if all of the values are truthy.
 *
 * @example
 * ```
 *
 * let vals = [ 1, true, {}, "hello world"];
 * vals.reduce(allTrueR, true); // true
 *
 * vals.push(0);
 * vals.reduce(allTrueR, true); // false
 * ```
 */
exports.allTrueR = function (memo, elem) { return memo && elem; };
/**
 * Reduce function that returns true if any of the values are truthy.
 *
 *  * @example
 * ```
 *
 * let vals = [ 0, null, undefined ];
 * vals.reduce(anyTrueR, true); // false
 *
 * vals.push("hello world");
 * vals.reduce(anyTrueR, true); // true
 * ```
 */
exports.anyTrueR = function (memo, elem) { return memo || elem; };
/**
 * Reduce function which un-nests a single level of arrays
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * input.reduce(unnestR, []) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
 * ```
 */
exports.unnestR = function (memo, elem) { return memo.concat(elem); };
/**
 * Reduce function which recursively un-nests all arrays
 *
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * input.reduce(unnestR, []) // [ "a", "b", "c", "d", "double, "nested" ]
 * ```
 */
exports.flattenR = function (memo, elem) {
    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);
};
/**
 * Reduce function that pushes an object to an array, then returns the array.
 * Mostly just for [[flattenR]] and [[uniqR]]
 */
function pushR(arr, obj) {
    arr.push(obj);
    return arr;
}
exports.pushR = pushR;
/** Reduce function that filters out duplicates */
exports.uniqR = function (acc, token) {
    return exports.inArray(acc, token) ? acc : pushR(acc, token);
};
/**
 * Return a new array with a single level of arrays unnested.
 *
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * unnest(input) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
 * ```
 */
exports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };
/**
 * Return a completely flattened version of an array.
 *
 * @example
 * ```
 *
 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
 * flatten(input) // [ "a", "b", "c", "d", "double, "nested" ]
 * ```
 */
exports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };
/**
 * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.
 * @example
 * ```
 *
 * let isNumber = (obj) => typeof(obj) === 'number';
 * let allNumbers = [ 1, 2, 3, 4, 5 ];
 * allNumbers.filter(assertPredicate(isNumber)); //OK
 *
 * let oneString = [ 1, 2, 3, 4, "5" ];
 * oneString.filter(assertPredicate(isNumber, "Not all numbers")); // throws Error(""Not all numbers"");
 * ```
 */
exports.assertPredicate = assertFn;
/**
 * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.
 * @example
 * ```
 *
 * var data = { foo: 1, bar: 2 };
 *
 * let keys = [ 'foo', 'bar' ]
 * let values = keys.map(assertMap(key => data[key], "Key not found"));
 * // values is [1, 2]
 *
 * let keys = [ 'foo', 'bar', 'baz' ]
 * let values = keys.map(assertMap(key => data[key], "Key not found"));
 * // throws Error("Key not found")
 * ```
 */
exports.assertMap = assertFn;
function assertFn(predicateOrMap, errMsg) {
    if (errMsg === void 0) { errMsg = "assert failure"; }
    return function (obj) {
        var result = predicateOrMap(obj);
        if (!result) {
            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);
        }
        return result;
    };
}
exports.assertFn = assertFn;
/**
 * Like _.pairs: Given an object, returns an array of key/value pairs
 *
 * @example
 * ```
 *
 * pairs({ foo: "FOO", bar: "BAR }) // [ [ "foo", "FOO" ], [ "bar": "BAR" ] ]
 * ```
 */
exports.pairs = function (obj) {
    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });
};
/**
 * Given two or more parallel arrays, returns an array of tuples where
 * each tuple is composed of [ a[i], b[i], ... z[i] ]
 *
 * @example
 * ```
 *
 * let foo = [ 0, 2, 4, 6 ];
 * let bar = [ 1, 3, 5, 7 ];
 * let baz = [ 10, 30, 50, 70 ];
 * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]
 * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]
 * ```
 */
function arrayTuples() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length === 0)
        return [];
    var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53 − 1 aka Number.MAX_SAFE_INTEGER
    var i, result = [];
    for (i = 0; i < maxArrayLen; i++) {
        // This is a hot function
        // Unroll when there are 1-4 arguments
        switch (args.length) {
            case 1:
                result.push([args[0][i]]);
                break;
            case 2:
                result.push([args[0][i], args[1][i]]);
                break;
            case 3:
                result.push([args[0][i], args[1][i], args[2][i]]);
                break;
            case 4:
                result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);
                break;
            default:
                result.push(args.map(function (array) { return array[i]; }));
                break;
        }
    }
    return result;
}
exports.arrayTuples = arrayTuples;
/**
 * Reduce function which builds an object from an array of [key, value] pairs.
 *
 * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.
 *
 * Each keyValueTuple should be an array with values [ key: string, value: any ]
 *
 * @example
 * ```
 *
 * var pairs = [ ["fookey", "fooval"], ["barkey", "barval"] ]
 *
 * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})
 * // pairsToObj == { fookey: "fooval", barkey: "barval" }
 *
 * // Or, more simply:
 * var pairsToObj = pairs.reduce(applyPairs, {})
 * // pairsToObj == { fookey: "fooval", barkey: "barval" }
 * ```
 */
function applyPairs(memo, keyValTuple) {
    var key, value;
    if (predicates_1.isArray(keyValTuple))
        key = keyValTuple[0], value = keyValTuple[1];
    if (!predicates_1.isString(key))
        throw new Error("invalid parameters to applyPairs");
    memo[key] = value;
    return memo;
}
exports.applyPairs = applyPairs;
/** Get the last element of an array */
function tail(arr) {
    return arr.length && arr[arr.length - 1] || undefined;
}
exports.tail = tail;
/**
 * shallow copy from src to dest
 *
 * note: This is a shallow copy, while angular.copy is a deep copy.
 * ui-router uses `copy` only to make copies of state parameters.
 */
function _copy(src, dest) {
    if (dest)
        Object.keys(dest).forEach(function (key) { return delete dest[key]; });
    if (!dest)
        dest = {};
    return exports.extend(dest, src);
}
/** Naive forEach implementation works with Objects or Arrays */
function _forEach(obj, cb, _this) {
    if (predicates_1.isArray(obj))
        return obj.forEach(cb, _this);
    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });
}
function _extend(toObj) {
    for (var i = 1; i < arguments.length; i++) {
        var obj = arguments[i];
        if (!obj)
            continue;
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; j++) {
            toObj[keys[j]] = obj[keys[j]];
        }
    }
    return toObj;
}
exports._extend = _extend;
function _equals(o1, o2) {
    if (o1 === o2)
        return true;
    if (o1 === null || o2 === null)
        return false;
    if (o1 !== o1 && o2 !== o2)
        return true; // NaN === NaN
    var t1 = typeof o1, t2 = typeof o2;
    if (t1 !== t2 || t1 !== 'object')
        return false;
    var tup = [o1, o2];
    if (hof_1.all(predicates_1.isArray)(tup))
        return _arraysEq(o1, o2);
    if (hof_1.all(predicates_1.isDate)(tup))
        return o1.getTime() === o2.getTime();
    if (hof_1.all(predicates_1.isRegExp)(tup))
        return o1.toString() === o2.toString();
    if (hof_1.all(predicates_1.isFunction)(tup))
        return true; // meh
    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];
    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))
        return false;
    var key, keys = {};
    for (key in o1) {
        if (!_equals(o1[key], o2[key]))
            return false;
        keys[key] = true;
    }
    for (key in o2) {
        if (!keys[key])
            return false;
    }
    return true;
}
function _arraysEq(a1, a2) {
    if (a1.length !== a2.length)
        return false;
    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);
}
/**
 * Create a sort function
 *
 * Creates a sort function which sorts by a numeric property.
 *
 * The `propFn` should return the property as a number which can be sorted.
 *
 * #### Example:
 * This example returns the `priority` prop.
 * ```js
 * var sortfn = sortBy(obj => obj.priority)
 * // equivalent to:
 * var longhandSortFn = (a, b) => a.priority - b.priority;
 * ```
 *
 * #### Example:
 * This example uses [[prop]]
 * ```js
 * var sortfn = sortBy(prop('priority'))
 * ```
 *
 * The `checkFn` can be used to exclude objects from sorting.
 *
 * #### Example:
 * This example only sorts objects with type === 'FOO'
 * ```js
 * var sortfn = sortBy(prop('priority'), propEq('type', 'FOO'))
 * ```
 *
 * @param propFn a function that returns the property (as a number)
 * @param checkFn a predicate
 *
 * @return a sort function like: `(a, b) => (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0`
 */
exports.sortBy = function (propFn, checkFn) {
    if (checkFn === void 0) { checkFn = hof_1.val(true); }
    return function (a, b) {
        return (checkFn(a) && checkFn(b)) ? propFn(a) - propFn(b) : 0;
    };
};
/**
 * Composes a list of sort functions
 *
 * Creates a sort function composed of multiple sort functions.
 * Each sort function is invoked in series.
 * The first sort function to return non-zero "wins".
 *
 * @param sortFns list of sort functions
 */
exports.composeSort = function () {
    var sortFns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sortFns[_i] = arguments[_i];
    }
    return function composedSort(a, b) {
        return sortFns.reduce(function (prev, fn) { return prev || fn(a, b); }, 0);
    };
};
// issue #2676
exports.silenceUncaughtInPromise = function (promise) {
    return promise.catch(function (e) { return 0; }) && promise;
};
exports.silentRejection = function (error) {
    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));
};
//# sourceMappingURL=common.js.map

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** Predicates
 *
 * These predicates return true/false based on the input.
 * Although these functions are exported, they are subject to change without notice.
 *
 * @module common_predicates
 */
/** */
var hof_1 = __webpack_require__(2);
var stateObject_1 = __webpack_require__(26);
var toStr = Object.prototype.toString;
var tis = function (t) { return function (x) { return typeof (x) === t; }; };
exports.isUndefined = tis('undefined');
exports.isDefined = hof_1.not(exports.isUndefined);
exports.isNull = function (o) { return o === null; };
exports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);
exports.isFunction = tis('function');
exports.isNumber = tis('number');
exports.isString = tis('string');
exports.isObject = function (x) { return x !== null && typeof x === 'object'; };
exports.isArray = Array.isArray;
exports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });
exports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });
exports.isState = stateObject_1.StateObject.isState;
/**
 * Predicate which checks if a value is injectable
 *
 * A value is "injectable" if it is a function, or if it is an ng1 array-notation-style array
 * where all the elements in the array are Strings, except the last one, which is a Function
 */
function isInjectable(val) {
    if (exports.isArray(val) && val.length) {
        var head = val.slice(0, -1), tail = val.slice(-1);
        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);
    }
    return exports.isFunction(val);
}
exports.isInjectable = isInjectable;
/**
 * Predicate which checks if a value looks like a Promise
 *
 * It is probably a Promise if it's an object, and it has a `then` property which is a Function
 */
exports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));
//# sourceMappingURL=predicates.js.map

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Higher order functions
 *
 * These utility functions are exported, but are subject to change without notice.
 *
 * @module common_hof
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.
 *
 * Given a function with N parameters, returns a new function that supports partial application.
 * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,
 * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to
 * accept more parameters until all N parameters have been supplied.
 *
 *
 * This contrived example uses a partially applied function as an predicate, which returns true
 * if an object is found in both arrays.
 * @example
 * ```
 * // returns true if an object is in both of the two arrays
 * function inBoth(array1, array2, object) {
 *   return array1.indexOf(object) !== -1 &&
 *          array2.indexOf(object) !== 1;
 * }
 * let obj1, obj2, obj3, obj4, obj5, obj6, obj7
 * let foos = [obj1, obj3]
 * let bars = [obj3, obj4, obj5]
 *
 * // A curried "copy" of inBoth
 * let curriedInBoth = curry(inBoth);
 * // Partially apply both the array1 and array2
 * let inFoosAndBars = curriedInBoth(foos, bars);
 *
 * // Supply the final argument; since all arguments are
 * // supplied, the original inBoth function is then called.
 * let obj1InBoth = inFoosAndBars(obj1); // false
 *
 * // Use the inFoosAndBars as a predicate.
 * // Filter, on each iteration, supplies the final argument
 * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];
 * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]
 *
 * ```
 *
 * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function
 *
 * @param fn
 * @returns {*|function(): (*|any)}
 */
function curry(fn) {
    var initial_args = [].slice.apply(arguments, [1]);
    var func_args_length = fn.length;
    function curried(args) {
        if (args.length >= func_args_length)
            return fn.apply(null, args);
        return function () {
            return curried(args.concat([].slice.apply(arguments)));
        };
    }
    return curried(initial_args);
}
exports.curry = curry;
/**
 * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left
 * given: f(x), g(x), h(x)
 * let composed = compose(f,g,h)
 * then, composed is: f(g(h(x)))
 */
function compose() {
    var args = arguments;
    var start = args.length - 1;
    return function () {
        var i = start, result = args[start].apply(this, arguments);
        while (i--)
            result = args[i].call(this, result);
        return result;
    };
}
exports.compose = compose;
/**
 * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right
 * given: f(x), g(x), h(x)
 * let piped = pipe(f,g,h);
 * then, piped is: h(g(f(x)))
 */
function pipe() {
    var funcs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        funcs[_i] = arguments[_i];
    }
    return compose.apply(null, [].slice.call(arguments).reverse());
}
exports.pipe = pipe;
/**
 * Given a property name, returns a function that returns that property from an object
 * let obj = { foo: 1, name: "blarg" };
 * let getName = prop("name");
 * getName(obj) === "blarg"
 */
exports.prop = function (name) {
    return function (obj) { return obj && obj[name]; };
};
/**
 * Given a property name and a value, returns a function that returns a boolean based on whether
 * the passed object has a property that matches the value
 * let obj = { foo: 1, name: "blarg" };
 * let getName = propEq("name", "blarg");
 * getName(obj) === true
 */
exports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });
/**
 * Given a dotted property name, returns a function that returns a nested property from an object, or undefined
 * let obj = { id: 1, nestedObj: { foo: 1, name: "blarg" }, };
 * let getName = prop("nestedObj.name");
 * getName(obj) === "blarg"
 * let propNotFound = prop("this.property.doesnt.exist");
 * propNotFound(obj) === undefined
 */
exports.parse = function (name) {
    return pipe.apply(null, name.split(".").map(exports.prop));
};
/**
 * Given a function that returns a truthy or falsey value, returns a
 * function that returns the opposite (falsey or truthy) value given the same inputs
 */
exports.not = function (fn) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return !fn.apply(null, args);
    };
};
/**
 * Given two functions that return truthy or falsey values, returns a function that returns truthy
 * if both functions return truthy for the given arguments
 */
function and(fn1, fn2) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return fn1.apply(null, args) && fn2.apply(null, args);
    };
}
exports.and = and;
/**
 * Given two functions that return truthy or falsey values, returns a function that returns truthy
 * if at least one of the functions returns truthy for the given arguments
 */
function or(fn1, fn2) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return fn1.apply(null, args) || fn2.apply(null, args);
    };
}
exports.or = or;
/**
 * Check if all the elements of an array match a predicate function
 *
 * @param fn1 a predicate function `fn1`
 * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array
 */
exports.all = function (fn1) {
    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };
};
exports.any = function (fn1) {
    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };
};
/** Given a class, returns a Predicate function that returns true if the object is of that class */
exports.is = function (ctor) {
    return function (obj) {
        return (obj != null && obj.constructor === ctor || obj instanceof ctor);
    };
};
/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */
exports.eq = function (val) { return function (other) {
    return val === other;
}; };
/** Given a value, returns a function which returns the value */
exports.val = function (v) { return function () { return v; }; };
function invoke(fnName, args) {
    return function (obj) {
        return obj[fnName].apply(obj, args);
    };
}
exports.invoke = invoke;
/**
 * Sorta like Pattern Matching (a functional programming conditional construct)
 *
 * See http://c2.com/cgi/wiki?PatternMatching
 *
 * This is a conditional construct which allows a series of predicates and output functions
 * to be checked and then applied.  Each predicate receives the input.  If the predicate
 * returns truthy, then its matching output function (mapping function) is provided with
 * the input and, then the result is returned.
 *
 * Each combination (2-tuple) of predicate + output function should be placed in an array
 * of size 2: [ predicate, mapFn ]
 *
 * These 2-tuples should be put in an outer array.
 *
 * @example
 * ```
 *
 * // Here's a 2-tuple where the first element is the isString predicate
 * // and the second element is a function that returns a description of the input
 * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];
 *
 * // Second tuple: predicate "isNumber", mapfn returns a description
 * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];
 *
 * let third = [ (input) => input === null,  (input) => `Oh, null...` ];
 *
 * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];
 *
 * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);
 *
 * console.log(descriptionOf(undefined)); // 'notdefined'
 * console.log(descriptionOf(55)); // '(55) That's a number!'
 * console.log(descriptionOf("foo")); // 'Here's your string foo'
 * ```
 *
 * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,
 * with a Predicate and a mapping/output function
 * @returns {function(any): *}
 */
function pattern(struct) {
    return function (x) {
        for (var i = 0; i < struct.length; i++) {
            if (struct[i][0](x))
                return struct[i][1](x);
        }
    };
}
exports.pattern = pattern;
//# sourceMappingURL=hof.js.map

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.notImplemented = function (fnname) { return function () {
    throw new Error(fnname + "(): No coreservices implementation for UI-Router is loaded.");
}; };
var services = {
    $q: undefined,
    $injector: undefined,
};
exports.services = services;
//# sourceMappingURL=coreservices.js.map

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module common
 */ /** */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(17));
__export(__webpack_require__(77));
__export(__webpack_require__(78));
__export(__webpack_require__(79));
__export(__webpack_require__(80));
__export(__webpack_require__(81));
__export(__webpack_require__(82));
__export(__webpack_require__(86));
__export(__webpack_require__(31));
__export(__webpack_require__(36));
__export(__webpack_require__(83));
__export(__webpack_require__(76));
//# sourceMappingURL=index.js.map

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Functions that manipulate strings
 *
 * Although these functions are exported, they are subject to change without notice.
 *
 * @module common_strings
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
var predicates_1 = __webpack_require__(1);
var rejectFactory_1 = __webpack_require__(13);
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var transition_1 = __webpack_require__(20);
var resolvable_1 = __webpack_require__(12);
/**
 * Returns a string shortened to a maximum length
 *
 * If the string is already less than the `max` length, return the string.
 * Else return the string, shortened to `max - 3` and append three dots ("...").
 *
 * @param max the maximum length of the string to return
 * @param str the input string
 */
function maxLength(max, str) {
    if (str.length <= max)
        return str;
    return str.substr(0, max - 3) + "...";
}
exports.maxLength = maxLength;
/**
 * Returns a string, with spaces added to the end, up to a desired str length
 *
 * If the string is already longer than the desired length, return the string.
 * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.
 *
 * @param length the desired length of the string to return
 * @param str the input string
 */
function padString(length, str) {
    while (str.length < length)
        str += " ";
    return str;
}
exports.padString = padString;
function kebobString(camelCase) {
    return camelCase
        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char
        .replace(/([A-Z])/g, function ($1) { return "-" + $1.toLowerCase(); }); // replace rest
}
exports.kebobString = kebobString;
function _toJson(obj) {
    return JSON.stringify(obj);
}
function _fromJson(json) {
    return predicates_1.isString(json) ? JSON.parse(json) : json;
}
function promiseToString(p) {
    return "Promise(" + JSON.stringify(p) + ")";
}
function functionToString(fn) {
    var fnStr = fnToString(fn);
    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/);
    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;
    var fnName = fn['name'] || "";
    if (fnName && toStr.match(/function \(/)) {
        return 'function ' + fnName + toStr.substr(9);
    }
    return toStr;
}
exports.functionToString = functionToString;
function fnToString(fn) {
    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;
    return _fn && _fn.toString() || "undefined";
}
exports.fnToString = fnToString;
var stringifyPatternFn = null;
var stringifyPattern = function (value) {
    var isRejection = rejectFactory_1.Rejection.isRejectionPromise;
    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([
        [hof_1.not(predicates_1.isDefined), hof_1.val("undefined")],
        [predicates_1.isNull, hof_1.val("null")],
        [predicates_1.isPromise, hof_1.val("[Promise]")],
        [isRejection, function (x) { return x._transitionRejection.toString(); }],
        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke("toString")],
        [hof_1.is(transition_1.Transition), hof_1.invoke("toString")],
        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke("toString")],
        [predicates_1.isInjectable, functionToString],
        [hof_1.val(true), common_1.identity]
    ]);
    return stringifyPatternFn(value);
};
function stringify(o) {
    var seen = [];
    function format(val) {
        if (predicates_1.isObject(val)) {
            if (seen.indexOf(val) !== -1)
                return '[circular ref]';
            seen.push(val);
        }
        return stringifyPattern(val);
    }
    return JSON.stringify(o, function (key, val) { return format(val); }).replace(/\\"/g, '"');
}
exports.stringify = stringify;
/** Returns a function that splits a string on a character or substring */
exports.beforeAfterSubstr = function (char) { return function (str) {
    if (!str)
        return ["", ""];
    var idx = str.indexOf(char);
    if (idx === -1)
        return [str, ""];
    return [str.substr(0, idx), str.substr(idx + 1)];
}; };
/**
 * Splits on a delimiter, but returns the delimiters in the array
 *
 * #### Example:
 * ```js
 * var splitOnSlashes = splitOnDelim('/');
 * splitOnSlashes("/foo"); // ["/", "foo"]
 * splitOnSlashes("/foo/"); // ["/", "foo", "/"]
 * ```
 */
function splitOnDelim(delim) {
    var re = new RegExp("(" + delim + ")", "g");
    return function (str) {
        return str.split(re).filter(common_1.identity);
    };
}
exports.splitOnDelim = splitOnDelim;
;
/**
 * Reduce fn that joins neighboring strings
 *
 * Given an array of strings, returns a new array
 * where all neighboring strings have been joined.
 *
 * #### Example:
 * ```js
 * let arr = ["foo", "bar", 1, "baz", "", "qux" ];
 * arr.reduce(joinNeighborsR, []) // ["foobar", 1, "bazqux" ]
 * ```
 */
function joinNeighborsR(acc, x) {
    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))
        return acc.slice(0, -1).concat(common_1.tail(acc) + x);
    return common_1.pushR(acc, x);
}
exports.joinNeighborsR = joinNeighborsR;
;
//# sourceMappingURL=strings.js.map

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * # Transition tracing (debug)
 *
 * Enable transition tracing to print transition information to the console,
 * in order to help debug your application.
 * Tracing logs detailed information about each Transition to your console.
 *
 * To enable tracing, import the [[Trace]] singleton and enable one or more categories.
 *
 * ### ES6
 * ```js
 * import {trace} from "ui-router-ng2"; // or "angular-ui-router"
 * trace.enable(1, 5); // TRANSITION and VIEWCONFIG
 * ```
 *
 * ### CJS
 * ```js
 * let trace = require("angular-ui-router").trace; // or "ui-router-ng2"
 * trace.enable("TRANSITION", "VIEWCONFIG");
 * ```
 *
 * ### Globals
 * ```js
 * let trace = window["angular-ui-router"].trace; // or "ui-router-ng2"
 * trace.enable(); // Trace everything (very verbose)
 * ```
 *
 * ### Angular 1:
 * ```js
 * app.run($trace => $trace.enable());
 * ```
 *
 * @coreapi
 * @module trace
 */ /** for typedoc */
var hof_1 = __webpack_require__(2);
var predicates_1 = __webpack_require__(1);
var strings_1 = __webpack_require__(5);
/** @hidden */
function uiViewString(viewData) {
    if (!viewData)
        return 'ui-view (defunct)';
    return "[ui-view#" + viewData.id + " tag " +
        ("in template from '" + (viewData.creationContext && viewData.creationContext.name || '(root)') + "' state]: ") +
        ("fqn: '" + viewData.fqn + "', ") +
        ("name: '" + viewData.name + "@" + viewData.creationContext + "')");
}
/** @hidden */
var viewConfigString = function (viewConfig) {
    return "[ViewConfig#" + viewConfig.$id + " from '" + (viewConfig.viewDecl.$context.name || '(root)') + "' state]: target ui-view: '" + viewConfig.viewDecl.$uiViewName + "@" + viewConfig.viewDecl.$uiViewContextAnchor + "'";
};
/** @hidden */
function normalizedCat(input) {
    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];
}
/**
 * Trace categories Enum
 *
 * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]
 *
 * `trace.enable(Category.TRANSITION)`
 *
 * These can also be provided using a matching string, or position ordinal
 *
 * `trace.enable("TRANSITION")`
 *
 * `trace.enable(1)`
 */
var Category;
(function (Category) {
    Category[Category["RESOLVE"] = 0] = "RESOLVE";
    Category[Category["TRANSITION"] = 1] = "TRANSITION";
    Category[Category["HOOK"] = 2] = "HOOK";
    Category[Category["UIVIEW"] = 3] = "UIVIEW";
    Category[Category["VIEWCONFIG"] = 4] = "VIEWCONFIG";
})(Category = exports.Category || (exports.Category = {}));
/** @hidden */ var _tid = hof_1.parse("$id");
/** @hidden */ var _rid = hof_1.parse("router.$id");
/** @hidden */ var transLbl = function (trans) { return "Transition #" + _tid(trans) + "-" + _rid(trans); };
/**
 * Prints UI-Router Transition trace information to the console.
 */
var Trace = (function () {
    /** @hidden */
    function Trace() {
        /** @hidden */
        this._enabled = {};
        this.approximateDigests = 0;
    }
    /** @hidden */
    Trace.prototype._set = function (enabled, categories) {
        var _this = this;
        if (!categories.length) {
            categories = Object.keys(Category)
                .map(function (k) { return parseInt(k, 10); })
                .filter(function (k) { return !isNaN(k); })
                .map(function (key) { return Category[key]; });
        }
        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });
    };
    /**
     * Enables a trace [[Category]]
     *
     * ```js
     * trace.enable("TRANSITION");
     * ```
     *
     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.
     *        Also takes strings (category name) or ordinal (category position)
     */
    Trace.prototype.enable = function () {
        var categories = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            categories[_i] = arguments[_i];
        }
        this._set(true, categories);
    };
    /**
     * Disables a trace [[Category]]
     *
     * ```js
     * trace.disable("VIEWCONFIG");
     * ```
     *
     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.
     *        Also takes strings (category name) or ordinal (category position)
     */
    Trace.prototype.disable = function () {
        var categories = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            categories[_i] = arguments[_i];
        }
        this._set(false, categories);
    };
    /**
     * Retrieves the enabled stateus of a [[Category]]
     *
     * ```js
     * trace.enabled("VIEWCONFIG"); // true or false
     * ```
     *
     * @returns boolean true if the category is enabled
     */
    Trace.prototype.enabled = function (category) {
        return !!this._enabled[normalizedCat(category)];
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceTransitionStart = function (trans) {
        if (!this.enabled(Category.TRANSITION))
            return;
        console.log(transLbl(trans) + ": Started  -> " + strings_1.stringify(trans));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceTransitionIgnored = function (trans) {
        if (!this.enabled(Category.TRANSITION))
            return;
        console.log(transLbl(trans) + ": Ignored  <> " + strings_1.stringify(trans));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceHookInvocation = function (step, trans, options) {
        if (!this.enabled(Category.HOOK))
            return;
        var event = hof_1.parse("traceData.hookType")(options) || "internal", context = hof_1.parse("traceData.context.state.name")(options) || hof_1.parse("traceData.context")(options) || "unknown", name = strings_1.functionToString(step.registeredHook.callback);
        console.log(transLbl(trans) + ":   Hook -> " + event + " context: " + context + ", " + strings_1.maxLength(200, name));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {
        if (!this.enabled(Category.HOOK))
            return;
        console.log(transLbl(trans) + ":   <- Hook returned: " + strings_1.maxLength(200, strings_1.stringify(hookResult)));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceResolvePath = function (path, when, trans) {
        if (!this.enabled(Category.RESOLVE))
            return;
        console.log(transLbl(trans) + ":         Resolving " + path + " (" + when + ")");
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {
        if (!this.enabled(Category.RESOLVE))
            return;
        console.log(transLbl(trans) + ":               <- Resolved  " + resolvable + " to: " + strings_1.maxLength(200, strings_1.stringify(resolvable.data)));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceError = function (reason, trans) {
        if (!this.enabled(Category.TRANSITION))
            return;
        console.log(transLbl(trans) + ": <- Rejected " + strings_1.stringify(trans) + ", reason: " + reason);
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceSuccess = function (finalState, trans) {
        if (!this.enabled(Category.TRANSITION))
            return;
        console.log(transLbl(trans) + ": <- Success  " + strings_1.stringify(trans) + ", final state: " + finalState.name);
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {
        if (extra === void 0) { extra = ""; }
        if (!this.enabled(Category.UIVIEW))
            return;
        console.log("ui-view: " + strings_1.padString(30, event) + " " + uiViewString(viewData) + extra);
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {
        if (!this.enabled(Category.UIVIEW))
            return;
        this.traceUIViewEvent("Updating", viewData, " with ViewConfig from context='" + context + "'");
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceUIViewFill = function (viewData, html) {
        if (!this.enabled(Category.UIVIEW))
            return;
        this.traceUIViewEvent("Fill", viewData, " with: " + strings_1.maxLength(200, html));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {
        if (!this.enabled(Category.VIEWCONFIG))
            return;
        console.log("VIEWCONFIG: " + event + " " + viewConfigString(viewConfig));
    };
    /** @internalapi called by ui-router code */
    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {
        if (!this.enabled(Category.VIEWCONFIG))
            return;
        console.log("VIEWCONFIG: " + event + " " + uiViewString(viewData));
    };
    return Trace;
}());
exports.Trace = Trace;
/**
 * The [[Trace]] singleton
 *
 * #### Example:
 * ```js
 * import {trace} from "angular-ui-router";
 * trace.enable(1, 5);
 * ```
 */
var trace = new Trace();
exports.trace = trace;
//# sourceMappingURL=trace.js.map

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module state
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
/**
 * Encapsulate the target (destination) state/params/options of a [[Transition]].
 *
 * This class is frequently used to redirect a transition to a new destination.
 *
 * See:
 *
 * - [[HookResult]]
 * - [[TransitionHookFn]]
 * - [[TransitionService.onStart]]
 *
 * To create a `TargetState`, use [[StateService.target]].
 *
 * ---
 *
 * This class wraps:
 *
 * 1) an identifier for a state
 * 2) a set of parameters
 * 3) and transition options
 * 4) the registered state object (the [[StateDeclaration]])
 *
 * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can
 * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).
 * The `TargetState` class normalizes those options.
 *
 * A `TargetState` may be valid (the state being targeted exists in the registry)
 * or invalid (the state being targeted is not registered).
 */
var TargetState = (function () {
    /**
     * The TargetState constructor
     *
     * Note: Do not construct a `TargetState` manually.
     * To create a `TargetState`, use the [[StateService.target]] factory method.
     *
     * @param _identifier An identifier for a state.
     *    Either a fully-qualified state name, or the object used to define the state.
     * @param _definition The internal state representation, if exists.
     * @param _params Parameters for the target state
     * @param _options Transition options.
     *
     * @internalapi
     */
    function TargetState(_identifier, _definition, _params, _options) {
        if (_options === void 0) { _options = {}; }
        this._identifier = _identifier;
        this._definition = _definition;
        this._options = _options;
        this._params = _params || {};
    }
    /** The name of the state this object targets */
    TargetState.prototype.name = function () {
        return this._definition && this._definition.name || this._identifier;
    };
    /** The identifier used when creating this TargetState */
    TargetState.prototype.identifier = function () {
        return this._identifier;
    };
    /** The target parameter values */
    TargetState.prototype.params = function () {
        return this._params;
    };
    /** The internal state object (if it was found) */
    TargetState.prototype.$state = function () {
        return this._definition;
    };
    /** The internal state declaration (if it was found) */
    TargetState.prototype.state = function () {
        return this._definition && this._definition.self;
    };
    /** The target options */
    TargetState.prototype.options = function () {
        return this._options;
    };
    /** True if the target state was found */
    TargetState.prototype.exists = function () {
        return !!(this._definition && this._definition.self);
    };
    /** True if the object is valid */
    TargetState.prototype.valid = function () {
        return !this.error();
    };
    /** If the object is invalid, returns the reason why */
    TargetState.prototype.error = function () {
        var base = this.options().relative;
        if (!this._definition && !!base) {
            var stateName = base.name ? base.name : base;
            return "Could not resolve '" + this.name() + "' from state '" + stateName + "'";
        }
        if (!this._definition)
            return "No such state '" + this.name() + "'";
        if (!this._definition.self)
            return "State '" + this.name() + "' has an invalid definition";
    };
    TargetState.prototype.toString = function () {
        return "'" + this.name() + "'" + common_1.toJson(this.params());
    };
    return TargetState;
}());
/** Returns true if the object has a state property that might be a state or state name */
TargetState.isDef = function (obj) {
    return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));
};
exports.TargetState = TargetState;
//# sourceMappingURL=targetState.js.map

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module params
 */ /** for typedoc */
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var predicates_1 = __webpack_require__(1);
var coreservices_1 = __webpack_require__(3);
var paramType_1 = __webpack_require__(24);
/** @hidden */ var hasOwn = Object.prototype.hasOwnProperty;
/** @hidden */ var isShorthand = function (cfg) {
    return ["value", "type", "squash", "array", "dynamic"].filter(hasOwn.bind(cfg || {})).length === 0;
};
/** @internalapi */
var DefType;
(function (DefType) {
    DefType[DefType["PATH"] = 0] = "PATH";
    DefType[DefType["SEARCH"] = 1] = "SEARCH";
    DefType[DefType["CONFIG"] = 2] = "CONFIG";
})(DefType = exports.DefType || (exports.DefType = {}));
/** @hidden */
function unwrapShorthand(cfg) {
    cfg = isShorthand(cfg) && { value: cfg } || cfg;
    getStaticDefaultValue['__cacheable'] = true;
    function getStaticDefaultValue() {
        return cfg.value;
    }
    return common_1.extend(cfg, {
        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue,
    });
}
/** @hidden */
function getType(cfg, urlType, location, id, paramTypes) {
    if (cfg.type && urlType && urlType.name !== 'string')
        throw new Error("Param '" + id + "' has two type configurations.");
    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))
        return paramTypes.type(cfg.type);
    if (urlType)
        return urlType;
    if (!cfg.type) {
        var type = location === DefType.CONFIG ? "any" :
            location === DefType.PATH ? "path" :
                location === DefType.SEARCH ? "query" : "string";
        return paramTypes.type(type);
    }
    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);
}
/**
 * @internalapi
 * returns false, true, or the squash value to indicate the "default parameter url squash policy".
 */
function getSquashPolicy(config, isOptional, defaultPolicy) {
    var squash = config.squash;
    if (!isOptional || squash === false)
        return false;
    if (!predicates_1.isDefined(squash) || squash == null)
        return defaultPolicy;
    if (squash === true || predicates_1.isString(squash))
        return squash;
    throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
}
/** @internalapi */
function getReplace(config, arrayMode, isOptional, squash) {
    var replace, configuredKeys, defaultPolicy = [
        { from: "", to: (isOptional || arrayMode ? undefined : "") },
        { from: null, to: (isOptional || arrayMode ? undefined : "") },
    ];
    replace = predicates_1.isArray(config.replace) ? config.replace : [];
    if (predicates_1.isString(squash))
        replace.push({ from: squash, to: undefined });
    configuredKeys = common_1.map(replace, hof_1.prop("from"));
    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);
}
/** @internalapi */
var Param = (function () {
    function Param(id, type, config, location, urlMatcherFactory) {
        config = unwrapShorthand(config);
        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);
        var arrayMode = getArrayMode();
        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;
        var isOptional = config.value !== undefined || location === DefType.SEARCH;
        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;
        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;
        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());
        var replace = getReplace(config, arrayMode, isOptional, squash);
        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;
        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
        function getArrayMode() {
            var arrayDefaults = { array: (location === DefType.SEARCH ? "auto" : false) };
            var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;
        }
        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config });
    }
    Param.prototype.isDefaultValue = function (value) {
        return this.isOptional && this.type.equals(this.value(), value);
    };
    /**
     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
     * default value, which may be the result of an injectable function.
     */
    Param.prototype.value = function (value) {
        var _this = this;
        /**
         * [Internal] Get the default value of a parameter, which may be an injectable function.
         */
        var getDefaultValue = function () {
            if (_this._defaultValueCache)
                return _this._defaultValueCache.defaultValue;
            if (!coreservices_1.services.$injector)
                throw new Error("Injectable functions cannot be called at configuration time");
            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);
            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))
                throw new Error("Default value (" + defaultValue + ") for parameter '" + _this.id + "' is not an instance of ParamType (" + _this.type.name + ")");
            if (_this.config.$$fn['__cacheable']) {
                _this._defaultValueCache = { defaultValue: defaultValue };
            }
            return defaultValue;
        };
        var replaceSpecialValues = function (val) {
            for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {
                var tuple = _a[_i];
                if (tuple.from === val)
                    return tuple.to;
            }
            return val;
        };
        value = replaceSpecialValues(value);
        return predicates_1.isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);
    };
    Param.prototype.isSearch = function () {
        return this.location === DefType.SEARCH;
    };
    Param.prototype.validates = function (value) {
        // There was no parameter value, but the param is optional
        if ((predicates_1.isUndefined(value) || value === null) && this.isOptional)
            return true;
        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType
        var normalized = this.type.$normalize(value);
        if (!this.type.is(normalized))
            return false;
        // The value was of the correct type, but when encoded, did not match the ParamType's regexp
        var encoded = this.type.encode(normalized);
        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));
    };
    Param.prototype.toString = function () {
        return "{Param:" + this.id + " " + this.type + " squash: '" + this.squash + "' optional: " + this.isOptional + "}";
    };
    Param.values = function (params, values) {
        if (values === void 0) { values = {}; }
        var paramValues = {};
        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
            var param = params_1[_i];
            paramValues[param.id] = param.value(values[param.id]);
        }
        return paramValues;
    };
    /**
     * Finds [[Param]] objects which have different param values
     *
     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects
     *
     * @param params: The list of Param objects to filter
     * @param values1: The first set of parameter values
     * @param values2: the second set of parameter values
     *
     * @returns any Param objects whose values were different between values1 and values2
     */
    Param.changed = function (params, values1, values2) {
        if (values1 === void 0) { values1 = {}; }
        if (values2 === void 0) { values2 = {}; }
        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });
    };
    /**
     * Checks if two param value objects are equal (for a set of [[Param]] objects)
     *
     * @param params The list of [[Param]] objects to check
     * @param values1 The first set of param values
     * @param values2 The second set of param values
     *
     * @returns true if the param values in values1 and values2 are equal
     */
    Param.equals = function (params, values1, values2) {
        if (values1 === void 0) { values1 = {}; }
        if (values2 === void 0) { values2 = {}; }
        return Param.changed(params, values1, values2).length === 0;
    };
    /** Returns true if a the parameter values are valid, according to the Param definitions */
    Param.validates = function (params, values) {
        if (values === void 0) { values = {}; }
        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);
    };
    return Param;
}());
exports.Param = Param;
//# sourceMappingURL=param.js.map

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TransitionHookPhase;
(function (TransitionHookPhase) {
    TransitionHookPhase[TransitionHookPhase["CREATE"] = 0] = "CREATE";
    TransitionHookPhase[TransitionHookPhase["BEFORE"] = 1] = "BEFORE";
    TransitionHookPhase[TransitionHookPhase["RUN"] = 2] = "RUN";
    TransitionHookPhase[TransitionHookPhase["SUCCESS"] = 3] = "SUCCESS";
    TransitionHookPhase[TransitionHookPhase["ERROR"] = 4] = "ERROR";
})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));
var TransitionHookScope;
(function (TransitionHookScope) {
    TransitionHookScope[TransitionHookScope["TRANSITION"] = 0] = "TRANSITION";
    TransitionHookScope[TransitionHookScope["STATE"] = 1] = "STATE";
})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));
//# sourceMappingURL=interface.js.map

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ng_from_import = __webpack_require__(11);
var ng_from_global = angular;
exports.ng = (ng_from_import && ng_from_import.module) ? ng_from_import : ng_from_global;
//# sourceMappingURL=angular.js.map

/***/ }),
/* 11 */,
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module resolve
 */ /** for typedoc */
var common_1 = __webpack_require__(0);
var coreservices_1 = __webpack_require__(3);
var trace_1 = __webpack_require__(6);
var strings_1 = __webpack_require__(5);
var predicates_1 = __webpack_require__(1);
// TODO: explicitly make this user configurable
exports.defaultResolvePolicy = {
    when: "LAZY",
    async: "WAIT"
};
/**
 * The basic building block for the resolve system.
 *
 * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),
 * and the unwrapped-when-complete (.data) result of the resolveFn.
 *
 * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the
 * resolveFn) and returns the resulting promise.
 *
 * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first
 * parameter to those fns.
 */
var Resolvable = (function () {
    function Resolvable(arg1, resolveFn, deps, policy, data) {
        this.resolved = false;
        this.promise = undefined;
        if (arg1 instanceof Resolvable) {
            common_1.extend(this, arg1);
        }
        else if (predicates_1.isFunction(resolveFn)) {
            if (arg1 == null || arg1 == undefined)
                throw new Error("new Resolvable(): token argument is required");
            if (!predicates_1.isFunction(resolveFn))
                throw new Error("new Resolvable(): resolveFn argument must be a function");
            this.token = arg1;
            this.policy = policy;
            this.resolveFn = resolveFn;
            this.deps = deps || [];
            this.data = data;
            this.resolved = data !== undefined;
            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;
        }
        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {
            var literal = arg1;
            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);
        }
    }
    Resolvable.prototype.getPolicy = function (state) {
        var thisPolicy = this.policy || {};
        var statePolicy = state && state.resolvePolicy || {};
        return {
            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,
            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,
        };
    };
    /**
     * Asynchronously resolve this Resolvable's data
     *
     * Given a ResolveContext that this Resolvable is found in:
     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function
     * and update the Resolvable's state
     */
    Resolvable.prototype.resolve = function (resolveContext, trans) {
        var _this = this;
        var $q = coreservices_1.services.$q;
        // Gets all dependencies from ResolveContext and wait for them to be resolved
        var getResolvableDependencies = function () {
            return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) {
                return resolvable.get(resolveContext, trans);
            }));
        };
        // Invokes the resolve function passing the resolved dependencies as arguments
        var invokeResolveFn = function (resolvedDeps) {
            return _this.resolveFn.apply(null, resolvedDeps);
        };
        /**
         * For RXWAIT policy:
         *
         * Given an observable returned from a resolve function:
         * - enables .cache() mode (this allows multicast subscribers)
         * - then calls toPromise() (this triggers subscribe() and thus fetches)
         * - Waits for the promise, then return the cached observable (not the first emitted value).
         */
        var waitForRx = function (observable$) {
            var cached = observable$.cache(1);
            return cached.take(1).toPromise().then(function () { return cached; });
        };
        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.
        var node = resolveContext.findNode(this);
        var state = node && node.state;
        var maybeWaitForRx = this.getPolicy(state).async === "RXWAIT" ? waitForRx : common_1.identity;
        // After the final value has been resolved, update the state of the Resolvable
        var applyResolvedValue = function (resolvedValue) {
            _this.data = resolvedValue;
            _this.resolved = true;
            trace_1.trace.traceResolvableResolved(_this, trans);
            return _this.data;
        };
        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.
        return this.promise = $q.when()
            .then(getResolvableDependencies)
            .then(invokeResolveFn)
            .then(maybeWaitForRx)
            .then(applyResolvedValue);
    };
    /**
     * Gets a promise for this Resolvable's data.
     *
     * Fetches the data and returns a promise.
     * Returns the existing promise if it has already been fetched once.
     */
    Resolvable.prototype.get = function (resolveContext, trans) {
        return this.promise || this.resolve(resolveContext, trans);
    };
    Resolvable.prototype.toString = function () {
        return "Resolvable(token: " + strings_1.stringify(this.token) + ", requires: [" + this.deps.map(strings_1.stringify) + "])";
    };
    Resolvable.prototype.clone = function () {
        return new Resolvable(this);
    };
    return Resolvable;
}());
Resolvable.fromData = function (token, data) {
    return new Resolvable(token, function () { return data; }, null, null, data);
};
exports.Resolvable = Resolvable;
//# sourceMappingURL=resolvable.js.map

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @coreapi
 * @module transition
 */ /** for typedoc */

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(0);
var strings_1 = __webpack_require__(5);
var hof_1 = __webpack_require__(2);
var RejectType;
(function (RejectType) {
    RejectType[RejectType["SUPERSEDED"] = 2] = "SUPERSEDED";
    RejectType[RejectType["ABORTED"] = 3] = "ABORTED";
    RejectType[RejectType["INVALID"] = 4] = "INVALID";
    RejectType[RejectType["IGNORED"] = 5] = "IGNORED";
    RejectType[RejectType["ERROR"] = 6] = "ERROR";
})(RejectType = exports.RejectType || (exports.RejectType = {}));
/** @hidden */ var id = 0;
var Rejection = (function () {
    function Rejection(type, message, detail) {
        this.$id = id++;
        this.type = type;
        this.message = message;
        this.detail = detail;
    }
    Rejection.prototype.toString = function () {
        var detailString = function (d) {
            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);
        };
        var detail = detailString(this.detail);
        var _a = this, $id = _a.$id, type = _a.type, message = _a.message;
        return "Transition Rejection($id: " + $id + " type: " + type + ", message: " + message + ", detail: " + detail + ")";
    };
    Rejection.prototype.toPromise = function () {
        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });
    };
    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */
    Rejection.isRejectionPromise = function (obj) {
        return obj && (typeof obj.then === 'function') && hof_1.is(Rejection)(obj._transitionRejection);
    };
    /** Returns a Rejection due to transition superseded */
    Rejection.superseded = function (detail, options) {
        var message = "The transition has been superseded by a different transition";
        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);
        if (options && options.redirected) {
            rejection.redirected = true;
        }
        return rejection;
    };
    /** Returns a Rejection due to redirected transition */
    Rejection.redirected = function (detail) {
        return Rejection.superseded(detail, { redirected: true });
    };
    /** Returns a Rejection due to invalid transition */
    Rejection.invalid = function (detail) {
        var message = "This transition is invalid";
        return new Rejection(RejectType.INVALID, message, detail);
    };
    /** Returns a Rejection due to ignored transition */
    Rejection.ignored = function (detail) {
        var message = "The transition was ignored";
        return new Rejection(RejectType.IGNORED, message, detail);
    };
    /** Returns a Rejection due to aborted transition */
    Rejection.aborted = function (detail) {
        var message = "The transition has been aborted";
        return new Rejection(RejectType.ABORTED, message, detail);
    };
    /** Returns a Rejection due to aborted transition */
    Rejection.errored = function (detail) {
        var message = "The transition errored";
        return new Rejection(RejectType.ERROR, message, detail);
    };
    /**
     * Returns a Rejection
     *
     * Normalizes a value as a Rejection.
     * If the value is already a Rejection, returns it.
     * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).
     *
     * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.
     */
    Rejection.normalize = function (detail) {
        return hof_1.is(Rejection)(detail) ? detail : Rejection.errored(detail);
    };
    return Rejection;
}());
exports.Rejection = Rejection;
//# sourceMappingURL=rejectFactory.js.map

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module transition
 */
/** for typedoc */
var interface_1 = __webpack_require__(9);
var common_1 = __webpack_require__(0);
var strings_1 = __webpack_require__(5);
var predicates_1 = __webpack_require__(1);
var hof_1 = __webpack_require__(2);
var trace_1 = __webpack_require__(6);
var coreservices_1 = __webpack_require__(3);
var rejectFactory_1 = __webpack_require__(13);
var targetState_1 = __webpack_require__(7);
var defaultOptions = {
    current: common_1.noop,
    transition: null,
    traceData: {},
    bind: null,
};
/** @hidden */
var TransitionHook = (function () {
    function TransitionHook(transition, stateContext, registeredHook, options) {
        var _this = this;
        this.transition = transition;
        this.stateContext = stateContext;
        this.registeredHook = registeredHook;
        this.options = options;
        this.isSuperseded = function () {
            return _this.type.hookPhase === interface_1.TransitionHookPhase.RUN && !_this.options.transition.isActive();
        };
        this.options = common_1.defaults(options, defaultOptions);
        this.type = registeredHook.eventType;
    }
    TransitionHook.prototype.logError = function (err) {
        this.transition.router.stateService.defaultErrorHandler()(err);
    };
    TransitionHook.prototype.invokeHook = function () {
        var _this = this;
        var hook = this.registeredHook;
        if (hook._deregistered)
            return;
        var notCurrent = this.getNotCurrentRejection();
        if (notCurrent)
            return notCurrent;
        var options = this.options;
        trace_1.trace.traceHookInvocation(this, this.transition, options);
        var invokeCallback = function () {
            return hook.callback.call(options.bind, _this.transition, _this.stateContext);
        };
        var normalizeErr = function (err) {
            return rejectFactory_1.Rejection.normalize(err).toPromise();
        };
        var handleError = function (err) {
            return hook.eventType.getErrorHandler(_this)(err);
        };
        var handleResult = function (result) {
            return hook.eventType.getResultHandler(_this)(result);
        };
        try {
            var result = invokeCallback();
            if (!this.type.synchronous && predicates_1.isPromise(result)) {
                return result.catch(normalizeErr)
                    .then(handleResult, handleError);
            }
            else {
                return handleResult(result);
            }
        }
        catch (err) {
            // If callback throws (synchronously)
            return handleError(rejectFactory_1.Rejection.normalize(err));
        }
    };
    /**
     * This method handles the return value of a Transition Hook.
     *
     * A hook can return false (cancel), a TargetState (redirect),
     * or a promise (which may later resolve to false or a redirect)
     *
     * This also handles "transition superseded" -- when a new transition
     * was started while the hook was still running
     */
    TransitionHook.prototype.handleHookResult = function (result) {
        var _this = this;
        var notCurrent = this.getNotCurrentRejection();
        if (notCurrent)
            return notCurrent;
        // Hook returned a promise
        if (predicates_1.isPromise(result)) {
            // Wait for the promise, then reprocess with the resulting value
            return result.then(function (val) { return _this.handleHookResult(val); });
        }
        trace_1.trace.traceHookResult(result, this.transition, this.options);
        // Hook returned false
        if (result === false) {
            // Abort this Transition
            return rejectFactory_1.Rejection.aborted("Hook aborted transition").toPromise();
        }
        var isTargetState = hof_1.is(targetState_1.TargetState);
        // hook returned a TargetState
        if (isTargetState(result)) {
            // Halt the current Transition and redirect (a new Transition) to the TargetState.
            return rejectFactory_1.Rejection.redirected(result).toPromise();
        }
    };
    /**
     * Return a Rejection promise if the transition is no longer current due
     * to a stopped router (disposed), or a new transition has started and superseded this one.
     */
    TransitionHook.prototype.getNotCurrentRejection = function () {
        var router = this.transition.router;
        // The router is stopped
        if (router._disposed) {
            return rejectFactory_1.Rejection.aborted("UIRouter instance #" + router.$id + " has been stopped (disposed)").toPromise();
        }
        if (this.transition._aborted) {
            return rejectFactory_1.Rejection.aborted().toPromise();
        }
        // This transition is no longer current.
        // Another transition started while this hook was still running.
        if (this.isSuperseded()) {
            // Abort this transition
            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();
        }
    };
    TransitionHook.prototype.toString = function () {
        var _a = this, options = _a.options, registeredHook = _a.registeredHook;
        var event = hof_1.parse("traceData.hookType")(options) || "internal", context = hof_1.parse("traceData.context.state.name")(options) || hof_1.parse("traceData.context")(options) || "unknown", name = strings_1.fnToString(registeredHook.callback);
        return event + " context: " + context + ", " + strings_1.maxLength(200, name);
    };
    /**
     * Chains together an array of TransitionHooks.
     *
     * Given a list of [[TransitionHook]] objects, chains them together.
     * Each hook is invoked after the previous one completes.
     *
     * #### Example:
     * ```js
     * var hooks: TransitionHook[] = getHooks();
     * let promise: Promise<any> = TransitionHook.chain(hooks);
     *
     * promise.then(handleSuccess, handleError);
     * ```
     *
     * @param hooks the list of hooks to chain together
     * @param waitFor if provided, the chain is `.then()`'ed off this promise
     * @returns a `Promise` for sequentially invoking the hooks (in order)
     */
    TransitionHook.chain = function (hooks, waitFor) {
        // Chain the next hook off the previous
        var createHookChainR = function (prev, nextHook) {
            return prev.then(function () { return nextHook.invokeHook(); });
        };
        return hooks.reduce(createHookChainR, waitFor || coreservices_1.services.$q.when());
    };
    /**
     * Invokes all the provided TransitionHooks, in order.
     * Each hook's return value is checked.
     * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.
     * If no hook returns a promise, then all hooks are processed synchronously.
     *
     * @param hooks the list of TransitionHooks to invoke
     * @param doneCallback a callback that is invoked after all the hooks have successfully completed
     *
     * @returns a promise for the async result, or the result of the callback
     */
    TransitionHook.invokeHooks = function (hooks, doneCallback) {
        for (var idx = 0; idx < hooks.length; idx++) {
            var hookResult = hooks[idx].invokeHook();
            if (predicates_1.isPromise(hookResult)) {
                var remainingHooks = hooks.slice(idx + 1);
                return TransitionHook.chain(remainingHooks, hookResult)
                    .then(doneCallback);
            }
        }
        return doneCallback();
    };
    /**
     * Run all TransitionHooks, ignoring their return value.
     */
    TransitionHook.runAllHooks = function (hooks) {
        hooks.forEach(function (hook) { return hook.invokeHook(); });
    };
    return TransitionHook;
}());
/**
 * These GetResultHandler(s) are used by [[invokeHook]] below
 * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])
 */
TransitionHook.HANDLE_RESULT = function (hook) { return function (result) {
    return hook.handleHookResult(result);
}; };
/**
 * If the result is a promise rejection, log it.
 * Otherwise, ignore the result.
 */
TransitionHook.LOG_REJECTED_RESULT = function (hook) { return function (result) {
    predicates_1.isPromise(result) && result.catch(function (err) {
        return hook.logError(rejectFactory_1.Rejection.normalize(err));
    });
    return undefined;
}; };
/**
 * These GetErrorHandler(s) are used by [[invokeHook]] below
 * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])
 */
TransitionHook.LOG_ERROR = function (hook) { return function (error) {
    return hook.logError(error);
}; };
TransitionHook.REJECT_ERROR = function (hook) { return function (error) {
    return common_1.silentRejection(error);
}; };
TransitionHook.THROW_ERROR = function (hook) { return function (error) {
    throw error;
}; };
exports.TransitionHook = TransitionHook;
//# sourceMappingURL=transitionHook.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var index_1 = __webpack_require__(17);
var common_1 = __webpack_require__(0);
var beforeAfterSubstr = function (char) { return function (str) {
    if (!str)
        return ["", ""];
    var idx = str.indexOf(char);
    if (idx === -1)
        return [str, ""];
    return [str.substr(0, idx), str.substr(idx + 1)];
}; };
exports.splitHash = beforeAfterSubstr("#");
exports.splitQuery = beforeAfterSubstr("?");
exports.splitEqual = beforeAfterSubstr("=");
exports.trimHashVal = function (str) { return str ? str.replace(/^#/, "") : ""; };
exports.keyValsToObjectR = function (accum, _a) {
    var key = _a[0], val = _a[1];
    if (!accum.hasOwnProperty(key)) {
        accum[key] = val;
    }
    else if (index_1.isArray(accum[key])) {
        accum[key].push(val);
    }
    else {
        accum[key] = [accum[key], val];
    }
    return accum;
};
exports.getParams = function (queryString) {
    return queryString.split("&").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});
};
function parseUrl(url) {
    var orEmptyString = function (x) { return x || ""; };
    var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];
    var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];
    return { path: path, search: search, hash: hash, url: url };
}
exports.parseUrl = parseUrl;
exports.buildUrl = function (loc) {
    var path = loc.path();
    var searchObject = loc.search();
    var hash = loc.hash();
    var search = Object.keys(searchObject).map(function (key) {
        var param = searchObject[key];
        var vals = index_1.isArray(param) ? param : [param];
        return vals.map(function (val) { return key + "=" + val; });
    }).reduce(common_1.unnestR, []).join("&");
    return path + (search ? "?" + search : "") + (hash ? "#" + hash : "");
};
function locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {
    return function (router) {
        var service = router.locationService = new serviceClass(router);
        var configuration = router.locationConfig = new configurationClass(router, isHtml5);
        function dispose(router) {
            router.dispose(service);
            router.dispose(configuration);
        }
        return { name: name, service: service, configuration: configuration, dispose: dispose };
    };
}
exports.locationPluginFactory = locationPluginFactory;
//# sourceMappingURL=utils.js.map

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module core
 */
/**
 * Matches state names using glob-like pattern strings.
 *
 * Globs can be used in specific APIs including:
 *
 * - [[StateService.is]]
 * - [[StateService.includes]]
 * - The first argument to Hook Registration functions like [[TransitionService.onStart]]
 *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]
 *
 * A `Glob` string is a pattern which matches state names.
 * Nested state names are split into segments (separated by a dot) when processing.
 * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']
 *
 * Globs work according to the following rules:
 *
 * ### Exact match:
 *
 * The glob `'A.B'` matches the state named exactly `'A.B'`.
 *
 * | Glob        |Matches states named|Does not match state named|
 * |:------------|:--------------------|:---------------------|
 * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |
 * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |
 * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|
 *
 * ### Single star (`*`)
 *
 * A single star (`*`) is a wildcard that matches exactly one segment.
 *
 * | Glob        |Matches states named  |Does not match state named |
 * |:------------|:---------------------|:--------------------------|
 * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |
 * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |
 * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|
 *
 * ### Double star (`**`)
 *
 * A double star (`'**'`) is a wildcard that matches *zero or more segments*
 *
 * | Glob        |Matches states named                           |Does not match state named         |
 * |:------------|:----------------------------------------------|:----------------------------------|
 * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |
 * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |
 * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |
 * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |
 *
 */
var Glob = (function () {
    function Glob(text) {
        this.text = text;
        this.glob = text.split('.');
        var regexpString = this.text.split('.')
            .map(function (seg) {
            if (seg === '**')
                return '(?:|(?:\\.[^.]*)*)';
            if (seg === '*')
                return '\\.[^.]*';
            return '\\.' + seg;
        }).join('');
        this.regexp = new RegExp("^" + regexpString + "$");
    }
    Glob.prototype.matches = function (name) {
        return this.regexp.test('.' + name);
    };
    /** Returns true if the string has glob-like characters in it */
    Glob.is = function (text) {
        return !!/[!,*]+/.exec(text);
    };
    /** Returns a glob from the string, or null if the string isn't Glob-like */
    Glob.fromString = function (text) {
        return Glob.is(text) ? new Glob(text) : null;
    };
    return Glob;
}());
exports.Glob = Glob;
//# sourceMappingURL=glob.js.map

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/** @module common */ /** for typedoc */
__export(__webpack_require__(0));
__export(__webpack_require__(3));
__export(__webpack_require__(16));
__export(__webpack_require__(2));
__export(__webpack_require__(1));
__export(__webpack_require__(23));
__export(__webpack_require__(5));
__export(__webpack_require__(6));
//# sourceMappingURL=index.js.map

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module path */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var targetState_1 = __webpack_require__(7);
var pathNode_1 = __webpack_require__(25);
/**
 * This class contains functions which convert TargetStates, Nodes and paths from one type to another.
 */
var PathUtils = (function () {
    function PathUtils() {
    }
    /** Given a PathNode[], create an TargetState */
    PathUtils.makeTargetState = function (path) {
        var state = common_1.tail(path).state;
        return new targetState_1.TargetState(state, state, path.map(hof_1.prop("paramValues")).reduce(common_1.mergeR, {}));
    };
    PathUtils.buildPath = function (targetState) {
        var toParams = targetState.params();
        return targetState.$state().path.map(function (state) { return new pathNode_1.PathNode(state).applyRawParams(toParams); });
    };
    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */
    PathUtils.buildToPath = function (fromPath, targetState) {
        var toPath = PathUtils.buildPath(targetState);
        if (targetState.options().inherit) {
            return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));
        }
        return toPath;
    };
    /**
     * Creates ViewConfig objects and adds to nodes.
     *
     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state
     */
    PathUtils.applyViewConfigs = function ($view, path, states) {
        // Only apply the viewConfigs to the nodes for the given states
        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {
            var viewDecls = common_1.values(node.state.views || {});
            var subPath = PathUtils.subPath(path, function (n) { return n === node; });
            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });
            node.views = viewConfigs.reduce(common_1.unnestR, []);
        });
    };
    /**
     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath
     *
     * For a parameter in a node to be inherited from the from path:
     * - The toPath's node must have a matching node in the fromPath (by state).
     * - The parameter name must not be found in the toKeys parameter array.
     *
     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some
     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,
     * it is not inherited from the fromPath.
     */
    PathUtils.inheritParams = function (fromPath, toPath, toKeys) {
        if (toKeys === void 0) { toKeys = []; }
        function nodeParamVals(path, state) {
            var node = common_1.find(path, hof_1.propEq('state', state));
            return common_1.extend({}, node && node.paramValues);
        }
        var noInherit = fromPath.map(function (node) { return node.paramSchema; })
            .reduce(common_1.unnestR, [])
            .filter(function (param) { return !param.inherit; })
            .map(hof_1.prop('id'));
        /**
         * Given an [[PathNode]] "toNode", return a new [[PathNode]] with param values inherited from the
         * matching node in fromPath.  Only inherit keys that aren't found in "toKeys" from the node in "fromPath""
         */
        function makeInheritedParamsNode(toNode) {
            // All param values for the node (may include default key/vals, when key was not found in toParams)
            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);
            // limited to only those keys found in toParams
            var incomingParamVals = common_1.pick(toParamVals, toKeys);
            toParamVals = common_1.omit(toParamVals, toKeys);
            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);
            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals
            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);
            return new pathNode_1.PathNode(toNode.state).applyRawParams(ownParamVals);
        }
        // The param keys specified by the incoming toParams
        return toPath.map(makeInheritedParamsNode);
    };
    /**
     * Computes the tree changes (entering, exiting) between a fromPath and toPath.
     */
    PathUtils.treeChanges = function (fromPath, toPath, reloadState) {
        var keep = 0, max = Math.min(fromPath.length, toPath.length);
        var nodesMatch = function (node1, node2) {
            return node1.equals(node2, PathUtils.nonDynamicParams);
        };
        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {
            keep++;
        }
        /** Given a retained node, return a new node which uses the to node's param values */
        function applyToParams(retainedNode, idx) {
            var cloned = pathNode_1.PathNode.clone(retainedNode);
            cloned.paramValues = toPath[idx].paramValues;
            return cloned;
        }
        var from, retained, exiting, entering, to;
        from = fromPath;
        retained = from.slice(0, keep);
        exiting = from.slice(keep);
        // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped
        var retainedWithToParams = retained.map(applyToParams);
        entering = toPath.slice(keep);
        to = (retainedWithToParams).concat(entering);
        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };
    };
    /**
     * Returns a new path which is: the subpath of the first path which matches the second path.
     *
     * The new path starts from root and contains any nodes that match the nodes in the second path.
     * It stops before the first non-matching node.
     *
     * Nodes are compared using their state property and their parameter values.
     * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.
     *
     * @param pathA the first path
     * @param pathB the second path
     * @param paramsFn a function which returns the parameters to consider when comparing
     *
     * @returns an array of PathNodes from the first path which match the nodes in the second path
     */
    PathUtils.matching = function (pathA, pathB, paramsFn) {
        var done = false;
        var tuples = common_1.arrayTuples(pathA, pathB);
        return tuples.reduce(function (matching, _a) {
            var nodeA = _a[0], nodeB = _a[1];
            done = done || !nodeA.equals(nodeB, paramsFn);
            return done ? matching : matching.concat(nodeA);
        }, []);
    };
    /**
     * Returns true if two paths are identical.
     *
     * @param pathA
     * @param pathB
     * @param paramsFn a function which returns the parameters to consider when comparing
     * @returns true if the the states and parameter values for both paths are identical
     */
    PathUtils.equals = function (pathA, pathB, paramsFn) {
        return pathA.length === pathB.length &&
            PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;
    };
    /**
     * Return a subpath of a path, which stops at the first matching node
     *
     * Given an array of nodes, returns a subset of the array starting from the first node,
     * stopping when the first node matches the predicate.
     *
     * @param path a path of [[PathNode]]s
     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s
     * @returns a subpath up to the matching node, or undefined if no match is found
     */
    PathUtils.subPath = function (path, predicate) {
        var node = common_1.find(path, predicate);
        var elementIdx = path.indexOf(node);
        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);
    };
    return PathUtils;
}());
PathUtils.nonDynamicParams = function (node) {
    return node.state.parameters({ inherit: false })
        .filter(function (param) { return !param.dynamic; });
};
/** Gets the raw parameter values from a path */
PathUtils.paramValues = function (path) {
    return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {});
};
exports.PathUtils = PathUtils;
//# sourceMappingURL=pathFactory.js.map

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module resolve */
/** for typedoc */
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var trace_1 = __webpack_require__(6);
var coreservices_1 = __webpack_require__(3);
var interface_1 = __webpack_require__(35);
var resolvable_1 = __webpack_require__(12);
var pathFactory_1 = __webpack_require__(18);
var strings_1 = __webpack_require__(5);
var when = interface_1.resolvePolicies.when;
var ALL_WHENS = [when.EAGER, when.LAZY];
var EAGER_WHENS = [when.EAGER];
exports.NATIVE_INJECTOR_TOKEN = "Native Injector";
/**
 * Encapsulates Dependency Injection for a path of nodes
 *
 * UI-Router states are organized as a tree.
 * A nested state has a path of ancestors to the root of the tree.
 * When a state is being activated, each element in the path is wrapped as a [[PathNode]].
 * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.
 *
 * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.
 */
var ResolveContext = (function () {
    function ResolveContext(_path) {
        this._path = _path;
    }
    /** Gets all the tokens found in the resolve context, de-duplicated */
    ResolveContext.prototype.getTokens = function () {
        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);
    };
    /**
     * Gets the Resolvable that matches the token
     *
     * Gets the last Resolvable that matches the token in this context, or undefined.
     * Throws an error if it doesn't exist in the ResolveContext
     */
    ResolveContext.prototype.getResolvable = function (token) {
        var matching = this._path.map(function (node) { return node.resolvables; })
            .reduce(common_1.unnestR, [])
            .filter(function (r) { return r.token === token; });
        return common_1.tail(matching);
    };
    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */
    ResolveContext.prototype.getPolicy = function (resolvable) {
        var node = this.findNode(resolvable);
        return resolvable.getPolicy(node.state);
    };
    /**
     * Returns a ResolveContext that includes a portion of this one
     *
     * Given a state, this method creates a new ResolveContext from this one.
     * The new context starts at the first node (root) and stops at the node for the `state` parameter.
     *
     * #### Why
     *
     * When a transition is created, the nodes in the "To Path" are injected from a ResolveContext.
     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.
     * The "To State" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).
     * This method is used to create a narrower context when injecting ancestor nodes.
     *
     * @example
     * `let ABCD = new ResolveContext([A, B, C, D]);`
     *
     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:
     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.
     * However, `B` should only be able to access resolvables from `A`, `B`.
     *
     * When resolving for the `B` node, first take the full "To Path" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.
     * `let AB = ABCD.subcontext(a)`
     */
    ResolveContext.prototype.subContext = function (state) {
        return new ResolveContext(pathFactory_1.PathUtils.subPath(this._path, function (node) { return node.state === state; }));
    };
    /**
     * Adds Resolvables to the node that matches the state
     *
     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).
     * The resolvable is added to the node matching the `state` parameter.
     *
     * These new resolvables are not automatically fetched.
     * The calling code should either fetch them, fetch something that depends on them,
     * or rely on [[resolvePath]] being called when some state is being entered.
     *
     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.
     *
     * @param newResolvables the new Resolvables
     * @param state Used to find the node to put the resolvable on
     */
    ResolveContext.prototype.addResolvables = function (newResolvables, state) {
        var node = common_1.find(this._path, hof_1.propEq('state', state));
        var keys = newResolvables.map(function (r) { return r.token; });
        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);
    };
    /**
     * Returns a promise for an array of resolved path Element promises
     *
     * @param when
     * @param trans
     * @returns {Promise<any>|any}
     */
    ResolveContext.prototype.resolvePath = function (when, trans) {
        var _this = this;
        if (when === void 0) { when = "LAZY"; }
        // This option determines which 'when' policy Resolvables we are about to fetch.
        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : "LAZY";
        // If the caller specified EAGER, only the EAGER Resolvables are fetched.
        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`
        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;
        // get the subpath to the state argument, if provided
        trace_1.trace.traceResolvePath(this._path, when, trans);
        var matchesPolicy = function (acceptedVals, whenOrAsync) {
            return function (resolvable) {
                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);
            };
        };
        // Trigger all the (matching) Resolvables in the path
        // Reduce all the "WAIT" Resolvables into an array
        var promises = this._path.reduce(function (acc, node) {
            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));
            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));
            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));
            // For the matching Resolvables, start their async fetch process.
            var subContext = _this.subContext(node.state);
            var getResult = function (r) { return r.get(subContext, trans)
                .then(function (value) { return ({ token: r.token, value: value }); }); };
            nowait.forEach(getResult);
            return acc.concat(wait.map(getResult));
        }, []);
        // Wait for all the "WAIT" resolvables
        return coreservices_1.services.$q.all(promises);
    };
    ResolveContext.prototype.injector = function () {
        return this._injector || (this._injector = new UIInjectorImpl(this));
    };
    ResolveContext.prototype.findNode = function (resolvable) {
        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });
    };
    /**
     * Gets the async dependencies of a Resolvable
     *
     * Given a Resolvable, returns its dependencies as a Resolvable[]
     */
    ResolveContext.prototype.getDependencies = function (resolvable) {
        var _this = this;
        var node = this.findNode(resolvable);
        // Find which other resolvables are "visible" to the `resolvable` argument
        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)
        var subPath = pathFactory_1.PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;
        var availableResolvables = subPath
            .reduce(function (acc, node) { return acc.concat(node.resolvables); }, []) //all of subpath's resolvables
            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument
        var getDependency = function (token) {
            var matching = availableResolvables.filter(function (r) { return r.token === token; });
            if (matching.length)
                return common_1.tail(matching);
            var fromInjector = _this.injector().getNative(token);
            if (!fromInjector) {
                throw new Error("Could not find Dependency Injection token: " + strings_1.stringify(token));
            }
            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);
        };
        return resolvable.deps.map(getDependency);
    };
    return ResolveContext;
}());
exports.ResolveContext = ResolveContext;
var UIInjectorImpl = (function () {
    function UIInjectorImpl(context) {
        this.context = context;
        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;
    }
    UIInjectorImpl.prototype.get = function (token) {
        var resolvable = this.context.getResolvable(token);
        if (resolvable) {
            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {
                return resolvable.get(this.context);
            }
            if (!resolvable.resolved) {
                throw new Error("Resolvable async .get() not complete:" + strings_1.stringify(resolvable.token));
            }
            return resolvable.data;
        }
        return this.native && this.native.get(token);
    };
    UIInjectorImpl.prototype.getAsync = function (token) {
        var resolvable = this.context.getResolvable(token);
        if (resolvable)
            return resolvable.get(this.context);
        return coreservices_1.services.$q.when(this.native.get(token));
    };
    UIInjectorImpl.prototype.getNative = function (token) {
        return this.native && this.native.get(token);
    };
    return UIInjectorImpl;
}());
//# sourceMappingURL=resolveContext.js.map

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module transition
 */
/** for typedoc */
var trace_1 = __webpack_require__(6);
var coreservices_1 = __webpack_require__(3);
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var hof_1 = __webpack_require__(2);
var interface_1 = __webpack_require__(9); // has or is using
var transitionHook_1 = __webpack_require__(14);
var hookRegistry_1 = __webpack_require__(27);
var hookBuilder_1 = __webpack_require__(42);
var pathFactory_1 = __webpack_require__(18);
var targetState_1 = __webpack_require__(7);
var param_1 = __webpack_require__(8);
var resolvable_1 = __webpack_require__(12);
var resolveContext_1 = __webpack_require__(19);
/** @hidden */
var stateSelf = hof_1.prop("self");
/**
 * Represents a transition between two states.
 *
 * When navigating to a state, we are transitioning **from** the current state **to** the new state.
 *
 * This object contains all contextual information about the to/from states, parameters, resolves.
 * It has information about all states being entered and exited as a result of the transition.
 */
var Transition = (function () {
    /**
     * Creates a new Transition object.
     *
     * If the target state is not valid, an error is thrown.
     *
     * @internalapi
     *
     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`
     *        encapsulates the "from state".
     * @param targetState The target state and parameters being transitioned to (also, the transition options)
     * @param router The [[UIRouter]] instance
     */
    function Transition(fromPath, targetState, router) {
        var _this = this;
        /** @hidden */
        this._deferred = coreservices_1.services.$q.defer();
        /**
         * This promise is resolved or rejected based on the outcome of the Transition.
         *
         * When the transition is successful, the promise is resolved
         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error
         */
        this.promise = this._deferred.promise;
        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */
        this._registeredHooks = {};
        /** @hidden */
        this._hookBuilder = new hookBuilder_1.HookBuilder(this);
        /** Checks if this transition is currently active/running. */
        this.isActive = function () {
            return _this.router.globals.transition === _this;
        };
        this.router = router;
        this._targetState = targetState;
        if (!targetState.valid()) {
            throw new Error(targetState.error());
        }
        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.
        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());
        this.$id = router.transitionService._transitionCount++;
        var toPath = pathFactory_1.PathUtils.buildToPath(fromPath, targetState);
        this._treeChanges = pathFactory_1.PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);
        this.createTransitionHookRegFns();
        var onCreateHooks = this._hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);
        transitionHook_1.TransitionHook.invokeHooks(onCreateHooks, function () { return null; });
        this.applyViewConfigs(router);
    }
    /** @hidden */
    Transition.prototype.onBefore = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onStart = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onExit = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onRetain = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onEnter = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onFinish = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    Transition.prototype.onError = function (criteria, callback, options) { return; };
    /** @hidden
     * Creates the transition-level hook registration functions
     * (which can then be used to register hooks)
     */
    Transition.prototype.createTransitionHookRegFns = function () {
        var _this = this;
        this.router.transitionService._pluginapi._getEvents()
            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })
            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });
    };
    /** @internalapi */
    Transition.prototype.getHooks = function (hookName) {
        return this._registeredHooks[hookName];
    };
    Transition.prototype.applyViewConfigs = function (router) {
        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });
        pathFactory_1.PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);
    };
    /**
     * @internalapi
     *
     * @returns the internal from [State] object
     */
    Transition.prototype.$from = function () {
        return common_1.tail(this._treeChanges.from).state;
    };
    /**
     * @internalapi
     *
     * @returns the internal to [State] object
     */
    Transition.prototype.$to = function () {
        return common_1.tail(this._treeChanges.to).state;
    };
    /**
     * Returns the "from state"
     *
     * Returns the state that the transition is coming *from*.
     *
     * @returns The state declaration object for the Transition's ("from state").
     */
    Transition.prototype.from = function () {
        return this.$from().self;
    };
    /**
     * Returns the "to state"
     *
     * Returns the state that the transition is going *to*.
     *
     * @returns The state declaration object for the Transition's target state ("to state").
     */
    Transition.prototype.to = function () {
        return this.$to().self;
    };
    /**
     * Gets the Target State
     *
     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.
     *
     * @returns the [[TargetState]] of this Transition
     */
    Transition.prototype.targetState = function () {
        return this._targetState;
    };
    /**
     * Determines whether two transitions are equivalent.
     * @deprecated
     */
    Transition.prototype.is = function (compare) {
        if (compare instanceof Transition) {
            // TODO: Also compare parameters
            return this.is({ to: compare.$to().name, from: compare.$from().name });
        }
        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||
            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));
    };
    Transition.prototype.params = function (pathname) {
        if (pathname === void 0) { pathname = "to"; }
        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop("paramValues")).reduce(common_1.mergeR, {}));
    };
    /**
     * Creates a [[UIInjector]] Dependency Injector
     *
     * Returns a Dependency Injector for the Transition's target state (to state).
     * The injector provides resolve values which the target state has access to.
     *
     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).
     *
     * #### Example:
     * ```js
     * .onEnter({ entering: 'myState' }, trans => {
     *   var myResolveValue = trans.injector().get('myResolve');
     *   // Inject a global service from the global/native injector (if it exists)
     *   var MyService = trans.injector().get('MyService');
     * })
     * ```
     *
     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.
     * You can use [[UIInjector.getAsync]] to get a promise for the data.
     * #### Example:
     * ```js
     * .onBefore({}, trans => {
     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>
     *     return myResolveValue !== 'ABORT';
     *   });
     * });
     * ```
     *
     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.
     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.
     * #### Example:
     * ```js
     * .onEnter({ to: 'foo.bar' }, trans => {
     *   // returns result of `foo` state's `data` resolve
     *   // even though `foo.bar` also has a `data` resolve
     *   var fooData = trans.injector('foo').get('data');
     * });
     * ```
     *
     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.
     * The resolve data from the `from` path will be returned.
     * #### Example:
     * ```js
     * .onExit({ exiting: 'foo.bar' }, trans => {
     *   // Gets the resolve value of `data` from the exiting state.
     *   var fooData = trans.injector(null, 'foo.bar').get('data');
     * });
     * ```
     *
     *
     * @param state Limits the resolves provided to only the resolves the provided state has access to.
     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.
     *
     * @returns a [[UIInjector]]
     */
    Transition.prototype.injector = function (state, pathName) {
        if (pathName === void 0) { pathName = "to"; }
        var path = this._treeChanges[pathName];
        if (state)
            path = pathFactory_1.PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });
        return new resolveContext_1.ResolveContext(path).injector();
    };
    /**
     * Gets all available resolve tokens (keys)
     *
     * This method can be used in conjunction with [[injector]] to inspect the resolve values
     * available to the Transition.
     *
     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states
     * in the Transition's [[TreeChanges.to]] path.
     *
     * #### Example:
     * This example logs all resolve values
     * ```js
     * let tokens = trans.getResolveTokens();
     * tokens.forEach(token => console.log(token + " = " + trans.injector().get(token)));
     * ```
     *
     * #### Example:
     * This example creates promises for each resolve value.
     * This triggers fetches of resolves (if any have not yet been fetched).
     * When all promises have all settled, it logs the resolve values.
     * ```js
     * let tokens = trans.getResolveTokens();
     * let promise = tokens.map(token => trans.injector().getAsync(token));
     * Promise.all(promises).then(values => console.log("Resolved values: " + values));
     * ```
     *
     * Note: Angular 1 users whould use `$q.all()`
     *
     * @param pathname resolve context's path name (e.g., `to` or `from`)
     *
     * @returns an array of resolve tokens (keys)
     */
    Transition.prototype.getResolveTokens = function (pathname) {
        if (pathname === void 0) { pathname = "to"; }
        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();
    };
    /**
     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.
     *
     * #### Example:
     * ```js
     * transitionService.onBefore({}, transition => {
     *   transition.addResolvable({
     *     token: 'myResolve',
     *     deps: ['MyService'],
     *     resolveFn: myService => myService.getData()
     *   });
     * });
     * ```
     *
     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])
     * @param state the state in the "to path" which should receive the new resolve (otherwise, the root state)
     */
    Transition.prototype.addResolvable = function (resolvable, state) {
        if (state === void 0) { state = ""; }
        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);
        var stateName = (typeof state === "string") ? state : state.name;
        var topath = this._treeChanges.to;
        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });
        var resolveContext = new resolveContext_1.ResolveContext(topath);
        resolveContext.addResolvables([resolvable], targetNode.state);
    };
    /**
     * Gets the transition from which this transition was redirected.
     *
     * If the current transition is a redirect, this method returns the transition that was redirected.
     *
     * #### Example:
     * ```js
     * let transitionA = $state.go('A').transition
     * transitionA.onStart({}, () => $state.target('B'));
     * $transitions.onSuccess({ to: 'B' }, (trans) => {
     *   trans.to().name === 'B'; // true
     *   trans.redirectedFrom() === transitionA; // true
     * });
     * ```
     *
     * @returns The previous Transition, or null if this Transition is not the result of a redirection
     */
    Transition.prototype.redirectedFrom = function () {
        return this._options.redirectedFrom || null;
    };
    /**
     * Gets the original transition in a redirect chain
     *
     * A transition might belong to a long chain of multiple redirects.
     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.
     *
     * #### Example:
     * ```js
     * // states
     * registry.register({ name: 'A', redirectTo: 'B' });
     * registry.register({ name: 'B', redirectTo: 'C' });
     * registry.register({ name: 'C', redirectTo: 'D' });
     * registry.register({ name: 'D' });
     *
     * let transitionA = $state.go('A').transition
     *
     * $transitions.onSuccess({ to: 'D' }, (trans) => {
     *   trans.to().name === 'D'; // true
     *   trans.redirectedFrom().to().name === 'C'; // true
     *   trans.originalTransition() === transitionA; // true
     *   trans.originalTransition().to().name === 'A'; // true
     * });
     * ```
     *
     * @returns The original Transition that started a redirect chain
     */
    Transition.prototype.originalTransition = function () {
        var rf = this.redirectedFrom();
        return (rf && rf.originalTransition()) || this;
    };
    /**
     * Get the transition options
     *
     * @returns the options for this Transition.
     */
    Transition.prototype.options = function () {
        return this._options;
    };
    /**
     * Gets the states being entered.
     *
     * @returns an array of states that will be entered during this transition.
     */
    Transition.prototype.entering = function () {
        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);
    };
    /**
     * Gets the states being exited.
     *
     * @returns an array of states that will be exited during this transition.
     */
    Transition.prototype.exiting = function () {
        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();
    };
    /**
     * Gets the states being retained.
     *
     * @returns an array of states that are already entered from a previous Transition, that will not be
     *    exited during this Transition
     */
    Transition.prototype.retained = function () {
        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);
    };
    /**
     * Get the [[ViewConfig]]s associated with this Transition
     *
     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.
     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., "to" or "entering").
     *
     * @param pathname the name of the path to fetch views for:
     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)
     * @param state If provided, only returns the `ViewConfig`s for a single state in the path
     *
     * @returns a list of ViewConfig objects for the given path.
     */
    Transition.prototype.views = function (pathname, state) {
        if (pathname === void 0) { pathname = "entering"; }
        var path = this._treeChanges[pathname];
        path = !state ? path : path.filter(hof_1.propEq('state', state));
        return path.map(hof_1.prop("views")).filter(common_1.identity).reduce(common_1.unnestR, []);
    };
    Transition.prototype.treeChanges = function (pathname) {
        return pathname ? this._treeChanges[pathname] : this._treeChanges;
    };
    /**
     * Creates a new transition that is a redirection of the current one.
     *
     * This transition can be returned from a [[TransitionService]] hook to
     * redirect a transition to a new state and/or set of parameters.
     *
     * @internalapi
     *
     * @returns Returns a new [[Transition]] instance.
     */
    Transition.prototype.redirect = function (targetState) {
        var redirects = 1, trans = this;
        while ((trans = trans.redirectedFrom()) != null) {
            if (++redirects > 20)
                throw new Error("Too many consecutive Transition redirects (20+)");
        }
        var redirectOpts = { redirectedFrom: this, source: "redirect" };
        // If the original transition was caused by URL sync, then use { location: 'replace' }
        // on the new transition (unless the target state explicitly specifies location: false).
        // This causes the original url to be replaced with the url for the redirect target
        // so the original url disappears from the browser history.
        if (this.options().source === 'url' && targetState.options().location !== false) {
            redirectOpts.location = 'replace';
        }
        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);
        targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);
        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);
        var originalEnteringNodes = this._treeChanges.entering;
        var redirectEnteringNodes = newTransition._treeChanges.entering;
        // --- Re-use resolve data from original transition ---
        // When redirecting from a parent state to a child state where the parent parameter values haven't changed
        // (because of the redirect), the resolves fetched by the original transition are still valid in the
        // redirected transition.
        //
        // This allows you to define a redirect on a parent state which depends on an async resolve value.
        // You can wait for the resolve, then redirect to a child state based on the result.
        // The redirected transition does not have to re-fetch the resolve.
        // ---------------------------------------------------------
        var nodeIsReloading = function (reloadState) { return function (node) {
            return reloadState && node.state.includes[reloadState.name];
        }; };
        // Find any "entering" nodes in the redirect path that match the original path and aren't being reloaded
        var matchingEnteringNodes = pathFactory_1.PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, pathFactory_1.PathUtils.nonDynamicParams)
            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));
        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.
        matchingEnteringNodes.forEach(function (node, idx) {
            node.resolvables = originalEnteringNodes[idx].resolvables;
        });
        return newTransition;
    };
    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */
    Transition.prototype._changedParams = function () {
        var tc = this._treeChanges;
        /** Return undefined if it's not a "dynamic" transition, for the following reasons */
        // If user explicitly wants a reload
        if (this._options.reload)
            return undefined;
        // If any states are exiting or entering
        if (tc.exiting.length || tc.entering.length)
            return undefined;
        // If to/from path lengths differ
        if (tc.to.length !== tc.from.length)
            return undefined;
        // If the to/from paths are different
        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)
            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })
            .reduce(common_1.anyTrueR, false);
        if (pathsDiffer)
            return undefined;
        // Find any parameter values that differ
        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });
        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];
        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);
        return tuples.map(function (_a) {
            var schema = _a[0], toVals = _a[1], fromVals = _a[2];
            return param_1.Param.changed(schema, toVals, fromVals);
        }).reduce(common_1.unnestR, []);
    };
    /**
     * Returns true if the transition is dynamic.
     *
     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.
     *
     * @returns true if the Transition is dynamic
     */
    Transition.prototype.dynamic = function () {
        var changes = this._changedParams();
        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);
    };
    /**
     * Returns true if the transition is ignored.
     *
     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.
     *
     * @returns true if the Transition is ignored.
     */
    Transition.prototype.ignored = function () {
        return !!this._ignoredReason();
    };
    /** @hidden */
    Transition.prototype._ignoredReason = function () {
        var pending = this.router.globals.transition;
        var reloadState = this._options.reloadState;
        var same = function (pathA, pathB) {
            if (pathA.length !== pathB.length)
                return false;
            var matching = pathFactory_1.PathUtils.matching(pathA, pathB);
            return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;
        };
        var newTC = this.treeChanges();
        var pendTC = pending && pending.treeChanges();
        if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))
            return "SameAsPending";
        if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))
            return "SameAsCurrent";
    };
    /**
     * Runs the transition
     *
     * This method is generally called from the [[StateService.transitionTo]]
     *
     * @internalapi
     *
     * @returns a promise for a successful transition.
     */
    Transition.prototype.run = function () {
        var _this = this;
        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;
        // Gets transition hooks array for the given phase
        var getHooksFor = function (phase) {
            return _this._hookBuilder.buildHooksForPhase(phase);
        };
        // When the chain is complete, then resolve or reject the deferred
        var transitionSuccess = function () {
            trace_1.trace.traceSuccess(_this.$to(), _this);
            _this.success = true;
            _this._deferred.resolve(_this.to());
            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.SUCCESS));
        };
        var transitionError = function (reason) {
            trace_1.trace.traceError(reason, _this);
            _this.success = false;
            _this._deferred.reject(reason);
            _this._error = reason;
            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.ERROR));
        };
        var runTransition = function () {
            // Wait to build the RUN hook chain until the BEFORE hooks are done
            // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.
            var allRunHooks = getHooksFor(interface_1.TransitionHookPhase.RUN);
            var done = function () { return coreservices_1.services.$q.when(undefined); };
            return transitionHook_1.TransitionHook.invokeHooks(allRunHooks, done);
        };
        var startTransition = function () {
            var globals = _this.router.globals;
            globals.lastStartedTransitionId = _this.$id;
            globals.transition = _this;
            globals.transitionHistory.enqueue(_this);
            trace_1.trace.traceTransitionStart(_this);
            return coreservices_1.services.$q.when(undefined);
        };
        var allBeforeHooks = getHooksFor(interface_1.TransitionHookPhase.BEFORE);
        transitionHook_1.TransitionHook.invokeHooks(allBeforeHooks, startTransition)
            .then(runTransition)
            .then(transitionSuccess, transitionError);
        return this.promise;
    };
    /**
     * Checks if the Transition is valid
     *
     * @returns true if the Transition is valid
     */
    Transition.prototype.valid = function () {
        return !this.error() || this.success !== undefined;
    };
    /**
     * Aborts this transition
     *
     * Imperative API to abort a Transition.
     * This only applies to Transitions that are not yet complete.
     */
    Transition.prototype.abort = function () {
        // Do not set flag if the transition is already complete
        if (predicates_1.isUndefined(this.success)) {
            this._aborted = true;
        }
    };
    /**
     * The Transition error reason.
     *
     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.
     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.
     *
     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.
     */
    Transition.prototype.error = function () {
        var state = this.$to();
        if (state.self.abstract)
            return "Cannot transition to abstract state '" + state.name + "'";
        if (!param_1.Param.validates(state.parameters(), this.params()))
            return "Param values not valid for state '" + state.name + "'";
        if (this.success === false)
            return this._error;
    };
    /**
     * A string representation of the Transition
     *
     * @returns A string representation of the Transition
     */
    Transition.prototype.toString = function () {
        var fromStateOrName = this.from();
        var toStateOrName = this.to();
        var avoidEmptyHash = function (params) {
            return (params["#"] !== null && params["#"] !== undefined) ? params : common_1.omit(params, ["#"]);
        };
        // (X) means the to state is invalid.
        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? "" : "(X) ", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));
        return "Transition#" + id + "( '" + from + "'" + fromParams + " -> " + toValid + "'" + to + "'" + toParams + " )";
    };
    return Transition;
}());
/** @hidden */
Transition.diToken = Transition;
exports.Transition = Transition;
//# sourceMappingURL=transition.js.map

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module url
 */
/** for typedoc */
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var predicates_1 = __webpack_require__(1);
var param_1 = __webpack_require__(8);
var strings_1 = __webpack_require__(5);
/** @hidden */
function quoteRegExp(string, param) {
    var surroundPattern = ['', ''], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
    if (!param)
        return result;
    switch (param.squash) {
        case false:
            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];
            break;
        case true:
            result = result.replace(/\/$/, '');
            surroundPattern = ['(?:\/(', ')|\/)?'];
            break;
        default:
            surroundPattern = ["(" + param.squash + "|", ')?'];
            break;
    }
    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];
}
/** @hidden */
var memoizeTo = function (obj, prop, fn) {
    return obj[prop] = obj[prop] || fn();
};
/** @hidden */
var splitOnSlash = strings_1.splitOnDelim('/');
/**
 * Matches URLs against patterns.
 *
 * Matches URLs against patterns and extracts named parameters from the path or the search
 * part of the URL.
 *
 * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)
 * parameters. Multiple search parameter names are separated by '&'. Search parameters
 * do not influence whether or not a URL is matched, but their values are passed through into
 * the matched parameters returned by [[UrlMatcher.exec]].
 *
 * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)
 * or colon placeholders (`/somePath/:param`).
 *
 * - *A parameter RegExp* may be defined for a param after a colon
 * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.
 * The regexp must match for the url to be matched.
 * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
 *
 * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].
 *
 * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.
 *   See [[UrlMatcherFactory.type]] for more information.
 *
 * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).
 *   A catch-all * parameter value will contain the remainder of the URL.
 *
 * ---
 *
 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
 * must be unique within the pattern (across both path and search parameters).
 * A path parameter matches any number of characters other than '/'. For catch-all
 * placeholders the path parameter matches any number of characters.
 *
 * Examples:
 *
 * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
 * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
 * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
 * * `'/user/{id:[^/]*}'` - Same as the previous example.
 * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
 *   parameter consists of 1 to 8 hex digits.
 * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
 *   path into the parameter 'path'.
 * * `'/files/*path'` - ditto.
 * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
 *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start
 *
 */
var UrlMatcher = (function () {
    /**
     * @param pattern The pattern to compile into a matcher.
     * @param paramTypes The [[ParamTypes]] registry
     * @param config  A configuration object
     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.
     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.
     */
    function UrlMatcher(pattern, paramTypes, paramFactory, config) {
        var _this = this;
        this.config = config;
        /** @hidden */
        this._cache = { path: [this] };
        /** @hidden */
        this._children = [];
        /** @hidden */
        this._params = [];
        /** @hidden */
        this._segments = [];
        /** @hidden */
        this._compiled = [];
        this.pattern = pattern;
        this.config = common_1.defaults(this.config, {
            params: {},
            strict: true,
            caseInsensitive: false,
            paramMap: common_1.identity
        });
        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
        //   '*' name
        //   ':' name
        //   '{' name '}'
        //   '{' name ':' regexp '}'
        // The regular expression is somewhat complicated due to the need to allow curly braces
        // inside the regular expression. The placeholder regexp breaks down as follows:
        //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
        //    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
        //    [^{}\\]+                       - anything other than curly braces or backslash
        //    \\.                            - a backslash escape
        //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, last = 0, m, patterns = [];
        var checkParamErrors = function (id) {
            if (!UrlMatcher.nameValidator.test(id))
                throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (common_1.find(_this._params, hof_1.propEq('id', id)))
                throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
        };
        // Split into static segments separated by path parameter placeholders.
        // The number of segments is always 1 more than the number of parameters.
        var matchDetails = function (m, isSearch) {
            // IE[78] returns '' for unmatched groups instead of null
            var id = m[2] || m[3];
            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '.*' : null);
            var makeRegexpType = function (regexp) { return common_1.inherit(paramTypes.type(isSearch ? "query" : "path"), {
                pattern: new RegExp(regexp, _this.config.caseInsensitive ? 'i' : undefined)
            }); };
            return {
                id: id,
                regexp: regexp,
                cfg: _this.config.params[id],
                segment: pattern.substring(last, m.index),
                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)
            };
        };
        var p, segment;
        while ((m = placeholder.exec(pattern))) {
            p = matchDetails(m, false);
            if (p.segment.indexOf('?') >= 0)
                break; // we're into the search part
            checkParamErrors(p.id);
            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));
            this._segments.push(p.segment);
            patterns.push([p.segment, common_1.tail(this._params)]);
            last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        // Find any search parameter names and remove them from the last segment
        var i = segment.indexOf('?');
        if (i >= 0) {
            var search = segment.substring(i);
            segment = segment.substring(0, i);
            if (search.length > 0) {
                last = 0;
                while ((m = searchPlaceholder.exec(search))) {
                    p = matchDetails(m, true);
                    checkParamErrors(p.id);
                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));
                    last = placeholder.lastIndex;
                    // check if ?&
                }
            }
        }
        this._segments.push(segment);
        this._compiled = patterns.map(function (pattern) { return quoteRegExp.apply(null, pattern); }).concat(quoteRegExp(segment));
    }
    /**
     * Creates a new concatenated UrlMatcher
     *
     * Builds a new UrlMatcher by appending another UrlMatcher to this one.
     *
     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.
     */
    UrlMatcher.prototype.append = function (url) {
        this._children.push(url);
        url._cache = {
            path: this._cache.path.concat(url),
            parent: this,
            pattern: null,
        };
        return url;
    };
    /** @hidden */
    UrlMatcher.prototype.isRoot = function () {
        return this._cache.path[0] === this;
    };
    /** Returns the input pattern string */
    UrlMatcher.prototype.toString = function () {
        return this.pattern;
    };
    /**
     * Tests the specified url/path against this matcher.
     *
     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured
     * parameter values.  Returns null if the path does not match.
     *
     * The returned object contains the values
     * of any search parameters that are mentioned in the pattern, but their value may be null if
     * they are not present in `search`. This means that search parameters are always treated
     * as optional.
     *
     * #### Example:
     * ```js
     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
     *   x: '1', q: 'hello'
     * });
     * // returns { id: 'bob', q: 'hello', r: null }
     * ```
     *
     * @param path    The URL path to match, e.g. `$location.path()`.
     * @param search  URL search parameters, e.g. `$location.search()`.
     * @param hash    URL hash e.g. `$location.hash()`.
     * @param options
     *
     * @returns The captured parameter values.
     */
    UrlMatcher.prototype.exec = function (path, search, hash, options) {
        var _this = this;
        if (search === void 0) { search = {}; }
        if (options === void 0) { options = {}; }
        var match = memoizeTo(this._cache, 'pattern', function () {
            return new RegExp([
                '^',
                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),
                _this.config.strict === false ? '\/?' : '',
                '$'
            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);
        }).exec(path);
        if (!match)
            return null;
        //options = defaults(options, { isolate: false });
        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};
        if (nPathSegments !== match.length - 1)
            throw new Error("Unbalanced capture group in route '" + this.pattern + "'");
        function decodePathArray(string) {
            var reverseString = function (str) { return str.split("").reverse().join(""); };
            var unquoteDashes = function (str) { return str.replace(/\\-/g, "-"); };
            var split = reverseString(string).split(/-(?!\\)/);
            var allReversed = common_1.map(split, reverseString);
            return common_1.map(allReversed, unquoteDashes).reverse();
        }
        for (var i = 0; i < nPathSegments; i++) {
            var param = pathParams[i];
            var value = match[i + 1];
            // if the param value matches a pre-replace pair, replace the value before decoding.
            for (var j = 0; j < param.replace.length; j++) {
                if (param.replace[j].from === value)
                    value = param.replace[j].to;
            }
            if (value && param.array === true)
                value = decodePathArray(value);
            if (predicates_1.isDefined(value))
                value = param.type.decode(value);
            values[param.id] = param.value(value);
        }
        searchParams.forEach(function (param) {
            var value = search[param.id];
            for (var j = 0; j < param.replace.length; j++) {
                if (param.replace[j].from === value)
                    value = param.replace[j].to;
            }
            if (predicates_1.isDefined(value))
                value = param.type.decode(value);
            values[param.id] = param.value(value);
        });
        if (hash)
            values["#"] = hash;
        return values;
    };
    /**
     * @hidden
     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.
     *
     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the
     *    pattern has no parameters, an empty array is returned.
     */
    UrlMatcher.prototype.parameters = function (opts) {
        if (opts === void 0) { opts = {}; }
        if (opts.inherit === false)
            return this._params;
        return common_1.unnest(this._cache.path.map(function (matcher) { return matcher._params; }));
    };
    /**
     * @hidden
     * Returns a single parameter from this UrlMatcher by id
     *
     * @param id
     * @param opts
     * @returns {T|Param|any|boolean|UrlMatcher|null}
     */
    UrlMatcher.prototype.parameter = function (id, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var findParam = function () {
            for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {
                var param = _a[_i];
                if (param.id === id)
                    return param;
            }
        };
        var parent = this._cache.parent;
        return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;
    };
    /**
     * Validates the input parameter values against this UrlMatcher
     *
     * Checks an object hash of parameters to validate their correctness according to the parameter
     * types of this `UrlMatcher`.
     *
     * @param params The object hash of parameters to validate.
     * @returns Returns `true` if `params` validates, otherwise `false`.
     */
    UrlMatcher.prototype.validates = function (params) {
        var validParamVal = function (param, val) {
            return !param || param.validates(val);
        };
        params = params || {};
        // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher
        var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });
        return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(common_1.allTrueR, true);
    };
    /**
     * Given a set of parameter values, creates a URL from this UrlMatcher.
     *
     * Creates a URL that matches this pattern by substituting the specified values
     * for the path and search parameters.
     *
     * #### Example:
     * ```js
     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
     * // returns '/user/bob?q=yes'
     * ```
     *
     * @param values  the values to substitute for the parameters in this pattern.
     * @returns the formatted URL (path and optionally search part).
     */
    UrlMatcher.prototype.format = function (values) {
        if (values === void 0) { values = {}; }
        // Build the full path of UrlMatchers (including all parent UrlMatchers)
        var urlMatchers = this._cache.path;
        // Extract all the static segments and Params (processed as ParamDetails)
        // into an ordered array
        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams)
            .reduce(common_1.unnestR, [])
            .map(function (x) { return predicates_1.isString(x) ? x : getDetails(x); });
        // Extract the query params into a separate array
        var queryParams = urlMatchers.map(UrlMatcher.queryParams)
            .reduce(common_1.unnestR, [])
            .map(getDetails);
        var isInvalid = function (param) { return param.isValid === false; };
        if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {
            return null;
        }
        /**
         * Given a Param, applies the parameter value, then returns detailed information about it
         */
        function getDetails(param) {
            // Normalize to typed value
            var value = param.value(values[param.id]);
            var isValid = param.validates(value);
            var isDefaultValue = param.isDefaultValue(value);
            // Check if we're in squash mode for the parameter
            var squash = isDefaultValue ? param.squash : false;
            // Allow the Parameter's Type to encode the value
            var encoded = param.type.encode(value);
            return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };
        }
        // Build up the path-portion from the list of static segments and parameters
        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {
            // The element is a static segment (a raw string); just append it
            if (predicates_1.isString(x))
                return acc + x;
            // Otherwise, it's a ParamDetails.
            var squash = x.squash, encoded = x.encoded, param = x.param;
            // If squash is === true, try to remove a slash from the path
            if (squash === true)
                return (acc.match(/\/$/)) ? acc.slice(0, -1) : acc;
            // If squash is a string, use the string for the param value
            if (predicates_1.isString(squash))
                return acc + squash;
            if (squash !== false)
                return acc; // ?
            if (encoded == null)
                return acc;
            // If this parameter value is an array, encode the value using encodeDashes
            if (predicates_1.isArray(encoded))
                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join("-");
            // If the parameter type is "raw", then do not encodeURIComponent
            if (param.raw)
                return acc + encoded;
            // Encode the value
            return acc + encodeURIComponent(encoded);
        }, "");
        // Build the query string by applying parameter values (array or regular)
        // then mapping to key=value, then flattening and joining using "&"
        var queryString = queryParams.map(function (paramDetails) {
            var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;
            if (encoded == null || (isDefaultValue && squash !== false))
                return;
            if (!predicates_1.isArray(encoded))
                encoded = [encoded];
            if (encoded.length === 0)
                return;
            if (!param.raw)
                encoded = common_1.map(encoded, encodeURIComponent);
            return encoded.map(function (val) { return param.id + "=" + val; });
        }).filter(common_1.identity).reduce(common_1.unnestR, []).join("&");
        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)
        return pathString + (queryString ? "?" + queryString : "") + (values["#"] ? "#" + values["#"] : "");
    };
    /** @hidden */
    UrlMatcher.encodeDashes = function (str) {
        return encodeURIComponent(str).replace(/-/g, function (c) { return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase(); });
    };
    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */
    UrlMatcher.pathSegmentsAndParams = function (matcher) {
        var staticSegments = matcher._segments;
        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });
        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))
            .reduce(common_1.unnestR, [])
            .filter(function (x) { return x !== "" && predicates_1.isDefined(x); });
    };
    /** @hidden Given a matcher, return an array with the matcher's query params */
    UrlMatcher.queryParams = function (matcher) {
        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });
    };
    /**
     * Compare two UrlMatchers
     *
     * This comparison function converts a UrlMatcher into static and dynamic path segments.
     * Each static path segment is a static string between a path separator (slash character).
     * Each dynamic segment is a path parameter.
     *
     * The comparison function sorts static segments before dynamic ones.
     */
    UrlMatcher.compare = function (a, b) {
        /**
         * Turn a UrlMatcher and all its parent matchers into an array
         * of slash literals '/', string literals, and Param objects
         *
         * This example matcher matches strings like "/foo/:param/tail":
         * var matcher = $umf.compile("/foo").append($umf.compile("/:param")).append($umf.compile("/")).append($umf.compile("tail"));
         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]
         *
         * Caches the result as `matcher._cache.segments`
         */
        var segments = function (matcher) {
            return matcher._cache.segments = matcher._cache.segments ||
                matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)
                    .reduce(common_1.unnestR, [])
                    .reduce(strings_1.joinNeighborsR, [])
                    .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })
                    .reduce(common_1.unnestR, []);
        };
        /**
         * Gets the sort weight for each segment of a UrlMatcher
         *
         * Caches the result as `matcher._cache.weights`
         */
        var weights = function (matcher) {
            return matcher._cache.weights = matcher._cache.weights ||
                segments(matcher).map(function (segment) {
                    // Sort slashes first, then static strings, the Params
                    if (segment === '/')
                        return 1;
                    if (predicates_1.isString(segment))
                        return 2;
                    if (segment instanceof param_1.Param)
                        return 3;
                });
        };
        var cmp, i, pairs = common_1.arrayTuples(weights(a), weights(b));
        for (i = 0; i < pairs.length; i++) {
            cmp = pairs[i][0] - pairs[i][1];
            if (cmp !== 0)
                return cmp;
        }
        return 0;
    };
    return UrlMatcher;
}());
/** @hidden */
UrlMatcher.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/;
exports.UrlMatcher = UrlMatcher;
//# sourceMappingURL=urlMatcher.js.map

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @internalapi
 * @module vanilla
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(15);
var predicates_1 = __webpack_require__(1);
var common_1 = __webpack_require__(0);
/** A base `LocationServices` */
var BaseLocationServices = (function () {
    function BaseLocationServices(router, fireAfterUpdate) {
        var _this = this;
        this.fireAfterUpdate = fireAfterUpdate;
        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };
        this._listeners = [];
        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };
        this.path = function () { return utils_1.parseUrl(_this._get()).path; };
        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };
        this._location = window && window.location;
        this._history = window && window.history;
    }
    BaseLocationServices.prototype.url = function (url, replace) {
        if (replace === void 0) { replace = true; }
        if (predicates_1.isDefined(url) && url !== this._get()) {
            this._set(null, null, url, replace);
            if (this.fireAfterUpdate) {
                var evt_1 = common_1.extend(new Event("locationchange"), { url: url });
                this._listeners.forEach(function (cb) { return cb(evt_1); });
            }
        }
        return utils_1.buildUrl(this);
    };
    BaseLocationServices.prototype.onChange = function (cb) {
        var _this = this;
        this._listeners.push(cb);
        return function () { return common_1.removeFrom(_this._listeners, cb); };
    };
    BaseLocationServices.prototype.dispose = function (router) {
        common_1.deregAll(this._listeners);
    };
    return BaseLocationServices;
}());
exports.BaseLocationServices = BaseLocationServices;
//# sourceMappingURL=baseLocationService.js.map

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @module common
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var Queue = (function () {
    function Queue(_items, _limit) {
        if (_items === void 0) { _items = []; }
        if (_limit === void 0) { _limit = null; }
        this._items = _items;
        this._limit = _limit;
    }
    Queue.prototype.enqueue = function (item) {
        var items = this._items;
        items.push(item);
        if (this._limit && items.length > this._limit)
            items.shift();
        return item;
    };
    Queue.prototype.dequeue = function () {
        if (this.size())
            return this._items.splice(0, 1)[0];
    };
    Queue.prototype.clear = function () {
        var current = this._items;
        this._items = [];
        return current;
    };
    Queue.prototype.size = function () {
        return this._items.length;
    };
    Queue.prototype.remove = function (item) {
        var idx = this._items.indexOf(item);
        return idx > -1 && this._items.splice(idx, 1)[0];
    };
    Queue.prototype.peekTail = function () {
        return this._items[this._items.length - 1];
    };
    Queue.prototype.peekHead = function () {
        if (this.size())
            return this._items[0];
    };
    return Queue;
}());
exports.Queue = Queue;
//# sourceMappingURL=queue.js.map

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module params
 */
/** */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
/**
 * An internal class which implements [[ParamTypeDefinition]].
 *
 * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.
 * When a param type definition is registered, an instance of this class is created internally.
 *
 * This class has naive implementations for all the [[ParamTypeDefinition]] methods.
 *
 * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.
 *
 * #### Example:
 * ```js
 * var paramTypeDef = {
 *   decode: function(val) { return parseInt(val, 10); },
 *   encode: function(val) { return val && val.toString(); },
 *   equals: function(a, b) { return this.is(a) && a === b; },
 *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },
 *   pattern: /\d+/
 * }
 *
 * var paramType = new ParamType(paramTypeDef);
 * ```
 * @internalapi
 */
var ParamType = (function () {
    /**
     * @param def  A configuration object which contains the custom type definition.  The object's
     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.
     * @returns a new ParamType object
     */
    function ParamType(def) {
        /** @inheritdoc */
        this.pattern = /.*/;
        /** @inheritdoc */
        this.inherit = true;
        common_1.extend(this, def);
    }
    // consider these four methods to be "abstract methods" that should be overridden
    /** @inheritdoc */
    ParamType.prototype.is = function (val, key) { return true; };
    /** @inheritdoc */
    ParamType.prototype.encode = function (val, key) { return val; };
    /** @inheritdoc */
    ParamType.prototype.decode = function (val, key) { return val; };
    /** @inheritdoc */
    ParamType.prototype.equals = function (a, b) { return a == b; };
    ParamType.prototype.$subPattern = function () {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    };
    ParamType.prototype.toString = function () {
        return "{ParamType:" + this.name + "}";
    };
    /** Given an encoded string, or a decoded object, returns a decoded object */
    ParamType.prototype.$normalize = function (val) {
        return this.is(val) ? val : this.decode(val);
    };
    /**
     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.
     * e.g.:
     * - urlmatcher pattern "/path?{queryParam[]:int}"
     * - url: "/path?queryParam=1&queryParam=2
     * - $stateParams.queryParam will be [1, 2]
     * if `mode` is "auto", then
     * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
     * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
     */
    ParamType.prototype.$asArray = function (mode, isSearch) {
        if (!mode)
            return this;
        if (mode === "auto" && !isSearch)
            throw new Error("'auto' array mode is for query parameters only");
        return new ArrayType(this, mode);
    };
    return ParamType;
}());
exports.ParamType = ParamType;
/**
 * Wraps up a `ParamType` object to handle array values.
 * @internalapi
 */
function ArrayType(type, mode) {
    var _this = this;
    // Wrap non-array value as array
    function arrayWrap(val) {
        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);
    }
    // Unwrap array value for "auto" mode. Return undefined for empty array.
    function arrayUnwrap(val) {
        switch (val.length) {
            case 0: return undefined;
            case 1: return mode === "auto" ? val[0] : val;
            default: return val;
        }
    }
    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
    function arrayHandler(callback, allTruthyMode) {
        return function handleArray(val) {
            if (predicates_1.isArray(val) && val.length === 0)
                return val;
            var arr = arrayWrap(val);
            var result = common_1.map(arr, callback);
            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);
        };
    }
    // Wraps type (.equals) functions to operate on each value of an array
    function arrayEqualsHandler(callback) {
        return function handleArray(val1, val2) {
            var left = arrayWrap(val1), right = arrayWrap(val2);
            if (left.length !== right.length)
                return false;
            for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                    return false;
            }
            return true;
        };
    }
    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {
        var paramTypeFn = type[name].bind(type);
        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;
        _this[name] = wrapperFn(paramTypeFn);
    });
    common_1.extend(this, {
        dynamic: type.dynamic,
        name: type.name,
        pattern: type.pattern,
        inherit: type.inherit,
        is: arrayHandler(type.is.bind(type), true),
        $arrayMode: mode
    });
}
//# sourceMappingURL=paramType.js.map

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module path */ /** for typedoc */
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var param_1 = __webpack_require__(8);
/**
 * @internalapi
 *
 * A node in a [[TreeChanges]] path
 *
 * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.
 * Each PathNode corresponds to a state being entered, exited, or retained.
 * The stateful information includes parameter values and resolve data.
 */
var PathNode = (function () {
    function PathNode(stateOrNode) {
        if (stateOrNode instanceof PathNode) {
            var node = stateOrNode;
            this.state = node.state;
            this.paramSchema = node.paramSchema.slice();
            this.paramValues = common_1.extend({}, node.paramValues);
            this.resolvables = node.resolvables.slice();
            this.views = node.views && node.views.slice();
        }
        else {
            var state = stateOrNode;
            this.state = state;
            this.paramSchema = state.parameters({ inherit: false });
            this.paramValues = {};
            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });
        }
    }
    /** Sets [[paramValues]] for the node, from the values of an object hash */
    PathNode.prototype.applyRawParams = function (params) {
        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };
        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});
        return this;
    };
    /** Gets a specific [[Param]] metadata that belongs to the node */
    PathNode.prototype.parameter = function (name) {
        return common_1.find(this.paramSchema, hof_1.propEq("id", name));
    };
    /**
     * @returns true if the state and parameter values for another PathNode are
     * equal to the state and param values for this PathNode
     */
    PathNode.prototype.equals = function (node, paramsFn) {
        var diff = this.diff(node, paramsFn);
        return diff && diff.length === 0;
    };
    /**
     * Finds Params with different parameter values on another PathNode.
     *
     * Given another node (of the same state), finds the parameter values which differ.
     * Returns the [[Param]] (schema objects) whose parameter values differ.
     *
     * Given another node for a different state, returns `false`
     *
     * @param node The node to compare to
     * @param paramsFn A function that returns which parameters should be compared.
     * @returns The [[Param]]s which differ, or null if the two nodes are for different states
     */
    PathNode.prototype.diff = function (node, paramsFn) {
        if (this.state !== node.state)
            return false;
        var params = paramsFn ? paramsFn(this) : this.paramSchema;
        return param_1.Param.changed(params, this.paramValues, node.paramValues);
    };
    /** Returns a clone of the PathNode */
    PathNode.clone = function (node) {
        return new PathNode(node);
    };
    return PathNode;
}());
exports.PathNode = PathNode;
//# sourceMappingURL=pathNode.js.map

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var glob_1 = __webpack_require__(16);
var predicates_1 = __webpack_require__(1);
/**
 * Internal representation of a UI-Router state.
 *
 * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].
 *
 * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.
 *
 * This class prototypally inherits from the corresponding [[StateDeclaration]].
 * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].
 */
var StateObject = (function () {
    /** @deprecated use State.create() */
    function StateObject(config) {
        return StateObject.create(config || {});
    }
    /**
     * Create a state object to put the private/internal implementation details onto.
     * The object's prototype chain looks like:
     * (Internal State Object) -> (Copy of State.prototype) -> (State Declaration object) -> (State Declaration's prototype...)
     *
     * @param stateDecl the user-supplied State Declaration
     * @returns {StateObject} an internal State object
     */
    StateObject.create = function (stateDecl) {
        stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;
        var state = common_1.inherit(common_1.inherit(stateDecl, StateObject.prototype));
        stateDecl.$$state = function () { return state; };
        state.self = stateDecl;
        state.__stateObjectCache = {
            nameGlob: glob_1.Glob.fromString(state.name) // might return null
        };
        return state;
    };
    /**
     * Returns true if the provided parameter is the same state.
     *
     * Compares the identity of the state against the passed value, which is either an object
     * reference to the actual `State` instance, the original definition object passed to
     * `$stateProvider.state()`, or the fully-qualified name.
     *
     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed
     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.
     * @returns Returns `true` if `ref` matches the current `State` instance.
     */
    StateObject.prototype.is = function (ref) {
        return this === ref || this.self === ref || this.fqn() === ref;
    };
    /**
     * @deprecated this does not properly handle dot notation
     * @returns Returns a dot-separated name of the state.
     */
    StateObject.prototype.fqn = function () {
        if (!this.parent || !(this.parent instanceof this.constructor))
            return this.name;
        var name = this.parent.fqn();
        return name ? name + "." + this.name : this.name;
    };
    /**
     * Returns the root node of this state's tree.
     *
     * @returns The root of this state's tree.
     */
    StateObject.prototype.root = function () {
        return this.parent && this.parent.root() || this;
    };
    /**
     * Gets the state's `Param` objects
     *
     * Gets the list of [[Param]] objects owned by the state.
     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.
     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object
     *
     * @param opts options
     */
    StateObject.prototype.parameters = function (opts) {
        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });
        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];
        return inherited.concat(common_1.values(this.params))
            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });
    };
    /**
     * Returns a single [[Param]] that is owned by the state
     *
     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.
     * @param id the name of the [[Param]] to return
     * @param opts options
     */
    StateObject.prototype.parameter = function (id, opts) {
        if (opts === void 0) { opts = {}; }
        return (this.url && this.url.parameter(id, opts) ||
            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||
            opts.inherit && this.parent && this.parent.parameter(id));
    };
    StateObject.prototype.toString = function () {
        return this.fqn();
    };
    return StateObject;
}());
/** Predicate which returns true if the object is an class with @State() decorator */
StateObject.isStateClass = function (stateDecl) {
    return predicates_1.isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;
};
/** Predicate which returns true if the object is an internal [[StateObject]] object */
StateObject.isState = function (obj) {
    return predicates_1.isObject(obj['__stateObjectCache']);
};
exports.StateObject = StateObject;
//# sourceMappingURL=stateObject.js.map

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module transition
 */ /** for typedoc */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var interface_1 = __webpack_require__(9); // has or is using
var glob_1 = __webpack_require__(16);
/**
 * Determines if the given state matches the matchCriteria
 *
 * @hidden
 *
 * @param state a State Object to test against
 * @param criterion
 * - If a string, matchState uses the string as a glob-matcher against the state name
 * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name
 *   and returns a positive match if any of the globs match.
 * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.
 * @returns {boolean}
 */
function matchState(state, criterion) {
    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;
    function matchGlobs(_state) {
        var globStrings = toMatch;
        for (var i = 0; i < globStrings.length; i++) {
            var glob = new glob_1.Glob(globStrings[i]);
            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {
                return true;
            }
        }
        return false;
    }
    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);
    return !!matchFn(state);
}
exports.matchState = matchState;
/**
 * @internalapi
 * The registration data for a registered transition hook
 */
var RegisteredHook = (function () {
    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {
        if (options === void 0) { options = {}; }
        this.tranSvc = tranSvc;
        this.eventType = eventType;
        this.callback = callback;
        this.matchCriteria = matchCriteria;
        this.priority = options.priority || 0;
        this.bind = options.bind || null;
        this._deregistered = false;
    }
    /**
     * Gets the matching [[PathNode]]s
     *
     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing
     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.
     *
     * Returning `null` is significant to distinguish between the default
     * "match-all criterion value" of `true` compared to a `() => true` function,
     * when the nodes is an empty array.
     *
     * This is useful to allow a transition match criteria of `entering: true`
     * to still match a transition, even when `entering === []`.  Contrast that
     * with `entering: (state) => true` which only matches when a state is actually
     * being entered.
     */
    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {
        if (criterion === true)
            return nodes;
        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });
        return matching.length ? matching : null;
    };
    /**
     * Gets the default match criteria (all `true`)
     *
     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:
     *
     * ```js
     * {
     *   to: true,
     *   from: true,
     *   entering: true,
     *   exiting: true,
     *   retained: true,
     * }
     */
    RegisteredHook.prototype._getDefaultMatchCriteria = function () {
        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });
    };
    /**
     * Gets matching nodes as [[IMatchingNodes]]
     *
     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:
     *
     * ```js
     * let matches: IMatchingNodes = {
     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),
     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),
     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),
     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),
     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),
     * };
     * ```
     */
    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {
        var _this = this;
        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);
        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());
        return paths.reduce(function (mn, pathtype) {
            // STATE scope criteria matches against every node in the path.
            // TRANSITION scope criteria matches against only the last node in the path
            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;
            var path = treeChanges[pathtype.name] || [];
            var nodes = isStateHook ? path : [common_1.tail(path)];
            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);
            return mn;
        }, {});
    };
    /**
     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]
     *
     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values
     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)
     */
    RegisteredHook.prototype.matches = function (treeChanges) {
        var matches = this._getMatchingNodes(treeChanges);
        // Check if all the criteria matched the TreeChanges object
        var allMatched = common_1.values(matches).every(common_1.identity);
        return allMatched ? matches : null;
    };
    return RegisteredHook;
}());
exports.RegisteredHook = RegisteredHook;
/** @hidden Return a registration function of the requested type. */
function makeEvent(registry, transitionService, eventType) {
    // Create the object which holds the registered transition hooks.
    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});
    var hooks = _registeredHooks[eventType.name] = [];
    // Create hook registration function on the IHookRegistry for the event
    registry[eventType.name] = hookRegistrationFn;
    function hookRegistrationFn(matchObject, callback, options) {
        if (options === void 0) { options = {}; }
        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);
        hooks.push(registeredHook);
        return function deregisterEventHook() {
            registeredHook._deregistered = true;
            common_1.removeFrom(hooks)(registeredHook);
        };
    }
    return hookRegistrationFn;
}
exports.makeEvent = makeEvent;
//# sourceMappingURL=hookRegistry.js.map

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module transition
 */
/** for typedoc */
var interface_1 = __webpack_require__(9);
var transition_1 = __webpack_require__(20);
var hookRegistry_1 = __webpack_require__(27);
var coreResolvables_1 = __webpack_require__(67);
var redirectTo_1 = __webpack_require__(71);
var onEnterExitRetain_1 = __webpack_require__(70);
var resolve_1 = __webpack_require__(72);
var views_1 = __webpack_require__(75);
var updateGlobals_1 = __webpack_require__(73);
var url_1 = __webpack_require__(74);
var lazyLoad_1 = __webpack_require__(32);
var transitionEventType_1 = __webpack_require__(43);
var transitionHook_1 = __webpack_require__(14);
var predicates_1 = __webpack_require__(1);
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var ignoredTransition_1 = __webpack_require__(68);
var invalidTransition_1 = __webpack_require__(69);
/**
 * The default [[Transition]] options.
 *
 * Include this object when applying custom defaults:
 * let reloadOpts = { reload: true, notify: true }
 * let options = defaults(theirOpts, customDefaults, defaultOptions);
 */
exports.defaultTransOpts = {
    location: true,
    relative: null,
    inherit: false,
    notify: true,
    reload: false,
    custom: {},
    current: function () { return null; },
    source: "unknown"
};
/**
 * This class provides services related to Transitions.
 *
 * - Most importantly, it allows global Transition Hooks to be registered.
 * - It allows the default transition error handler to be set.
 * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).
 *
 * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.
 */
var TransitionService = (function () {
    /** @hidden */
    function TransitionService(_router) {
        /** @hidden */
        this._transitionCount = 0;
        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */
        this._eventTypes = [];
        /** @hidden The registered transition hooks */
        this._registeredHooks = {};
        /** @hidden The  paths on a criteria object */
        this._criteriaPaths = {};
        this._router = _router;
        this.$view = _router.viewService;
        this._deregisterHookFns = {};
        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [
            '_definePathType',
            '_defineEvent',
            '_getPathTypes',
            '_getEvents',
            'getHooks',
        ]);
        this._defineCorePaths();
        this._defineCoreEvents();
        this._registerCoreTransitionHooks();
    }
    /**
     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.
     *
     * Registers a transition lifecycle hook, which is invoked during transition construction.
     *
     * This low level hook should only be used by plugins.
     * This can be a useful time for plugins to add resolves or mutate the transition as needed.
     * The Sticky States plugin uses this hook to modify the treechanges.
     *
     * ### Lifecycle
     *
     * `onCreate` hooks are invoked *while a transition is being constructed*.
     *
     * ### Return value
     *
     * The hook's return value is ignored
     *
     * @internalapi
     * @param criteria defines which Transitions the Hook should be invoked for.
     * @param callback the hook function which will be invoked.
     * @param options the registration options
     * @returns a function which deregisters the hook.
     */
    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };
    /** @inheritdoc */
    TransitionService.prototype.onError = function (criteria, callback, options) { return; };
    /**
     * dispose
     * @internalapi
     */
    TransitionService.prototype.dispose = function (router) {
        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {
            hook._deregistered = true;
            common_1.removeFrom(hooksArray, hook);
        }); });
    };
    /**
     * Creates a new [[Transition]] object
     *
     * This is a factory function for creating new Transition objects.
     * It is used internally by the [[StateService]] and should generally not be called by application code.
     *
     * @param fromPath the path to the current state (the from state)
     * @param targetState the target state (destination)
     * @returns a Transition
     */
    TransitionService.prototype.create = function (fromPath, targetState) {
        return new transition_1.Transition(fromPath, targetState, this._router);
    };
    /** @hidden */
    TransitionService.prototype._defineCoreEvents = function () {
        var Phase = interface_1.TransitionHookPhase;
        var TH = transitionHook_1.TransitionHook;
        var paths = this._criteriaPaths;
        var NORMAL_SORT = false, REVERSE_SORT = true;
        var ASYNCHRONOUS = false, SYNCHRONOUS = true;
        this._defineEvent("onCreate", Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);
        this._defineEvent("onBefore", Phase.BEFORE, 0, paths.to);
        this._defineEvent("onStart", Phase.RUN, 0, paths.to);
        this._defineEvent("onExit", Phase.RUN, 100, paths.exiting, REVERSE_SORT);
        this._defineEvent("onRetain", Phase.RUN, 200, paths.retained);
        this._defineEvent("onEnter", Phase.RUN, 300, paths.entering);
        this._defineEvent("onFinish", Phase.RUN, 400, paths.to);
        this._defineEvent("onSuccess", Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
        this._defineEvent("onError", Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
    };
    /** @hidden */
    TransitionService.prototype._defineCorePaths = function () {
        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;
        this._definePathType("to", TRANSITION);
        this._definePathType("from", TRANSITION);
        this._definePathType("exiting", STATE);
        this._definePathType("retained", STATE);
        this._definePathType("entering", STATE);
    };
    /** @hidden */
    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
        if (reverseSort === void 0) { reverseSort = false; }
        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }
        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }
        if (synchronous === void 0) { synchronous = false; }
        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);
        this._eventTypes.push(eventType);
        hookRegistry_1.makeEvent(this, this, eventType);
    };
    ;
    /** @hidden */
    TransitionService.prototype._getEvents = function (phase) {
        var transitionHookTypes = predicates_1.isDefined(phase) ?
            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :
            this._eventTypes.slice();
        return transitionHookTypes.sort(function (l, r) {
            var cmpByPhase = l.hookPhase - r.hookPhase;
            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;
        });
    };
    /**
     * Adds a Path to be used as a criterion against a TreeChanges path
     *
     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.
     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`
     * Each state in the exiting path is checked against the criteria and returned as part of the match.
     *
     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.
     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`
     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.
     *
     * @hidden
     */
    TransitionService.prototype._definePathType = function (name, hookScope) {
        this._criteriaPaths[name] = { name: name, scope: hookScope };
    };
    /** * @hidden */
    TransitionService.prototype._getPathTypes = function () {
        return this._criteriaPaths;
    };
    /** @hidden */
    TransitionService.prototype.getHooks = function (hookName) {
        return this._registeredHooks[hookName];
    };
    /** @hidden */
    TransitionService.prototype._registerCoreTransitionHooks = function () {
        var fns = this._deregisterHookFns;
        fns.addCoreResolves = coreResolvables_1.registerAddCoreResolvables(this);
        fns.ignored = ignoredTransition_1.registerIgnoredTransitionHook(this);
        fns.invalid = invalidTransition_1.registerInvalidTransitionHook(this);
        // Wire up redirectTo hook
        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);
        // Wire up onExit/Retain/Enter state hooks
        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);
        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);
        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);
        // Wire up Resolve hooks
        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);
        fns.lazyResolve = resolve_1.registerLazyResolveState(this);
        // Wire up the View management hooks
        fns.loadViews = views_1.registerLoadEnteringViews(this);
        fns.activateViews = views_1.registerActivateViews(this);
        // Updates global state after a transition
        fns.updateGlobals = updateGlobals_1.registerUpdateGlobalState(this);
        // After globals.current is updated at priority: 10000
        fns.updateUrl = url_1.registerUpdateUrl(this);
        // Lazy load state trees
        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);
    };
    return TransitionService;
}());
exports.TransitionService = TransitionService;
//# sourceMappingURL=transitionService.js.map

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * # Angular 1 types
 *
 * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.
 * The customizations to the core types for Angular UI-Router are documented here.
 *
 * The optional [[$resolve]] service is also documented here.
 *
 * @module ng1
 * @preferred
 */
/** for typedoc */
var angular_1 = __webpack_require__(10);
var core_1 = __webpack_require__(4);
var views_1 = __webpack_require__(30);
var templateFactory_1 = __webpack_require__(94);
var stateProvider_1 = __webpack_require__(56);
var onEnterExitRetain_1 = __webpack_require__(93);
var locationServices_1 = __webpack_require__(91);
var urlRouterProvider_1 = __webpack_require__(57);
angular_1.ng.module("ui.router.angular1", []);
var mod_init = angular_1.ng.module('ui.router.init', []);
var mod_util = angular_1.ng.module('ui.router.util', ['ng', 'ui.router.init']);
var mod_rtr = angular_1.ng.module('ui.router.router', ['ui.router.util']);
var mod_state = angular_1.ng.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);
var mod_main = angular_1.ng.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);
var mod_cmpt = angular_1.ng.module('ui.router.compat', ['ui.router']); // tslint:disable-line
var router = null;
$uiRouter.$inject = ['$locationProvider'];
/** This angular 1 provider instantiates a Router and exposes its services via the angular injector */
function $uiRouter($locationProvider) {
    // Create a new instance of the Router when the $uiRouterProvider is initialized
    router = this.router = new core_1.UIRouter();
    router.stateProvider = new stateProvider_1.StateProvider(router.stateRegistry, router.stateService);
    // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties
    router.stateRegistry.decorator("views", views_1.ng1ViewsBuilder);
    router.stateRegistry.decorator("onExit", onEnterExitRetain_1.getStateHookBuilder("onExit"));
    router.stateRegistry.decorator("onRetain", onEnterExitRetain_1.getStateHookBuilder("onRetain"));
    router.stateRegistry.decorator("onEnter", onEnterExitRetain_1.getStateHookBuilder("onEnter"));
    router.viewService._pluginapi._viewConfigFactory('ng1', views_1.getNg1ViewConfigFactory());
    var ng1LocationService = router.locationService = router.locationConfig = new locationServices_1.Ng1LocationServices($locationProvider);
    locationServices_1.Ng1LocationServices.monkeyPatchPathParameterType(router);
    // backwards compat: also expose router instance as $uiRouterProvider.router
    router['router'] = router;
    router['$get'] = $get;
    $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];
    function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {
        ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser);
        delete router['router'];
        delete router['$get'];
        return router;
    }
    return router;
}
var getProviderFor = function (serviceName) { return ['$uiRouterProvider', function ($urp) {
        var service = $urp.router[serviceName];
        service["$get"] = function () { return service; };
        return service;
    }]; };
// This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)
runBlock.$inject = ['$injector', '$q', '$uiRouter'];
function runBlock($injector, $q, $uiRouter) {
    core_1.services.$injector = $injector;
    core_1.services.$q = $q;
    // The $injector is now available.
    // Find any resolvables that had dependency annotation deferred
    $uiRouter.stateRegistry.get()
        .map(function (x) { return x.$$state().resolvables; })
        .reduce(core_1.unnestR, [])
        .filter(function (x) { return x.deps === "deferred"; })
        .forEach(function (resolvable) { return resolvable.deps = $injector.annotate(resolvable.resolveFn); });
}
// $urlRouter service and $urlRouterProvider
var getUrlRouterProvider = function (uiRouter) {
    return uiRouter.urlRouterProvider = new urlRouterProvider_1.UrlRouterProvider(uiRouter);
};
// $state service and $stateProvider
// $urlRouter service and $urlRouterProvider
var getStateProvider = function () {
    return core_1.extend(router.stateProvider, { $get: function () { return router.stateService; } });
};
watchDigests.$inject = ['$rootScope'];
function watchDigests($rootScope) {
    $rootScope.$watch(function () { core_1.trace.approximateDigests++; });
}
exports.watchDigests = watchDigests;
mod_init.provider("$uiRouter", $uiRouter);
mod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);
mod_util.provider('$urlService', getProviderFor('urlService'));
mod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);
mod_util.provider('$templateFactory', function () { return new templateFactory_1.TemplateFactory(); });
mod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));
mod_state.provider('$uiRouterGlobals', getProviderFor('globals'));
mod_state.provider('$transitions', getProviderFor('transitionService'));
mod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);
mod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);
mod_main.factory('$view', function () { return router.viewService; });
mod_main.service("$trace", function () { return core_1.trace; });
mod_main.run(watchDigests);
mod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);
mod_state.run(['$state', function ($state) { }]);
mod_rtr.run(['$urlRouter', function ($urlRouter) { }]);
mod_init.run(runBlock);
/** @hidden TODO: find a place to move this */
exports.getLocals = function (ctx) {
    var tokens = ctx.getTokens().filter(core_1.isString);
    var tuples = tokens.map(function (key) {
        var resolvable = ctx.getResolvable(key);
        var waitPolicy = ctx.getPolicy(resolvable).async;
        return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];
    });
    return tuples.reduce(core_1.applyPairs, {});
};
//# sourceMappingURL=services.js.map

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(4);
function getNg1ViewConfigFactory() {
    var templateFactory = null;
    return function (path, view) {
        templateFactory = templateFactory || core_1.services.$injector.get("$templateFactory");
        return [new Ng1ViewConfig(path, view, templateFactory)];
    };
}
exports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;
var hasAnyKey = function (keys, obj) {
    return keys.reduce(function (acc, key) { return acc || core_1.isDefined(obj[key]); }, false);
};
/**
 * This is a [[StateBuilder.builder]] function for angular1 `views`.
 *
 * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
 * handles the `views` property with logic specific to @uirouter/angularjs (ng1).
 *
 * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object
 * and applies the state-level configuration to a view named `$default`.
 */
function ng1ViewsBuilder(state) {
    // Do not process root state
    if (!state.parent)
        return {};
    var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);
    // Do not allow a state to have both state-level props and also a `views: {}` property.
    // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.
    // However, the `$default` approach should not be mixed with a separate `views: ` block.
    if (core_1.isDefined(state.views) && hasAnyKey(allViewKeys, state)) {
        throw new Error("State '" + state.name + "' has a 'views' object. " +
            "It cannot also have \"view properties\" at the state level.  " +
            "Move the following properties into a view (in the 'views' object): " +
            (" " + allViewKeys.filter(function (key) { return core_1.isDefined(state[key]); }).join(", ")));
    }
    var views = {}, viewsObject = state.views || { "$default": core_1.pick(state, allViewKeys) };
    core_1.forEach(viewsObject, function (config, name) {
        // Account for views: { "": { template... } }
        name = name || "$default";
        // Account for views: { header: "headerComponent" }
        if (core_1.isString(config))
            config = { component: config };
        // Make a shallow copy of the config object
        config = core_1.extend({}, config);
        // Do not allow a view to mix props for component-style view with props for template/controller-style view
        if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {
            throw new Error("Cannot combine: " + compKeys.join("|") + " with: " + nonCompKeys.join("|") + " in stateview: '" + name + "@" + state.name + "'");
        }
        config.resolveAs = config.resolveAs || '$resolve';
        config.$type = "ng1";
        config.$context = state;
        config.$name = name;
        var normalized = core_1.ViewService.normalizeUIViewTarget(config.$context, config.$name);
        config.$uiViewName = normalized.uiViewName;
        config.$uiViewContextAnchor = normalized.uiViewContextAnchor;
        views[name] = config;
    });
    return views;
}
exports.ng1ViewsBuilder = ng1ViewsBuilder;
var id = 0;
var Ng1ViewConfig = (function () {
    function Ng1ViewConfig(path, viewDecl, factory) {
        var _this = this;
        this.path = path;
        this.viewDecl = viewDecl;
        this.factory = factory;
        this.$id = id++;
        this.loaded = false;
        this.getTemplate = function (uiView, context) {
            return _this.component ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings) : _this.template;
        };
    }
    Ng1ViewConfig.prototype.load = function () {
        var _this = this;
        var $q = core_1.services.$q;
        var context = new core_1.ResolveContext(this.path);
        var params = this.path.reduce(function (acc, node) { return core_1.extend(acc, node.paramValues); }, {});
        var promises = {
            template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),
            controller: $q.when(this.getController(context))
        };
        return $q.all(promises).then(function (results) {
            core_1.trace.traceViewServiceEvent("Loaded", _this);
            _this.controller = results.controller;
            core_1.extend(_this, results.template); // Either { template: "tpl" } or { component: "cmpName" }
            return _this;
        });
    };
    /**
     * Gets the controller for a view configuration.
     *
     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.
     */
    Ng1ViewConfig.prototype.getController = function (context) {
        var provider = this.viewDecl.controllerProvider;
        if (!core_1.isInjectable(provider))
            return this.viewDecl.controller;
        var deps = core_1.services.$injector.annotate(provider);
        var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;
        var resolvable = new core_1.Resolvable("", providerFn, deps);
        return resolvable.get(context);
    };
    return Ng1ViewConfig;
}());
exports.Ng1ViewConfig = Ng1ViewConfig;
//# sourceMappingURL=views.js.map

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module core
 */ /** */
var stateParams_1 = __webpack_require__(34);
var queue_1 = __webpack_require__(23);
/**
 * Global router state
 *
 * This is where we hold the global mutable state such as current state, current
 * params, current transition, etc.
 */
var UIRouterGlobals = (function () {
    function UIRouterGlobals() {
        /**
         * Current parameter values
         *
         * The parameter values from the latest successful transition
         */
        this.params = new stateParams_1.StateParams();
        /** @internalapi */
        this.lastStartedTransitionId = -1;
        /** @internalapi */
        this.transitionHistory = new queue_1.Queue([], 1);
        /** @internalapi */
        this.successfulTransitions = new queue_1.Queue([], 1);
    }
    UIRouterGlobals.prototype.dispose = function () {
        this.transitionHistory.clear();
        this.successfulTransitions.clear();
        this.transition = null;
    };
    return UIRouterGlobals;
}());
exports.UIRouterGlobals = UIRouterGlobals;
//# sourceMappingURL=globals.js.map

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var coreservices_1 = __webpack_require__(3);
/**
 * A [[TransitionHookFn]] that performs lazy loading
 *
 * When entering a state "abc" which has a `lazyLoad` function defined:
 * - Invoke the `lazyLoad` function (unless it is already in process)
 *   - Flag the hook function as "in process"
 *   - The function should return a promise (that resolves when lazy loading is complete)
 * - Wait for the promise to settle
 *   - If the promise resolves to a [[LazyLoadResult]], then register those states
 *   - Flag the hook function as "not in process"
 * - If the hook was successful
 *   - Remove the `lazyLoad` function from the state declaration
 * - If all the hooks were successful
 *   - Retry the transition (by returning a TargetState)
 *
 * ```
 * .state('abc', {
 *   component: 'fooComponent',
 *   lazyLoad: () => System.import('./fooComponent')
 *   });
 * ```
 *
 * See [[StateDeclaration.lazyLoad]]
 */
var lazyLoadHook = function (transition) {
    var router = transition.router;
    function retryTransition() {
        if (transition.originalTransition().options().source !== 'url') {
            // The original transition was not triggered via url sync
            // The lazy state should be loaded now, so re-try the original transition
            var orig = transition.targetState();
            return router.stateService.target(orig.identifier(), orig.params(), orig.options());
        }
        // The original transition was triggered via url sync
        // Run the URL rules and find the best match
        var $url = router.urlService;
        var result = $url.match($url.parts());
        var rule = result && result.rule;
        // If the best match is a state, redirect the transition (instead
        // of calling sync() which supersedes the current transition)
        if (rule && rule.type === "STATE") {
            var state = rule.state;
            var params = result.match;
            return router.stateService.target(state, params, transition.options());
        }
        // No matching state found, so let .sync() choose the best non-state match/otherwise
        router.urlService.sync();
    }
    var promises = transition.entering()
        .filter(function (state) { return !!state.$$state().lazyLoad; })
        .map(function (state) { return lazyLoadState(transition, state); });
    return coreservices_1.services.$q.all(promises).then(retryTransition);
};
exports.registerLazyLoadHook = function (transitionService) {
    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);
};
/**
 * Invokes a state's lazy load function
 *
 * @param transition a Transition context
 * @param state the state to lazy load
 * @returns A promise for the lazy load result
 */
function lazyLoadState(transition, state) {
    var lazyLoadFn = state.$$state().lazyLoad;
    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked
    var promise = lazyLoadFn['_promise'];
    if (!promise) {
        var success = function (result) {
            delete state.lazyLoad;
            delete state.$$state().lazyLoad;
            delete lazyLoadFn['_promise'];
            return result;
        };
        var error = function (err) {
            delete lazyLoadFn['_promise'];
            return coreservices_1.services.$q.reject(err);
        };
        promise = lazyLoadFn['_promise'] =
            coreservices_1.services.$q.when(lazyLoadFn(transition, state))
                .then(updateStateRegistry)
                .then(success, error);
    }
    /** Register any lazy loaded state definitions */
    function updateStateRegistry(result) {
        if (result && Array.isArray(result.states)) {
            result.states.forEach(function (state) { return transition.router.stateRegistry.register(state); });
        }
        return result;
    }
    return promise;
}
exports.lazyLoadState = lazyLoadState;
//# sourceMappingURL=lazyLoad.js.map

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module params
 */
/** */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var hof_1 = __webpack_require__(2);
var coreservices_1 = __webpack_require__(3);
var paramType_1 = __webpack_require__(24);
/**
 * A registry for parameter types.
 *
 * This registry manages the built-in (and custom) parameter types.
 *
 * The built-in parameter types are:
 *
 * - [[string]]
 * - [[path]]
 * - [[query]]
 * - [[hash]]
 * - [[int]]
 * - [[bool]]
 * - [[date]]
 * - [[json]]
 * - [[any]]
 */
var ParamTypes = (function () {
    /** @internalapi */
    function ParamTypes() {
        /** @hidden */
        this.enqueue = true;
        /** @hidden */
        this.typeQueue = [];
        /** @internalapi */
        this.defaultTypes = common_1.pick(ParamTypes.prototype, ["hash", "string", "query", "path", "int", "bool", "date", "json", "any"]);
        // Register default types. Store them in the prototype of this.types.
        var makeType = function (definition, name) {
            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));
        };
        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});
    }
    /** @internalapi */
    ParamTypes.prototype.dispose = function () {
        this.types = {};
    };
    /**
     * Registers a parameter type
     *
     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.
     */
    ParamTypes.prototype.type = function (name, definition, definitionFn) {
        if (!predicates_1.isDefined(definition))
            return this.types[name];
        if (this.types.hasOwnProperty(name))
            throw new Error("A type named '" + name + "' has already been defined.");
        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));
        if (definitionFn) {
            this.typeQueue.push({ name: name, def: definitionFn });
            if (!this.enqueue)
                this._flushTypeQueue();
        }
        return this;
    };
    /** @internalapi */
    ParamTypes.prototype._flushTypeQueue = function () {
        while (this.typeQueue.length) {
            var type = this.typeQueue.shift();
            if (type.pattern)
                throw new Error("You cannot override a type's .pattern at runtime.");
            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));
        }
    };
    return ParamTypes;
}());
exports.ParamTypes = ParamTypes;
/** @hidden */
function initDefaultTypes() {
    var makeDefaultType = function (def) {
        var valToString = function (val) {
            return val != null ? val.toString() : val;
        };
        var defaultTypeBase = {
            encode: valToString,
            decode: valToString,
            is: hof_1.is(String),
            pattern: /.*/,
            equals: function (a, b) { return a == b; },
        };
        return common_1.extend({}, defaultTypeBase, def);
    };
    // Default Parameter Type Definitions
    common_1.extend(ParamTypes.prototype, {
        string: makeDefaultType({}),
        path: makeDefaultType({
            pattern: /[^/]*/,
        }),
        query: makeDefaultType({}),
        hash: makeDefaultType({
            inherit: false,
        }),
        int: makeDefaultType({
            decode: function (val) { return parseInt(val, 10); },
            is: function (val) {
                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;
            },
            pattern: /-?\d+/,
        }),
        bool: makeDefaultType({
            encode: function (val) { return val && 1 || 0; },
            decode: function (val) { return parseInt(val, 10) !== 0; },
            is: hof_1.is(Boolean),
            pattern: /0|1/
        }),
        date: makeDefaultType({
            encode: function (val) {
                return !this.is(val) ? undefined : [
                    val.getFullYear(),
                    ('0' + (val.getMonth() + 1)).slice(-2),
                    ('0' + val.getDate()).slice(-2)
                ].join("-");
            },
            decode: function (val) {
                if (this.is(val))
                    return val;
                var match = this.capture.exec(val);
                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
            },
            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },
            equals: function (l, r) {
                return ['getFullYear', 'getMonth', 'getDate']
                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);
            },
            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
        }),
        json: makeDefaultType({
            encode: common_1.toJson,
            decode: common_1.fromJson,
            is: hof_1.is(Object),
            equals: common_1.equals,
            pattern: /[^/]*/
        }),
        // does not encode/decode
        any: makeDefaultType({
            encode: common_1.identity,
            decode: common_1.identity,
            is: function () { return true; },
            equals: common_1.equals,
        }),
    });
}
initDefaultTypes();
//# sourceMappingURL=paramTypes.js.map

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module params
 */
/** */
var common_1 = __webpack_require__(0);
/** @internalapi */
var StateParams = (function () {
    function StateParams(params) {
        if (params === void 0) { params = {}; }
        common_1.extend(this, params);
    }
    /**
     * Merges a set of parameters with all parameters inherited between the common parents of the
     * current state and a given destination state.
     *
     * @param {Object} newParams The set of parameters which will be composited with inherited params.
     * @param {Object} $current Internal definition of object representing the current state.
     * @param {Object} $to Internal definition of object representing state to transition to.
     */
    StateParams.prototype.$inherit = function (newParams, $current, $to) {
        var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];
        for (var i in parents) {
            if (!parents[i] || !parents[i].params)
                continue;
            parentParams = Object.keys(parents[i].params);
            if (!parentParams.length)
                continue;
            for (var j in parentParams) {
                if (inheritList.indexOf(parentParams[j]) >= 0)
                    continue;
                inheritList.push(parentParams[j]);
                inherited[parentParams[j]] = this[parentParams[j]];
            }
        }
        return common_1.extend({}, inherited, newParams);
    };
    ;
    return StateParams;
}());
exports.StateParams = StateParams;
//# sourceMappingURL=stateParams.js.map

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @internalapi */
exports.resolvePolicies = {
    when: {
        LAZY: "LAZY",
        EAGER: "EAGER"
    },
    async: {
        WAIT: "WAIT",
        NOWAIT: "NOWAIT",
        RXWAIT: "RXWAIT"
    }
};
//# sourceMappingURL=interface.js.map

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module core
 */ /** */
var urlMatcherFactory_1 = __webpack_require__(44);
var urlRouter_1 = __webpack_require__(45);
var transitionService_1 = __webpack_require__(28);
var view_1 = __webpack_require__(55);
var stateRegistry_1 = __webpack_require__(40);
var stateService_1 = __webpack_require__(41);
var globals_1 = __webpack_require__(31);
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var urlService_1 = __webpack_require__(47);
var trace_1 = __webpack_require__(6);
/** @hidden */
var _routerInstance = 0;
/**
 * The master class used to instantiate an instance of UI-Router.
 *
 * UI-Router (for each specific framework) will create an instance of this class during bootstrap.
 * This class instantiates and wires the UI-Router services together.
 *
 * After a new instance of the UIRouter class is created, it should be configured for your app.
 * For instance, app states should be registered with the [[UIRouter.stateRegistry]].
 *
 * ---
 *
 * Normally the framework code will bootstrap UI-Router.
 * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling
 * [[UrlService.listen]] then [[UrlService.sync]].
 */
var UIRouter = (function () {
    /**
     * Creates a new `UIRouter` object
     *
     * @param locationService a [[LocationServices]] implementation
     * @param locationConfig a [[LocationConfig]] implementation
     * @internalapi
     */
    function UIRouter(locationService, locationConfig) {
        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }
        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }
        this.locationService = locationService;
        this.locationConfig = locationConfig;
        /** @hidden */ this.$id = _routerInstance++;
        /** @hidden */ this._disposed = false;
        /** @hidden */ this._disposables = [];
        /** Provides trace information to the console */
        this.trace = trace_1.trace;
        /** Provides services related to ui-view synchronization */
        this.viewService = new view_1.ViewService();
        /** Provides services related to Transitions */
        this.transitionService = new transitionService_1.TransitionService(this);
        /** Global router state */
        this.globals = new globals_1.UIRouterGlobals();
        /**
         * Deprecated for public use. Use [[urlService]] instead.
         * @deprecated Use [[urlService]] instead
         */
        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();
        /**
         * Deprecated for public use. Use [[urlService]] instead.
         * @deprecated Use [[urlService]] instead
         */
        this.urlRouter = new urlRouter_1.UrlRouter(this);
        /** Provides a registry for states, and related registration services */
        this.stateRegistry = new stateRegistry_1.StateRegistry(this);
        /** Provides services related to states */
        this.stateService = new stateService_1.StateService(this);
        /** Provides services related to the URL */
        this.urlService = new urlService_1.UrlService(this);
        /** @hidden */
        this._plugins = {};
        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());
        this.globals.$current = this.stateRegistry.root();
        this.globals.current = this.globals.$current.self;
        this.disposable(this.globals);
        this.disposable(this.stateService);
        this.disposable(this.stateRegistry);
        this.disposable(this.transitionService);
        this.disposable(this.urlRouter);
        this.disposable(locationService);
        this.disposable(locationConfig);
    }
    /** Registers an object to be notified when the router is disposed */
    UIRouter.prototype.disposable = function (disposable) {
        this._disposables.push(disposable);
    };
    /**
     * Disposes this router instance
     *
     * When called, clears resources retained by the router by calling `dispose(this)` on all
     * registered [[disposable]] objects.
     *
     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.
     *
     * @param disposable (optional) the disposable to dispose
     */
    UIRouter.prototype.dispose = function (disposable) {
        var _this = this;
        if (disposable && predicates_1.isFunction(disposable.dispose)) {
            disposable.dispose(this);
            return undefined;
        }
        this._disposed = true;
        this._disposables.slice().forEach(function (d) {
            try {
                typeof d.dispose === 'function' && d.dispose(_this);
                common_1.removeFrom(_this._disposables, d);
            }
            catch (ignored) { }
        });
    };
    /**
     * Adds a plugin to UI-Router
     *
     * This method adds a UI-Router Plugin.
     * A plugin can enhance or change UI-Router behavior using any public API.
     *
     * #### Example:
     * ```js
     * import { MyCoolPlugin } from "ui-router-cool-plugin";
     *
     * var plugin = router.addPlugin(MyCoolPlugin);
     * ```
     *
     * ### Plugin authoring
     *
     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.
     *
     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].
     * For example, it may configure router options or add a Transition Hook.
     *
     * The plugin can then be published as a separate module.
     *
     * #### Example:
     * ```js
     * export class MyAuthPlugin implements UIRouterPlugin {
     *   constructor(router: UIRouter, options: any) {
     *     this.name = "MyAuthPlugin";
     *     let $transitions = router.transitionService;
     *     let $state = router.stateService;
     *
     *     let authCriteria = {
     *       to: (state) => state.data && state.data.requiresAuth
     *     };
     *
     *     function authHook(transition: Transition) {
     *       let authService = transition.injector().get('AuthService');
     *       if (!authService.isAuthenticated()) {
     *         return $state.target('login');
     *       }
     *     }
     *
     *     $transitions.onStart(authCriteria, authHook);
     *   }
     * }
     * ```
     *
     * @param plugin one of:
     *        - a plugin class which implements [[UIRouterPlugin]]
     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance
     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance
     * @param options options to pass to the plugin class/factory
     * @returns the registered plugin instance
     */
    UIRouter.prototype.plugin = function (plugin, options) {
        if (options === void 0) { options = {}; }
        var pluginInstance = new plugin(this, options);
        if (!pluginInstance.name)
            throw new Error("Required property `name` missing on plugin: " + pluginInstance);
        this._disposables.push(pluginInstance);
        return this._plugins[pluginInstance.name] = pluginInstance;
    };
    UIRouter.prototype.getPlugin = function (pluginName) {
        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);
    };
    return UIRouter;
}());
exports.UIRouter = UIRouter;
//# sourceMappingURL=router.js.map

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module state */ /** for typedoc */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var strings_1 = __webpack_require__(5);
var hof_1 = __webpack_require__(2);
var resolvable_1 = __webpack_require__(12);
var coreservices_1 = __webpack_require__(3);
var parseUrl = function (url) {
    if (!predicates_1.isString(url))
        return false;
    var root = url.charAt(0) === '^';
    return { val: root ? url.substring(1) : url, root: root };
};
function nameBuilder(state) {
    return state.name;
}
function selfBuilder(state) {
    state.self.$$state = function () { return state; };
    return state.self;
}
function dataBuilder(state) {
    if (state.parent && state.parent.data) {
        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);
    }
    return state.data;
}
var getUrlBuilder = function ($urlMatcherFactoryProvider, root) {
    return function urlBuilder(state) {
        var stateDec = state;
        // For future states, i.e., states whose name ends with `.**`,
        // match anything that starts with the url prefix
        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\.\*\*$/)) {
            stateDec.url += "{remainder:any}"; // match any path (.*)
        }
        var parsed = parseUrl(stateDec.url), parent = state.parent;
        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {
            params: state.params || {},
            paramMap: function (paramConfig, isSearch) {
                if (stateDec.reloadOnSearch === false && isSearch)
                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });
                return paramConfig;
            }
        });
        if (!url)
            return null;
        if (!$urlMatcherFactoryProvider.isMatcher(url))
            throw new Error("Invalid url '" + url + "' in state '" + state + "'");
        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);
    };
};
var getNavigableBuilder = function (isRoot) {
    return function navigableBuilder(state) {
        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);
    };
};
var getParamsBuilder = function (paramFactory) {
    return function paramsBuilder(state) {
        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };
        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];
        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));
        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});
    };
};
function pathBuilder(state) {
    return state.parent ? state.parent.path.concat(state) : [state];
}
function includesBuilder(state) {
    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};
    includes[state.name] = true;
    return includes;
}
/**
 * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].
 *
 * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
 * validates the `resolve` property and converts it to a [[Resolvable]] array.
 *
 * resolve: input value can be:
 *
 * {
 *   // analyzed but not injected
 *   myFooResolve: function() { return "myFooData"; },
 *
 *   // function.toString() parsed, "DependencyName" dep as string (not min-safe)
 *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },
 *
 *   // Array split; "DependencyName" dep as string
 *   myBazResolve: [ "DependencyName", function(dep) { return dep.fetchSomethingAsPromise() },
 *
 *   // Array split; DependencyType dep as token (compared using ===)
 *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },
 *
 *   // val.$inject used as deps
 *   // where:
 *   //     corgeResolve.$inject = ["DependencyName"];
 *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }
 *   // then "DependencyName" dep as string
 *   myCorgeResolve: corgeResolve,
 *
 *  // inject service by name
 *  // When a string is found, desugar creating a resolve that injects the named service
 *   myGraultResolve: "SomeService"
 * }
 *
 * or:
 *
 * [
 *   new Resolvable("myFooResolve", function() { return "myFooData" }),
 *   new Resolvable("myBarResolve", function(dep) { return dep.fetchSomethingAsPromise() }, [ "DependencyName" ]),
 *   { provide: "myBazResolve", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ "DependencyName" ] }
 * ]
 */
function resolvablesBuilder(state) {
    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */
    var objects2Tuples = function (resolveObj, resolvePolicies) {
        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });
    };
    /** fetch DI annotations from a function or ng1-style array */
    var annotate = function (fn) {
        var $injector = coreservices_1.services.$injector;
        // ng1 doesn't have an $injector until runtime.
        // If the $injector doesn't exist, use "deferred" literal as a
        // marker indicating they should be annotated when runtime starts
        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || "deferred";
    };
    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */
    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };
    /** true if the object looks like a provide literal, or a ng2 Provider */
    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };
    /** true if the object looks like a tuple from obj2Tuples */
    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };
    /** extracts the token from a Provider or provide literal */
    var token = function (p) { return p.provide || p.token; };
    /** Given a literal resolve or provider object, returns a Resolvable */
    var literal2Resolvable = hof_1.pattern([
        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy); }],
        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(token(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],
        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return new p.useClass(); }, [], p.policy); }],
        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(token(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],
        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(token(p), common_1.identity, [p.useExisting], p.policy); }],
    ]);
    var tuple2Resolvable = hof_1.pattern([
        [hof_1.pipe(hof_1.prop("val"), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],
        [hof_1.pipe(hof_1.prop("val"), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],
        [hof_1.pipe(hof_1.prop("val"), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],
    ]);
    var item2Resolvable = hof_1.pattern([
        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],
        [isResolveLiteral, literal2Resolvable],
        [isLikeNg2Provider, literal2Resolvable],
        [isTupleFromObj, tuple2Resolvable],
        [hof_1.val(true), function (obj) { throw new Error("Invalid resolve value: " + strings_1.stringify(obj)); }]
    ]);
    // If resolveBlock is already an array, use it as-is.
    // Otherwise, assume it's an object and convert to an Array of tuples
    var decl = state.resolve;
    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});
    return items.map(item2Resolvable);
}
exports.resolvablesBuilder = resolvablesBuilder;
/**
 * @internalapi A internal global service
 *
 * StateBuilder is a factory for the internal [[StateObject]] objects.
 *
 * When you register a state with the [[StateRegistry]], you register a plain old javascript object which
 * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding
 * [[StateObject]] object, which has an API and is used internally.
 *
 * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function
 * using the [[builder]] method.
 */
var StateBuilder = (function () {
    function StateBuilder(matcher, urlMatcherFactory) {
        this.matcher = matcher;
        var self = this;
        var root = function () { return matcher.find(""); };
        var isRoot = function (state) { return state.name === ""; };
        function parentBuilder(state) {
            if (isRoot(state))
                return null;
            return matcher.find(self.parentName(state)) || root();
        }
        this.builders = {
            name: [nameBuilder],
            self: [selfBuilder],
            parent: [parentBuilder],
            data: [dataBuilder],
            // Build a URLMatcher if necessary, either via a relative or absolute URL
            url: [getUrlBuilder(urlMatcherFactory, root)],
            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
            navigable: [getNavigableBuilder(isRoot)],
            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],
            // Each framework-specific ui-router implementation should define its own `views` builder
            // e.g., src/ng1/statebuilders/views.ts
            views: [],
            // Keep a full path from the root down to this state as this is needed for state activation.
            path: [pathBuilder],
            // Speed up $state.includes() as it's used a lot
            includes: [includesBuilder],
            resolvables: [resolvablesBuilder]
        };
    }
    /**
     * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).
     * More than one BuilderFunction can be registered for a given property.
     *
     * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.
     *
     * @param name The name of the State property being registered for.
     * @param fn The BuilderFunction which will be used to build the State property
     * @returns a function which deregisters the BuilderFunction
     */
    StateBuilder.prototype.builder = function (name, fn) {
        var builders = this.builders;
        var array = builders[name] || [];
        // Backwards compat: if only one builder exists, return it, else return whole arary.
        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))
            return array.length > 1 ? array : array[0];
        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))
            return;
        builders[name] = array;
        builders[name].push(fn);
        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };
    };
    /**
     * Builds all of the properties on an essentially blank State object, returning a State object which has all its
     * properties and API built.
     *
     * @param state an uninitialized State object
     * @returns the built State object
     */
    StateBuilder.prototype.build = function (state) {
        var _a = this, matcher = _a.matcher, builders = _a.builders;
        var parent = this.parentName(state);
        if (parent && !matcher.find(parent, undefined, false)) {
            return null;
        }
        for (var key in builders) {
            if (!builders.hasOwnProperty(key))
                continue;
            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);
            state[key] = chain(state);
        }
        return state;
    };
    StateBuilder.prototype.parentName = function (state) {
        var name = state.name || "";
        var segments = name.split('.');
        if (segments.length > 1) {
            if (state.parent) {
                throw new Error("States that specify the 'parent:' property should not have a '.' in their name (" + name + ")");
            }
            var lastSegment = segments.pop();
            if (lastSegment === '**')
                segments.pop();
            return segments.join(".");
        }
        if (!state.parent)
            return "";
        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;
    };
    StateBuilder.prototype.name = function (state) {
        var name = state.name;
        if (name.indexOf('.') !== -1 || !state.parent)
            return name;
        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;
        return parentName ? parentName + "." + name : name;
    };
    return StateBuilder;
}());
exports.StateBuilder = StateBuilder;
//# sourceMappingURL=stateBuilder.js.map

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module state */ /** for typedoc */
var predicates_1 = __webpack_require__(1);
var common_1 = __webpack_require__(0);
var StateMatcher = (function () {
    function StateMatcher(_states) {
        this._states = _states;
    }
    StateMatcher.prototype.isRelative = function (stateName) {
        stateName = stateName || "";
        return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
    };
    StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {
        if (matchGlob === void 0) { matchGlob = true; }
        if (!stateOrName && stateOrName !== "")
            return undefined;
        var isStr = predicates_1.isString(stateOrName);
        var name = isStr ? stateOrName : stateOrName.name;
        if (this.isRelative(name))
            name = this.resolvePath(name, base);
        var state = this._states[name];
        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
            return state;
        }
        else if (isStr && matchGlob) {
            var _states = common_1.values(this._states);
            var matches = _states.filter(function (state) {
                return state.__stateObjectCache.nameGlob &&
                    state.__stateObjectCache.nameGlob.matches(name);
            });
            if (matches.length > 1) {
                console.log("stateMatcher.find: Found multiple matches for " + name + " using glob: ", matches.map(function (match) { return match.name; }));
            }
            return matches[0];
        }
        return undefined;
    };
    StateMatcher.prototype.resolvePath = function (name, base) {
        if (!base)
            throw new Error("No reference point given for path '" + name + "'");
        var baseState = this.find(base);
        var splitName = name.split("."), i = 0, pathLength = splitName.length, current = baseState;
        for (; i < pathLength; i++) {
            if (splitName[i] === "" && i === 0) {
                current = baseState;
                continue;
            }
            if (splitName[i] === "^") {
                if (!current.parent)
                    throw new Error("Path '" + name + "' not valid for state '" + baseState.name + "'");
                current = current.parent;
                continue;
            }
            break;
        }
        var relName = splitName.slice(i).join(".");
        return current.name + (current.name && relName ? "." : "") + relName;
    };
    return StateMatcher;
}());
exports.StateMatcher = StateMatcher;
//# sourceMappingURL=stateMatcher.js.map

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module state */ /** for typedoc */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var stateObject_1 = __webpack_require__(26);
var hof_1 = __webpack_require__(2);
/** @internalapi */
var StateQueueManager = (function () {
    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {
        this.$registry = $registry;
        this.$urlRouter = $urlRouter;
        this.states = states;
        this.builder = builder;
        this.listeners = listeners;
        this.queue = [];
        this.matcher = $registry.matcher;
    }
    /** @internalapi */
    StateQueueManager.prototype.dispose = function () {
        this.queue = [];
    };
    StateQueueManager.prototype.register = function (stateDecl) {
        var queue = this.queue;
        var state = stateObject_1.StateObject.create(stateDecl);
        var name = state.name;
        if (!predicates_1.isString(name))
            throw new Error("State must have a valid name");
        if (this.states.hasOwnProperty(name) || common_1.inArray(queue.map(hof_1.prop('name')), name))
            throw new Error("State '" + name + "' is already defined");
        queue.push(state);
        this.flush();
        return state;
    };
    StateQueueManager.prototype.flush = function () {
        var _this = this;
        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;
        var registered = [], // states that got registered
        orphans = [], // states that don't yet have a parent registered
        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered
        var getState = function (name) {
            return _this.states.hasOwnProperty(name) && _this.states[name];
        };
        while (queue.length > 0) {
            var state = queue.shift();
            var name_1 = state.name;
            var result = builder.build(state);
            var orphanIdx = orphans.indexOf(state);
            if (result) {
                var existingState = getState(name_1);
                if (existingState && existingState.name === name_1) {
                    throw new Error("State '" + name_1 + "' is already defined");
                }
                var existingFutureState = getState(name_1 + ".**");
                if (existingFutureState) {
                    // Remove future state of the same name
                    this.$registry.deregister(existingFutureState);
                }
                states[name_1] = state;
                this.attachRoute(state);
                if (orphanIdx >= 0)
                    orphans.splice(orphanIdx, 1);
                registered.push(state);
                continue;
            }
            var prev = previousQueueLength[name_1];
            previousQueueLength[name_1] = queue.length;
            if (orphanIdx >= 0 && prev === queue.length) {
                // Wait until two consecutive iterations where no additional states were dequeued successfully.
                // throw new Error(`Cannot register orphaned state '${name}'`);
                queue.push(state);
                return states;
            }
            else if (orphanIdx < 0) {
                orphans.push(state);
            }
            queue.push(state);
        }
        if (registered.length) {
            this.listeners.forEach(function (listener) { return listener("registered", registered.map(function (s) { return s.self; })); });
        }
        return states;
    };
    StateQueueManager.prototype.attachRoute = function (state) {
        if (state.abstract || !state.url)
            return;
        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));
    };
    return StateQueueManager;
}());
exports.StateQueueManager = StateQueueManager;
//# sourceMappingURL=stateQueueManager.js.map

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module state
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var stateMatcher_1 = __webpack_require__(38);
var stateBuilder_1 = __webpack_require__(37);
var stateQueueManager_1 = __webpack_require__(39);
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var StateRegistry = (function () {
    /** @internalapi */
    function StateRegistry(_router) {
        this._router = _router;
        this.states = {};
        this.listeners = [];
        this.matcher = new stateMatcher_1.StateMatcher(this.states);
        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);
        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);
        this._registerRoot();
    }
    /** @internalapi */
    StateRegistry.prototype._registerRoot = function () {
        var rootStateDef = {
            name: '',
            url: '^',
            views: null,
            params: {
                '#': { value: null, type: 'hash', dynamic: true }
            },
            abstract: true
        };
        var _root = this._root = this.stateQueue.register(rootStateDef);
        _root.navigable = null;
    };
    /** @internalapi */
    StateRegistry.prototype.dispose = function () {
        var _this = this;
        this.stateQueue.dispose();
        this.listeners = [];
        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });
    };
    /**
     * Listen for a State Registry events
     *
     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.
     *
     * #### Example:
     * ```js
     * let allStates = registry.get();
     *
     * // Later, invoke deregisterFn() to remove the listener
     * let deregisterFn = registry.onStatesChanged((event, states) => {
     *   switch(event) {
     *     case: 'registered':
     *       states.forEach(state => allStates.push(state));
     *       break;
     *     case: 'deregistered':
     *       states.forEach(state => {
     *         let idx = allStates.indexOf(state);
     *         if (idx !== -1) allStates.splice(idx, 1);
     *       });
     *       break;
     *   }
     * });
     * ```
     *
     * @param listener a callback function invoked when the registered states changes.
     *        The function receives two parameters, `event` and `state`.
     *        See [[StateRegistryListener]]
     * @return a function that deregisters the listener
     */
    StateRegistry.prototype.onStatesChanged = function (listener) {
        this.listeners.push(listener);
        return function deregisterListener() {
            common_1.removeFrom(this.listeners)(listener);
        }.bind(this);
    };
    /**
     * Gets the implicit root state
     *
     * Gets the root of the state tree.
     * The root state is implicitly created by UI-Router.
     * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]
     *
     * @return the root [[StateObject]]
     */
    StateRegistry.prototype.root = function () {
        return this._root;
    };
    /**
     * Adds a state to the registry
     *
     * Registers a [[StateDeclaration]] or queues it for registration.
     *
     * Note: a state will be queued if the state's parent isn't yet registered.
     *
     * @param stateDefinition the definition of the state to register.
     * @returns the internal [[StateObject]] object.
     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).
     *          If the state was only queued, then the object is not fully built.
     */
    StateRegistry.prototype.register = function (stateDefinition) {
        return this.stateQueue.register(stateDefinition);
    };
    /** @hidden */
    StateRegistry.prototype._deregisterTree = function (state) {
        var _this = this;
        var all = this.get().map(function (s) { return s.$$state(); });
        var getChildren = function (states) {
            var children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });
            return children.length === 0 ? children : children.concat(getChildren(children));
        };
        var children = getChildren([state]);
        var deregistered = [state].concat(children).reverse();
        deregistered.forEach(function (state) {
            var $ur = _this._router.urlRouter;
            // Remove URL rule
            $ur.rules().filter(hof_1.propEq("state", state)).forEach($ur.removeRule.bind($ur));
            // Remove state from registry
            delete _this.states[state.name];
        });
        return deregistered;
    };
    /**
     * Removes a state from the registry
     *
     * This removes a state from the registry.
     * If the state has children, they are are also removed from the registry.
     *
     * @param stateOrName the state's name or object representation
     * @returns {StateObject[]} a list of removed states
     */
    StateRegistry.prototype.deregister = function (stateOrName) {
        var _state = this.get(stateOrName);
        if (!_state)
            throw new Error("Can't deregister state; not found: " + stateOrName);
        var deregisteredStates = this._deregisterTree(_state.$$state());
        this.listeners.forEach(function (listener) { return listener("deregistered", deregisteredStates.map(function (s) { return s.self; })); });
        return deregisteredStates;
    };
    StateRegistry.prototype.get = function (stateOrName, base) {
        var _this = this;
        if (arguments.length === 0)
            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });
        var found = this.matcher.find(stateOrName, base);
        return found && found.self || null;
    };
    StateRegistry.prototype.decorator = function (name, func) {
        return this.builder.builder(name, func);
    };
    return StateRegistry;
}());
exports.StateRegistry = StateRegistry;
//# sourceMappingURL=stateRegistry.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module state
 */
/** */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var queue_1 = __webpack_require__(23);
var coreservices_1 = __webpack_require__(3);
var pathFactory_1 = __webpack_require__(18);
var pathNode_1 = __webpack_require__(25);
var transitionService_1 = __webpack_require__(28);
var rejectFactory_1 = __webpack_require__(13);
var targetState_1 = __webpack_require__(7);
var param_1 = __webpack_require__(8);
var glob_1 = __webpack_require__(16);
var resolveContext_1 = __webpack_require__(19);
var lazyLoad_1 = __webpack_require__(32);
var hof_1 = __webpack_require__(2);
/**
 * Provides state related service functions
 *
 * This class provides services related to ui-router states.
 * An instance of this class is located on the global [[UIRouter]] object.
 */
var StateService = (function () {
    /** @internalapi */
    function StateService(router) {
        this.router = router;
        /** @internalapi */
        this.invalidCallbacks = [];
        /** @hidden */
        this._defaultErrorHandler = function $defaultErrorHandler($error$) {
            if ($error$ instanceof Error && $error$.stack) {
                console.error($error$);
                console.error($error$.stack);
            }
            else if ($error$ instanceof rejectFactory_1.Rejection) {
                console.error($error$.toString());
                if ($error$.detail && $error$.detail.stack)
                    console.error($error$.detail.stack);
            }
            else {
                console.error($error$);
            }
        };
        var getters = ['current', '$current', 'params', 'transition'];
        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));
        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);
    }
    Object.defineProperty(StateService.prototype, "transition", {
        /**
         * The [[Transition]] currently in progress (or null)
         *
         * This is a passthrough through to [[UIRouterGlobals.transition]]
         */
        get: function () { return this.router.globals.transition; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "params", {
        /**
         * The latest successful state parameters
         *
         * This is a passthrough through to [[UIRouterGlobals.params]]
         */
        get: function () { return this.router.globals.params; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "current", {
        /**
         * The current [[StateDeclaration]]
         *
         * This is a passthrough through to [[UIRouterGlobals.current]]
         */
        get: function () { return this.router.globals.current; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateService.prototype, "$current", {
        /**
         * The current [[StateObject]]
         *
         * This is a passthrough through to [[UIRouterGlobals.$current]]
         */
        get: function () { return this.router.globals.$current; },
        enumerable: true,
        configurable: true
    });
    /** @internalapi */
    StateService.prototype.dispose = function () {
        this.defaultErrorHandler(common_1.noop);
        this.invalidCallbacks = [];
    };
    /**
     * Handler for when [[transitionTo]] is called with an invalid state.
     *
     * Invokes the [[onInvalid]] callbacks, in natural order.
     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.
     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.
     *
     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.
     *
     * @internalapi
     */
    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {
        var _this = this;
        var fromState = pathFactory_1.PathUtils.makeTargetState(fromPath);
        var globals = this.router.globals;
        var latestThing = function () { return globals.transitionHistory.peekTail(); };
        var latest = latestThing();
        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());
        var injector = new resolveContext_1.ResolveContext(fromPath).injector();
        var checkForRedirect = function (result) {
            if (!(result instanceof targetState_1.TargetState)) {
                return;
            }
            var target = result;
            // Recreate the TargetState, in case the state is now defined.
            target = _this.target(target.identifier(), target.params(), target.options());
            if (!target.valid()) {
                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();
            }
            if (latestThing() !== latest) {
                return rejectFactory_1.Rejection.superseded().toPromise();
            }
            return _this.transitionTo(target.identifier(), target.params(), target.options());
        };
        function invokeNextCallback() {
            var nextCallback = callbackQueue.dequeue();
            if (nextCallback === undefined)
                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();
            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));
            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });
        }
        return invokeNextCallback();
    };
    /**
     * Registers an Invalid State handler
     *
     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]
     * has been called with an invalid state reference parameter
     *
     * Example:
     * ```js
     * stateService.onInvalid(function(to, from, injector) {
     *   if (to.name() === 'foo') {
     *     let lazyLoader = injector.get('LazyLoadService');
     *     return lazyLoader.load('foo')
     *         .then(() => stateService.target('foo'));
     *   }
     * });
     * ```
     *
     * @param {function} callback invoked when the toState is invalid
     *   This function receives the (invalid) toState, the fromState, and an injector.
     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.
     *   If one is returned, it is treated as a redirect.
     *
     * @returns a function which deregisters the callback
     */
    StateService.prototype.onInvalid = function (callback) {
        this.invalidCallbacks.push(callback);
        return function deregisterListener() {
            common_1.removeFrom(this.invalidCallbacks)(callback);
        }.bind(this);
    };
    /**
     * Reloads the current state
     *
     * A method that force reloads the current state, or a partial state hierarchy.
     * All resolves are re-resolved, and components reinstantiated.
     *
     * #### Example:
     * ```js
     * let app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     $state.reload();
     *   }
     * });
     * ```
     *
     * Note: `reload()` is just an alias for:
     *
     * ```js
     * $state.transitionTo($state.current, $state.params, {
     *   reload: true, inherit: false
     * });
     * ```
     *
     * @param reloadState A state name or a state object.
     *    If present, this state and all its children will be reloaded, but ancestors will not reload.
     *
     * #### Example:
     * ```js
     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'
     * //and current state is 'contacts.detail.item'
     * let app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     //will reload 'contact.detail' and nested 'contact.detail.item' states
     *     $state.reload('contact.detail');
     *   }
     * });
     * ```
     *
     * @returns A promise representing the state of the new transition. See [[StateService.go]]
     */
    StateService.prototype.reload = function (reloadState) {
        return this.transitionTo(this.current, this.params, {
            reload: predicates_1.isDefined(reloadState) ? reloadState : true,
            inherit: false,
            notify: false,
        });
    };
    ;
    /**
     * Transition to a different state and/or parameters
     *
     * Convenience method for transitioning to a new state.
     *
     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to
     * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.
     * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).
     * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters
     * inherit from the current parameter values (because of `inherit: true`).
     *
     * #### Example:
     * ```js
     * let app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.go('contact.detail');
     *   };
     * });
     * ```
     *
     * @param to Absolute state name, state object, or relative state path (relative to current state).
     *
     * Some examples:
     *
     * - `$state.go('contact.detail')` - will go to the `contact.detail` state
     * - `$state.go('^')` - will go to the parent state
     * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state
     * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state
     *
     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.
     *
     *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).
     *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.
     *
     * @param options Transition options
     *
     * @returns {promise} A promise representing the state of the new transition.
     */
    StateService.prototype.go = function (to, params, options) {
        var defautGoOpts = { relative: this.$current, inherit: true };
        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);
        return this.transitionTo(to, params, transOpts);
    };
    ;
    /**
     * Creates a [[TargetState]]
     *
     * This is a factory method for creating a TargetState
     *
     * This may be returned from a Transition Hook to redirect a transition, for example.
     */
    StateService.prototype.target = function (identifier, params, options) {
        if (options === void 0) { options = {}; }
        // If we're reloading, find the state object to reload from
        if (predicates_1.isObject(options.reload) && !options.reload.name)
            throw new Error('Invalid reload state object');
        var reg = this.router.stateRegistry;
        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);
        if (options.reload && !options.reloadState)
            throw new Error("No such reload state '" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + "'");
        var stateDefinition = reg.matcher.find(identifier, options.relative);
        return new targetState_1.TargetState(identifier, stateDefinition, params, options);
    };
    ;
    StateService.prototype.getCurrentPath = function () {
        var _this = this;
        var globals = this.router.globals;
        var latestSuccess = globals.successfulTransitions.peekTail();
        var rootPath = function () { return [new pathNode_1.PathNode(_this.router.stateRegistry.root())]; };
        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();
    };
    /**
     * Low-level method for transitioning to a new state.
     *
     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.
     *
     * #### Example:
     * ```js
     * let app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.transitionTo('contact.detail');
     *   };
     * });
     * ```
     *
     * @param to State name or state object.
     * @param toParams A map of the parameters that will be sent to the state,
     *      will populate $stateParams.
     * @param options Transition options
     *
     * @returns A promise representing the state of the new transition. See [[go]]
     */
    StateService.prototype.transitionTo = function (to, toParams, options) {
        var _this = this;
        if (toParams === void 0) { toParams = {}; }
        if (options === void 0) { options = {}; }
        var router = this.router;
        var globals = router.globals;
        options = common_1.defaults(options, transitionService_1.defaultTransOpts);
        var getCurrent = function () {
            return globals.transition;
        };
        options = common_1.extend(options, { current: getCurrent });
        var ref = this.target(to, toParams, options);
        var currentPath = this.getCurrentPath();
        if (!ref.exists())
            return this._handleInvalidTargetState(currentPath, ref);
        if (!ref.valid())
            return common_1.silentRejection(ref.error());
        /**
         * Special handling for Ignored, Aborted, and Redirected transitions
         *
         * The semantics for the transition.run() promise and the StateService.transitionTo()
         * promise differ. For instance, the run() promise may be rejected because it was
         * IGNORED, but the transitionTo() promise is resolved because from the user perspective
         * no error occurred.  Likewise, the transition.run() promise may be rejected because of
         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.
         */
        var rejectedTransitionHandler = function (transition) { return function (error) {
            if (error instanceof rejectFactory_1.Rejection) {
                var isLatest = router.globals.lastStartedTransitionId === transition.$id;
                if (error.type === rejectFactory_1.RejectType.IGNORED) {
                    isLatest && router.urlRouter.update();
                    // Consider ignored `Transition.run()` as a successful `transitionTo`
                    return coreservices_1.services.$q.when(globals.current);
                }
                var detail = error.detail;
                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {
                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully
                    // by returning the promise for the new (redirect) `Transition.run()`.
                    var redirect = transition.redirect(detail);
                    return redirect.run().catch(rejectedTransitionHandler(redirect));
                }
                if (error.type === rejectFactory_1.RejectType.ABORTED) {
                    isLatest && router.urlRouter.update();
                    return coreservices_1.services.$q.reject(error);
                }
            }
            var errorHandler = _this.defaultErrorHandler();
            errorHandler(error);
            return coreservices_1.services.$q.reject(error);
        }; };
        var transition = this.router.transitionService.create(currentPath, ref);
        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));
        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676
        // Return a promise for the transition, which also has the transition object on it.
        return common_1.extend(transitionToPromise, { transition: transition });
    };
    ;
    /**
     * Checks if the current state *is* the provided state
     *
     * Similar to [[includes]] but only checks for the full state name.
     * If params is supplied then it will be tested for strict equality against the current
     * active params object, so all params must match with none missing and no extras.
     *
     * #### Example:
     * ```js
     * $state.$current.name = 'contacts.details.item';
     *
     * // absolute name
     * $state.is('contact.details.item'); // returns true
     * $state.is(contactDetailItemStateObject); // returns true
     * ```
     *
     * // relative name (. and ^), typically from a template
     * // E.g. from the 'contacts.details' template
     * ```html
     * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
     * ```
     *
     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.
     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like
     * to test against the current active state.
     * @param options An options object. The options are:
     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
     *     test relative to `options.relative` state (or name).
     *
     * @returns Returns true if it is the state.
     */
    StateService.prototype.is = function (stateOrName, params, options) {
        options = common_1.defaults(options, { relative: this.$current });
        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
        if (!predicates_1.isDefined(state))
            return undefined;
        if (this.$current !== state)
            return false;
        if (!params)
            return true;
        var schema = state.parameters({ inherit: true, matchingKeys: params });
        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);
    };
    ;
    /**
     * Checks if the current state *includes* the provided state
     *
     * A method to determine if the current active state is equal to or is the child of the
     * state stateName. If any params are passed then they will be tested for a match as well.
     * Not all the parameters need to be passed, just the ones you'd like to test for equality.
     *
     * #### Example when `$state.$current.name === 'contacts.details.item'`
     * ```js
     * // Using partial names
     * $state.includes("contacts"); // returns true
     * $state.includes("contacts.details"); // returns true
     * $state.includes("contacts.details.item"); // returns true
     * $state.includes("contacts.list"); // returns false
     * $state.includes("about"); // returns false
     * ```
     *
     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:
     * ```js
     * $state.includes("*.details.*.*"); // returns true
     * $state.includes("*.details.**"); // returns true
     * $state.includes("**.item.**"); // returns true
     * $state.includes("*.details.item.url"); // returns true
     * $state.includes("*.details.*.url"); // returns true
     * $state.includes("*.details.*"); // returns false
     * $state.includes("item.**"); // returns false
     * ```
     *
     * @param stateOrName A partial name, relative name, glob pattern,
     *   or state object to be searched for within the current state name.
     * @param params A param object, e.g. `{sectionId: section.id}`,
     *   that you'd like to test against the current active state.
     * @param options An options object. The options are:
     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
     *     test relative to `options.relative` state (or name).
     *
     * @returns {boolean} Returns true if it does include the state
     */
    StateService.prototype.includes = function (stateOrName, params, options) {
        options = common_1.defaults(options, { relative: this.$current });
        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);
        if (glob) {
            if (!glob.matches(this.$current.name))
                return false;
            stateOrName = this.$current.name;
        }
        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;
        if (!predicates_1.isDefined(state))
            return undefined;
        if (!predicates_1.isDefined(include[state.name]))
            return false;
        if (!params)
            return true;
        var schema = state.parameters({ inherit: true, matchingKeys: params });
        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);
    };
    ;
    /**
     * Generates a URL for a state and parameters
     *
     * Returns the url for the given state populated with the given params.
     *
     * #### Example:
     * ```js
     * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
     * ```
     *
     * @param stateOrName The state name or state object you'd like to generate a url from.
     * @param params An object of parameter values to fill the state's required parameters.
     * @param options Options object. The options are:
     *
     * @returns {string} compiled state url
     */
    StateService.prototype.href = function (stateOrName, params, options) {
        var defaultHrefOpts = {
            lossy: true,
            inherit: true,
            absolute: false,
            relative: this.$current,
        };
        options = common_1.defaults(options, defaultHrefOpts);
        params = params || {};
        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
        if (!predicates_1.isDefined(state))
            return null;
        if (options.inherit)
            params = this.params.$inherit(params, this.$current, state);
        var nav = (state && options.lossy) ? state.navigable : state;
        if (!nav || nav.url === undefined || nav.url === null) {
            return null;
        }
        return this.router.urlRouter.href(nav.url, params, {
            absolute: options.absolute,
        });
    };
    ;
    /**
     * Sets or gets the default [[transitionTo]] error handler.
     *
     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.
     * This includes errors caused by resolves and transition hooks.
     *
     * Note:
     * This handler does not receive certain Transition rejections.
     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].
     *
     * The built-in default error handler logs the error to the console.
     *
     * You can provide your own custom handler.
     *
     * #### Example:
     * ```js
     * stateService.defaultErrorHandler(function() {
     *   // Do not log transitionTo errors
     * });
     * ```
     *
     * @param handler a global error handler function
     * @returns the current global error handler
     */
    StateService.prototype.defaultErrorHandler = function (handler) {
        return this._defaultErrorHandler = handler || this._defaultErrorHandler;
    };
    StateService.prototype.get = function (stateOrName, base) {
        var reg = this.router.stateRegistry;
        if (arguments.length === 0)
            return reg.get();
        return reg.get(stateOrName, base || this.$current);
    };
    /**
     * Lazy loads a state
     *
     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.
     *
     * @param stateOrName the state that should be lazy loaded
     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)
     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.
     * This noop transition is not actually run.
     *
     * @returns a promise to lazy load
     */
    StateService.prototype.lazyLoad = function (stateOrName, transition) {
        var state = this.get(stateOrName);
        if (!state || !state.lazyLoad)
            throw new Error("Can not lazy load " + stateOrName);
        var currentPath = this.getCurrentPath();
        var target = pathFactory_1.PathUtils.makeTargetState(currentPath);
        transition = transition || this.router.transitionService.create(currentPath, target);
        return lazyLoad_1.lazyLoadState(transition, state);
    };
    return StateService;
}());
exports.StateService = StateService;
//# sourceMappingURL=stateService.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module transition
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var interface_1 = __webpack_require__(9);
var transitionHook_1 = __webpack_require__(14);
/**
 * This class returns applicable TransitionHooks for a specific Transition instance.
 *
 * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.
 * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is
 * determined by the type of hook)
 *
 * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.
 *
 * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder
 * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private
 * in the Transition class, so we must also provide the Transition's _treeChanges)
 *
 */
var HookBuilder = (function () {
    function HookBuilder(transition) {
        this.transition = transition;
    }
    HookBuilder.prototype.buildHooksForPhase = function (phase) {
        var _this = this;
        var $transitions = this.transition.router.transitionService;
        return $transitions._pluginapi._getEvents(phase)
            .map(function (type) { return _this.buildHooks(type); })
            .reduce(common_1.unnestR, [])
            .filter(common_1.identity);
    };
    /**
     * Returns an array of newly built TransitionHook objects.
     *
     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].
     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)
     * - For each of the [[PathNode]]s, creates a TransitionHook
     *
     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.
     */
    HookBuilder.prototype.buildHooks = function (hookType) {
        var transition = this.transition;
        var treeChanges = transition.treeChanges();
        // Find all the matching registered hooks for a given hook type
        var matchingHooks = this.getMatchingHooks(hookType, treeChanges);
        if (!matchingHooks)
            return [];
        var baseHookOptions = {
            transition: transition,
            current: transition.options().current
        };
        var makeTransitionHooks = function (hook) {
            // Fetch the Nodes that caused this hook to match.
            var matches = hook.matches(treeChanges);
            // Select the PathNode[] that will be used as TransitionHook context objects
            var matchingNodes = matches[hookType.criteriaMatchPath.name];
            // Return an array of HookTuples
            return matchingNodes.map(function (node) {
                var _options = common_1.extend({
                    bind: hook.bind,
                    traceData: { hookType: hookType.name, context: node }
                }, baseHookOptions);
                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state.self : null;
                var transitionHook = new transitionHook_1.TransitionHook(transition, state, hook, _options);
                return { hook: hook, node: node, transitionHook: transitionHook };
            });
        };
        return matchingHooks.map(makeTransitionHooks)
            .reduce(common_1.unnestR, [])
            .sort(tupleSort(hookType.reverseSort))
            .map(function (tuple) { return tuple.transitionHook; });
    };
    /**
     * Finds all RegisteredHooks from:
     * - The Transition object instance hook registry
     * - The TransitionService ($transitions) global hook registry
     *
     * which matched:
     * - the eventType
     * - the matchCriteria (to, from, exiting, retained, entering)
     *
     * @returns an array of matched [[RegisteredHook]]s
     */
    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {
        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;
        // Instance and Global hook registries
        var $transitions = this.transition.router.transitionService;
        var registries = isCreate ? [$transitions] : [this.transition, $transitions];
        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries
            .filter(common_1.assertPredicate(predicates_1.isArray, "broken event named: " + hookType.name)) // Sanity check
            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array
            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria
    };
    return HookBuilder;
}());
exports.HookBuilder = HookBuilder;
/**
 * A factory for a sort function for HookTuples.
 *
 * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares
 * the EventHook priority.
 *
 * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth
 * @returns a tuple sort function
 */
function tupleSort(reverseDepthSort) {
    if (reverseDepthSort === void 0) { reverseDepthSort = false; }
    return function nodeDepthThenPriority(l, r) {
        var factor = reverseDepthSort ? -1 : 1;
        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;
        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;
    };
}
//# sourceMappingURL=hookBuilder.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var transitionHook_1 = __webpack_require__(14);
/**
 * This class defines a type of hook, such as `onBefore` or `onEnter`.
 * Plugins can define custom hook types, such as sticky states does for `onInactive`.
 *
 * @interalapi
 */
var TransitionEventType = (function () {
    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
        if (reverseSort === void 0) { reverseSort = false; }
        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }
        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }
        if (synchronous === void 0) { synchronous = false; }
        this.name = name;
        this.hookPhase = hookPhase;
        this.hookOrder = hookOrder;
        this.criteriaMatchPath = criteriaMatchPath;
        this.reverseSort = reverseSort;
        this.getResultHandler = getResultHandler;
        this.getErrorHandler = getErrorHandler;
        this.synchronous = synchronous;
    }
    return TransitionEventType;
}());
exports.TransitionEventType = TransitionEventType;
//# sourceMappingURL=transitionEventType.js.map

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module url
 */ /** for typedoc */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var urlMatcher_1 = __webpack_require__(21);
var param_1 = __webpack_require__(8);
var paramTypes_1 = __webpack_require__(33);
/**
 * Factory for [[UrlMatcher]] instances.
 *
 * The factory is available to ng1 services as
 * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.
 */
var UrlMatcherFactory = (function () {
    function UrlMatcherFactory() {
        var _this = this;
        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();
        /** @hidden */ this._isCaseInsensitive = false;
        /** @hidden */ this._isStrictMode = true;
        /** @hidden */ this._defaultSquashPolicy = false;
        /** @hidden */
        this._getConfig = function (config) {
            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);
        };
        /** @internalapi Creates a new [[Param]] for a given location (DefType) */
        this.paramFactory = {
            /** Creates a new [[Param]] from a CONFIG block */
            fromConfig: function (id, type, config) {
                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);
            },
            /** Creates a new [[Param]] from a url PATH */
            fromPath: function (id, type, config) {
                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);
            },
            /** Creates a new [[Param]] from a url SEARCH */
            fromSearch: function (id, type, config) {
                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);
            },
        };
        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });
    }
    /** @inheritdoc */
    UrlMatcherFactory.prototype.caseInsensitive = function (value) {
        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;
    };
    /** @inheritdoc */
    UrlMatcherFactory.prototype.strictMode = function (value) {
        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;
    };
    /** @inheritdoc */
    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {
        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))
            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;
    };
    /**
     * Creates a [[UrlMatcher]] for the specified pattern.
     *
     * @param pattern  The URL pattern.
     * @param config  The config object hash.
     * @returns The UrlMatcher.
     */
    UrlMatcherFactory.prototype.compile = function (pattern, config) {
        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));
    };
    /**
     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.
     *
     * @param object  The object to perform the type check against.
     * @returns `true` if the object matches the `UrlMatcher` interface, by
     *          implementing all the same methods.
     */
    UrlMatcherFactory.prototype.isMatcher = function (object) {
        // TODO: typeof?
        if (!predicates_1.isObject(object))
            return false;
        var result = true;
        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {
            if (predicates_1.isFunction(val))
                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));
        });
        return result;
    };
    ;
    /**
     * Creates and registers a custom [[ParamType]] object
     *
     * A [[ParamType]] can be used to generate URLs with typed parameters.
     *
     * @param name  The type name.
     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.
     * @param definitionFn A function that is injected before the app runtime starts.
     *        The result of this function should be a [[ParamTypeDefinition]].
     *        The result is merged into the existing `definition`.
     *        See [[ParamType]] for information on the values accepted.
     *
     * @returns - if a type was registered: the [[UrlMatcherFactory]]
     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined
     *
     * Note: Register custom types *before using them* in a state definition.
     *
     * See [[ParamTypeDefinition]] for examples
     */
    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {
        var type = this.paramTypes.type(name, definition, definitionFn);
        return !predicates_1.isDefined(definition) ? type : this;
    };
    ;
    /** @hidden */
    UrlMatcherFactory.prototype.$get = function () {
        this.paramTypes.enqueue = false;
        this.paramTypes._flushTypeQueue();
        return this;
    };
    ;
    /** @internalapi */
    UrlMatcherFactory.prototype.dispose = function () {
        this.paramTypes.dispose();
    };
    return UrlMatcherFactory;
}());
exports.UrlMatcherFactory = UrlMatcherFactory;
//# sourceMappingURL=urlMatcherFactory.js.map

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module url
 */
/** for typedoc */
var common_1 = __webpack_require__(0);
var predicates_1 = __webpack_require__(1);
var urlMatcher_1 = __webpack_require__(21);
var hof_1 = __webpack_require__(2);
var urlRule_1 = __webpack_require__(46);
var targetState_1 = __webpack_require__(7);
/** @hidden */
function appendBasePath(url, isHtml5, absolute, baseHref) {
    if (baseHref === '/')
        return url;
    if (isHtml5)
        return baseHref.slice(0, -1) + url;
    if (absolute)
        return baseHref.slice(1) + url;
    return url;
}
/** @hidden */
var getMatcher = hof_1.prop("urlMatcher");
/**
 * Default rule priority sorting function.
 *
 * Sorts rules by:
 *
 * - Explicit priority (set rule priority using [[UrlRulesApi.when]])
 * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)
 * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.
 * - Registration order (for rule types other than STATE and URLMATCHER)
 *
 * @coreapi
 */
var defaultRuleSortFn;
defaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop("priority"), function (x) { return -x; })), common_1.sortBy(hof_1.pipe(hof_1.prop("type"), function (type) { return ({ "STATE": 4, "URLMATCHER": 4, "REGEXP": 3, "RAW": 2, "OTHER": 1 })[type]; })), function (a, b) { return (getMatcher(a) && getMatcher(b)) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0; }, common_1.sortBy(hof_1.prop("$id"), common_1.inArray(["REGEXP", "RAW", "OTHER"])));
/**
 * Updates URL and responds to URL changes
 *
 * ### Deprecation warning:
 * This class is now considered to be an internal API
 * Use the [[UrlService]] instead.
 * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].
 *
 * This class updates the URL when the state changes.
 * It also responds to changes in the URL.
 */
var UrlRouter = (function () {
    /** @hidden */
    function UrlRouter(router) {
        /** @hidden */ this._sortFn = defaultRuleSortFn;
        /** @hidden */ this._rules = [];
        /** @hidden */ this.interceptDeferred = false;
        /** @hidden */ this._id = 0;
        /** @hidden */ this._sorted = false;
        this._router = router;
        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);
        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));
    }
    /** @internalapi */
    UrlRouter.prototype.dispose = function () {
        this.listen(false);
        this._rules = [];
        delete this._otherwiseFn;
    };
    /** @inheritdoc */
    UrlRouter.prototype.sort = function (compareFn) {
        this._rules.sort(this._sortFn = compareFn || this._sortFn);
        this._sorted = true;
    };
    UrlRouter.prototype.ensureSorted = function () {
        this._sorted || this.sort();
    };
    /**
     * Given a URL, check all rules and return the best [[MatchResult]]
     * @param url
     * @returns {MatchResult}
     */
    UrlRouter.prototype.match = function (url) {
        var _this = this;
        this.ensureSorted();
        url = common_1.extend({ path: '', search: {}, hash: '' }, url);
        var rules = this.rules();
        if (this._otherwiseFn)
            rules.push(this._otherwiseFn);
        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined
        var checkRule = function (rule) {
            var match = rule.match(url, _this._router);
            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };
        };
        // The rules are pre-sorted.
        // - Find the first matching rule.
        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.
        // - Choose the rule with the highest match weight.
        var best;
        for (var i = 0; i < rules.length; i++) {
            // Stop when there is a 'best' rule and the next rule sorts differently than it.
            if (best && this._sortFn(rules[i], best.rule) !== 0)
                break;
            var current = checkRule(rules[i]);
            // Pick the best MatchResult
            best = (!best || current && current.weight > best.weight) ? current : best;
        }
        return best;
    };
    /** @inheritdoc */
    UrlRouter.prototype.sync = function (evt) {
        if (evt && evt.defaultPrevented)
            return;
        var router = this._router, $url = router.urlService, $state = router.stateService;
        var url = {
            path: $url.path(), search: $url.search(), hash: $url.hash(),
        };
        var best = this.match(url);
        var applyResult = hof_1.pattern([
            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],
            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],
            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],
        ]);
        applyResult(best && best.rule.handler(best.match, url, router));
    };
    /** @inheritdoc */
    UrlRouter.prototype.listen = function (enabled) {
        var _this = this;
        if (enabled === false) {
            this._stopFn && this._stopFn();
            delete this._stopFn;
        }
        else {
            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });
        }
    };
    /**
     * Internal API.
     * @internalapi
     */
    UrlRouter.prototype.update = function (read) {
        var $url = this._router.locationService;
        if (read) {
            this.location = $url.path();
            return;
        }
        if ($url.path() === this.location)
            return;
        $url.url(this.location, true);
    };
    /**
     * Internal API.
     *
     * Pushes a new location to the browser history.
     *
     * @internalapi
     * @param urlMatcher
     * @param params
     * @param options
     */
    UrlRouter.prototype.push = function (urlMatcher, params, options) {
        var replace = options && !!options.replace;
        this._router.urlService.url(urlMatcher.format(params || {}), replace);
    };
    /**
     * Builds and returns a URL with interpolated parameters
     *
     * #### Example:
     * ```js
     * matcher = $umf.compile("/about/:person");
     * params = { person: "bob" };
     * $bob = $urlRouter.href(matcher, params);
     * // $bob == "/about/bob";
     * ```
     *
     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.
     * @param params An object of parameter values to fill the matcher's required parameters.
     * @param options Options object. The options are:
     *
     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
     *
     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
     */
    UrlRouter.prototype.href = function (urlMatcher, params, options) {
        var url = urlMatcher.format(params);
        if (url == null)
            return null;
        options = options || { absolute: false };
        var cfg = this._router.urlService.config;
        var isHtml5 = cfg.html5Mode();
        if (!isHtml5 && url !== null) {
            url = "#" + cfg.hashPrefix() + url;
        }
        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());
        if (!options.absolute || !url) {
            return url;
        }
        var slash = (!isHtml5 && url ? '/' : ''), port = cfg.port();
        port = (port === 80 || port === 443 ? '' : ':' + port);
        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');
    };
    /**
     * Manually adds a URL Rule.
     *
     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].
     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).
     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.
     *
     * A rule should have a `match` function which returns truthy if the rule matched.
     * It should also have a `handler` function which is invoked if the rule is the best match.
     *
     * @return a function that deregisters the rule
     */
    UrlRouter.prototype.rule = function (rule) {
        var _this = this;
        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))
            throw new Error("invalid rule");
        rule.$id = this._id++;
        rule.priority = rule.priority || 0;
        this._rules.push(rule);
        this._sorted = false;
        return function () { return _this.removeRule(rule); };
    };
    /** @inheritdoc */
    UrlRouter.prototype.removeRule = function (rule) {
        common_1.removeFrom(this._rules, rule);
    };
    /** @inheritdoc */
    UrlRouter.prototype.rules = function () {
        this.ensureSorted();
        return this._rules.slice();
    };
    /** @inheritdoc */
    UrlRouter.prototype.otherwise = function (handler) {
        var handlerFn = getHandlerFn(handler);
        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);
        this._sorted = false;
    };
    ;
    /** @inheritdoc */
    UrlRouter.prototype.initial = function (handler) {
        var handlerFn = getHandlerFn(handler);
        var matchFn = function (urlParts, router) {
            return router.globals.transitionHistory.size() === 0 && !!/^\/?$/.exec(urlParts.path);
        };
        this.rule(this.urlRuleFactory.create(matchFn, handlerFn));
    };
    ;
    /** @inheritdoc */
    UrlRouter.prototype.when = function (matcher, handler, options) {
        var rule = this.urlRuleFactory.create(matcher, handler);
        if (predicates_1.isDefined(options && options.priority))
            rule.priority = options.priority;
        this.rule(rule);
        return rule;
    };
    ;
    /** @inheritdoc */
    UrlRouter.prototype.deferIntercept = function (defer) {
        if (defer === undefined)
            defer = true;
        this.interceptDeferred = defer;
    };
    ;
    return UrlRouter;
}());
exports.UrlRouter = UrlRouter;
function getHandlerFn(handler) {
    if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {
        throw new Error("'handler' must be a string, function, TargetState, or have a state: 'newtarget' property");
    }
    return predicates_1.isFunction(handler) ? handler : hof_1.val(handler);
}
//# sourceMappingURL=urlRouter.js.map

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module url
 */ /** */
var urlMatcher_1 = __webpack_require__(21);
var predicates_1 = __webpack_require__(1);
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
/**
 * Creates a [[UrlRule]]
 *
 * Creates a [[UrlRule]] from a:
 *
 * - `string`
 * - [[UrlMatcher]]
 * - `RegExp`
 * - [[StateObject]]
 * @internalapi
 */
var UrlRuleFactory = (function () {
    function UrlRuleFactory(router) {
        this.router = router;
    }
    UrlRuleFactory.prototype.compile = function (str) {
        return this.router.urlMatcherFactory.compile(str);
    };
    UrlRuleFactory.prototype.create = function (what, handler) {
        var _this = this;
        var makeRule = hof_1.pattern([
            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],
            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],
            [predicates_1.isState, function (_what) { return _this.fromState(_what, _this.router); }],
            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],
            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],
        ]);
        var rule = makeRule(what);
        if (!rule)
            throw new Error("invalid 'what' in when()");
        return rule;
    };
    /**
     * A UrlRule which matches based on a UrlMatcher
     *
     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]
     *
     * ## Handler as a function
     *
     * If `handler` is a function, the function is invoked with:
     *
     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])
     * - url: the current Url ([[UrlParts]])
     * - router: the router object ([[UIRouter]])
     *
     * #### Example:
     * ```js
     * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
     * var rule = factory.fromUrlMatcher(urlMatcher, match => "/home/" + match.fooId + "/" + match.barId);
     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
     * var result = rule.handler(match); // '/home/123/456'
     * ```
     *
     * ## Handler as UrlMatcher
     *
     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.
     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.
     * The url is replaced with the result.
     *
     * #### Example:
     * ```js
     * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
     * var handler = $umf.compile("/home/:fooId/:barId");
     * var rule = factory.fromUrlMatcher(urlMatcher, handler);
     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
     * var result = rule.handler(match); // '/home/123/456'
     * ```
     */
    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {
        var _handler = handler;
        if (predicates_1.isString(handler))
            handler = this.router.urlMatcherFactory.compile(handler);
        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))
            _handler = function (match) { return handler.format(match); };
        function match(url) {
            var match = urlMatcher.exec(url.path, url.search, url.hash);
            return urlMatcher.validates(match) && match;
        }
        // Prioritize URLs, lowest to highest:
        // - Some optional URL parameters, but none matched
        // - No optional parameters in URL
        // - Some optional parameters, some matched
        // - Some optional parameters, all matched
        function matchPriority(params) {
            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });
            if (!optional.length)
                return 0.000001;
            var matched = optional.filter(function (param) { return params[param.id]; });
            return matched.length / optional.length;
        }
        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: "URLMATCHER" };
        return common_1.extend(new BaseUrlRule(match, _handler), details);
    };
    /**
     * A UrlRule which matches a state by its url
     *
     * #### Example:
     * ```js
     * var rule = factory.fromState($state.get('foo'), router);
     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
     * var result = rule.handler(match);
     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }
     * ```
     */
    UrlRuleFactory.prototype.fromState = function (state, router) {
        /**
         * Handles match by transitioning to matched state
         *
         * First checks if the router should start a new transition.
         * A new transition is not required if the current state's URL
         * and the new URL are already identical
         */
        var handler = function (match) {
            var $state = router.stateService;
            var globals = router.globals;
            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {
                $state.transitionTo(state, match, { inherit: true, source: "url" });
            }
        };
        var details = { state: state, type: "STATE" };
        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);
    };
    /**
     * A UrlRule which matches based on a regular expression
     *
     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.
     *
     * ## Handler as a function
     *
     * If `handler` is a function, the function is invoked with:
     *
     * - regexp match array (from `regexp`)
     * - url: the current Url ([[UrlParts]])
     * - router: the router object ([[UIRouter]])
     *
     * #### Example:
     * ```js
     * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, match => "/home/" + match[1])
     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
     * var result = rule.handler(match); // '/home/bar'
     * ```
     *
     * ## Handler as string
     *
     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.
     * The string is first interpolated using `string.replace()` style pattern.
     *
     * #### Example:
     * ```js
     * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, "/home/$1")
     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
     * var result = rule.handler(match); // '/home/bar'
     * ```
     */
    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {
        if (regexp.global || regexp.sticky)
            throw new Error("Rule RegExp must not be global or sticky");
        /**
         * If handler is a string, the url will be replaced by the string.
         * If the string has any String.replace() style variables in it (like `$2`),
         * they will be replaced by the captures from [[match]]
         */
        var redirectUrlTo = function (match) {
            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern
            return handler.replace(/\$(\$|\d{1,2})/, function (m, what) {
                return match[what === '$' ? 0 : Number(what)];
            });
        };
        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;
        var match = function (url) {
            return regexp.exec(url.path);
        };
        var details = { regexp: regexp, type: "REGEXP" };
        return common_1.extend(new BaseUrlRule(match, _handler), details);
    };
    return UrlRuleFactory;
}());
UrlRuleFactory.isUrlRule = function (obj) {
    return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });
};
exports.UrlRuleFactory = UrlRuleFactory;
/**
 * A base rule which calls `match`
 *
 * The value from the `match` function is passed through to the `handler`.
 * @internalapi
 */
var BaseUrlRule = (function () {
    function BaseUrlRule(match, handler) {
        var _this = this;
        this.match = match;
        this.type = "RAW";
        this.matchPriority = function (match) { return 0 - _this.$id; };
        this.handler = handler || common_1.identity;
    }
    return BaseUrlRule;
}());
exports.BaseUrlRule = BaseUrlRule;
//# sourceMappingURL=urlRule.js.map

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @coreapi
 * @module url
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
var coreservices_1 = __webpack_require__(3);
var common_1 = __webpack_require__(0);
/** @hidden */
var makeStub = function (keys) {
    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });
};
/** @hidden */ var locationServicesFns = ["url", "path", "search", "hash", "onChange"];
/** @hidden */ var locationConfigFns = ["port", "protocol", "host", "baseHref", "html5Mode", "hashPrefix"];
/** @hidden */ var umfFns = ["type", "caseInsensitive", "strictMode", "defaultSquashPolicy"];
/** @hidden */ var rulesFns = ["sort", "when", "initial", "otherwise", "rules", "rule", "removeRule"];
/** @hidden */ var syncFns = ["deferIntercept", "listen", "sync", "match"];
/**
 * API for URL management
 */
var UrlService = (function () {
    /** @hidden */
    function UrlService(router, lateBind) {
        if (lateBind === void 0) { lateBind = true; }
        this.router = router;
        this.rules = {};
        this.config = {};
        // proxy function calls from UrlService to the LocationService/LocationConfig
        var locationServices = function () { return router.locationService; };
        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);
        var locationConfig = function () { return router.locationConfig; };
        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);
        var umf = function () { return router.urlMatcherFactory; };
        common_1.createProxyFunctions(umf, this.config, umf, umfFns);
        var urlRouter = function () { return router.urlRouter; };
        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);
        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);
    }
    UrlService.prototype.url = function (newurl, replace, state) { return; };
    ;
    /** @inheritdoc */
    UrlService.prototype.path = function () { return; };
    ;
    /** @inheritdoc */
    UrlService.prototype.search = function () { return; };
    ;
    /** @inheritdoc */
    UrlService.prototype.hash = function () { return; };
    ;
    /** @inheritdoc */
    UrlService.prototype.onChange = function (callback) { return; };
    ;
    /**
     * Returns the current URL parts
     *
     * This method returns the current URL components as a [[UrlParts]] object.
     *
     * @returns the current url parts
     */
    UrlService.prototype.parts = function () {
        return { path: this.path(), search: this.search(), hash: this.hash() };
    };
    UrlService.prototype.dispose = function () { };
    /** @inheritdoc */
    UrlService.prototype.sync = function (evt) { return; };
    /** @inheritdoc */
    UrlService.prototype.listen = function (enabled) { return; };
    ;
    /** @inheritdoc */
    UrlService.prototype.deferIntercept = function (defer) { return; };
    /** @inheritdoc */
    UrlService.prototype.match = function (urlParts) { return; };
    return UrlService;
}());
/** @hidden */
UrlService.locationServiceStub = makeStub(locationServicesFns);
/** @hidden */
UrlService.locationConfigStub = makeStub(locationConfigFns);
exports.UrlService = UrlService;
//# sourceMappingURL=urlService.js.map

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var predicates_1 = __webpack_require__(1);
/** A `LocationConfig` that delegates to the browser's `location` object */
var BrowserLocationConfig = (function () {
    function BrowserLocationConfig(router, _isHtml5) {
        if (_isHtml5 === void 0) { _isHtml5 = false; }
        this._isHtml5 = _isHtml5;
        this._baseHref = undefined;
        this._hashPrefix = "";
    }
    BrowserLocationConfig.prototype.port = function () {
        if (location.port) {
            return Number(location.port);
        }
        return this.protocol() === 'https' ? 443 : 80;
    };
    BrowserLocationConfig.prototype.protocol = function () {
        return location.protocol.replace(/:/g, '');
    };
    BrowserLocationConfig.prototype.host = function () {
        return location.host;
    };
    BrowserLocationConfig.prototype.html5Mode = function () {
        return this._isHtml5;
    };
    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {
        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;
    };
    ;
    BrowserLocationConfig.prototype.baseHref = function (href) {
        return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();
    };
    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {
        var baseTags = document.getElementsByTagName("base");
        return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : "";
    };
    BrowserLocationConfig.prototype.dispose = function () { };
    return BrowserLocationConfig;
}());
exports.BrowserLocationConfig = BrowserLocationConfig;
//# sourceMappingURL=browserLocationConfig.js.map

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var utils_1 = __webpack_require__(15);
var baseLocationService_1 = __webpack_require__(22);
/** A `LocationServices` that uses the browser hash "#" to get/set the current location */
var HashLocationService = (function (_super) {
    __extends(HashLocationService, _super);
    function HashLocationService(router) {
        var _this = _super.call(this, router, false) || this;
        window.addEventListener('hashchange', _this._listener, false);
        return _this;
    }
    HashLocationService.prototype._get = function () {
        return utils_1.trimHashVal(this._location.hash);
    };
    HashLocationService.prototype._set = function (state, title, url, replace) {
        this._location.hash = url;
    };
    HashLocationService.prototype.dispose = function (router) {
        _super.prototype.dispose.call(this, router);
        window.removeEventListener('hashchange', this._listener);
    };
    return HashLocationService;
}(baseLocationService_1.BaseLocationServices));
exports.HashLocationService = HashLocationService;
//# sourceMappingURL=hashLocationService.js.map

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var index_1 = __webpack_require__(17);
// globally available injectables
var globals = {};
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
/**
 * A basic angular1-like injector api
 *
 * This object implements four methods similar to the
 * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)
 *
 * UI-Router evolved from an angular 1 library to a framework agnostic library.
 * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.
 *
 * This object provides a naive implementation of a globally scoped dependency injection system.
 * It supports the following DI approaches:
 *
 * ### Function parameter names
 *
 * A function's `.toString()` is called, and the parameter names are parsed.
 * This only works when the parameter names aren't "mangled" by a minifier such as UglifyJS.
 *
 * ```js
 * function injectedFunction(FooService, BarService) {
 *   // FooService and BarService are injected
 * }
 * ```
 *
 * ### Function annotation
 *
 * A function may be annotated with an array of dependency names as the `$inject` property.
 *
 * ```js
 * injectedFunction.$inject = [ 'FooService', 'BarService' ];
 * function injectedFunction(fs, bs) {
 *   // FooService and BarService are injected as fs and bs parameters
 * }
 * ```
 *
 * ### Array notation
 *
 * An array provides the names of the dependencies to inject (as strings).
 * The function is the last element of the array.
 *
 * ```js
 * [ 'FooService', 'BarService', function (fs, bs) {
 *   // FooService and BarService are injected as fs and bs parameters
 * }]
 * ```
 *
 * @type {$InjectorLike}
 */
exports.$injector = {
    /** Gets an object from DI based on a string token */
    get: function (name) { return globals[name]; },
    /** Returns true if an object named `name` exists in global DI */
    has: function (name) { return exports.$injector.get(name) != null; },
    /**
     * Injects a function
     *
     * @param fn the function to inject
     * @param context the function's `this` binding
     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`
     */
    invoke: function (fn, context, locals) {
        var all = index_1.extend({}, globals, locals || {});
        var params = exports.$injector.annotate(fn);
        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return "DI can't find injectable: '" + key + "'"; });
        var args = params.filter(ensureExist).map(function (x) { return all[x]; });
        if (index_1.isFunction(fn))
            return fn.apply(context, args);
        else
            return fn.slice(-1)[0].apply(context, args);
    },
    /**
     * Returns a function's dependencies
     *
     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.
     * @return an array of `string`s
     */
    annotate: function (fn) {
        if (!index_1.isInjectable(fn))
            throw new Error("Not an injectable function: " + fn);
        if (fn && fn.$inject)
            return fn.$inject;
        if (index_1.isArray(fn))
            return fn.slice(0, -1);
        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');
        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
        return result || [];
    }
};
//# sourceMappingURL=injector.js.map

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var predicates_1 = __webpack_require__(1);
var common_1 = __webpack_require__(0);
/** A `LocationConfig` mock that gets/sets all config from an in-memory object */
var MemoryLocationConfig = (function () {
    function MemoryLocationConfig() {
        var _this = this;
        this._baseHref = '';
        this._port = 80;
        this._protocol = "http";
        this._host = "localhost";
        this._hashPrefix = "";
        this.port = function () { return _this._port; };
        this.protocol = function () { return _this._protocol; };
        this.host = function () { return _this._host; };
        this.baseHref = function () { return _this._baseHref; };
        this.html5Mode = function () { return false; };
        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };
        this.dispose = common_1.noop;
    }
    return MemoryLocationConfig;
}());
exports.MemoryLocationConfig = MemoryLocationConfig;
//# sourceMappingURL=memoryLocationConfig.js.map

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var baseLocationService_1 = __webpack_require__(22);
/** A `LocationServices` that gets/sets the current location from an in-memory object */
var MemoryLocationService = (function (_super) {
    __extends(MemoryLocationService, _super);
    function MemoryLocationService(router) {
        return _super.call(this, router, true) || this;
    }
    MemoryLocationService.prototype._get = function () {
        return this._url;
    };
    MemoryLocationService.prototype._set = function (state, title, url, replace) {
        this._url = url;
    };
    return MemoryLocationService;
}(baseLocationService_1.BaseLocationServices));
exports.MemoryLocationService = MemoryLocationService;
//# sourceMappingURL=memoryLocationService.js.map

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(15);
var baseLocationService_1 = __webpack_require__(22);
/**
 * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis
 *
 * Uses `history.pushState` and `history.replaceState`
 */
var PushStateLocationService = (function (_super) {
    __extends(PushStateLocationService, _super);
    function PushStateLocationService(router) {
        var _this = _super.call(this, router, true) || this;
        _this._config = router.urlService.config;
        window.addEventListener("popstate", _this._listener, false);
        return _this;
    }
    ;
    PushStateLocationService.prototype._get = function () {
        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;
        search = utils_1.splitQuery(search)[1]; // strip ? if found
        hash = utils_1.splitHash(hash)[1]; // strip # if found
        return pathname + (search ? "?" + search : "") + (hash ? "$" + search : "");
    };
    PushStateLocationService.prototype._set = function (state, title, url, replace) {
        var _a = this, _config = _a._config, _history = _a._history;
        var fullUrl = _config.baseHref() + url;
        if (replace) {
            _history.replaceState(state, title, fullUrl);
        }
        else {
            _history.pushState(state, title, fullUrl);
        }
    };
    PushStateLocationService.prototype.dispose = function (router) {
        _super.prototype.dispose.call(this, router);
        window.removeEventListener("popstate", this._listener);
    };
    return PushStateLocationService;
}(baseLocationService_1.BaseLocationServices));
exports.PushStateLocationService = PushStateLocationService;
//# sourceMappingURL=pushStateLocationService.js.map

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var index_1 = __webpack_require__(17);
/**
 * An angular1-like promise api
 *
 * This object implements four methods similar to the
 * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)
 *
 * UI-Router evolved from an angular 1 library to a framework agnostic library.
 * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.
 *
 * This API provides native ES6 promise support wrapped as a $q-like API.
 * Internally, UI-Router uses this $q object to perform promise operations.
 * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.
 *
 * $q-like promise api
 */
exports.$q = {
    /** Normalizes a value as a promise */
    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },
    /** Normalizes a value as a promise rejection */
    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },
    /** @returns a deferred object, which has `resolve` and `reject` functions */
    defer: function () {
        var deferred = {};
        deferred.promise = new Promise(function (resolve, reject) {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });
        return deferred;
    },
    /** Like Promise.all(), but also supports object key/promise notation like $q */
    all: function (promises) {
        if (index_1.isArray(promises)) {
            return Promise.all(promises);
        }
        if (index_1.isObject(promises)) {
            // Convert promises map to promises array.
            // When each promise resolves, map it to a tuple { key: key, val: val }
            var chain = Object.keys(promises)
                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });
            // Then wait for all promises to resolve, and convert them back to an object
            return exports.$q.all(chain).then(function (values) {
                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});
            });
        }
    }
};
//# sourceMappingURL=q.js.map

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @coreapi
 * @module view
 */ /** for typedoc */
var common_1 = __webpack_require__(0);
var hof_1 = __webpack_require__(2);
var predicates_1 = __webpack_require__(1);
var trace_1 = __webpack_require__(6);
/**
 * The View service
 *
 * This service pairs existing `ui-view` components (which live in the DOM)
 * with view configs (from the state declaration objects: [[StateDeclaration.views]]).
 *
 * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].
 *   The views from exited states are deactivated via [[deactivateViewConfig]].
 *   (See: the [[registerActivateViews]] Transition Hook)
 *
 * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].
 *
 * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])
 * are configured with the matching [[ViewConfig]](s)
 *
 */
var ViewService = (function () {
    function ViewService() {
        var _this = this;
        this._uiViews = [];
        this._viewConfigs = [];
        this._viewConfigFactories = {};
        this._pluginapi = {
            _rootViewContext: this._rootViewContext.bind(this),
            _viewConfigFactory: this._viewConfigFactory.bind(this),
            _registeredUIViews: function () { return _this._uiViews; },
            _activeViewConfigs: function () { return _this._viewConfigs; },
        };
    }
    ViewService.prototype._rootViewContext = function (context) {
        return this._rootContext = context || this._rootContext;
    };
    ;
    ViewService.prototype._viewConfigFactory = function (viewType, factory) {
        this._viewConfigFactories[viewType] = factory;
    };
    ViewService.prototype.createViewConfig = function (path, decl) {
        var cfgFactory = this._viewConfigFactories[decl.$type];
        if (!cfgFactory)
            throw new Error("ViewService: No view config factory registered for type " + decl.$type);
        var cfgs = cfgFactory(path, decl);
        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];
    };
    /**
     * Deactivates a ViewConfig.
     *
     * This function deactivates a `ViewConfig`.
     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.
     *
     * @param viewConfig The ViewConfig view to deregister.
     */
    ViewService.prototype.deactivateViewConfig = function (viewConfig) {
        trace_1.trace.traceViewServiceEvent("<- Removing", viewConfig);
        common_1.removeFrom(this._viewConfigs, viewConfig);
    };
    ViewService.prototype.activateViewConfig = function (viewConfig) {
        trace_1.trace.traceViewServiceEvent("-> Registering", viewConfig);
        this._viewConfigs.push(viewConfig);
    };
    ViewService.prototype.sync = function () {
        var _this = this;
        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});
        // Return a weighted depth value for a uiView.
        // The depth is the nesting depth of ui-views (based on FQN; times 10,000)
        // plus the depth of the state that is populating the uiView
        function uiViewDepth(uiView) {
            var stateDepth = function (context) {
                return context && context.parent ? stateDepth(context.parent) + 1 : 1;
            };
            return (uiView.fqn.split(".").length * 10000) + stateDepth(uiView.creationContext);
        }
        // Return the ViewConfig's context's depth in the context tree.
        function viewConfigDepth(config) {
            var context = config.viewDecl.$context, count = 0;
            while (++count && context.parent)
                context = context.parent;
            return count;
        }
        // Given a depth function, returns a compare function which can return either ascending or descending order
        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });
        var matchingConfigPair = function (uiView) {
            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));
            if (matchingConfigs.length > 1) {
                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)
                // Sort by depth and return the match from the deepest child
                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);
                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending
            }
            return [uiView, matchingConfigs[0]];
        };
        var configureUIView = function (_a) {
            var uiView = _a[0], viewConfig = _a[1];
            // If a parent ui-view is reconfigured, it could destroy child ui-views.
            // Before configuring a child ui-view, make sure it's still in the active uiViews array.
            if (_this._uiViews.indexOf(uiView) !== -1)
                uiView.configUpdated(viewConfig);
        };
        // Sort views by FQN and state depth. Process uiviews nearest the root first.
        this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);
    };
    ;
    /**
     * Registers a `ui-view` component
     *
     * When a `ui-view` component is created, it uses this method to register itself.
     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].
     *
     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,
     * and what the view's state context is.
     *
     * Note: There is no corresponding `deregisterUIView`.
     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.
     *
     * @param uiView The metadata for a UIView
     * @return a de-registration function used when the view is destroyed.
     */
    ViewService.prototype.registerUIView = function (uiView) {
        trace_1.trace.traceViewServiceUIViewEvent("-> Registering", uiView);
        var uiViews = this._uiViews;
        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };
        if (uiViews.filter(fqnMatches).length)
            trace_1.trace.traceViewServiceUIViewEvent("!!!! duplicate uiView named:", uiView);
        uiViews.push(uiView);
        this.sync();
        return function () {
            var idx = uiViews.indexOf(uiView);
            if (idx === -1) {
                trace_1.trace.traceViewServiceUIViewEvent("Tried removing non-registered uiView", uiView);
                return;
            }
            trace_1.trace.traceViewServiceUIViewEvent("<- Deregistering", uiView);
            common_1.removeFrom(uiViews)(uiView);
        };
    };
    ;
    /**
     * Returns the list of views currently available on the page, by fully-qualified name.
     *
     * @return {Array} Returns an array of fully-qualified view names.
     */
    ViewService.prototype.available = function () {
        return this._uiViews.map(hof_1.prop("fqn"));
    };
    /**
     * Returns the list of views on the page containing loaded content.
     *
     * @return {Array} Returns an array of fully-qualified view names.
     */
    ViewService.prototype.active = function () {
        return this._uiViews.filter(hof_1.prop("$config")).map(hof_1.prop("name"));
    };
    /**
     * Normalizes a view's name from a state.views configuration block.
     *
     * This should be used by a framework implementation to calculate the values for
     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].
     *
     * @param context the context object (state declaration) that the view belongs to
     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]
     *
     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets
     */
    ViewService.normalizeUIViewTarget = function (context, rawViewName) {
        if (rawViewName === void 0) { rawViewName = ""; }
        // TODO: Validate incoming view name with a regexp to allow:
        // ex: "view.name@foo.bar" , "^.^.view.name" , "view.name@^.^" , "" ,
        // "@" , "$default@^" , "!$default.$default" , "!foo.bar"
        var viewAtContext = rawViewName.split("@");
        var uiViewName = viewAtContext[0] || "$default"; // default to unnamed view
        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : "^"; // default to parent context
        // Handle relative view-name sugar syntax.
        // Matches rawViewName "^.^.^.foo.bar" into array: ["^.^.^.foo.bar", "^.^.^", "foo.bar"],
        var relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(uiViewName);
        if (relativeViewNameSugar) {
            // Clobbers existing contextAnchor (rawViewName validation will fix this)
            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to "^.^.^"
            uiViewName = relativeViewNameSugar[2]; // set view-name to "foo.bar"
        }
        if (uiViewName.charAt(0) === '!') {
            uiViewName = uiViewName.substr(1);
            uiViewContextAnchor = ""; // target absolutely from root
        }
        // handle parent relative targeting "^.^.^"
        var relativeMatch = /^(\^(?:\.\^)*)$/;
        if (relativeMatch.exec(uiViewContextAnchor)) {
            var anchor = uiViewContextAnchor.split(".").reduce((function (anchor, x) { return anchor.parent; }), context);
            uiViewContextAnchor = anchor.name;
        }
        else if (uiViewContextAnchor === '.') {
            uiViewContextAnchor = context.name;
        }
        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };
    };
    return ViewService;
}());
/**
 * Given a ui-view and a ViewConfig, determines if they "match".
 *
 * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in
 * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.
 *
 * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or
 * can be a segmented ui-view path, describing a portion of a ui-view fqn.
 *
 * In order for a ui-view to match ViewConfig, ui-view's $type must match the ViewConfig's $type
 *
 * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:
 * - the ui-view's name matches the ViewConfig's target name
 * - the ui-view's context matches the ViewConfig's anchor
 *
 * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:
 * - There exists a parent ui-view where:
 *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name
 *    - the parent ui-view's context matches the ViewConfig's anchor
 * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn
 *
 * Example:
 *
 * DOM:
 * <ui-view>                        <!-- created in the root context (name: "") -->
 *   <ui-view name="foo">                <!-- created in the context named: "A"      -->
 *     <ui-view>                    <!-- created in the context named: "A.B"    -->
 *       <ui-view name="bar">            <!-- created in the context named: "A.B.C"  -->
 *       </ui-view>
 *     </ui-view>
 *   </ui-view>
 * </ui-view>
 *
 * uiViews: [
 *  { fqn: "$default",                  creationContext: { name: "" } },
 *  { fqn: "$default.foo",              creationContext: { name: "A" } },
 *  { fqn: "$default.foo.$default",     creationContext: { name: "A.B" } }
 *  { fqn: "$default.foo.$default.bar", creationContext: { name: "A.B.C" } }
 * ]
 *
 * These four view configs all match the ui-view with the fqn: "$default.foo.$default.bar":
 *
 * - ViewConfig1: { uiViewName: "bar",                       uiViewContextAnchor: "A.B.C" }
 * - ViewConfig2: { uiViewName: "$default.bar",              uiViewContextAnchor: "A.B" }
 * - ViewConfig3: { uiViewName: "foo.$default.bar",          uiViewContextAnchor: "A" }
 * - ViewConfig4: { uiViewName: "$default.foo.$default.bar", uiViewContextAnchor: "" }
 *
 * Using ViewConfig3 as an example, it matches the ui-view with fqn "$default.foo.$default.bar" because:
 * - The ViewConfig's segmented target name is: [ "foo", "$default", "bar" ]
 * - There exists a parent ui-view (which has fqn: "$default.foo") where:
 *    - the parent ui-view's name "foo" matches the first segment "foo" of the ViewConfig's target name
 *    - the parent ui-view's context "A" matches the ViewConfig's anchor context "A"
 * - And the remaining segments [ "$default", "bar" ].join("."_ of the ViewConfig's target name match
 *   the tail of the ui-view's fqn "default.bar"
 *
 * @internalapi
 */
ViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {
    // Don't supply an ng1 ui-view with an ng2 ViewConfig, etc
    if (uiView.$type !== viewConfig.viewDecl.$type)
        return false;
    // Split names apart from both viewConfig and uiView into segments
    var vc = viewConfig.viewDecl;
    var vcSegments = vc.$uiViewName.split(".");
    var uivSegments = uiView.fqn.split(".");
    // Check if the tails of the segment arrays match. ex, these arrays' tails match:
    // vc: ["foo", "bar"], uiv fqn: ["$default", "foo", "bar"]
    if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))
        return false;
    // Now check if the fqn ending at the first segment of the viewConfig matches the context:
    // ["$default", "foo"].join(".") == "$default.foo", does the ui-view $default.foo context match?
    var negOffset = (1 - vcSegments.length) || undefined;
    var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(".");
    var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;
    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);
}; };
exports.ViewService = ViewService;
//# sourceMappingURL=view.js.map

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module ng1 */ /** for typedoc */
var core_1 = __webpack_require__(4);
/**
 * The Angular 1 `StateProvider`
 *
 * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely
 * on state.
 *
 * A state corresponds to a "place" in the application in terms of the overall UI and
 * navigation. A state describes (via the controller / template / view properties) what
 * the UI looks like and does at that place.
 *
 * States often have things in common, and the primary way of factoring out these
 * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
 * nested states.
 *
 * The `$stateProvider` provides interfaces to declare these states for your app.
 */
var StateProvider = (function () {
    function StateProvider(stateRegistry, stateService) {
        this.stateRegistry = stateRegistry;
        this.stateService = stateService;
        core_1.createProxyFunctions(core_1.val(StateProvider.prototype), this, core_1.val(this));
    }
    /**
     * Decorates states when they are registered
     *
     * Allows you to extend (carefully) or override (at your own peril) the
     * `stateBuilder` object used internally by [[StateRegistry]].
     * This can be used to add custom functionality to ui-router,
     * for example inferring templateUrl based on the state name.
     *
     * When passing only a name, it returns the current (original or decorated) builder
     * function that matches `name`.
     *
     * The builder functions that can be decorated are listed below. Though not all
     * necessarily have a good use case for decoration, that is up to you to decide.
     *
     * In addition, users can attach custom decorators, which will generate new
     * properties within the state's internal definition. There is currently no clear
     * use-case for this beyond accessing internal states (i.e. $state.$current),
     * however, expect this to become increasingly relevant as we introduce additional
     * meta-programming features.
     *
     * **Warning**: Decorators should not be interdependent because the order of
     * execution of the builder functions in non-deterministic. Builder functions
     * should only be dependent on the state definition object and super function.
     *
     *
     * Existing builder functions and current return values:
     *
     * - **parent** `{object}` - returns the parent state object.
     * - **data** `{object}` - returns state data, including any inherited data that is not
     *   overridden by own values (if any).
     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
     *   or `null`.
     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is
     *   navigable).
     * - **params** `{object}` - returns an array of state params that are ensured to
     *   be a super-set of parent's params.
     * - **views** `{object}` - returns a views object where each key is an absolute view
     *   name (i.e. "viewName@stateName") and each value is the config object
     *   (template, controller) for the view. Even when you don't use the views object
     *   explicitly on a state config, one is still created for you internally.
     *   So by decorating this builder function you have access to decorating template
     *   and controller properties.
     * - **ownParams** `{object}` - returns an array of params that belong to the state,
     *   not including any params defined by ancestor states.
     * - **path** `{string}` - returns the full path from the root down to this state.
     *   Needed for state activation.
     * - **includes** `{object}` - returns an object that includes every state that
     *   would pass a `$state.includes()` test.
     *
     * #### Example:
     * Override the internal 'views' builder with a function that takes the state
     * definition, and a reference to the internal function being overridden:
     * ```js
     * $stateProvider.decorator('views', function (state, parent) {
     *   let result = {},
     *       views = parent(state);
     *
     *   angular.forEach(views, function (config, name) {
     *     let autoName = (state.name + '.' + name).replace('.', '/');
     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
     *     result[name] = config;
     *   });
     *   return result;
     * });
     *
     * $stateProvider.state('home', {
     *   views: {
     *     'contact.list': { controller: 'ListController' },
     *     'contact.item': { controller: 'ItemController' }
     *   }
     * });
     * ```
     *
     *
     * ```js
     * // Auto-populates list and item views with /partials/home/contact/list.html,
     * // and /partials/home/contact/item.html, respectively.
     * $state.go('home');
     * ```
     *
     * @param {string} name The name of the builder function to decorate.
     * @param {object} func A function that is responsible for decorating the original
     * builder function. The function receives two parameters:
     *
     *   - `{object}` - state - The state config object.
     *   - `{object}` - super - The original builder function.
     *
     * @return {object} $stateProvider - $stateProvider instance
     */
    StateProvider.prototype.decorator = function (name, func) {
        return this.stateRegistry.decorator(name, func) || this;
    };
    StateProvider.prototype.state = function (name, definition) {
        if (core_1.isObject(name)) {
            definition = name;
        }
        else {
            definition.name = name;
        }
        this.stateRegistry.register(definition);
        return this;
    };
    /**
     * Registers an invalid state handler
     *
     * This is a passthrough to [[StateService.onInvalid]] for ng1.
     */
    StateProvider.prototype.onInvalid = function (callback) {
        return this.stateService.onInvalid(callback);
    };
    return StateProvider;
}());
exports.StateProvider = StateProvider;
//# sourceMappingURL=stateProvider.js.map

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module url */ /** */
var core_1 = __webpack_require__(4);
var core_2 = __webpack_require__(4);
/**
 * Manages rules for client-side URL
 *
 * ### Deprecation warning:
 * This class is now considered to be an internal API
 * Use the [[UrlService]] instead.
 * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].
 *
 * This class manages the router rules for what to do when the URL changes.
 *
 * This provider remains for backwards compatibility.
 *
 * @deprecated
 */
var UrlRouterProvider = (function () {
    /** @hidden */
    function UrlRouterProvider(router) {
        this._router = router;
        this._urlRouter = router.urlRouter;
    }
    /** @hidden */
    UrlRouterProvider.prototype.$get = function () {
        var urlRouter = this._urlRouter;
        urlRouter.update(true);
        if (!urlRouter.interceptDeferred)
            urlRouter.listen();
        return urlRouter;
    };
    /**
     * Registers a url handler function.
     *
     * Registers a low level url handler (a `rule`).
     * A rule detects specific URL patterns and returns a redirect, or performs some action.
     *
     * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.
     *
     * #### Example:
     * ```js
     * var app = angular.module('app', ['ui.router.router']);
     *
     * app.config(function ($urlRouterProvider) {
     *   // Here's an example of how you might allow case insensitive urls
     *   $urlRouterProvider.rule(function ($injector, $location) {
     *     var path = $location.path(),
     *         normalized = path.toLowerCase();
     *
     *     if (path !== normalized) {
     *       return normalized;
     *     }
     *   });
     * });
     * ```
     *
     * @param ruleFn
     * Handler function that takes `$injector` and `$location` services as arguments.
     * You can use them to detect a url and return a different url as a string.
     *
     * @return [[UrlRouterProvider]] (`this`)
     */
    UrlRouterProvider.prototype.rule = function (ruleFn) {
        var _this = this;
        if (!core_2.isFunction(ruleFn))
            throw new Error("'rule' must be a function");
        var match = function () {
            return ruleFn(core_2.services.$injector, _this._router.locationService);
        };
        var rule = new core_1.BaseUrlRule(match, core_2.identity);
        this._urlRouter.rule(rule);
        return this;
    };
    ;
    /**
     * Defines the path or behavior to use when no url can be matched.
     *
     * #### Example:
     * ```js
     * var app = angular.module('app', ['ui.router.router']);
     *
     * app.config(function ($urlRouterProvider) {
     *   // if the path doesn't match any of the urls you configured
     *   // otherwise will take care of routing the user to the
     *   // specified url
     *   $urlRouterProvider.otherwise('/index');
     *
     *   // Example of using function rule as param
     *   $urlRouterProvider.otherwise(function ($injector, $location) {
     *     return '/a/valid/url';
     *   });
     * });
     * ```
     *
     * @param rule
     * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.
     * The function version is passed two params: `$injector` and `$location` services, and should return a url string.
     *
     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
     */
    UrlRouterProvider.prototype.otherwise = function (rule) {
        var _this = this;
        var urlRouter = this._urlRouter;
        if (core_2.isString(rule)) {
            urlRouter.otherwise(rule);
        }
        else if (core_2.isFunction(rule)) {
            urlRouter.otherwise(function () { return rule(core_2.services.$injector, _this._router.locationService); });
        }
        else {
            throw new Error("'rule' must be a string or function");
        }
        return this;
    };
    ;
    /**
     * Registers a handler for a given url matching.
     *
     * If the handler is a string, it is
     * treated as a redirect, and is interpolated according to the syntax of match
     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).
     *
     * If the handler is a function, it is injectable.
     * It gets invoked if `$location` matches.
     * You have the option of inject the match object as `$match`.
     *
     * The handler can return
     *
     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
     *   will continue trying to find another one that matches.
     * - **string** which is treated as a redirect and passed to `$location.url()`
     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
     *
     * #### Example:
     * ```js
     * var app = angular.module('app', ['ui.router.router']);
     *
     * app.config(function ($urlRouterProvider) {
     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
     *     if ($state.$current.navigable !== state ||
     *         !equalForKeys($match, $stateParams) {
     *      $state.transitionTo(state, $match, false);
     *     }
     *   });
     * });
     * ```
     *
     * @param what A pattern string to match, compiled as a [[UrlMatcher]].
     * @param handler The path (or function that returns a path) that you want to redirect your user to.
     * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]
     *
     * Note: the handler may also invoke arbitrary code, such as `$state.go()`
     */
    UrlRouterProvider.prototype.when = function (what, handler) {
        if (core_2.isArray(handler) || core_2.isFunction(handler)) {
            handler = UrlRouterProvider.injectableHandler(this._router, handler);
        }
        this._urlRouter.when(what, handler);
        return this;
    };
    ;
    UrlRouterProvider.injectableHandler = function (router, handler) {
        return function (match) {
            return core_2.services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params });
        };
    };
    /**
     * Disables monitoring of the URL.
     *
     * Call this method before UI-Router has bootstrapped.
     * It will stop UI-Router from performing the initial url sync.
     *
     * This can be useful to perform some asynchronous initialization before the router starts.
     * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.
     *
     * #### Example:
     * ```js
     * var app = angular.module('app', ['ui.router']);
     *
     * app.config(function ($urlRouterProvider) {
     *   // Prevent $urlRouter from automatically intercepting URL changes;
     *   $urlRouterProvider.deferIntercept();
     * })
     *
     * app.run(function (MyService, $urlRouter, $http) {
     *   $http.get("/stuff").then(function(resp) {
     *     MyService.doStuff(resp.data);
     *     $urlRouter.listen();
     *     $urlRouter.sync();
     *   });
     * });
     * ```
     *
     * @param defer Indicates whether to defer location change interception.
     *        Passing no parameter is equivalent to `true`.
     */
    UrlRouterProvider.prototype.deferIntercept = function (defer) {
        this._urlRouter.deferIntercept(defer);
    };
    ;
    return UrlRouterProvider;
}());
exports.UrlRouterProvider = UrlRouterProvider;
//# sourceMappingURL=urlRouterProvider.js.map

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = headerCtrl;
function headerCtrl(uibDateParser) {
    'ngInject';

    var $ctrl = this;

    $ctrl.updateTitle = function () {
        $ctrl.name = $ctrl.title;
    };
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = aboutCtrl;
function aboutCtrl($state) {
    'ngInject';

    var $ctrl = this;

    $ctrl.test = $state;

    console.log('abbout test');
}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = contactCtrl;
function contactCtrl() {
    'ngInject';

    var $ctrl = this;
}

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = homeCtrl;
function homeCtrl() {
    'ngInject';
}

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = navigationCtrl;
function navigationCtrl($state, states, $rootScope) {
    'ngInject';

    var $ctrl = this;

    $ctrl.name = "Nav Section";

    $ctrl.state = $state;
    $ctrl.navItems = states.mainNav;

    $rootScope.$on('$stateChangeStart', function () {
        var stateTemp = $state;
        var statetestplz = 'test';
        console.log('test');
    });
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(87);

module.exports = 'ui.bootstrap';


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Main entry point for angular 1.x build
 * @module ng1
 */ /** */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var core = __webpack_require__(4);
exports.core = core;
__export(__webpack_require__(4));
__export(__webpack_require__(29));
__export(__webpack_require__(30));
__export(__webpack_require__(56));
__export(__webpack_require__(57));
__webpack_require__(90);
__webpack_require__(88);
__webpack_require__(92);
__webpack_require__(89);
__webpack_require__(95);
exports.default = "ui.router";
//# sourceMappingURL=index.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _header = __webpack_require__(99);

var _header2 = _interopRequireDefault(_header);

var _navigation = __webpack_require__(107);

var _navigation2 = _interopRequireDefault(_navigation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = angular.module('layout', [_header2.default, _navigation2.default]).name;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _states = __webpack_require__(109);

var _states2 = _interopRequireDefault(_states);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = angular.module('widget.constants', [_states2.default]).name;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module hooks */ /** */
var transition_1 = __webpack_require__(20);
var router_1 = __webpack_require__(36);
function addCoreResolvables(trans) {
    trans.addResolvable({ token: router_1.UIRouter, deps: [], resolveFn: function () { return trans.router; }, data: trans.router }, "");
    trans.addResolvable({ token: transition_1.Transition, deps: [], resolveFn: function () { return trans; }, data: trans }, "");
    trans.addResolvable({ token: '$transition$', deps: [], resolveFn: function () { return trans; }, data: trans }, "");
    trans.addResolvable({ token: '$stateParams', deps: [], resolveFn: function () { return trans.params(); }, data: trans.params() }, "");
    trans.entering().forEach(function (state) {
        trans.addResolvable({ token: '$state$', deps: [], resolveFn: function () { return state; }, data: state }, state);
    });
}
exports.registerAddCoreResolvables = function (transitionService) {
    return transitionService.onCreate({}, addCoreResolvables);
};
//# sourceMappingURL=coreResolvables.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module hooks */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
var trace_1 = __webpack_require__(6);
var rejectFactory_1 = __webpack_require__(13);
/**
 * A [[TransitionHookFn]] that skips a transition if it should be ignored
 *
 * This hook is invoked at the end of the onBefore phase.
 *
 * If the transition should be ignored (because no parameter or states changed)
 * then the transition is ignored and not processed.
 */
function ignoredHook(trans) {
    var ignoredReason = trans._ignoredReason();
    if (!ignoredReason)
        return;
    trace_1.trace.traceTransitionIgnored(trans);
    var pending = trans.router.globals.transition;
    // The user clicked a link going back to the *current state* ('A')
    // However, there is also a pending transition in flight (to 'B')
    // Abort the transition to 'B' because the user now wants to be back at 'A'.
    if (ignoredReason === 'SameAsCurrent' && pending) {
        pending.abort();
    }
    return rejectFactory_1.Rejection.ignored().toPromise();
}
exports.registerIgnoredTransitionHook = function (transitionService) {
    return transitionService.onBefore({}, ignoredHook, { priority: -9999 });
};
//# sourceMappingURL=ignoredTransition.js.map

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module hooks */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A [[TransitionHookFn]] that rejects the Transition if it is invalid
 *
 * This hook is invoked at the end of the onBefore phase.
 * If the transition is invalid (for example, param values do not validate)
 * then the transition is rejected.
 */
function invalidTransitionHook(trans) {
    if (!trans.valid()) {
        throw new Error(trans.error());
    }
}
exports.registerInvalidTransitionHook = function (transitionService) {
    return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });
};
//# sourceMappingURL=invalidTransition.js.map

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A factory which creates an onEnter, onExit or onRetain transition hook function
 *
 * The returned function invokes the (for instance) state.onEnter hook when the
 * state is being entered.
 *
 * @hidden
 */
function makeEnterExitRetainHook(hookName) {
    return function (transition, state) {
        var _state = state.$$state();
        var hookFn = _state[hookName];
        return hookFn(transition, state);
    };
}
/**
 * The [[TransitionStateHookFn]] for onExit
 *
 * When the state is being exited, the state's .onExit function is invoked.
 *
 * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`
 *
 * See: [[IHookRegistry.onExit]]
 */
var onExitHook = makeEnterExitRetainHook('onExit');
exports.registerOnExitHook = function (transitionService) {
    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);
};
/**
 * The [[TransitionStateHookFn]] for onRetain
 *
 * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.
 *
 * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`
 *
 * See: [[IHookRegistry.onRetain]]
 */
var onRetainHook = makeEnterExitRetainHook('onRetain');
exports.registerOnRetainHook = function (transitionService) {
    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);
};
/**
 * The [[TransitionStateHookFn]] for onEnter
 *
 * When the state is being entered, the state's .onEnter function is invoked.
 *
 * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`
 *
 * See: [[IHookRegistry.onEnter]]
 */
var onEnterHook = makeEnterExitRetainHook('onEnter');
exports.registerOnEnterHook = function (transitionService) {
    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);
};
//# sourceMappingURL=onEnterExitRetain.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module hooks */ /** */
var predicates_1 = __webpack_require__(1);
var coreservices_1 = __webpack_require__(3);
var targetState_1 = __webpack_require__(7);
/**
 * A [[TransitionHookFn]] that redirects to a different state or params
 *
 * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`
 *
 * See [[StateDeclaration.redirectTo]]
 */
var redirectToHook = function (trans) {
    var redirect = trans.to().redirectTo;
    if (!redirect)
        return;
    var $state = trans.router.stateService;
    function handleResult(result) {
        if (!result)
            return;
        if (result instanceof targetState_1.TargetState)
            return result;
        if (predicates_1.isString(result))
            return $state.target(result, trans.params(), trans.options());
        if (result['state'] || result['params'])
            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());
    }
    if (predicates_1.isFunction(redirect)) {
        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);
    }
    return handleResult(redirect);
};
exports.registerRedirectToHook = function (transitionService) {
    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);
};
//# sourceMappingURL=redirectTo.js.map

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module hooks */
/** for typedoc */
var common_1 = __webpack_require__(0);
var resolveContext_1 = __webpack_require__(19);
var hof_1 = __webpack_require__(2);
/**
 * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path
 *
 * Registered using `transitionService.onStart({}, eagerResolvePath);`
 *
 * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.
 *
 * See [[StateDeclaration.resolve]]
 */
var eagerResolvePath = function (trans) {
    return new resolveContext_1.ResolveContext(trans.treeChanges().to)
        .resolvePath("EAGER", trans)
        .then(common_1.noop);
};
exports.registerEagerResolvePath = function (transitionService) {
    return transitionService.onStart({}, eagerResolvePath, { priority: 1000 });
};
/**
 * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path
 *
 * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState);`
 *
 * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.
 *
 * See [[StateDeclaration.resolve]]
 */
var lazyResolveState = function (trans, state) {
    return new resolveContext_1.ResolveContext(trans.treeChanges().to)
        .subContext(state.$$state())
        .resolvePath("LAZY", trans)
        .then(common_1.noop);
};
exports.registerLazyResolveState = function (transitionService) {
    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: 1000 });
};
//# sourceMappingURL=resolve.js.map

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(0);
/**
 * A [[TransitionHookFn]] which updates global UI-Router state
 *
 * Registered using `transitionService.onBefore({}, updateGlobalState);`
 *
 * Before a [[Transition]] starts, updates the global value of "the current transition" ([[Globals.transition]]).
 * After a successful [[Transition]], updates the global values of "the current state"
 * ([[Globals.current]] and [[Globals.$current]]) and "the current param values" ([[Globals.params]]).
 *
 * See also the deprecated properties:
 * [[StateService.transition]], [[StateService.current]], [[StateService.params]]
 */
var updateGlobalState = function (trans) {
    var globals = trans.router.globals;
    var transitionSuccessful = function () {
        globals.successfulTransitions.enqueue(trans);
        globals.$current = trans.$to();
        globals.current = globals.$current.self;
        common_1.copy(trans.params(), globals.params);
    };
    var clearCurrentTransition = function () {
        // Do not clear globals.transition if a different transition has started in the meantime
        if (globals.transition === trans)
            globals.transition = null;
    };
    trans.onSuccess({}, transitionSuccessful, { priority: 10000 });
    trans.promise.then(clearCurrentTransition, clearCurrentTransition);
};
exports.registerUpdateGlobalState = function (transitionService) {
    return transitionService.onCreate({}, updateGlobalState);
};
//# sourceMappingURL=updateGlobals.js.map

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A [[TransitionHookFn]] which updates the URL after a successful transition
 *
 * Registered using `transitionService.onSuccess({}, updateUrl);`
 */
var updateUrl = function (transition) {
    var options = transition.options();
    var $state = transition.router.stateService;
    var $urlRouter = transition.router.urlRouter;
    // Dont update the url in these situations:
    // The transition was triggered by a URL sync (options.source === 'url')
    // The user doesn't want the url to update (options.location === false)
    // The destination state, and all parents have no navigable url
    if (options.source !== 'url' && options.location && $state.$current.navigable) {
        var urlOptions = { replace: options.location === 'replace' };
        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);
    }
    $urlRouter.update(true);
};
exports.registerUpdateUrl = function (transitionService) {
    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });
};
//# sourceMappingURL=url.js.map

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module hooks */ /** for typedoc */
var common_1 = __webpack_require__(0);
var coreservices_1 = __webpack_require__(3);
/**
 * A [[TransitionHookFn]] which waits for the views to load
 *
 * Registered using `transitionService.onStart({}, loadEnteringViews);`
 *
 * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.
 * In angular 1, this includes loading the templates.
 */
var loadEnteringViews = function (transition) {
    var $q = coreservices_1.services.$q;
    var enteringViews = transition.views("entering");
    if (!enteringViews.length)
        return;
    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);
};
exports.registerLoadEnteringViews = function (transitionService) {
    return transitionService.onFinish({}, loadEnteringViews);
};
/**
 * A [[TransitionHookFn]] which activates the new views when a transition is successful.
 *
 * Registered using `transitionService.onSuccess({}, activateViews);`
 *
 * After a transition is complete, this hook deactivates the old views from the previous state,
 * and activates the new views from the destination state.
 *
 * See [[ViewService]]
 */
var activateViews = function (transition) {
    var enteringViews = transition.views("entering");
    var exitingViews = transition.views("exiting");
    if (!enteringViews.length && !exitingViews.length)
        return;
    var $view = transition.router.viewService;
    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });
    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });
    $view.sync();
};
exports.registerActivateViews = function (transitionService) {
    return transitionService.onSuccess({}, activateViews);
};
//# sourceMappingURL=views.js.map

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * # Core classes and interfaces
 *
 * The classes and interfaces that are core to ui-router and do not belong
 * to a more specific subsystem (such as resolve).
 *
 * @coreapi
 * @preferred
 * @module core
 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
/** @internalapi */
var UIRouterPluginBase = (function () {
    function UIRouterPluginBase() {
    }
    UIRouterPluginBase.prototype.dispose = function (router) { };
    return UIRouterPluginBase;
}());
exports.UIRouterPluginBase = UIRouterPluginBase;
//# sourceMappingURL=interface.js.map

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(8));
__export(__webpack_require__(33));
__export(__webpack_require__(34));
__export(__webpack_require__(24));
//# sourceMappingURL=index.js.map

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/** @module path */ /** for typedoc */
__export(__webpack_require__(25));
__export(__webpack_require__(18));
//# sourceMappingURL=index.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/** @module resolve */ /** for typedoc */
__export(__webpack_require__(35));
__export(__webpack_require__(12));
__export(__webpack_require__(19));
//# sourceMappingURL=index.js.map

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(37));
__export(__webpack_require__(26));
__export(__webpack_require__(38));
__export(__webpack_require__(39));
__export(__webpack_require__(40));
__export(__webpack_require__(41));
__export(__webpack_require__(7));
//# sourceMappingURL=index.js.map

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * # Transition subsystem
 *
 * This module contains APIs related to a Transition.
 *
 * See:
 * - [[TransitionService]]
 * - [[Transition]]
 * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]
 *
 * @coreapi
 * @preferred
 * @module transition
 */ /** for typedoc */
__export(__webpack_require__(9));
__export(__webpack_require__(42));
__export(__webpack_require__(27));
__export(__webpack_require__(13));
__export(__webpack_require__(20));
__export(__webpack_require__(14));
__export(__webpack_require__(43));
__export(__webpack_require__(28));
//# sourceMappingURL=index.js.map

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(21));
__export(__webpack_require__(44));
__export(__webpack_require__(45));
__export(__webpack_require__(46));
__export(__webpack_require__(47));
//# sourceMappingURL=index.js.map

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
__export(__webpack_require__(84));
//# sourceMappingURL=vanilla.js.map

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(54));
__export(__webpack_require__(50));
__export(__webpack_require__(22));
__export(__webpack_require__(49));
__export(__webpack_require__(52));
__export(__webpack_require__(53));
__export(__webpack_require__(51));
__export(__webpack_require__(48));
__export(__webpack_require__(15));
__export(__webpack_require__(85));
//# sourceMappingURL=index.js.map

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internalapi
 * @module vanilla
 */
/** */
var browserLocationConfig_1 = __webpack_require__(48);
var hashLocationService_1 = __webpack_require__(49);
var utils_1 = __webpack_require__(15);
var pushStateLocationService_1 = __webpack_require__(53);
var memoryLocationService_1 = __webpack_require__(52);
var memoryLocationConfig_1 = __webpack_require__(51);
var injector_1 = __webpack_require__(50);
var q_1 = __webpack_require__(54);
var coreservices_1 = __webpack_require__(3);
function servicesPlugin(router) {
    coreservices_1.services.$injector = injector_1.$injector;
    coreservices_1.services.$q = q_1.$q;
    return { name: "vanilla.services", $q: q_1.$q, $injector: injector_1.$injector, dispose: function () { return null; } };
}
exports.servicesPlugin = servicesPlugin;
/** A `UIRouterPlugin` uses the browser hash to get/set the current location */
exports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);
/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */
exports.pushStateLocationPlugin = utils_1.locationPluginFactory("vanilla.pushStateLocation", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);
/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */
exports.memoryLocationPlugin = utils_1.locationPluginFactory("vanilla.memoryLocation", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);
//# sourceMappingURL=plugins.js.map

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(55));
//# sourceMappingURL=index.js.map

/***/ }),
/* 87 */
/***/ (function(module, exports) {

/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 2.5.0 - 2017-01-28
 * License: MIT
 */angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse","ui.bootstrap.tabindex","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.isClass","ui.bootstrap.datepicker","ui.bootstrap.position","ui.bootstrap.datepickerPopup","ui.bootstrap.debounce","ui.bootstrap.multiMap","ui.bootstrap.dropdown","ui.bootstrap.stackedMap","ui.bootstrap.modal","ui.bootstrap.paging","ui.bootstrap.pager","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html","uib/template/accordion/accordion.html","uib/template/alert/alert.html","uib/template/carousel/carousel.html","uib/template/carousel/slide.html","uib/template/datepicker/datepicker.html","uib/template/datepicker/day.html","uib/template/datepicker/month.html","uib/template/datepicker/year.html","uib/template/datepickerPopup/popup.html","uib/template/modal/window.html","uib/template/pager/pager.html","uib/template/pagination/pagination.html","uib/template/tooltip/tooltip-html-popup.html","uib/template/tooltip/tooltip-popup.html","uib/template/tooltip/tooltip-template-popup.html","uib/template/popover/popover-html.html","uib/template/popover/popover-template.html","uib/template/popover/popover.html","uib/template/progressbar/bar.html","uib/template/progressbar/progress.html","uib/template/progressbar/progressbar.html","uib/template/rating/rating.html","uib/template/tabs/tab.html","uib/template/tabs/tabset.html","uib/template/timepicker/timepicker.html","uib/template/typeahead/typeahead-match.html","uib/template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.collapse', [])

  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {
    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
    return {
      link: function(scope, element, attrs) {
        var expandingExpr = $parse(attrs.expanding),
          expandedExpr = $parse(attrs.expanded),
          collapsingExpr = $parse(attrs.collapsing),
          collapsedExpr = $parse(attrs.collapsed),
          horizontal = false,
          css = {},
          cssTo = {};

        init();

        function init() {
          horizontal = !!('horizontal' in attrs);
          if (horizontal) {
            css = {
              width: ''
            };
            cssTo = {width: '0'};
          } else {
            css = {
              height: ''
            };
            cssTo = {height: '0'};
          }
          if (!scope.$eval(attrs.uibCollapse)) {
            element.addClass('in')
              .addClass('collapse')
              .attr('aria-expanded', true)
              .attr('aria-hidden', false)
              .css(css);
          }
        }

        function getScrollFromElement(element) {
          if (horizontal) {
            return {width: element.scrollWidth + 'px'};
          }
          return {height: element.scrollHeight + 'px'};
        }

        function expand() {
          if (element.hasClass('collapse') && element.hasClass('in')) {
            return;
          }

          $q.resolve(expandingExpr(scope))
            .then(function() {
              element.removeClass('collapse')
                .addClass('collapsing')
                .attr('aria-expanded', true)
                .attr('aria-hidden', false);

              if ($animateCss) {
                $animateCss(element, {
                  addClass: 'in',
                  easing: 'ease',
                  css: {
                    overflow: 'hidden'
                  },
                  to: getScrollFromElement(element[0])
                }).start()['finally'](expandDone);
              } else {
                $animate.addClass(element, 'in', {
                  css: {
                    overflow: 'hidden'
                  },
                  to: getScrollFromElement(element[0])
                }).then(expandDone);
              }
            }, angular.noop);
        }

        function expandDone() {
          element.removeClass('collapsing')
            .addClass('collapse')
            .css(css);
          expandedExpr(scope);
        }

        function collapse() {
          if (!element.hasClass('collapse') && !element.hasClass('in')) {
            return collapseDone();
          }

          $q.resolve(collapsingExpr(scope))
            .then(function() {
              element
              // IMPORTANT: The width must be set before adding "collapsing" class.
              // Otherwise, the browser attempts to animate from width 0 (in
              // collapsing class) to the given width here.
                .css(getScrollFromElement(element[0]))
                // initially all panel collapse have the collapse class, this removal
                // prevents the animation from jumping to collapsed state
                .removeClass('collapse')
                .addClass('collapsing')
                .attr('aria-expanded', false)
                .attr('aria-hidden', true);

              if ($animateCss) {
                $animateCss(element, {
                  removeClass: 'in',
                  to: cssTo
                }).start()['finally'](collapseDone);
              } else {
                $animate.removeClass(element, 'in', {
                  to: cssTo
                }).then(collapseDone);
              }
            }, angular.noop);
        }

        function collapseDone() {
          element.css(cssTo); // Required so that collapse works when animation is disabled
          element.removeClass('collapsing')
            .addClass('collapse');
          collapsedExpr(scope);
        }

        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);

angular.module('ui.bootstrap.tabindex', [])

.directive('uibTabindexToggle', function() {
  return {
    restrict: 'A',
    link: function(scope, elem, attrs) {
      attrs.$observe('disabled', function(disabled) {
        attrs.$set('tabindex', disabled ? -1 : null);
      });
    }
  };
});

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex'])

.constant('uibAccordionConfig', {
  closeOthers: true
})

.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ?
      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if (closeOthers) {
      angular.forEach(this.groups, function(group) {
        if (group !== openGroup) {
          group.isOpen = false;
        }
      });
    }
  };

  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on('$destroy', function(event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if (index !== -1) {
      this.groups.splice(index, 1);
    }
  };
}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('uibAccordion', function() {
  return {
    controller: 'UibAccordionController',
    controllerAs: 'accordion',
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/accordion/accordion.html';
    }
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('uibAccordionGroup', function() {
  return {
    require: '^uibAccordion',         // We need this directive to be inside an accordion
    transclude: true,              // It transcludes the contents of the directive into the template
    restrict: 'A',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
    },
    scope: {
      heading: '@',               // Interpolate the heading attribute onto this scope
      panelClass: '@?',           // Ditto with panelClass
      isOpen: '=?',
      isDisabled: '=?'
    },
    controller: function() {
      this.setHeading = function(element) {
        this.heading = element;
      };
    },
    link: function(scope, element, attrs, accordionCtrl) {
      element.addClass('panel');
      accordionCtrl.addGroup(scope);

      scope.openClass = attrs.openClass || 'panel-open';
      scope.panelClass = attrs.panelClass || 'panel-default';
      scope.$watch('isOpen', function(value) {
        element.toggleClass(scope.openClass, !!value);
        if (value) {
          accordionCtrl.closeOthers(scope);
        }
      });

      scope.toggleOpen = function($event) {
        if (!scope.isDisabled) {
          if (!$event || $event.which === 32) {
            scope.isOpen = !scope.isOpen;
          }
        }
      };

      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      scope.headingId = id + '-tab';
      scope.panelId = id + '-panel';
    }
  };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
.directive('uibAccordionHeading', function() {
  return {
    transclude: true,   // Grab the contents to be used as the heading
    template: '',       // In effect remove this element!
    replace: true,
    require: '^uibAccordionGroup',
    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
      // Pass the heading to the accordion-group controller
      // so that it can be transcluded into the right place in the template
      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
.directive('uibAccordionTransclude', function() {
  return {
    require: '^uibAccordionGroup',
    link: function(scope, element, attrs, controller) {
      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {
        if (heading) {
          var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
          elem.html('');
          elem.append(heading);
        }
      });
    }
  };

  function getHeaderSelectors() {
      return 'uib-accordion-header,' +
          'data-uib-accordion-header,' +
          'x-uib-accordion-header,' +
          'uib\\:accordion-header,' +
          '[uib-accordion-header],' +
          '[data-uib-accordion-header],' +
          '[x-uib-accordion-header]';
  }
});

angular.module('ui.bootstrap.alert', [])

.controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function($scope, $element, $attrs, $interpolate, $timeout) {
  $scope.closeable = !!$attrs.close;
  $element.addClass('alert');
  $attrs.$set('role', 'alert');
  if ($scope.closeable) {
    $element.addClass('alert-dismissible');
  }

  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;

  if (dismissOnTimeout) {
    $timeout(function() {
      $scope.close();
    }, parseInt(dismissOnTimeout, 10));
  }
}])

.directive('uibAlert', function() {
  return {
    controller: 'UibAlertController',
    controllerAs: 'alert',
    restrict: 'A',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/alert/alert.html';
    },
    transclude: true,
    scope: {
      close: '&'
    }
  };
});

angular.module('ui.bootstrap.buttons', [])

.constant('uibButtonConfig', {
  activeClass: 'active',
  toggleEvent: 'click'
})

.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
  this.activeClass = buttonConfig.activeClass || 'active';
  this.toggleEvent = buttonConfig.toggleEvent || 'click';
}])

.directive('uibBtnRadio', ['$parse', function($parse) {
  return {
    require: ['uibBtnRadio', 'ngModel'],
    controller: 'UibButtonsController',
    controllerAs: 'buttons',
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      var uncheckableExpr = $parse(attrs.uibUncheckable);

      element.find('input').css({display: 'none'});

      //model -> UI
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
      };

      //ui->model
      element.on(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        var isActive = element.hasClass(buttonsCtrl.activeClass);

        if (!isActive || angular.isDefined(attrs.uncheckable)) {
          scope.$apply(function() {
            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
            ngModelCtrl.$render();
          });
        }
      });

      if (attrs.uibUncheckable) {
        scope.$watch(uncheckableExpr, function(uncheckable) {
          attrs.$set('uncheckable', uncheckable ? '' : undefined);
        });
      }
    }
  };
}])

.directive('uibBtnCheckbox', function() {
  return {
    require: ['uibBtnCheckbox', 'ngModel'],
    controller: 'UibButtonsController',
    controllerAs: 'button',
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      element.find('input').css({display: 'none'});

      function getTrueValue() {
        return getCheckboxValue(attrs.btnCheckboxTrue, true);
      }

      function getFalseValue() {
        return getCheckboxValue(attrs.btnCheckboxFalse, false);
      }

      function getCheckboxValue(attribute, defaultValue) {
        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
      }

      //model -> UI
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui->model
      element.on(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        scope.$apply(function() {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
});

angular.module('ui.bootstrap.carousel', [])

.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {
  var self = this,
    slides = self.slides = $scope.slides = [],
    SLIDE_DIRECTION = 'uib-slideDirection',
    currentIndex = $scope.active,
    currentInterval, isPlaying;

  var destroyed = false;
  $element.addClass('carousel');

  self.addSlide = function(slide, element) {
    slides.push({
      slide: slide,
      element: element
    });
    slides.sort(function(a, b) {
      return +a.slide.index - +b.slide.index;
    });
    //if this is the first slide or the slide is set to active, select it
    if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
      if ($scope.$currentTransition) {
        $scope.$currentTransition = null;
      }

      currentIndex = slide.index;
      $scope.active = slide.index;
      setActive(currentIndex);
      self.select(slides[findSlideIndex(slide)]);
      if (slides.length === 1) {
        $scope.play();
      }
    }
  };

  self.getCurrentIndex = function() {
    for (var i = 0; i < slides.length; i++) {
      if (slides[i].slide.index === currentIndex) {
        return i;
      }
    }
  };

  self.next = $scope.next = function() {
    var newIndex = (self.getCurrentIndex() + 1) % slides.length;

    if (newIndex === 0 && $scope.noWrap()) {
      $scope.pause();
      return;
    }

    return self.select(slides[newIndex], 'next');
  };

  self.prev = $scope.prev = function() {
    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

    if ($scope.noWrap() && newIndex === slides.length - 1) {
      $scope.pause();
      return;
    }

    return self.select(slides[newIndex], 'prev');
  };

  self.removeSlide = function(slide) {
    var index = findSlideIndex(slide);

    //get the index of the slide inside the carousel
    slides.splice(index, 1);
    if (slides.length > 0 && currentIndex === index) {
      if (index >= slides.length) {
        currentIndex = slides.length - 1;
        $scope.active = currentIndex;
        setActive(currentIndex);
        self.select(slides[slides.length - 1]);
      } else {
        currentIndex = index;
        $scope.active = currentIndex;
        setActive(currentIndex);
        self.select(slides[index]);
      }
    } else if (currentIndex > index) {
      currentIndex--;
      $scope.active = currentIndex;
    }

    //clean the active value when no more slide
    if (slides.length === 0) {
      currentIndex = null;
      $scope.active = null;
    }
  };

  /* direction: "prev" or "next" */
  self.select = $scope.select = function(nextSlide, direction) {
    var nextIndex = findSlideIndex(nextSlide.slide);
    //Decide direction if it's not given
    if (direction === undefined) {
      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
    }
    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (nextSlide.slide.index !== currentIndex &&
      !$scope.$currentTransition) {
      goNext(nextSlide.slide, nextIndex, direction);
    }
  };

  /* Allow outside people to call indexOf on slides array */
  $scope.indexOfSlide = function(slide) {
    return +slide.slide.index;
  };

  $scope.isActive = function(slide) {
    return $scope.active === slide.slide.index;
  };

  $scope.isPrevDisabled = function() {
    return $scope.active === 0 && $scope.noWrap();
  };

  $scope.isNextDisabled = function() {
    return $scope.active === slides.length - 1 && $scope.noWrap();
  };

  $scope.pause = function() {
    if (!$scope.noPause) {
      isPlaying = false;
      resetTimer();
    }
  };

  $scope.play = function() {
    if (!isPlaying) {
      isPlaying = true;
      restartTimer();
    }
  };

  $element.on('mouseenter', $scope.pause);
  $element.on('mouseleave', $scope.play);

  $scope.$on('$destroy', function() {
    destroyed = true;
    resetTimer();
  });

  $scope.$watch('noTransition', function(noTransition) {
    $animate.enabled($element, !noTransition);
  });

  $scope.$watch('interval', restartTimer);

  $scope.$watchCollection('slides', resetTransition);

  $scope.$watch('active', function(index) {
    if (angular.isNumber(index) && currentIndex !== index) {
      for (var i = 0; i < slides.length; i++) {
        if (slides[i].slide.index === index) {
          index = i;
          break;
        }
      }

      var slide = slides[index];
      if (slide) {
        setActive(index);
        self.select(slides[index]);
        currentIndex = index;
      }
    }
  });

  function getSlideByIndex(index) {
    for (var i = 0, l = slides.length; i < l; ++i) {
      if (slides[i].index === index) {
        return slides[i];
      }
    }
  }

  function setActive(index) {
    for (var i = 0; i < slides.length; i++) {
      slides[i].slide.active = i === index;
    }
  }

  function goNext(slide, index, direction) {
    if (destroyed) {
      return;
    }

    angular.extend(slide, {direction: direction});
    angular.extend(slides[currentIndex].slide || {}, {direction: direction});
    if ($animate.enabled($element) && !$scope.$currentTransition &&
      slides[index].element && self.slides.length > 1) {
      slides[index].element.data(SLIDE_DIRECTION, slide.direction);
      var currentIdx = self.getCurrentIndex();

      if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
      }

      $scope.$currentTransition = true;
      $animate.on('addClass', slides[index].element, function(element, phase) {
        if (phase === 'close') {
          $scope.$currentTransition = null;
          $animate.off('addClass', element);
        }
      });
    }

    $scope.active = slide.index;
    currentIndex = slide.index;
    setActive(index);

    //every time you change slides, reset the timer
    restartTimer();
  }

  function findSlideIndex(slide) {
    for (var i = 0; i < slides.length; i++) {
      if (slides[i].slide === slide) {
        return i;
      }
    }
  }

  function resetTimer() {
    if (currentInterval) {
      $interval.cancel(currentInterval);
      currentInterval = null;
    }
  }

  function resetTransition(slides) {
    if (!slides.length) {
      $scope.$currentTransition = null;
    }
  }

  function restartTimer() {
    resetTimer();
    var interval = +$scope.interval;
    if (!isNaN(interval) && interval > 0) {
      currentInterval = $interval(timerFn, interval);
    }
  }

  function timerFn() {
    var interval = +$scope.interval;
    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
      $scope.next();
    } else {
      $scope.pause();
    }
  }
}])

.directive('uibCarousel', function() {
  return {
    transclude: true,
    controller: 'UibCarouselController',
    controllerAs: 'carousel',
    restrict: 'A',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/carousel/carousel.html';
    },
    scope: {
      active: '=',
      interval: '=',
      noTransition: '=',
      noPause: '=',
      noWrap: '&'
    }
  };
})

.directive('uibSlide', ['$animate', function($animate) {
  return {
    require: '^uibCarousel',
    restrict: 'A',
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/carousel/slide.html';
    },
    scope: {
      actual: '=?',
      index: '=?'
    },
    link: function (scope, element, attrs, carouselCtrl) {
      element.addClass('item');
      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on('$destroy', function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch('active', function(active) {
        $animate[active ? 'addClass' : 'removeClass'](element, 'active');
      });
    }
  };
}])

.animation('.item', ['$animateCss',
function($animateCss) {
  var SLIDE_DIRECTION = 'uib-slideDirection';

  function removeClass(element, className, callback) {
    element.removeClass(className);
    if (callback) {
      callback();
    }
  }

  return {
    beforeAddClass: function(element, className, done) {
      if (className === 'active') {
        var stopped = false;
        var direction = element.data(SLIDE_DIRECTION);
        var directionClass = direction === 'next' ? 'left' : 'right';
        var removeClassFn = removeClass.bind(this, element,
          directionClass + ' ' + direction, done);
        element.addClass(direction);

        $animateCss(element, {addClass: directionClass})
          .start()
          .done(removeClassFn);

        return function() {
          stopped = true;
        };
      }
      done();
    },
    beforeRemoveClass: function (element, className, done) {
      if (className === 'active') {
        var stopped = false;
        var direction = element.data(SLIDE_DIRECTION);
        var directionClass = direction === 'next' ? 'left' : 'right';
        var removeClassFn = removeClass.bind(this, element, directionClass, done);

        $animateCss(element, {addClass: directionClass})
          .start()
          .done(removeClassFn);

        return function() {
          stopped = true;
        };
      }
      done();
    }
  };
}]);

angular.module('ui.bootstrap.dateparser', [])

.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', 'filterFilter', function($log, $locale, dateFilter, orderByFilter, filterFilter) {
  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  var localeId;
  var formatCodeToRegex;

  this.init = function() {
    localeId = $locale.id;

    this.parsers = {};
    this.formatters = {};

    formatCodeToRegex = [
      {
        key: 'yyyy',
        regex: '\\d{4}',
        apply: function(value) { this.year = +value; },
        formatter: function(date) {
          var _date = new Date();
          _date.setFullYear(Math.abs(date.getFullYear()));
          return dateFilter(_date, 'yyyy');
        }
      },
      {
        key: 'yy',
        regex: '\\d{2}',
        apply: function(value) { value = +value; this.year = value < 69 ? value + 2000 : value + 1900; },
        formatter: function(date) {
          var _date = new Date();
          _date.setFullYear(Math.abs(date.getFullYear()));
          return dateFilter(_date, 'yy');
        }
      },
      {
        key: 'y',
        regex: '\\d{1,4}',
        apply: function(value) { this.year = +value; },
        formatter: function(date) {
          var _date = new Date();
          _date.setFullYear(Math.abs(date.getFullYear()));
          return dateFilter(_date, 'y');
        }
      },
      {
        key: 'M!',
        regex: '0?[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; },
        formatter: function(date) {
          var value = date.getMonth();
          if (/^[0-9]$/.test(value)) {
            return dateFilter(date, 'MM');
          }

          return dateFilter(date, 'M');
        }
      },
      {
        key: 'MMMM',
        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },
        formatter: function(date) { return dateFilter(date, 'MMMM'); }
      },
      {
        key: 'MMM',
        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },
        formatter: function(date) { return dateFilter(date, 'MMM'); }
      },
      {
        key: 'MM',
        regex: '0[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; },
        formatter: function(date) { return dateFilter(date, 'MM'); }
      },
      {
        key: 'M',
        regex: '[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; },
        formatter: function(date) { return dateFilter(date, 'M'); }
      },
      {
        key: 'd!',
        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; },
        formatter: function(date) {
          var value = date.getDate();
          if (/^[1-9]$/.test(value)) {
            return dateFilter(date, 'dd');
          }

          return dateFilter(date, 'd');
        }
      },
      {
        key: 'dd',
        regex: '[0-2][0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; },
        formatter: function(date) { return dateFilter(date, 'dd'); }
      },
      {
        key: 'd',
        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; },
        formatter: function(date) { return dateFilter(date, 'd'); }
      },
      {
        key: 'EEEE',
        regex: $locale.DATETIME_FORMATS.DAY.join('|'),
        formatter: function(date) { return dateFilter(date, 'EEEE'); }
      },
      {
        key: 'EEE',
        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
        formatter: function(date) { return dateFilter(date, 'EEE'); }
      },
      {
        key: 'HH',
        regex: '(?:0|1)[0-9]|2[0-3]',
        apply: function(value) { this.hours = +value; },
        formatter: function(date) { return dateFilter(date, 'HH'); }
      },
      {
        key: 'hh',
        regex: '0[0-9]|1[0-2]',
        apply: function(value) { this.hours = +value; },
        formatter: function(date) { return dateFilter(date, 'hh'); }
      },
      {
        key: 'H',
        regex: '1?[0-9]|2[0-3]',
        apply: function(value) { this.hours = +value; },
        formatter: function(date) { return dateFilter(date, 'H'); }
      },
      {
        key: 'h',
        regex: '[0-9]|1[0-2]',
        apply: function(value) { this.hours = +value; },
        formatter: function(date) { return dateFilter(date, 'h'); }
      },
      {
        key: 'mm',
        regex: '[0-5][0-9]',
        apply: function(value) { this.minutes = +value; },
        formatter: function(date) { return dateFilter(date, 'mm'); }
      },
      {
        key: 'm',
        regex: '[0-9]|[1-5][0-9]',
        apply: function(value) { this.minutes = +value; },
        formatter: function(date) { return dateFilter(date, 'm'); }
      },
      {
        key: 'sss',
        regex: '[0-9][0-9][0-9]',
        apply: function(value) { this.milliseconds = +value; },
        formatter: function(date) { return dateFilter(date, 'sss'); }
      },
      {
        key: 'ss',
        regex: '[0-5][0-9]',
        apply: function(value) { this.seconds = +value; },
        formatter: function(date) { return dateFilter(date, 'ss'); }
      },
      {
        key: 's',
        regex: '[0-9]|[1-5][0-9]',
        apply: function(value) { this.seconds = +value; },
        formatter: function(date) { return dateFilter(date, 's'); }
      },
      {
        key: 'a',
        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
        apply: function(value) {
          if (this.hours === 12) {
            this.hours = 0;
          }

          if (value === 'PM') {
            this.hours += 12;
          }
        },
        formatter: function(date) { return dateFilter(date, 'a'); }
      },
      {
        key: 'Z',
        regex: '[+-]\\d{4}',
        apply: function(value) {
          var matches = value.match(/([+-])(\d{2})(\d{2})/),
            sign = matches[1],
            hours = matches[2],
            minutes = matches[3];
          this.hours += toInt(sign + hours);
          this.minutes += toInt(sign + minutes);
        },
        formatter: function(date) {
          return dateFilter(date, 'Z');
        }
      },
      {
        key: 'ww',
        regex: '[0-4][0-9]|5[0-3]',
        formatter: function(date) { return dateFilter(date, 'ww'); }
      },
      {
        key: 'w',
        regex: '[0-9]|[1-4][0-9]|5[0-3]',
        formatter: function(date) { return dateFilter(date, 'w'); }
      },
      {
        key: 'GGGG',
        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
        formatter: function(date) { return dateFilter(date, 'GGGG'); }
      },
      {
        key: 'GGG',
        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
        formatter: function(date) { return dateFilter(date, 'GGG'); }
      },
      {
        key: 'GG',
        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
        formatter: function(date) { return dateFilter(date, 'GG'); }
      },
      {
        key: 'G',
        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
        formatter: function(date) { return dateFilter(date, 'G'); }
      }
    ];

    if (angular.version.major >= 1 && angular.version.minor > 4) {
      formatCodeToRegex.push({
        key: 'LLLL',
        regex: $locale.DATETIME_FORMATS.STANDALONEMONTH.join('|'),
        apply: function(value) { this.month = $locale.DATETIME_FORMATS.STANDALONEMONTH.indexOf(value); },
        formatter: function(date) { return dateFilter(date, 'LLLL'); }
      });
    }
  };

  this.init();

  function getFormatCodeToRegex(key) {
    return filterFilter(formatCodeToRegex, {key: key}, true)[0];
  }

  this.getParser = function (key) {
    var f = getFormatCodeToRegex(key);
    return f && f.apply || null;
  };

  this.overrideParser = function (key, parser) {
    var f = getFormatCodeToRegex(key);
    if (f && angular.isFunction(parser)) {
      this.parsers = {};
      f.apply = parser;
    }
  }.bind(this);

  function createParser(format) {
    var map = [], regex = format.split('');

    // check for literal values
    var quoteIndex = format.indexOf('\'');
    if (quoteIndex > -1) {
      var inLiteral = false;
      format = format.split('');
      for (var i = quoteIndex; i < format.length; i++) {
        if (inLiteral) {
          if (format[i] === '\'') {
            if (i + 1 < format.length && format[i+1] === '\'') { // escaped single quote
              format[i+1] = '$';
              regex[i+1] = '';
            } else { // end of literal
              regex[i] = '';
              inLiteral = false;
            }
          }
          format[i] = '$';
        } else {
          if (format[i] === '\'') { // start of literal
            format[i] = '$';
            regex[i] = '';
            inLiteral = true;
          }
        }
      }

      format = format.join('');
    }

    angular.forEach(formatCodeToRegex, function(data) {
      var index = format.indexOf(data.key);

      if (index > -1) {
        format = format.split('');

        regex[index] = '(' + data.regex + ')';
        format[index] = '$'; // Custom symbol to define consumed part of format
        for (var i = index + 1, n = index + data.key.length; i < n; i++) {
          regex[i] = '';
          format[i] = '$';
        }
        format = format.join('');

        map.push({
          index: index,
          key: data.key,
          apply: data.apply,
          matcher: data.regex
        });
      }
    });

    return {
      regex: new RegExp('^' + regex.join('') + '$'),
      map: orderByFilter(map, 'index')
    };
  }

  function createFormatter(format) {
    var formatters = [];
    var i = 0;
    var formatter, literalIdx;
    while (i < format.length) {
      if (angular.isNumber(literalIdx)) {
        if (format.charAt(i) === '\'') {
          if (i + 1 >= format.length || format.charAt(i + 1) !== '\'') {
            formatters.push(constructLiteralFormatter(format, literalIdx, i));
            literalIdx = null;
          }
        } else if (i === format.length) {
          while (literalIdx < format.length) {
            formatter = constructFormatterFromIdx(format, literalIdx);
            formatters.push(formatter);
            literalIdx = formatter.endIdx;
          }
        }

        i++;
        continue;
      }

      if (format.charAt(i) === '\'') {
        literalIdx = i;
        i++;
        continue;
      }

      formatter = constructFormatterFromIdx(format, i);

      formatters.push(formatter.parser);
      i = formatter.endIdx;
    }

    return formatters;
  }

  function constructLiteralFormatter(format, literalIdx, endIdx) {
    return function() {
      return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
    };
  }

  function constructFormatterFromIdx(format, i) {
    var currentPosStr = format.substr(i);
    for (var j = 0; j < formatCodeToRegex.length; j++) {
      if (new RegExp('^' + formatCodeToRegex[j].key).test(currentPosStr)) {
        var data = formatCodeToRegex[j];
        return {
          endIdx: i + data.key.length,
          parser: data.formatter
        };
      }
    }

    return {
      endIdx: i + 1,
      parser: function() {
        return currentPosStr.charAt(0);
      }
    };
  }

  this.filter = function(date, format) {
    if (!angular.isDate(date) || isNaN(date) || !format) {
      return '';
    }

    format = $locale.DATETIME_FORMATS[format] || format;

    if ($locale.id !== localeId) {
      this.init();
    }

    if (!this.formatters[format]) {
      this.formatters[format] = createFormatter(format);
    }

    var formatters = this.formatters[format];

    return formatters.reduce(function(str, formatter) {
      return str + formatter(date);
    }, '');
  };

  this.parse = function(input, format, baseDate) {
    if (!angular.isString(input) || !format) {
      return input;
    }

    format = $locale.DATETIME_FORMATS[format] || format;
    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

    if ($locale.id !== localeId) {
      this.init();
    }

    if (!this.parsers[format]) {
      this.parsers[format] = createParser(format, 'apply');
    }

    var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex),
        tzOffset = false;
    if (results && results.length) {
      var fields, dt;
      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
        fields = {
          year: baseDate.getFullYear(),
          month: baseDate.getMonth(),
          date: baseDate.getDate(),
          hours: baseDate.getHours(),
          minutes: baseDate.getMinutes(),
          seconds: baseDate.getSeconds(),
          milliseconds: baseDate.getMilliseconds()
        };
      } else {
        if (baseDate) {
          $log.warn('dateparser:', 'baseDate is not a valid date');
        }
        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
      }

      for (var i = 1, n = results.length; i < n; i++) {
        var mapper = map[i - 1];
        if (mapper.matcher === 'Z') {
          tzOffset = true;
        }

        if (mapper.apply) {
          mapper.apply.call(fields, results[i]);
        }
      }

      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :
        Date.prototype.setFullYear;
      var timesetter = tzOffset ? Date.prototype.setUTCHours :
        Date.prototype.setHours;

      if (isValid(fields.year, fields.month, fields.date)) {
        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
          dt = new Date(baseDate);
          datesetter.call(dt, fields.year, fields.month, fields.date);
          timesetter.call(dt, fields.hours, fields.minutes,
            fields.seconds, fields.milliseconds);
        } else {
          dt = new Date(0);
          datesetter.call(dt, fields.year, fields.month, fields.date);
          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,
            fields.seconds || 0, fields.milliseconds || 0);
        }
      }

      return dt;
    }
  };

  // Check if date is valid for specific month (and year for February).
  // Month: 0 = Jan, 1 = Feb, etc
  function isValid(year, month, date) {
    if (date < 1) {
      return false;
    }

    if (month === 1 && date > 28) {
      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
    }

    if (month === 3 || month === 5 || month === 8 || month === 10) {
      return date < 31;
    }

    return true;
  }

  function toInt(str) {
    return parseInt(str, 10);
  }

  this.toTimezone = toTimezone;
  this.fromTimezone = fromTimezone;
  this.timezoneToOffset = timezoneToOffset;
  this.addDateMinutes = addDateMinutes;
  this.convertTimezoneToLocal = convertTimezoneToLocal;

  function toTimezone(date, timezone) {
    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
  }

  function fromTimezone(date, timezone) {
    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
  }

  //https://github.com/angular/angular.js/blob/622c42169699ec07fc6daaa19fe6d224e5d2f70e/src/Angular.js#L1207
  function timezoneToOffset(timezone, fallback) {
    timezone = timezone.replace(/:/g, '');
    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
  }

  function addDateMinutes(date, minutes) {
    date = new Date(date.getTime());
    date.setMinutes(date.getMinutes() + minutes);
    return date;
  }

  function convertTimezoneToLocal(date, timezone, reverse) {
    reverse = reverse ? -1 : 1;
    var dateTimezoneOffset = date.getTimezoneOffset();
    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
  }
}]);

// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to
// at most one element.
angular.module('ui.bootstrap.isClass', [])
.directive('uibIsClass', [
         '$animate',
function ($animate) {
  //                    11111111          22222222
  var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
  //                    11111111           22222222
  var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;

  var dataPerTracked = {};

  return {
    restrict: 'A',
    compile: function(tElement, tAttrs) {
      var linkedScopes = [];
      var instances = [];
      var expToData = {};
      var lastActivated = null;
      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
      var onExp = onExpMatches[2];
      var expsStr = onExpMatches[1];
      var exps = expsStr.split(',');

      return linkFn;

      function linkFn(scope, element, attrs) {
        linkedScopes.push(scope);
        instances.push({
          scope: scope,
          element: element
        });

        exps.forEach(function(exp, k) {
          addForExp(exp, scope);
        });

        scope.$on('$destroy', removeScope);
      }

      function addForExp(exp, scope) {
        var matches = exp.match(IS_REGEXP);
        var clazz = scope.$eval(matches[1]);
        var compareWithExp = matches[2];
        var data = expToData[exp];
        if (!data) {
          var watchFn = function(compareWithVal) {
            var newActivated = null;
            instances.some(function(instance) {
              var thisVal = instance.scope.$eval(onExp);
              if (thisVal === compareWithVal) {
                newActivated = instance;
                return true;
              }
            });
            if (data.lastActivated !== newActivated) {
              if (data.lastActivated) {
                $animate.removeClass(data.lastActivated.element, clazz);
              }
              if (newActivated) {
                $animate.addClass(newActivated.element, clazz);
              }
              data.lastActivated = newActivated;
            }
          };
          expToData[exp] = data = {
            lastActivated: null,
            scope: scope,
            watchFn: watchFn,
            compareWithExp: compareWithExp,
            watcher: scope.$watch(compareWithExp, watchFn)
          };
        }
        data.watchFn(scope.$eval(compareWithExp));
      }

      function removeScope(e) {
        var removedScope = e.targetScope;
        var index = linkedScopes.indexOf(removedScope);
        linkedScopes.splice(index, 1);
        instances.splice(index, 1);
        if (linkedScopes.length) {
          var newWatchScope = linkedScopes[0];
          angular.forEach(expToData, function(data) {
            if (data.scope === removedScope) {
              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
              data.scope = newWatchScope;
            }
          });
        } else {
          expToData = {};
        }
      }
    }
  };
}]);
angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])

.value('$datepickerSuppressError', false)

.value('$datepickerLiteralWarning', true)

.constant('uibDatepickerConfig', {
  datepickerMode: 'day',
  formatDay: 'dd',
  formatMonth: 'MMMM',
  formatYear: 'yyyy',
  formatDayHeader: 'EEE',
  formatDayTitle: 'MMMM yyyy',
  formatMonthTitle: 'yyyy',
  maxDate: null,
  maxMode: 'year',
  minDate: null,
  minMode: 'day',
  monthColumns: 3,
  ngModelOptions: {},
  shortcutPropagation: false,
  showWeeks: true,
  yearColumns: 5,
  yearRows: 4
})

.controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',
  function($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;
      ngModelOptions = {},
      watchListeners = [];

  $element.addClass('uib-datepicker');
  $attrs.$set('role', 'application');

  if (!$scope.datepickerOptions) {
    $scope.datepickerOptions = {};
  }

  // Modes chain
  this.modes = ['day', 'month', 'year'];

  [
    'customClass',
    'dateDisabled',
    'datepickerMode',
    'formatDay',
    'formatDayHeader',
    'formatDayTitle',
    'formatMonth',
    'formatMonthTitle',
    'formatYear',
    'maxDate',
    'maxMode',
    'minDate',
    'minMode',
    'monthColumns',
    'showWeeks',
    'shortcutPropagation',
    'startingDay',
    'yearColumns',
    'yearRows'
  ].forEach(function(key) {
    switch (key) {
      case 'customClass':
      case 'dateDisabled':
        $scope[key] = $scope.datepickerOptions[key] || angular.noop;
        break;
      case 'datepickerMode':
        $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?
          $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
        break;
      case 'formatDay':
      case 'formatDayHeader':
      case 'formatDayTitle':
      case 'formatMonth':
      case 'formatMonthTitle':
      case 'formatYear':
        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
          $interpolate($scope.datepickerOptions[key])($scope.$parent) :
          datepickerConfig[key];
        break;
      case 'monthColumns':
      case 'showWeeks':
      case 'shortcutPropagation':
      case 'yearColumns':
      case 'yearRows':
        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?
          $scope.datepickerOptions[key] : datepickerConfig[key];
        break;
      case 'startingDay':
        if (angular.isDefined($scope.datepickerOptions.startingDay)) {
          self.startingDay = $scope.datepickerOptions.startingDay;
        } else if (angular.isNumber(datepickerConfig.startingDay)) {
          self.startingDay = datepickerConfig.startingDay;
        } else {
          self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
        }

        break;
      case 'maxDate':
      case 'minDate':
        $scope.$watch('datepickerOptions.' + key, function(value) {
          if (value) {
            if (angular.isDate(value)) {
              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.getOption('timezone'));
            } else {
              if ($datepickerLiteralWarning) {
                $log.warn('Literal date support has been deprecated, please switch to date object usage');
              }

              self[key] = new Date(dateFilter(value, 'medium'));
            }
          } else {
            self[key] = datepickerConfig[key] ?
              dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.getOption('timezone')) :
              null;
          }

          self.refreshView();
        });

        break;
      case 'maxMode':
      case 'minMode':
        if ($scope.datepickerOptions[key]) {
          $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {
            self[key] = $scope[key] = angular.isDefined(value) ? value : $scope.datepickerOptions[key];
            if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||
              key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
              $scope.datepickerMode = self[key];
              $scope.datepickerOptions.datepickerMode = self[key];
            }
          });
        } else {
          self[key] = $scope[key] = datepickerConfig[key] || null;
        }

        break;
    }
  });

  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

  $scope.disabled = angular.isDefined($attrs.disabled) || false;
  if (angular.isDefined($attrs.ngDisabled)) {
    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
      $scope.disabled = disabled;
      self.refreshView();
    }));
  }

  $scope.isActive = function(dateObject) {
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelOptions = extractOptions(ngModelCtrl);

    if ($scope.datepickerOptions.initDate) {
      self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.getOption('timezone')) || new Date();
      $scope.$watch('datepickerOptions.initDate', function(initDate) {
        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
          self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.getOption('timezone'));
          self.refreshView();
        }
      });
    } else {
      self.activeDate = new Date();
    }

    var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
    this.activeDate = !isNaN(date) ?
      dateParser.fromTimezone(date, ngModelOptions.getOption('timezone')) :
      dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));

    ngModelCtrl.$render = function() {
      self.render();
    };
  };

  this.render = function() {
    if (ngModelCtrl.$viewValue) {
      var date = new Date(ngModelCtrl.$viewValue),
          isValid = !isNaN(date);

      if (isValid) {
        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));
      } else if (!$datepickerSuppressError) {
        $log.error('Datepicker directive: "ng-model" value must be a Date object');
      }
    }
    this.refreshView();
  };

  this.refreshView = function() {
    if (this.element) {
      $scope.selectedDt = null;
      this._refreshView();
      if ($scope.activeDt) {
        $scope.activeDateId = $scope.activeDt.uid;
      }

      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
      date = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));
      ngModelCtrl.$setValidity('dateDisabled', !date ||
        this.element && !this.isDisabled(date));
    }
  };

  this.createDateObject = function(date, format) {
    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
    model = dateParser.fromTimezone(model, ngModelOptions.getOption('timezone'));
    var today = new Date();
    today = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));
    var time = this.compare(date, today);
    var dt = {
      date: date,
      label: dateParser.filter(date, format),
      selected: model && this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      past: time < 0,
      current: time === 0,
      future: time > 0,
      customClass: this.customClass(date) || null
    };

    if (model && this.compare(date, model) === 0) {
      $scope.selectedDt = dt;
    }

    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
      $scope.activeDt = dt;
    }

    return dt;
  };

  this.isDisabled = function(date) {
    return $scope.disabled ||
      this.minDate && this.compare(date, this.minDate) < 0 ||
      this.maxDate && this.compare(date, this.maxDate) > 0 ||
      $scope.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});
  };

  this.customClass = function(date) {
    return $scope.customClass({date: date, mode: $scope.datepickerMode});
  };

  // Split array into smaller arrays
  this.split = function(arr, size) {
    var arrays = [];
    while (arr.length > 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  $scope.select = function(date) {
    if ($scope.datepickerMode === self.minMode) {
      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.getOption('timezone')) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
      dt = dateParser.toTimezone(dt, ngModelOptions.getOption('timezone'));
      ngModelCtrl.$setViewValue(dt);
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);

      $scope.$emit('uib:datepicker.mode');
    }

    $scope.$broadcast('uib:datepicker.focus');
  };

  $scope.move = function(direction) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function(direction) {
    direction = direction || 1;

    if ($scope.datepickerMode === self.maxMode && direction === 1 ||
      $scope.datepickerMode === self.minMode && direction === -1) {
      return;
    }

    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);

    $scope.$emit('uib:datepicker.mode');
  };

  // Key event mapper
  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

  var focusElement = function() {
    self.element[0].focus();
  };

  // Listen for focus requests from popup directive
  $scope.$on('uib:datepicker.focus', focusElement);

  $scope.keydown = function(evt) {
    var key = $scope.keys[evt.which];

    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
      return;
    }

    evt.preventDefault();
    if (!self.shortcutPropagation) {
      evt.stopPropagation();
    }

    if (key === 'enter' || key === 'space') {
      if (self.isDisabled(self.activeDate)) {
        return; // do nothing
      }
      $scope.select(self.activeDate);
    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
      $scope.toggleMode(key === 'up' ? 1 : -1);
    } else {
      self.handleKeyDown(key, evt);
      self.refreshView();
    }
  };

  $element.on('keydown', function(evt) {
    $scope.$apply(function() {
      $scope.keydown(evt);
    });
  });

  $scope.$on('$destroy', function() {
    //Clear all watch listeners on destroy
    while (watchListeners.length) {
      watchListeners.shift()();
    }
  });

  function setMode(mode) {
    $scope.datepickerMode = mode;
    $scope.datepickerOptions.datepickerMode = mode;
  }

  function extractOptions(ngModelCtrl) {
    var ngModelOptions;

    if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing
      // guarantee a value
      ngModelOptions = ngModelCtrl.$options ||
        $scope.datepickerOptions.ngModelOptions ||
        datepickerConfig.ngModelOptions ||
        {};

      // mimic 1.6+ api
      ngModelOptions.getOption = function (key) {
        return ngModelOptions[key];
      };
    } else { // in angular >=1.6 $options is always present
      // ng-model-options defaults timezone to null; don't let its precedence squash a non-null value
      var timezone = ngModelCtrl.$options.getOption('timezone') ||
        ($scope.datepickerOptions.ngModelOptions ? $scope.datepickerOptions.ngModelOptions.timezone : null) ||
        (datepickerConfig.ngModelOptions ? datepickerConfig.ngModelOptions.timezone : null);

      // values passed to createChild override existing values
      ngModelOptions = ngModelCtrl.$options // start with a ModelOptions instance
        .createChild(datepickerConfig.ngModelOptions) // lowest precedence
        .createChild($scope.datepickerOptions.ngModelOptions)
        .createChild(ngModelCtrl.$options) // highest precedence
        .createChild({timezone: timezone}); // to keep from squashing a non-null value
    }

    return ngModelOptions;
  }
}])

.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  this.step = { months: 1 };
  this.element = $element;
  function getDaysInMonth(year, month) {
    return month === 1 && year % 4 === 0 &&
      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
  }

  this.init = function(ctrl) {
    angular.extend(ctrl, this);
    scope.showWeeks = ctrl.showWeeks;
    ctrl.refreshView();
  };

  this.getDates = function(startDate, n) {
    var dates = new Array(n), current = new Date(startDate), i = 0, date;
    while (i < n) {
      date = new Date(current);
      dates[i++] = date;
      current.setDate(current.getDate() + 1);
    }
    return dates;
  };

  this._refreshView = function() {
    var year = this.activeDate.getFullYear(),
      month = this.activeDate.getMonth(),
      firstDayOfMonth = new Date(this.activeDate);

    firstDayOfMonth.setFullYear(year, month, 1);

    var difference = this.startingDay - firstDayOfMonth.getDay(),
      numDisplayedFromPreviousMonth = difference > 0 ?
        7 - difference : - difference,
      firstDate = new Date(firstDayOfMonth);

    if (numDisplayedFromPreviousMonth > 0) {
      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
    }

    // 42 is the number of days on a six-week calendar
    var days = this.getDates(firstDate, 42);
    for (var i = 0; i < 42; i ++) {
      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
        secondary: days[i].getMonth() !== month,
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.labels = new Array(7);
    for (var j = 0; j < 7; j++) {
      scope.labels[j] = {
        abbr: dateFilter(days[j].date, this.formatDayHeader),
        full: dateFilter(days[j].date, 'EEEE')
      };
    }

    scope.title = dateFilter(this.activeDate, this.formatDayTitle);
    scope.rows = this.split(days, 7);

    if (scope.showWeeks) {
      scope.weekNumbers = [];
      var thursdayIndex = (4 + 7 - this.startingDay) % 7,
          numWeeks = scope.rows.length;
      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
        scope.weekNumbers.push(
          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
      }
    }
  };

  this.compare = function(date1, date2) {
    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
    _date1.setFullYear(date1.getFullYear());
    _date2.setFullYear(date2.getFullYear());
    return _date1 - _date2;
  };

  function getISO8601WeekNumber(date) {
    var checkDate = new Date(date);
    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
    var time = checkDate.getTime();
    checkDate.setMonth(0); // Compare with Jan 1
    checkDate.setDate(1);
    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
  }

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getDate();

    if (key === 'left') {
      date = date - 1;
    } else if (key === 'up') {
      date = date - 7;
    } else if (key === 'right') {
      date = date + 1;
    } else if (key === 'down') {
      date = date + 7;
    } else if (key === 'pageup' || key === 'pagedown') {
      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
      this.activeDate.setMonth(month, 1);
      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
    } else if (key === 'home') {
      date = 1;
    } else if (key === 'end') {
      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
    }
    this.activeDate.setDate(date);
  };
}])

.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  this.step = { years: 1 };
  this.element = $element;

  this.init = function(ctrl) {
    angular.extend(ctrl, this);
    ctrl.refreshView();
  };

  this._refreshView = function() {
    var months = new Array(12),
        year = this.activeDate.getFullYear(),
        date;

    for (var i = 0; i < 12; i++) {
      date = new Date(this.activeDate);
      date.setFullYear(year, i, 1);
      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
    scope.rows = this.split(months, this.monthColumns);
    scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;
  };

  this.compare = function(date1, date2) {
    var _date1 = new Date(date1.getFullYear(), date1.getMonth());
    var _date2 = new Date(date2.getFullYear(), date2.getMonth());
    _date1.setFullYear(date1.getFullYear());
    _date2.setFullYear(date2.getFullYear());
    return _date1 - _date2;
  };

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getMonth();

    if (key === 'left') {
      date = date - 1;
    } else if (key === 'up') {
      date = date - this.monthColumns;
    } else if (key === 'right') {
      date = date + 1;
    } else if (key === 'down') {
      date = date + this.monthColumns;
    } else if (key === 'pageup' || key === 'pagedown') {
      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
      this.activeDate.setFullYear(year);
    } else if (key === 'home') {
      date = 0;
    } else if (key === 'end') {
      date = 11;
    }
    this.activeDate.setMonth(date);
  };
}])

.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  var columns, range;
  this.element = $element;

  function getStartingYear(year) {
    return parseInt((year - 1) / range, 10) * range + 1;
  }

  this.yearpickerInit = function() {
    columns = this.yearColumns;
    range = this.yearRows * columns;
    this.step = { years: range };
  };

  this._refreshView = function() {
    var years = new Array(range), date;

    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
      date = new Date(this.activeDate);
      date.setFullYear(start + i, 0, 1);
      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.title = [years[0].label, years[range - 1].label].join(' - ');
    scope.rows = this.split(years, columns);
    scope.columns = columns;
  };

  this.compare = function(date1, date2) {
    return date1.getFullYear() - date2.getFullYear();
  };

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getFullYear();

    if (key === 'left') {
      date = date - 1;
    } else if (key === 'up') {
      date = date - columns;
    } else if (key === 'right') {
      date = date + 1;
    } else if (key === 'down') {
      date = date + columns;
    } else if (key === 'pageup' || key === 'pagedown') {
      date += (key === 'pageup' ? - 1 : 1) * range;
    } else if (key === 'home') {
      date = getStartingYear(this.activeDate.getFullYear());
    } else if (key === 'end') {
      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
    }
    this.activeDate.setFullYear(date);
  };
}])

.directive('uibDatepicker', function() {
  return {
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
    },
    scope: {
      datepickerOptions: '=?'
    },
    require: ['uibDatepicker', '^ngModel'],
    restrict: 'A',
    controller: 'UibDatepickerController',
    controllerAs: 'datepicker',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      datepickerCtrl.init(ngModelCtrl);
    }
  };
})

.directive('uibDaypicker', function() {
  return {
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepicker/day.html';
    },
    require: ['^uibDatepicker', 'uibDaypicker'],
    restrict: 'A',
    controller: 'UibDaypickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0],
        daypickerCtrl = ctrls[1];

      daypickerCtrl.init(datepickerCtrl);
    }
  };
})

.directive('uibMonthpicker', function() {
  return {
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepicker/month.html';
    },
    require: ['^uibDatepicker', 'uibMonthpicker'],
    restrict: 'A',
    controller: 'UibMonthpickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0],
        monthpickerCtrl = ctrls[1];

      monthpickerCtrl.init(datepickerCtrl);
    }
  };
})

.directive('uibYearpicker', function() {
  return {
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepicker/year.html';
    },
    require: ['^uibDatepicker', 'uibYearpicker'],
    restrict: 'A',
    controller: 'UibYearpickerController',
    link: function(scope, element, attrs, ctrls) {
      var ctrl = ctrls[0];
      angular.extend(ctrl, ctrls[1]);
      ctrl.yearpickerInit();

      ctrl.refreshView();
    }
  };
});

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods for working with the DOM.
 * It is meant to be used where we need to absolute-position elements in
 * relation to another element (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$uibPosition', ['$document', '$window', function($document, $window) {
    /**
     * Used by scrollbarWidth() function to cache scrollbar's width.
     * Do not access this variable directly, use scrollbarWidth() instead.
     */
    var SCROLLBAR_WIDTH;
    /**
     * scrollbar on body and html element in IE and Edge overlay
     * content and should be considered 0 width.
     */
    var BODY_SCROLLBAR_WIDTH;
    var OVERFLOW_REGEX = {
      normal: /(auto|scroll)/,
      hidden: /(auto|scroll|hidden)/
    };
    var PLACEMENT_REGEX = {
      auto: /\s?auto?\s?/i,
      primary: /^(top|bottom|left|right)$/,
      secondary: /^(top|bottom|left|right|center)$/,
      vertical: /^(top|bottom)$/
    };
    var BODY_REGEX = /(HTML|BODY)/;

    return {

      /**
       * Provides a raw DOM element from a jQuery/jQLite element.
       *
       * @param {element} elem - The element to convert.
       *
       * @returns {element} A HTML element.
       */
      getRawNode: function(elem) {
        return elem.nodeName ? elem : elem[0] || elem;
      },

      /**
       * Provides a parsed number for a style property.  Strips
       * units and casts invalid numbers to 0.
       *
       * @param {string} value - The style value to parse.
       *
       * @returns {number} A valid number.
       */
      parseStyle: function(value) {
        value = parseFloat(value);
        return isFinite(value) ? value : 0;
      },

      /**
       * Provides the closest positioned ancestor.
       *
       * @param {element} element - The element to get the offest parent for.
       *
       * @returns {element} The closest positioned ancestor.
       */
      offsetParent: function(elem) {
        elem = this.getRawNode(elem);

        var offsetParent = elem.offsetParent || $document[0].documentElement;

        function isStaticPositioned(el) {
          return ($window.getComputedStyle(el).position || 'static') === 'static';
        }

        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || $document[0].documentElement;
      },

      /**
       * Provides the scrollbar width, concept from TWBS measureScrollbar()
       * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js
       * In IE and Edge, scollbar on body and html element overlay and should
       * return a width of 0.
       *
       * @returns {number} The width of the browser scollbar.
       */
      scrollbarWidth: function(isBody) {
        if (isBody) {
          if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
            var bodyElem = $document.find('body');
            bodyElem.addClass('uib-position-body-scrollbar-measure');
            BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
            BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
            bodyElem.removeClass('uib-position-body-scrollbar-measure');
          }
          return BODY_SCROLLBAR_WIDTH;
        }

        if (angular.isUndefined(SCROLLBAR_WIDTH)) {
          var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
          $document.find('body').append(scrollElem);
          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
          scrollElem.remove();
        }

        return SCROLLBAR_WIDTH;
      },

      /**
       * Provides the padding required on an element to replace the scrollbar.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**scrollbarWidth**: the width of the scrollbar</li>
       *     <li>**widthOverflow**: whether the the width is overflowing</li>
       *     <li>**right**: the amount of right padding on the element needed to replace the scrollbar</li>
       *     <li>**rightOriginal**: the amount of right padding currently on the element</li>
       *     <li>**heightOverflow**: whether the the height is overflowing</li>
       *     <li>**bottom**: the amount of bottom padding on the element needed to replace the scrollbar</li>
       *     <li>**bottomOriginal**: the amount of bottom padding currently on the element</li>
       *   </ul>
       */
      scrollbarPadding: function(elem) {
        elem = this.getRawNode(elem);

        var elemStyle = $window.getComputedStyle(elem);
        var paddingRight = this.parseStyle(elemStyle.paddingRight);
        var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
        var scrollParent = this.scrollParent(elem, false, true);
        var scrollbarWidth = this.scrollbarWidth(BODY_REGEX.test(scrollParent.tagName));

        return {
          scrollbarWidth: scrollbarWidth,
          widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
          right: paddingRight + scrollbarWidth,
          originalRight: paddingRight,
          heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
          bottom: paddingBottom + scrollbarWidth,
          originalBottom: paddingBottom
         };
      },

      /**
       * Checks to see if the element is scrollable.
       *
       * @param {element} elem - The element to check.
       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
       *   default is false.
       *
       * @returns {boolean} Whether the element is scrollable.
       */
      isScrollable: function(elem, includeHidden) {
        elem = this.getRawNode(elem);

        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
        var elemStyle = $window.getComputedStyle(elem);
        return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
      },

      /**
       * Provides the closest scrollable ancestor.
       * A port of the jQuery UI scrollParent method:
       * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js
       *
       * @param {element} elem - The element to find the scroll parent of.
       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
       *   default is false.
       * @param {boolean=} [includeSelf=false] - Should the element being passed be
       * included in the scrollable llokup.
       *
       * @returns {element} A HTML element.
       */
      scrollParent: function(elem, includeHidden, includeSelf) {
        elem = this.getRawNode(elem);

        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
        var documentEl = $document[0].documentElement;
        var elemStyle = $window.getComputedStyle(elem);
        if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
          return elem;
        }
        var excludeStatic = elemStyle.position === 'absolute';
        var scrollParent = elem.parentElement || documentEl;

        if (scrollParent === documentEl || elemStyle.position === 'fixed') {
          return documentEl;
        }

        while (scrollParent.parentElement && scrollParent !== documentEl) {
          var spStyle = $window.getComputedStyle(scrollParent);
          if (excludeStatic && spStyle.position !== 'static') {
            excludeStatic = false;
          }

          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
            break;
          }
          scrollParent = scrollParent.parentElement;
        }

        return scrollParent;
      },

      /**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/ - distance to closest positioned
       * ancestor.  Does not account for margins by default like jQuery position.
       *
       * @param {element} elem - The element to caclulate the position on.
       * @param {boolean=} [includeMargins=false] - Should margins be accounted
       * for, default is false.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**width**: the width of the element</li>
       *     <li>**height**: the height of the element</li>
       *     <li>**top**: distance to top edge of offset parent</li>
       *     <li>**left**: distance to left edge of offset parent</li>
       *   </ul>
       */
      position: function(elem, includeMagins) {
        elem = this.getRawNode(elem);

        var elemOffset = this.offset(elem);
        if (includeMagins) {
          var elemStyle = $window.getComputedStyle(elem);
          elemOffset.top -= this.parseStyle(elemStyle.marginTop);
          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
        }
        var parent = this.offsetParent(elem);
        var parentOffset = {top: 0, left: 0};

        if (parent !== $document[0].documentElement) {
          parentOffset = this.offset(parent);
          parentOffset.top += parent.clientTop - parent.scrollTop;
          parentOffset.left += parent.clientLeft - parent.scrollLeft;
        }

        return {
          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
          top: Math.round(elemOffset.top - parentOffset.top),
          left: Math.round(elemOffset.left - parentOffset.left)
        };
      },

      /**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/ - distance to viewport.  Does
       * not account for borders, margins, or padding on the body
       * element.
       *
       * @param {element} elem - The element to calculate the offset on.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**width**: the width of the element</li>
       *     <li>**height**: the height of the element</li>
       *     <li>**top**: distance to top edge of viewport</li>
       *     <li>**right**: distance to bottom edge of viewport</li>
       *   </ul>
       */
      offset: function(elem) {
        elem = this.getRawNode(elem);

        var elemBCR = elem.getBoundingClientRect();
        return {
          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
        };
      },

      /**
       * Provides offset distance to the closest scrollable ancestor
       * or viewport.  Accounts for border and scrollbar width.
       *
       * Right and bottom dimensions represent the distance to the
       * respective edge of the viewport element.  If the element
       * edge extends beyond the viewport, a negative value will be
       * reported.
       *
       * @param {element} elem - The element to get the viewport offset for.
       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead
       * of the first scrollable element, default is false.
       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element
       * be accounted for, default is true.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**top**: distance to the top content edge of viewport element</li>
       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>
       *     <li>**left**: distance to the left content edge of viewport element</li>
       *     <li>**right**: distance to the right content edge of viewport element</li>
       *   </ul>
       */
      viewportOffset: function(elem, useDocument, includePadding) {
        elem = this.getRawNode(elem);
        includePadding = includePadding !== false ? true : false;

        var elemBCR = elem.getBoundingClientRect();
        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};

        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
        var offsetParentBCR = offsetParent.getBoundingClientRect();

        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
        if (offsetParent === $document[0].documentElement) {
          offsetBCR.top += $window.pageYOffset;
          offsetBCR.left += $window.pageXOffset;
        }
        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;

        if (includePadding) {
          var offsetParentStyle = $window.getComputedStyle(offsetParent);
          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
        }

        return {
          top: Math.round(elemBCR.top - offsetBCR.top),
          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
          left: Math.round(elemBCR.left - offsetBCR.left),
          right: Math.round(offsetBCR.right - elemBCR.right)
        };
      },

      /**
       * Provides an array of placement values parsed from a placement string.
       * Along with the 'auto' indicator, supported placement strings are:
       *   <ul>
       *     <li>top: element on top, horizontally centered on host element.</li>
       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>
       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>
       *     <li>bottom: element on bottom, horizontally centered on host element.</li>
       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>
       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>
       *     <li>left: element on left, vertically centered on host element.</li>
       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>
       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>
       *     <li>right: element on right, vertically centered on host element.</li>
       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>
       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>
       *   </ul>
       * A placement string with an 'auto' indicator is expected to be
       * space separated from the placement, i.e: 'auto bottom-left'  If
       * the primary and secondary placement values do not match 'top,
       * bottom, left, right' then 'top' will be the primary placement and
       * 'center' will be the secondary placement.  If 'auto' is passed, true
       * will be returned as the 3rd value of the array.
       *
       * @param {string} placement - The placement string to parse.
       *
       * @returns {array} An array with the following values
       * <ul>
       *   <li>**[0]**: The primary placement.</li>
       *   <li>**[1]**: The secondary placement.</li>
       *   <li>**[2]**: If auto is passed: true, else undefined.</li>
       * </ul>
       */
      parsePlacement: function(placement) {
        var autoPlace = PLACEMENT_REGEX.auto.test(placement);
        if (autoPlace) {
          placement = placement.replace(PLACEMENT_REGEX.auto, '');
        }

        placement = placement.split('-');

        placement[0] = placement[0] || 'top';
        if (!PLACEMENT_REGEX.primary.test(placement[0])) {
          placement[0] = 'top';
        }

        placement[1] = placement[1] || 'center';
        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
          placement[1] = 'center';
        }

        if (autoPlace) {
          placement[2] = true;
        } else {
          placement[2] = false;
        }

        return placement;
      },

      /**
       * Provides coordinates for an element to be positioned relative to
       * another element.  Passing 'auto' as part of the placement parameter
       * will enable smart placement - where the element fits. i.e:
       * 'auto left-top' will check to see if there is enough space to the left
       * of the hostElem to fit the targetElem, if not place right (same for secondary
       * top placement).  Available space is calculated using the viewportOffset
       * function.
       *
       * @param {element} hostElem - The element to position against.
       * @param {element} targetElem - The element to position.
       * @param {string=} [placement=top] - The placement for the targetElem,
       *   default is 'top'. 'center' is assumed as secondary placement for
       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:
       *   <ul>
       *     <li>top</li>
       *     <li>top-right</li>
       *     <li>top-left</li>
       *     <li>bottom</li>
       *     <li>bottom-left</li>
       *     <li>bottom-right</li>
       *     <li>left</li>
       *     <li>left-top</li>
       *     <li>left-bottom</li>
       *     <li>right</li>
       *     <li>right-top</li>
       *     <li>right-bottom</li>
       *   </ul>
       * @param {boolean=} [appendToBody=false] - Should the top and left values returned
       *   be calculated from the body element, default is false.
       *
       * @returns {object} An object with the following properties:
       *   <ul>
       *     <li>**top**: Value for targetElem top.</li>
       *     <li>**left**: Value for targetElem left.</li>
       *     <li>**placement**: The resolved placement.</li>
       *   </ul>
       */
      positionElements: function(hostElem, targetElem, placement, appendToBody) {
        hostElem = this.getRawNode(hostElem);
        targetElem = this.getRawNode(targetElem);

        // need to read from prop to support tests.
        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');

        placement = this.parsePlacement(placement);

        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
        var targetElemPos = {top: 0, left: 0, placement: ''};

        if (placement[2]) {
          var viewportOffset = this.viewportOffset(hostElem, appendToBody);

          var targetElemStyle = $window.getComputedStyle(targetElem);
          var adjustedSize = {
            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
          };

          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :
                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :
                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :
                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :
                         placement[0];

          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :
                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :
                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :
                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :
                         placement[1];

          if (placement[1] === 'center') {
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                placement[1] = 'left';
              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                placement[1] = 'right';
              }
            } else {
              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                placement[1] = 'top';
              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                placement[1] = 'bottom';
              }
            }
          }
        }

        switch (placement[0]) {
          case 'top':
            targetElemPos.top = hostElemPos.top - targetHeight;
            break;
          case 'bottom':
            targetElemPos.top = hostElemPos.top + hostElemPos.height;
            break;
          case 'left':
            targetElemPos.left = hostElemPos.left - targetWidth;
            break;
          case 'right':
            targetElemPos.left = hostElemPos.left + hostElemPos.width;
            break;
        }

        switch (placement[1]) {
          case 'top':
            targetElemPos.top = hostElemPos.top;
            break;
          case 'bottom':
            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
            break;
          case 'left':
            targetElemPos.left = hostElemPos.left;
            break;
          case 'right':
            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
            break;
          case 'center':
            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
            } else {
              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
            }
            break;
        }

        targetElemPos.top = Math.round(targetElemPos.top);
        targetElemPos.left = Math.round(targetElemPos.left);
        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];

        return targetElemPos;
      },

      /**
       * Provides a way to adjust the top positioning after first
       * render to correctly align element to top after content
       * rendering causes resized element height
       *
       * @param {array} placementClasses - The array of strings of classes
       * element should have.
       * @param {object} containerPosition - The object with container
       * position information
       * @param {number} initialHeight - The initial height for the elem.
       * @param {number} currentHeight - The current height for the elem.
       */
      adjustTop: function(placementClasses, containerPosition, initialHeight, currentHeight) {
        if (placementClasses.indexOf('top') !== -1 && initialHeight !== currentHeight) {
          return {
            top: containerPosition.top - currentHeight + 'px'
          };
        }
      },

      /**
       * Provides a way for positioning tooltip & dropdown
       * arrows when using placement options beyond the standard
       * left, right, top, or bottom.
       *
       * @param {element} elem - The tooltip/dropdown element.
       * @param {string} placement - The placement for the elem.
       */
      positionArrow: function(elem, placement) {
        elem = this.getRawNode(elem);

        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
        if (!innerElem) {
          return;
        }

        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');

        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
        if (!arrowElem) {
          return;
        }

        var arrowCss = {
          top: '',
          bottom: '',
          left: '',
          right: ''
        };

        placement = this.parsePlacement(placement);
        if (placement[1] === 'center') {
          // no adjustment necessary - just reset styles
          angular.element(arrowElem).css(arrowCss);
          return;
        }

        var borderProp = 'border-' + placement[0] + '-width';
        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];

        var borderRadiusProp = 'border-';
        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
          borderRadiusProp += placement[0] + '-' + placement[1];
        } else {
          borderRadiusProp += placement[1] + '-' + placement[0];
        }
        borderRadiusProp += '-radius';
        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];

        switch (placement[0]) {
          case 'top':
            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'bottom':
            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'left':
            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
            break;
          case 'right':
            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
            break;
        }

        arrowCss[placement[1]] = borderRadius;

        angular.element(arrowElem).css(arrowCss);
      }
    };
  }]);

angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])

.value('$datepickerPopupLiteralWarning', true)

.constant('uibDatepickerPopupConfig', {
  altInputFormats: [],
  appendToBody: false,
  clearText: 'Clear',
  closeOnDateSelection: true,
  closeText: 'Done',
  currentText: 'Today',
  datepickerPopup: 'yyyy-MM-dd',
  datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
  html5Types: {
    date: 'yyyy-MM-dd',
    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
    'month': 'yyyy-MM'
  },
  onOpenFocus: true,
  showButtonBar: true,
  placement: 'auto bottom-left'
})

.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',
function($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
  var cache = {},
    isHtml5DateInput = false;
  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,
    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];

  this.init = function(_ngModel_) {
    ngModel = _ngModel_;
    ngModelOptions = extractOptions(ngModel);
    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?
      $scope.$parent.$eval($attrs.closeOnDateSelection) :
      datepickerPopupConfig.closeOnDateSelection;
    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?
      $scope.$parent.$eval($attrs.datepickerAppendToBody) :
      datepickerPopupConfig.appendToBody;
    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?
      $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?
      $attrs.datepickerPopupTemplateUrl :
      datepickerPopupConfig.datepickerPopupTemplateUrl;
    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?
      $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
    altInputFormats = angular.isDefined($attrs.altInputFormats) ?
      $scope.$parent.$eval($attrs.altInputFormats) :
      datepickerPopupConfig.altInputFormats;

    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?
      $scope.$parent.$eval($attrs.showButtonBar) :
      datepickerPopupConfig.showButtonBar;

    if (datepickerPopupConfig.html5Types[$attrs.type]) {
      dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
      isHtml5DateInput = true;
    } else {
      dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
      $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
        // Invalidate the $modelValue to ensure that formatters re-run
        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
        if (newDateFormat !== dateFormat) {
          dateFormat = newDateFormat;
          ngModel.$modelValue = null;

          if (!dateFormat) {
            throw new Error('uibDatepickerPopup must have a date format specified.');
          }
        }
      });
    }

    if (!dateFormat) {
      throw new Error('uibDatepickerPopup must have a date format specified.');
    }

    if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
      throw new Error('HTML5 date input types do not support custom formats.');
    }

    // popup element used to display calendar
    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');

    popupEl.attr({
      'ng-model': 'date',
      'ng-change': 'dateSelection(date)',
      'template-url': datepickerPopupTemplateUrl
    });

    // datepicker element
    datepickerEl = angular.element(popupEl.children()[0]);
    datepickerEl.attr('template-url', datepickerTemplateUrl);

    if (!$scope.datepickerOptions) {
      $scope.datepickerOptions = {};
    }

    if (isHtml5DateInput) {
      if ($attrs.type === 'month') {
        $scope.datepickerOptions.datepickerMode = 'month';
        $scope.datepickerOptions.minMode = 'month';
      }
    }

    datepickerEl.attr('datepicker-options', 'datepickerOptions');

    if (!isHtml5DateInput) {
      // Internal API to maintain the correct ng-invalid-[key] class
      ngModel.$$parserName = 'date';
      ngModel.$validators.date = validator;
      ngModel.$parsers.unshift(parseDate);
      ngModel.$formatters.push(function(value) {
        if (ngModel.$isEmpty(value)) {
          $scope.date = value;
          return value;
        }

        if (angular.isNumber(value)) {
          value = new Date(value);
        }

        $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));

        return dateParser.filter($scope.date, dateFormat);
      });
    } else {
      ngModel.$formatters.push(function(value) {
        $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));
        return value;
      });
    }

    // Detect changes in the view from the text box
    ngModel.$viewChangeListeners.push(function() {
      $scope.date = parseDateString(ngModel.$viewValue);
    });

    $element.on('keydown', inputKeydownBind);

    $popup = $compile(popupEl)($scope);
    // Prevent jQuery cache memory leak (template is now redundant after linking)
    popupEl.remove();

    if (appendToBody) {
      $document.find('body').append($popup);
    } else {
      $element.after($popup);
    }

    $scope.$on('$destroy', function() {
      if ($scope.isOpen === true) {
        if (!$rootScope.$$phase) {
          $scope.$apply(function() {
            $scope.isOpen = false;
          });
        }
      }

      $popup.remove();
      $element.off('keydown', inputKeydownBind);
      $document.off('click', documentClickBind);
      if (scrollParentEl) {
        scrollParentEl.off('scroll', positionPopup);
      }
      angular.element($window).off('resize', positionPopup);

      //Clear all watch listeners on destroy
      while (watchListeners.length) {
        watchListeners.shift()();
      }
    });
  };

  $scope.getText = function(key) {
    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
  };

  $scope.isDisabled = function(date) {
    if (date === 'today') {
      date = dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));
    }

    var dates = {};
    angular.forEach(['minDate', 'maxDate'], function(key) {
      if (!$scope.datepickerOptions[key]) {
        dates[key] = null;
      } else if (angular.isDate($scope.datepickerOptions[key])) {
        dates[key] = new Date($scope.datepickerOptions[key]);
      } else {
        if ($datepickerPopupLiteralWarning) {
          $log.warn('Literal date support has been deprecated, please switch to date object usage');
        }

        dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
      }
    });

    return $scope.datepickerOptions &&
      dates.minDate && $scope.compare(date, dates.minDate) < 0 ||
      dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
  };

  $scope.compare = function(date1, date2) {
    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
  };

  // Inner change
  $scope.dateSelection = function(dt) {
    $scope.date = dt;
    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
    $element.val(date);
    ngModel.$setViewValue(date);

    if (closeOnDateSelection) {
      $scope.isOpen = false;
      $element[0].focus();
    }
  };

  $scope.keydown = function(evt) {
    if (evt.which === 27) {
      evt.stopPropagation();
      $scope.isOpen = false;
      $element[0].focus();
    }
  };

  $scope.select = function(date, evt) {
    evt.stopPropagation();

    if (date === 'today') {
      var today = new Date();
      if (angular.isDate($scope.date)) {
        date = new Date($scope.date);
        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
      } else {
        date = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));
        date.setHours(0, 0, 0, 0);
      }
    }
    $scope.dateSelection(date);
  };

  $scope.close = function(evt) {
    evt.stopPropagation();

    $scope.isOpen = false;
    $element[0].focus();
  };

  $scope.disabled = angular.isDefined($attrs.disabled) || false;
  if ($attrs.ngDisabled) {
    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {
      $scope.disabled = disabled;
    }));
  }

  $scope.$watch('isOpen', function(value) {
    if (value) {
      if (!$scope.disabled) {
        $timeout(function() {
          positionPopup();

          if (onOpenFocus) {
            $scope.$broadcast('uib:datepicker.focus');
          }

          $document.on('click', documentClickBind);

          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
          if (appendToBody || $position.parsePlacement(placement)[2]) {
            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
            if (scrollParentEl) {
              scrollParentEl.on('scroll', positionPopup);
            }
          } else {
            scrollParentEl = null;
          }

          angular.element($window).on('resize', positionPopup);
        }, 0, false);
      } else {
        $scope.isOpen = false;
      }
    } else {
      $document.off('click', documentClickBind);
      if (scrollParentEl) {
        scrollParentEl.off('scroll', positionPopup);
      }
      angular.element($window).off('resize', positionPopup);
    }
  });

  function cameltoDash(string) {
    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
  }

  function parseDateString(viewValue) {
    var date = dateParser.parse(viewValue, dateFormat, $scope.date);
    if (isNaN(date)) {
      for (var i = 0; i < altInputFormats.length; i++) {
        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
        if (!isNaN(date)) {
          return date;
        }
      }
    }
    return date;
  }

  function parseDate(viewValue) {
    if (angular.isNumber(viewValue)) {
      // presumably timestamp to date object
      viewValue = new Date(viewValue);
    }

    if (!viewValue) {
      return null;
    }

    if (angular.isDate(viewValue) && !isNaN(viewValue)) {
      return viewValue;
    }

    if (angular.isString(viewValue)) {
      var date = parseDateString(viewValue);
      if (!isNaN(date)) {
        return dateParser.toTimezone(date, ngModelOptions.getOption('timezone'));
      }
    }

    return ngModelOptions.getOption('allowInvalid') ? viewValue : undefined;
  }

  function validator(modelValue, viewValue) {
    var value = modelValue || viewValue;

    if (!$attrs.ngRequired && !value) {
      return true;
    }

    if (angular.isNumber(value)) {
      value = new Date(value);
    }

    if (!value) {
      return true;
    }

    if (angular.isDate(value) && !isNaN(value)) {
      return true;
    }

    if (angular.isString(value)) {
      return !isNaN(parseDateString(value));
    }

    return false;
  }

  function documentClickBind(event) {
    if (!$scope.isOpen && $scope.disabled) {
      return;
    }

    var popup = $popup[0];
    var dpContainsTarget = $element[0].contains(event.target);
    // The popup node may not be an element node
    // In some browsers (IE) only element nodes have the 'contains' function
    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
    if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
      $scope.$apply(function() {
        $scope.isOpen = false;
      });
    }
  }

  function inputKeydownBind(evt) {
    if (evt.which === 27 && $scope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.$apply(function() {
        $scope.isOpen = false;
      });
      $element[0].focus();
    } else if (evt.which === 40 && !$scope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.$apply(function() {
        $scope.isOpen = true;
      });
    }
  }

  function positionPopup() {
    if ($scope.isOpen) {
      var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
      var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
      var position = $position.positionElements($element, dpElement, placement, appendToBody);
      dpElement.css({top: position.top + 'px', left: position.left + 'px'});
      if (dpElement.hasClass('uib-position-measure')) {
        dpElement.removeClass('uib-position-measure');
      }
    }
  }

  function extractOptions(ngModelCtrl) {
    var ngModelOptions;

    if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing
      // guarantee a value
      ngModelOptions = angular.isObject(ngModelCtrl.$options) ?
        ngModelCtrl.$options :
        {
          timezone: null
        };

      // mimic 1.6+ api
      ngModelOptions.getOption = function (key) {
        return ngModelOptions[key];
      };
    } else { // in angular >=1.6 $options is always present
      ngModelOptions = ngModelCtrl.$options;
    }

    return ngModelOptions;
  }

  $scope.$on('uib:datepicker.mode', function() {
    $timeout(positionPopup, 0, false);
  });
}])

.directive('uibDatepickerPopup', function() {
  return {
    require: ['ngModel', 'uibDatepickerPopup'],
    controller: 'UibDatepickerPopupController',
    scope: {
      datepickerOptions: '=?',
      isOpen: '=?',
      currentText: '@',
      clearText: '@',
      closeText: '@'
    },
    link: function(scope, element, attrs, ctrls) {
      var ngModel = ctrls[0],
        ctrl = ctrls[1];

      ctrl.init(ngModel);
    }
  };
})

.directive('uibDatepickerPopupWrap', function() {
  return {
    restrict: 'A',
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
    }
  };
});

angular.module('ui.bootstrap.debounce', [])
/**
 * A helper, internal service that debounces a function
 */
  .factory('$$debounce', ['$timeout', function($timeout) {
    return function(callback, debounceTime) {
      var timeoutPromise;

      return function() {
        var self = this;
        var args = Array.prototype.slice.call(arguments);
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }

        timeoutPromise = $timeout(function() {
          callback.apply(self, args);
        }, debounceTime);
      };
    };
  }]);

angular.module('ui.bootstrap.multiMap', [])
/**
 * A helper, internal data structure that stores all references attached to key
 */
  .factory('$$multiMap', function() {
    return {
      createNew: function() {
        var map = {};

        return {
          entries: function() {
            return Object.keys(map).map(function(key) {
              return {
                key: key,
                value: map[key]
              };
            });
          },
          get: function(key) {
            return map[key];
          },
          hasKey: function(key) {
            return !!map[key];
          },
          keys: function() {
            return Object.keys(map);
          },
          put: function(key, value) {
            if (!map[key]) {
              map[key] = [];
            }

            map[key].push(value);
          },
          remove: function(key, value) {
            var values = map[key];

            if (!values) {
              return;
            }

            var idx = values.indexOf(value);

            if (idx !== -1) {
              values.splice(idx, 1);
            }

            if (!values.length) {
              delete map[key];
            }
          }
        };
      }
    };
  });

angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.multiMap', 'ui.bootstrap.position'])

.constant('uibDropdownConfig', {
  appendToOpenClass: 'uib-dropdown-open',
  openClass: 'open'
})

.service('uibDropdownService', ['$document', '$rootScope', '$$multiMap', function($document, $rootScope, $$multiMap) {
  var openScope = null;
  var openedContainers = $$multiMap.createNew();

  this.isOnlyOpen = function(dropdownScope, appendTo) {
    var openedDropdowns = openedContainers.get(appendTo);
    if (openedDropdowns) {
      var openDropdown = openedDropdowns.reduce(function(toClose, dropdown) {
        if (dropdown.scope === dropdownScope) {
          return dropdown;
        }

        return toClose;
      }, {});
      if (openDropdown) {
        return openedDropdowns.length === 1;
      }
    }

    return false;
  };

  this.open = function(dropdownScope, element, appendTo) {
    if (!openScope) {
      $document.on('click', closeDropdown);
    }

    if (openScope && openScope !== dropdownScope) {
      openScope.isOpen = false;
    }

    openScope = dropdownScope;

    if (!appendTo) {
      return;
    }

    var openedDropdowns = openedContainers.get(appendTo);
    if (openedDropdowns) {
      var openedScopes = openedDropdowns.map(function(dropdown) {
        return dropdown.scope;
      });
      if (openedScopes.indexOf(dropdownScope) === -1) {
        openedContainers.put(appendTo, {
          scope: dropdownScope
        });
      }
    } else {
      openedContainers.put(appendTo, {
        scope: dropdownScope
      });
    }
  };

  this.close = function(dropdownScope, element, appendTo) {
    if (openScope === dropdownScope) {
      $document.off('click', closeDropdown);
      $document.off('keydown', this.keybindFilter);
      openScope = null;
    }

    if (!appendTo) {
      return;
    }

    var openedDropdowns = openedContainers.get(appendTo);
    if (openedDropdowns) {
      var dropdownToClose = openedDropdowns.reduce(function(toClose, dropdown) {
        if (dropdown.scope === dropdownScope) {
          return dropdown;
        }

        return toClose;
      }, {});
      if (dropdownToClose) {
        openedContainers.remove(appendTo, dropdownToClose);
      }
    }
  };

  var closeDropdown = function(evt) {
    // This method may still be called during the same mouse event that
    // unbound this event handler. So check openScope before proceeding.
    if (!openScope || !openScope.isOpen) { return; }

    if (evt && openScope.getAutoClose() === 'disabled') { return; }

    if (evt && evt.which === 3) { return; }

    var toggleElement = openScope.getToggleElement();
    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
      return;
    }

    var dropdownElement = openScope.getDropdownElement();
    if (evt && openScope.getAutoClose() === 'outsideClick' &&
      dropdownElement && dropdownElement[0].contains(evt.target)) {
      return;
    }

    openScope.focusToggleElement();
    openScope.isOpen = false;

    if (!$rootScope.$$phase) {
      openScope.$apply();
    }
  };

  this.keybindFilter = function(evt) {
    if (!openScope) {
      // see this.close as ESC could have been pressed which kills the scope so we can not proceed
      return;
    }

    var dropdownElement = openScope.getDropdownElement();
    var toggleElement = openScope.getToggleElement();
    var dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target);
    var toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);
    if (evt.which === 27) {
      evt.stopPropagation();
      openScope.focusToggleElement();
      closeDropdown();
    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted)) {
      evt.preventDefault();
      evt.stopPropagation();
      openScope.focusDropdownEntry(evt.which);
    }
  };
}])

.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
  var self = this,
    scope = $scope.$new(), // create a child scope so we are not polluting original one
    templateScope,
    appendToOpenClass = dropdownConfig.appendToOpenClass,
    openClass = dropdownConfig.openClass,
    getIsOpen,
    setIsOpen = angular.noop,
    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
    keynavEnabled = false,
    selectedOption = null,
    body = $document.find('body');

  $element.addClass('dropdown');

  this.init = function() {
    if ($attrs.isOpen) {
      getIsOpen = $parse($attrs.isOpen);
      setIsOpen = getIsOpen.assign;

      $scope.$watch(getIsOpen, function(value) {
        scope.isOpen = !!value;
      });
    }

    keynavEnabled = angular.isDefined($attrs.keyboardNav);
  };

  this.toggle = function(open) {
    scope.isOpen = arguments.length ? !!open : !scope.isOpen;
    if (angular.isFunction(setIsOpen)) {
      setIsOpen(scope, scope.isOpen);
    }

    return scope.isOpen;
  };

  // Allow other directives to watch status
  this.isOpen = function() {
    return scope.isOpen;
  };

  scope.getToggleElement = function() {
    return self.toggleElement;
  };

  scope.getAutoClose = function() {
    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
  };

  scope.getElement = function() {
    return $element;
  };

  scope.isKeynavEnabled = function() {
    return keynavEnabled;
  };

  scope.focusDropdownEntry = function(keyCode) {
    var elems = self.dropdownMenu ? //If append to body is used.
      angular.element(self.dropdownMenu).find('a') :
      $element.find('ul').eq(0).find('a');

    switch (keyCode) {
      case 40: {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = 0;
        } else {
          self.selectedOption = self.selectedOption === elems.length - 1 ?
            self.selectedOption :
            self.selectedOption + 1;
        }
        break;
      }
      case 38: {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = elems.length - 1;
        } else {
          self.selectedOption = self.selectedOption === 0 ?
            0 : self.selectedOption - 1;
        }
        break;
      }
    }
    elems[self.selectedOption].focus();
  };

  scope.getDropdownElement = function() {
    return self.dropdownMenu;
  };

  scope.focusToggleElement = function() {
    if (self.toggleElement) {
      self.toggleElement[0].focus();
    }
  };

  function removeDropdownMenu() {
    $element.append(self.dropdownMenu);
  }

  scope.$watch('isOpen', function(isOpen, wasOpen) {
    var appendTo = null,
      appendToBody = false;

    if (angular.isDefined($attrs.dropdownAppendTo)) {
      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
      if (appendToEl) {
        appendTo = angular.element(appendToEl);
      }
    }

    if (angular.isDefined($attrs.dropdownAppendToBody)) {
      var appendToBodyValue = $parse($attrs.dropdownAppendToBody)(scope);
      if (appendToBodyValue !== false) {
        appendToBody = true;
      }
    }

    if (appendToBody && !appendTo) {
      appendTo = body;
    }

    if (appendTo && self.dropdownMenu) {
      if (isOpen) {
        appendTo.append(self.dropdownMenu);
        $element.on('$destroy', removeDropdownMenu);
      } else {
        $element.off('$destroy', removeDropdownMenu);
        removeDropdownMenu();
      }
    }

    if (appendTo && self.dropdownMenu) {
      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
        css,
        rightalign,
        scrollbarPadding,
        scrollbarWidth = 0;

      css = {
        top: pos.top + 'px',
        display: isOpen ? 'block' : 'none'
      };

      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
      if (!rightalign) {
        css.left = pos.left + 'px';
        css.right = 'auto';
      } else {
        css.left = 'auto';
        scrollbarPadding = $position.scrollbarPadding(appendTo);

        if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
          scrollbarWidth = scrollbarPadding.scrollbarWidth;
        }

        css.right = window.innerWidth - scrollbarWidth -
          (pos.left + $element.prop('offsetWidth')) + 'px';
      }

      // Need to adjust our positioning to be relative to the appendTo container
      // if it's not the body element
      if (!appendToBody) {
        var appendOffset = $position.offset(appendTo);

        css.top = pos.top - appendOffset.top + 'px';

        if (!rightalign) {
          css.left = pos.left - appendOffset.left + 'px';
        } else {
          css.right = window.innerWidth -
            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
        }
      }

      self.dropdownMenu.css(css);
    }

    var openContainer = appendTo ? appendTo : $element;
    var dropdownOpenClass = appendTo ? appendToOpenClass : openClass;
    var hasOpenClass = openContainer.hasClass(dropdownOpenClass);
    var isOnlyOpen = uibDropdownService.isOnlyOpen($scope, appendTo);

    if (hasOpenClass === !isOpen) {
      var toggleClass;
      if (appendTo) {
        toggleClass = !isOnlyOpen ? 'addClass' : 'removeClass';
      } else {
        toggleClass = isOpen ? 'addClass' : 'removeClass';
      }
      $animate[toggleClass](openContainer, dropdownOpenClass).then(function() {
        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
          toggleInvoker($scope, { open: !!isOpen });
        }
      });
    }

    if (isOpen) {
      if (self.dropdownMenuTemplateUrl) {
        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
          templateScope = scope.$new();
          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
            var newEl = dropdownElement;
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
            $document.on('keydown', uibDropdownService.keybindFilter);
          });
        });
      } else {
        $document.on('keydown', uibDropdownService.keybindFilter);
      }

      scope.focusToggleElement();
      uibDropdownService.open(scope, $element, appendTo);
    } else {
      uibDropdownService.close(scope, $element, appendTo);
      if (self.dropdownMenuTemplateUrl) {
        if (templateScope) {
          templateScope.$destroy();
        }
        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
        self.dropdownMenu.replaceWith(newEl);
        self.dropdownMenu = newEl;
      }

      self.selectedOption = null;
    }

    if (angular.isFunction(setIsOpen)) {
      setIsOpen($scope, isOpen);
    }
  });
}])

.directive('uibDropdown', function() {
  return {
    controller: 'UibDropdownController',
    link: function(scope, element, attrs, dropdownCtrl) {
      dropdownCtrl.init();
    }
  };
})

.directive('uibDropdownMenu', function() {
  return {
    restrict: 'A',
    require: '?^uibDropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
        return;
      }

      element.addClass('dropdown-menu');

      var tplUrl = attrs.templateUrl;
      if (tplUrl) {
        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
      }

      if (!dropdownCtrl.dropdownMenu) {
        dropdownCtrl.dropdownMenu = element;
      }
    }
  };
})

.directive('uibDropdownToggle', function() {
  return {
    require: '?^uibDropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl) {
        return;
      }

      element.addClass('dropdown-toggle');

      dropdownCtrl.toggleElement = element;

      var toggleDropdown = function(event) {
        event.preventDefault();

        if (!element.hasClass('disabled') && !attrs.disabled) {
          scope.$apply(function() {
            dropdownCtrl.toggle();
          });
        }
      };

      element.on('click', toggleDropdown);

      // WAI-ARIA
      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
        element.attr('aria-expanded', !!isOpen);
      });

      scope.$on('$destroy', function() {
        element.off('click', toggleDropdown);
      });
    }
  };
});

angular.module('ui.bootstrap.stackedMap', [])
/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory('$$stackedMap', function() {
    return {
      createNew: function() {
        var stack = [];

        return {
          add: function(key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function(key) {
            for (var i = 0; i < stack.length; i++) {
              if (key === stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function() {
            return stack[stack.length - 1];
          },
          remove: function(key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key === stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function() {
            return stack.pop();
          },
          length: function() {
            return stack.length;
          }
        };
      }
    };
  });
angular.module('ui.bootstrap.modal', ['ui.bootstrap.multiMap', 'ui.bootstrap.stackedMap', 'ui.bootstrap.position'])
/**
 * Pluggable resolve mechanism for the modal resolve resolution
 * Supports UI Router's $resolve service
 */
  .provider('$uibResolve', function() {
    var resolve = this;
    this.resolver = null;

    this.setResolver = function(resolver) {
      this.resolver = resolver;
    };

    this.$get = ['$injector', '$q', function($injector, $q) {
      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
      return {
        resolve: function(invocables, locals, parent, self) {
          if (resolver) {
            return resolver.resolve(invocables, locals, parent, self);
          }

          var promises = [];

          angular.forEach(invocables, function(value) {
            if (angular.isFunction(value) || angular.isArray(value)) {
              promises.push($q.resolve($injector.invoke(value)));
            } else if (angular.isString(value)) {
              promises.push($q.resolve($injector.get(value)));
            } else {
              promises.push($q.resolve(value));
            }
          });

          return $q.all(promises).then(function(resolves) {
            var resolveObj = {};
            var resolveIter = 0;
            angular.forEach(invocables, function(value, key) {
              resolveObj[key] = resolves[resolveIter++];
            });

            return resolveObj;
          });
        }
      };
    }];
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',
  function($animate, $injector, $modalStack) {
    return {
      restrict: 'A',
      compile: function(tElement, tAttrs) {
        tElement.addClass(tAttrs.backdropClass);
        return linkFn;
      }
    };

    function linkFn(scope, element, attrs) {
      if (attrs.modalInClass) {
        $animate.addClass(element, attrs.modalInClass);

        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
          var done = setIsAsync();
          if (scope.modalOptions.animation) {
            $animate.removeClass(element, attrs.modalInClass).then(done);
          } else {
            done();
          }
        });
      }
    }
  }])

  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',
  function($modalStack, $q, $animateCss, $document) {
    return {
      scope: {
        index: '@'
      },
      restrict: 'A',
      transclude: true,
      templateUrl: function(tElement, tAttrs) {
        return tAttrs.templateUrl || 'uib/template/modal/window.html';
      },
      link: function(scope, element, attrs) {
        element.addClass(attrs.windowTopClass || '');
        scope.size = attrs.size;

        scope.close = function(evt) {
          var modal = $modalStack.getTop();
          if (modal && modal.value.backdrop &&
            modal.value.backdrop !== 'static' &&
            evt.target === evt.currentTarget) {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, 'backdrop click');
          }
        };

        // moved from template to fix issue #2280
        element.on('click', scope.close);

        // This property is only added to the scope for the purpose of detecting when this directive is rendered.
        // We can detect that by using this property in the template associated with this directive and then use
        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
        scope.$isRendered = true;

        // Deferred object that will be resolved when this modal is rendered.
        var modalRenderDeferObj = $q.defer();
        // Resolve render promise post-digest
        scope.$$postDigest(function() {
          modalRenderDeferObj.resolve();
        });

        modalRenderDeferObj.promise.then(function() {
          var animationPromise = null;

          if (attrs.modalInClass) {
            animationPromise = $animateCss(element, {
              addClass: attrs.modalInClass
            }).start();

            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
              var done = setIsAsync();
              $animateCss(element, {
                removeClass: attrs.modalInClass
              }).start().then(done);
            });
          }


          $q.when(animationPromise).then(function() {
            // Notify {@link $modalStack} that modal is rendered.
            var modal = $modalStack.getTop();
            if (modal) {
              $modalStack.modalRendered(modal.key);
            }

            /**
             * If something within the freshly-opened modal already has focus (perhaps via a
             * directive that causes focus) then there's no need to try to focus anything.
             */
            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
              var inputWithAutofocus = element[0].querySelector('[autofocus]');
              /**
               * Auto-focusing of a freshly-opened modal element causes any child elements
               * with the autofocus attribute to lose focus. This is an issue on touch
               * based devices which will show and then hide the onscreen keyboard.
               * Attempts to refocus the autofocus element via JavaScript will not reopen
               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
               * the modal element if the modal does not contain an autofocus element.
               */
              if (inputWithAutofocus) {
                inputWithAutofocus.focus();
              } else {
                element[0].focus();
              }
            }
          });
        });
      }
    };
  }])

  .directive('uibModalAnimationClass', function() {
    return {
      compile: function(tElement, tAttrs) {
        if (tAttrs.modalAnimation) {
          tElement.addClass(tAttrs.uibModalAnimationClass);
        }
      }
    };
  })

  .directive('uibModalTransclude', ['$animate', function($animate) {
    return {
      link: function(scope, element, attrs, controller, transclude) {
        transclude(scope.$parent, function(clone) {
          element.empty();
          $animate.enter(clone, element);
        });
      }
    };
  }])

  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',
    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',
    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
      var OPENED_MODAL_CLASS = 'modal-open';

      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {
        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
      };
      var topModalIndex = 0;
      var previousTopOpenedModal = null;
      var ARIA_HIDDEN_ATTRIBUTE_NAME = 'data-bootstrap-modal-aria-hidden-count';

      //Modal focus behavior
      var tabbableSelector = 'a[href], area[href], input:not([disabled]):not([tabindex=\'-1\']), ' +
        'button:not([disabled]):not([tabindex=\'-1\']),select:not([disabled]):not([tabindex=\'-1\']), textarea:not([disabled]):not([tabindex=\'-1\']), ' +
        'iframe, object, embed, *[tabindex]:not([tabindex=\'-1\']), *[contenteditable=true]';
      var scrollbarPadding;
      var SNAKE_CASE_REGEXP = /[A-Z]/g;

      // TODO: extract into common dependency with tooltip
      function snake_case(name) {
        var separator = '-';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }

      function isVisible(element) {
        return !!(element.offsetWidth ||
          element.offsetHeight ||
          element.getClientRects().length);
      }

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }

        // If any backdrop exist, ensure that it's index is always
        // right below the top modal
        if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
          topBackdropIndex = topModalIndex;
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value;
        var appendToElement = modalWindow.appendTo;

        //clean up the stack
        openedWindows.remove(modalInstance);
        previousTopOpenedModal = openedWindows.top();
        if (previousTopOpenedModal) {
          topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
        }

        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          var areAnyOpen = openedClasses.hasKey(modalBodyClass);
          appendToElement.toggleClass(modalBodyClass, areAnyOpen);
          if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
            if (scrollbarPadding.originalRight) {
              appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});
            } else {
              appendToElement.css({paddingRight: ''});
            }
            scrollbarPadding = null;
          }
          toggleTopWindowClass(true);
        }, modalWindow.closedDeferred);
        checkRemoveBackdrop();

        //move focus to specified element if available, or else to body
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else if (appendToElement.focus) {
          appendToElement.focus();
        }
      }

      // Add or remove "windowTopClass" from the top window in the stack
      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;

        if (openedWindows.length() > 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
        }
      }

      function checkRemoveBackdrop() {
        //remove backdrop if no longer needed
        if (backdropDomEl && backdropIndex() === -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function() {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }

      function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }

          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

        // Note that it's intentional that asyncPromise might be null.
        // That's when setIsAsync has not been called during the
        // NOW_CLOSING_EVENT broadcast.
        return $q.when(asyncPromise).then(afterAnimating);

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;

          $animate.leave(domEl).then(function() {
            if (done) {
              done();
            }

            domEl.remove();
            if (closedDeferred) {
              closedDeferred.resolve();
            }
          });

          scope.$destroy();
        }
      }

      $document.on('keydown', keydownListener);

      $rootScope.$on('$destroy', function() {
        $document.off('keydown', keydownListener);
      });

      function keydownListener(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }

        var modal = openedWindows.top();
        if (modal) {
          switch (evt.which) {
            case 27: {
              if (modal.value.keyboard) {
                evt.preventDefault();
                $rootScope.$apply(function() {
                  $modalStack.dismiss(modal.key, 'escape key press');
                });
              }
              break;
            }
            case 9: {
              var list = $modalStack.loadFocusElementList(modal);
              var focusChanged = false;
              if (evt.shiftKey) {
                if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
                  focusChanged = $modalStack.focusLastFocusableElement(list);
                }
              } else {
                if ($modalStack.isFocusInLastItem(evt, list)) {
                  focusChanged = $modalStack.focusFirstFocusableElement(list);
                }
              }

              if (focusChanged) {
                evt.preventDefault();
                evt.stopPropagation();
              }

              break;
            }
          }
        }
      }

      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

        toggleTopWindowClass(false);

        // Store the current top first, to determine what index we ought to use
        // for the current top modal
        previousTopOpenedModal = openedWindows.top();

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          closedDeferred: modal.closedDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass,
          animation: modal.animation,
          appendTo: modal.appendTo
        });

        openedClasses.put(modalBodyClass, modalInstance);

        var appendToElement = modal.appendTo,
            currBackdropIndex = backdropIndex();

        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.modalOptions = modal;
          backdropScope.index = currBackdropIndex;
          backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
          backdropDomEl.attr({
            'class': 'modal-backdrop',
            'ng-style': '{\'z-index\': 1040 + (index && 1 || 0) + index*10}',
            'uib-modal-animation-class': 'fade',
            'modal-in-class': 'in'
          });
          if (modal.backdropClass) {
            backdropDomEl.addClass(modal.backdropClass);
          }

          if (modal.animation) {
            backdropDomEl.attr('modal-animation', 'true');
          }
          $compile(backdropDomEl)(backdropScope);
          $animate.enter(backdropDomEl, appendToElement);
          if ($uibPosition.isScrollable(appendToElement)) {
            scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
            if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
              appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});
            }
          }
        }

        var content;
        if (modal.component) {
          content = document.createElement(snake_case(modal.component.name));
          content = angular.element(content);
          content.attr({
            resolve: '$resolve',
            'modal-instance': '$uibModalInstance',
            close: '$close($value)',
            dismiss: '$dismiss($value)'
          });
        } else {
          content = modal.content;
        }

        // Set the top modal index based on the index of the previous top modal
        topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
          'class': 'modal',
          'template-url': modal.windowTemplateUrl,
          'window-top-class': modal.windowTopClass,
          'role': 'dialog',
          'aria-labelledby': modal.ariaLabelledBy,
          'aria-describedby': modal.ariaDescribedBy,
          'size': modal.size,
          'index': topModalIndex,
          'animate': 'animate',
          'ng-style': '{\'z-index\': 1050 + $$topModalIndex*10, display: \'block\'}',
          'tabindex': -1,
          'uib-modal-animation-class': 'fade',
          'modal-in-class': 'in'
        }).append(content);
        if (modal.windowClass) {
          angularDomEl.addClass(modal.windowClass);
        }

        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }

        appendToElement.addClass(modalBodyClass);
        if (modal.scope) {
          // we need to explicitly add the modal index to the modal scope
          // because it is needed by ngStyle to compute the zIndex property.
          modal.scope.$$topModalIndex = topModalIndex;
        }
        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);

        openedWindows.top().value.modalDomEl = angularDomEl;
        openedWindows.top().value.modalOpener = modalOpener;

        applyAriaHidden(angularDomEl);

        function applyAriaHidden(el) {
          if (!el || el[0].tagName === 'BODY') {
            return;
          }

          getSiblings(el).forEach(function(sibling) {
            var elemIsAlreadyHidden = sibling.getAttribute('aria-hidden') === 'true',
              ariaHiddenCount = parseInt(sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10);

            if (!ariaHiddenCount) {
              ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0;
            }

            sibling.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, ariaHiddenCount + 1);
            sibling.setAttribute('aria-hidden', 'true');
          });

          return applyAriaHidden(el.parent());

          function getSiblings(el) {
            var children = el.parent() ? el.parent().children() : [];

            return Array.prototype.filter.call(children, function(child) {
              return child !== el[0];
            });
          }
        }
      };

      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }

      function unhideBackgroundElements() {
        Array.prototype.forEach.call(
          document.querySelectorAll('[' + ARIA_HIDDEN_ATTRIBUTE_NAME + ']'),
          function(hiddenEl) {
            var ariaHiddenCount = parseInt(hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10),
              newHiddenCount = ariaHiddenCount - 1;
            hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount);

            if (!newHiddenCount) {
              hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME);
              hiddenEl.removeAttribute('aria-hidden');
            }
          }
        );
      }

      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        unhideBackgroundElements();
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }

        return !modalWindow;
      };

      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        unhideBackgroundElements();
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };

      $modalStack.getTop = function() {
        return openedWindows.top();
      };

      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };

      $modalStack.focusFirstFocusableElement = function(list) {
        if (list.length > 0) {
          list[0].focus();
          return true;
        }
        return false;
      };

      $modalStack.focusLastFocusableElement = function(list) {
        if (list.length > 0) {
          list[list.length - 1].focus();
          return true;
        }
        return false;
      };

      $modalStack.isModalFocused = function(evt, modalWindow) {
        if (evt && modalWindow) {
          var modalDomEl = modalWindow.value.modalDomEl;
          if (modalDomEl && modalDomEl.length) {
            return (evt.target || evt.srcElement) === modalDomEl[0];
          }
        }
        return false;
      };

      $modalStack.isFocusInFirstItem = function(evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[0];
        }
        return false;
      };

      $modalStack.isFocusInLastItem = function(evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[list.length - 1];
        }
        return false;
      };

      $modalStack.loadFocusElementList = function(modalWindow) {
        if (modalWindow) {
          var modalDomE1 = modalWindow.value.modalDomEl;
          if (modalDomE1 && modalDomE1.length) {
            var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
            return elements ?
              Array.prototype.filter.call(elements, function(element) {
                return isVisible(element);
              }) : elements;
          }
        }
      };

      return $modalStack;
    }])

  .provider('$uibModal', function() {
    var $modalProvider = {
      options: {
        animation: true,
        backdrop: true, //can also be false or 'static'
        keyboard: true
      },
      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',
        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $templateRequest(angular.isFunction(options.templateUrl) ?
                options.templateUrl() : options.templateUrl);
          }

          var promiseChain = null;
          $modal.getPromiseChain = function() {
            return promiseChain;
          };

          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalClosedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              closed: modalClosedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function (result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);

            if (!modalOptions.appendTo.length) {
              throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
            }

            //verify options
            if (!modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of component or template or templateUrl options is required.');
            }

            var templateAndResolvePromise;
            if (modalOptions.component) {
              templateAndResolvePromise = $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null));
            } else {
              templateAndResolvePromise =
                $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);
            }

            function resolveWithTemplate() {
              return templateAndResolvePromise;
            }

            // Wait for the resolution of the existing promise chain.
            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
            // Then add to $modalStack and resolve opened.
            // Finally clean up the chain variable if no subsequent modal has overwritten it.
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain])
              .then(resolveWithTemplate, resolveWithTemplate)
              .then(function resolveSuccess(tplAndVars) {
                var providedScope = modalOptions.scope || $rootScope;

                var modalScope = providedScope.$new();
                modalScope.$close = modalInstance.close;
                modalScope.$dismiss = modalInstance.dismiss;

                modalScope.$on('$destroy', function() {
                  if (!modalScope.$$uibDestructionScheduled) {
                    modalScope.$dismiss('$uibUnscheduledDestruction');
                  }
                });

                var modal = {
                  scope: modalScope,
                  deferred: modalResultDeferred,
                  renderDeferred: modalRenderDeferred,
                  closedDeferred: modalClosedDeferred,
                  animation: modalOptions.animation,
                  backdrop: modalOptions.backdrop,
                  keyboard: modalOptions.keyboard,
                  backdropClass: modalOptions.backdropClass,
                  windowTopClass: modalOptions.windowTopClass,
                  windowClass: modalOptions.windowClass,
                  windowTemplateUrl: modalOptions.windowTemplateUrl,
                  ariaLabelledBy: modalOptions.ariaLabelledBy,
                  ariaDescribedBy: modalOptions.ariaDescribedBy,
                  size: modalOptions.size,
                  openedClass: modalOptions.openedClass,
                  appendTo: modalOptions.appendTo
                };

                var component = {};
                var ctrlInstance, ctrlInstantiate, ctrlLocals = {};

                if (modalOptions.component) {
                  constructLocals(component, false, true, false);
                  component.name = modalOptions.component;
                  modal.component = component;
                } else if (modalOptions.controller) {
                  constructLocals(ctrlLocals, true, false, true);

                  // the third param will make the controller instantiate later,private api
                  // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126
                  ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);
                  if (modalOptions.controllerAs && modalOptions.bindToController) {
                    ctrlInstance = ctrlInstantiate.instance;
                    ctrlInstance.$close = modalScope.$close;
                    ctrlInstance.$dismiss = modalScope.$dismiss;
                    angular.extend(ctrlInstance, {
                      $resolve: ctrlLocals.$scope.$resolve
                    }, providedScope);
                  }

                  ctrlInstance = ctrlInstantiate();

                  if (angular.isFunction(ctrlInstance.$onInit)) {
                    ctrlInstance.$onInit();
                  }
                }

                if (!modalOptions.component) {
                  modal.content = tplAndVars[0];
                }

                $modalStack.open(modalInstance, modal);
                modalOpenedDeferred.resolve(true);

                function constructLocals(obj, template, instanceOnScope, injectable) {
                  obj.$scope = modalScope;
                  obj.$scope.$resolve = {};
                  if (instanceOnScope) {
                    obj.$scope.$uibModalInstance = modalInstance;
                  } else {
                    obj.$uibModalInstance = modalInstance;
                  }

                  var resolves = template ? tplAndVars[1] : tplAndVars;
                  angular.forEach(resolves, function(value, key) {
                    if (injectable) {
                      obj[key] = value;
                    }

                    obj.$scope.$resolve[key] = value;
                  });
                }
            }, function resolveError(reason) {
              modalOpenedDeferred.reject(reason);
              modalResultDeferred.reject(reason);
            })['finally'](function() {
              if (promiseChain === samePromise) {
                promiseChain = null;
              }
            });

            return modalInstance;
          };

          return $modal;
        }
      ]
    };

    return $modalProvider;
  });

angular.module('ui.bootstrap.paging', [])
/**
 * Helper internal service for generating common controller code between the
 * pager and pagination components
 */
.factory('uibPaging', ['$parse', function($parse) {
  return {
    create: function(ctrl, $scope, $attrs) {
      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl
      ctrl._watchers = [];

      ctrl.init = function(ngModelCtrl, config) {
        ctrl.ngModelCtrl = ngModelCtrl;
        ctrl.config = config;

        ngModelCtrl.$render = function() {
          ctrl.render();
        };

        if ($attrs.itemsPerPage) {
          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {
            ctrl.itemsPerPage = parseInt(value, 10);
            $scope.totalPages = ctrl.calculateTotalPages();
            ctrl.updatePage();
          }));
        } else {
          ctrl.itemsPerPage = config.itemsPerPage;
        }

        $scope.$watch('totalItems', function(newTotal, oldTotal) {
          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
            $scope.totalPages = ctrl.calculateTotalPages();
            ctrl.updatePage();
          }
        });
      };

      ctrl.calculateTotalPages = function() {
        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
        return Math.max(totalPages || 0, 1);
      };

      ctrl.render = function() {
        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
      };

      $scope.selectPage = function(page, evt) {
        if (evt) {
          evt.preventDefault();
        }

        var clickAllowed = !$scope.ngDisabled || !evt;
        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
          if (evt && evt.target) {
            evt.target.blur();
          }
          ctrl.ngModelCtrl.$setViewValue(page);
          ctrl.ngModelCtrl.$render();
        }
      };

      $scope.getText = function(key) {
        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
      };

      $scope.noPrevious = function() {
        return $scope.page === 1;
      };

      $scope.noNext = function() {
        return $scope.page === $scope.totalPages;
      };

      ctrl.updatePage = function() {
        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable

        if ($scope.page > $scope.totalPages) {
          $scope.selectPage($scope.totalPages);
        } else {
          ctrl.ngModelCtrl.$render();
        }
      };

      $scope.$on('$destroy', function() {
        while (ctrl._watchers.length) {
          ctrl._watchers.shift()();
        }
      });
    }
  };
}]);

angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])

.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {
  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;

  uibPaging.create(this, $scope, $attrs);
}])

.constant('uibPagerConfig', {
  itemsPerPage: 10,
  previousText: '« Previous',
  nextText: 'Next »',
  align: true
})

.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {
  return {
    scope: {
      totalItems: '=',
      previousText: '@',
      nextText: '@',
      ngDisabled: '='
    },
    require: ['uibPager', '?ngModel'],
    restrict: 'A',
    controller: 'UibPagerController',
    controllerAs: 'pager',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/pager/pager.html';
    },
    link: function(scope, element, attrs, ctrls) {
      element.addClass('pager');
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
        return; // do nothing if no ng-model
      }

      paginationCtrl.init(ngModelCtrl, uibPagerConfig);
    }
  };
}]);

angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])
.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
  var ctrl = this;
  // Setup configuration parameters
  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,
    pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;
  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;
  $attrs.$set('role', 'menu');

  uibPaging.create(this, $scope, $attrs);

  if ($attrs.maxSize) {
    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
      maxSize = parseInt(value, 10);
      ctrl.render();
    }));
  }

  // Create page object used in template
  function makePage(number, text, isActive) {
    return {
      number: number,
      text: text,
      active: isActive
    };
  }

  function getPages(currentPage, totalPages) {
    var pages = [];

    // Default page limits
    var startPage = 1, endPage = totalPages;
    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

    // recompute if maxSize
    if (isMaxSized) {
      if (rotate) {
        // Current page is displayed in the middle of the visible ones
        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
        endPage = startPage + maxSize - 1;

        // Adjust if limit is exceeded
        if (endPage > totalPages) {
          endPage = totalPages;
          startPage = endPage - maxSize + 1;
        }
      } else {
        // Visible pages are paginated with maxSize
        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;

        // Adjust last page if limit is exceeded
        endPage = Math.min(startPage + maxSize - 1, totalPages);
      }
    }

    // Add page number links
    for (var number = startPage; number <= endPage; number++) {
      var page = makePage(number, pageLabel(number), number === currentPage);
      pages.push(page);
    }

    // Add links to move between page sets
    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
      if (startPage > 1) {
        if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning
        var previousPageSet = makePage(startPage - 1, '...', false);
        pages.unshift(previousPageSet);
      }
        if (boundaryLinkNumbers) {
          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential
            var secondPageLink = makePage(2, '2', false);
            pages.unshift(secondPageLink);
          }
          //add the first page
          var firstPageLink = makePage(1, '1', false);
          pages.unshift(firstPageLink);
        }
      }

      if (endPage < totalPages) {
        if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end
        var nextPageSet = makePage(endPage + 1, '...', false);
        pages.push(nextPageSet);
      }
        if (boundaryLinkNumbers) {
          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential
            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
            pages.push(secondToLastPageLink);
          }
          //add the last page
          var lastPageLink = makePage(totalPages, totalPages, false);
          pages.push(lastPageLink);
        }
      }
    }
    return pages;
  }

  var originalRender = this.render;
  this.render = function() {
    originalRender();
    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
      $scope.pages = getPages($scope.page, $scope.totalPages);
    }
  };
}])

.constant('uibPaginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  boundaryLinkNumbers: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true,
  forceEllipses: false
})

.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {
  return {
    scope: {
      totalItems: '=',
      firstText: '@',
      previousText: '@',
      nextText: '@',
      lastText: '@',
      ngDisabled:'='
    },
    require: ['uibPagination', '?ngModel'],
    restrict: 'A',
    controller: 'UibPaginationController',
    controllerAs: 'pagination',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/pagination/pagination.html';
    },
    link: function(scope, element, attrs, ctrls) {
      element.addClass('pagination');
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
    }
  };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider('$uibTooltip', function() {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: 'top',
    placementClassPrefix: '',
    animation: true,
    popupDelay: 0,
    popupCloseDelay: 0,
    useContentExp: false
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    'mouseenter': 'mouseleave',
    'click': 'click',
    'outsideClick': 'outsideClick',
    'focus': 'blur',
    'none': ''
  };

  // The options specified to the provider globally.
  var globalOptions = {};

  /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
	this.options = function(value) {
		angular.extend(globalOptions, value);
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( { 'openTrigger': 'closeTrigger' } );
   */
  this.setTriggers = function setTriggers(triggers) {
    angular.extend(triggerMap, triggers);
  };

  /**
   * This is a helper function for translating camel-case to snake_case.
   */
  function snake_case(name) {
    var regexp = /[A-Z]/g;
    var separator = '-';
    return name.replace(regexp, function(letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
    var openedTooltips = $$stackedMap.createNew();
    $document.on('keyup', keypressListener);

    $rootScope.$on('$destroy', function() {
      $document.off('keyup', keypressListener);
    });

    function keypressListener(e) {
      if (e.which === 27) {
        var last = openedTooltips.top();
        if (last) {
          last.value.close();
          last = null;
        }
      }
    }

    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
      options = angular.extend({}, defaultOptions, globalOptions, options);

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers(trigger) {
        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
        var hide = show.map(function(trigger) {
          return triggerMap[trigger] || trigger;
        });
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case(ttType);

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template =
        '<div '+ directiveName + '-popup ' +
          'uib-title="' + startSym + 'title' + endSym + '" ' +
          (options.useContentExp ?
            'content-exp="contentExp()" ' :
            'content="' + startSym + 'content' + endSym + '" ') +
          'origin-scope="origScope" ' +
          'class="uib-position-measure ' + prefix + '" ' +
          'tooltip-animation-class="fade"' +
          'uib-tooltip-classes ' +
          'ng-class="{ in: isOpen }" ' +
          '>' +
        '</div>';

      return {
        compile: function(tElem, tAttrs) {
          var tooltipLinker = $compile(template);

          return function link(scope, element, attrs, tooltipCtrl) {
            var tooltip;
            var tooltipLinkedScope;
            var transitionTimeout;
            var showTimeout;
            var hideTimeout;
            var positionTimeout;
            var adjustmentTimeout;
            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
            var triggers = getTriggers(undefined);
            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
            var ttScope = scope.$new(true);
            var repositionScheduled = false;
            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
            var observers = [];
            var lastPlacement;

            var positionTooltip = function() {
              // check if tooltip exists and is not empty
              if (!tooltip || !tooltip.html()) { return; }

              if (!positionTimeout) {
                positionTimeout = $timeout(function() {
                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                  var initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                  var elementPos = appendToBody ? $position.offset(element) : $position.position(element);
                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });
                  var placementClasses = ttPosition.placement.split('-');

                  if (!tooltip.hasClass(placementClasses[0])) {
                    tooltip.removeClass(lastPlacement.split('-')[0]);
                    tooltip.addClass(placementClasses[0]);
                  }

                  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
                    tooltip.removeClass(options.placementClassPrefix + lastPlacement);
                    tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
                  }

                  adjustmentTimeout = $timeout(function() {
                    var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');
                    var adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
                    if (adjustment) {
                      tooltip.css(adjustment);
                    }
                    adjustmentTimeout = null;
                  }, 0, false);

                  // first time through tt element will have the
                  // uib-position-measure class or if the placement
                  // has changed we need to position the arrow.
                  if (tooltip.hasClass('uib-position-measure')) {
                    $position.positionArrow(tooltip, ttPosition.placement);
                    tooltip.removeClass('uib-position-measure');
                  } else if (lastPlacement !== ttPosition.placement) {
                    $position.positionArrow(tooltip, ttPosition.placement);
                  }
                  lastPlacement = ttPosition.placement;

                  positionTimeout = null;
                }, 0, false);
              }
            };

            // Set up the correct scope to allow transclusion later
            ttScope.origScope = scope;

            // By default, the tooltip is not open.
            // TODO add ability to start tooltip opened
            ttScope.isOpen = false;

            function toggleTooltipBind() {
              if (!ttScope.isOpen) {
                showTooltipBind();
              } else {
                hideTooltipBind();
              }
            }

            // Show the tooltip with delay if specified, otherwise show it immediately
            function showTooltipBind() {
              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                return;
              }

              cancelHide();
              prepareTooltip();

              if (ttScope.popupDelay) {
                // Do nothing if the tooltip was already scheduled to pop-up.
                // This happens if show is triggered multiple times before any hide is triggered.
                if (!showTimeout) {
                  showTimeout = $timeout(show, ttScope.popupDelay, false);
                }
              } else {
                show();
              }
            }

            function hideTooltipBind() {
              cancelShow();

              if (ttScope.popupCloseDelay) {
                if (!hideTimeout) {
                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                }
              } else {
                hide();
              }
            }

            // Show the tooltip popup element.
            function show() {
              cancelShow();
              cancelHide();

              // Don't show empty tooltips.
              if (!ttScope.content) {
                return angular.noop;
              }

              createTooltip();

              // And show the tooltip.
              ttScope.$evalAsync(function() {
                ttScope.isOpen = true;
                assignIsOpen(true);
                positionTooltip();
              });
            }

            function cancelShow() {
              if (showTimeout) {
                $timeout.cancel(showTimeout);
                showTimeout = null;
              }

              if (positionTimeout) {
                $timeout.cancel(positionTimeout);
                positionTimeout = null;
              }
            }

            // Hide the tooltip popup element.
            function hide() {
              if (!ttScope) {
                return;
              }

              // First things first: we don't show it anymore.
              ttScope.$evalAsync(function() {
                if (ttScope) {
                  ttScope.isOpen = false;
                  assignIsOpen(false);
                  // And now we remove it from the DOM. However, if we have animation, we
                  // need to wait for it to expire beforehand.
                  // FIXME: this is a placeholder for a port of the transitions library.
                  // The fade transition in TWBS is 150ms.
                  if (ttScope.animation) {
                    if (!transitionTimeout) {
                      transitionTimeout = $timeout(removeTooltip, 150, false);
                    }
                  } else {
                    removeTooltip();
                  }
                }
              });
            }

            function cancelHide() {
              if (hideTimeout) {
                $timeout.cancel(hideTimeout);
                hideTimeout = null;
              }

              if (transitionTimeout) {
                $timeout.cancel(transitionTimeout);
                transitionTimeout = null;
              }
            }

            function createTooltip() {
              // There can only be one tooltip element per directive shown at once.
              if (tooltip) {
                return;
              }

              tooltipLinkedScope = ttScope.$new();
              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                if (appendToBody) {
                  $document.find('body').append(tooltip);
                } else {
                  element.after(tooltip);
                }
              });

              openedTooltips.add(ttScope, {
                close: hide
              });

              prepObservers();
            }

            function removeTooltip() {
              cancelShow();
              cancelHide();
              unregisterObservers();

              if (tooltip) {
                tooltip.remove();
                
                tooltip = null;
                if (adjustmentTimeout) {
                  $timeout.cancel(adjustmentTimeout);
                }
              }

              openedTooltips.remove(ttScope);
              
              if (tooltipLinkedScope) {
                tooltipLinkedScope.$destroy();
                tooltipLinkedScope = null;
              }
            }

            /**
             * Set the initial scope values. Once
             * the tooltip is created, the observers
             * will be added to keep things in sync.
             */
            function prepareTooltip() {
              ttScope.title = attrs[prefix + 'Title'];
              if (contentParse) {
                ttScope.content = contentParse(scope);
              } else {
                ttScope.content = attrs[ttType];
              }

              ttScope.popupClass = attrs[prefix + 'Class'];
              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
              var placement = $position.parsePlacement(ttScope.placement);
              lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];

              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
            }

            function assignIsOpen(isOpen) {
              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                isOpenParse.assign(scope, isOpen);
              }
            }

            ttScope.contentExp = function() {
              return ttScope.content;
            };

            /**
             * Observe the relevant attributes.
             */
            attrs.$observe('disabled', function(val) {
              if (val) {
                cancelShow();
              }

              if (val && ttScope.isOpen) {
                hide();
              }
            });

            if (isOpenParse) {
              scope.$watch(isOpenParse, function(val) {
                if (ttScope && !val === ttScope.isOpen) {
                  toggleTooltipBind();
                }
              });
            }

            function prepObservers() {
              observers.length = 0;

              if (contentParse) {
                observers.push(
                  scope.$watch(contentParse, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    }
                  })
                );

                observers.push(
                  tooltipLinkedScope.$watch(function() {
                    if (!repositionScheduled) {
                      repositionScheduled = true;
                      tooltipLinkedScope.$$postDigest(function() {
                        repositionScheduled = false;
                        if (ttScope && ttScope.isOpen) {
                          positionTooltip();
                        }
                      });
                    }
                  })
                );
              } else {
                observers.push(
                  attrs.$observe(ttType, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    } else {
                      positionTooltip();
                    }
                  })
                );
              }

              observers.push(
                attrs.$observe(prefix + 'Title', function(val) {
                  ttScope.title = val;
                  if (ttScope.isOpen) {
                    positionTooltip();
                  }
                })
              );

              observers.push(
                attrs.$observe(prefix + 'Placement', function(val) {
                  ttScope.placement = val ? val : options.placement;
                  if (ttScope.isOpen) {
                    positionTooltip();
                  }
                })
              );
            }

            function unregisterObservers() {
              if (observers.length) {
                angular.forEach(observers, function(observer) {
                  observer();
                });
                observers.length = 0;
              }
            }

            // hide tooltips/popovers for outsideClick trigger
            function bodyHideTooltipBind(e) {
              if (!ttScope || !ttScope.isOpen || !tooltip) {
                return;
              }
              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked
              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                hideTooltipBind();
              }
            }

            // KeyboardEvent handler to hide the tooltip on Escape key press
            function hideOnEscapeKey(e) {
              if (e.which === 27) {
                hideTooltipBind();
              }
            }

            var unregisterTriggers = function() {
              triggers.show.forEach(function(trigger) {
                if (trigger === 'outsideClick') {
                  element.off('click', toggleTooltipBind);
                } else {
                  element.off(trigger, showTooltipBind);
                  element.off(trigger, toggleTooltipBind);
                }
                element.off('keypress', hideOnEscapeKey);
              });
              triggers.hide.forEach(function(trigger) {
                if (trigger === 'outsideClick') {
                  $document.off('click', bodyHideTooltipBind);
                } else {
                  element.off(trigger, hideTooltipBind);
                }
              });
            };

            function prepTriggers() {
              var showTriggers = [], hideTriggers = [];
              var val = scope.$eval(attrs[prefix + 'Trigger']);
              unregisterTriggers();

              if (angular.isObject(val)) {
                Object.keys(val).forEach(function(key) {
                  showTriggers.push(key);
                  hideTriggers.push(val[key]);
                });
                triggers = {
                  show: showTriggers,
                  hide: hideTriggers
                };
              } else {
                triggers = getTriggers(val);
              }

              if (triggers.show !== 'none') {
                triggers.show.forEach(function(trigger, idx) {
                  if (trigger === 'outsideClick') {
                    element.on('click', toggleTooltipBind);
                    $document.on('click', bodyHideTooltipBind);
                  } else if (trigger === triggers.hide[idx]) {
                    element.on(trigger, toggleTooltipBind);
                  } else if (trigger) {
                    element.on(trigger, showTooltipBind);
                    element.on(triggers.hide[idx], hideTooltipBind);
                  }
                  element.on('keypress', hideOnEscapeKey);
                });
              }
            }

            prepTriggers();

            var animation = scope.$eval(attrs[prefix + 'Animation']);
            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

            var appendToBodyVal;
            var appendKey = prefix + 'AppendToBody';
            if (appendKey in attrs && attrs[appendKey] === undefined) {
              appendToBodyVal = true;
            } else {
              appendToBodyVal = scope.$eval(attrs[appendKey]);
            }

            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

            // Make sure tooltip is destroyed and removed.
            scope.$on('$destroy', function onDestroyTooltip() {
              unregisterTriggers();
              removeTooltip();
              ttScope = null;
            });
          };
        }
      };
    };
  }];
})

// This is mostly ngInclude code but with a custom scope
.directive('uibTooltipTemplateTransclude', [
         '$animate', '$sce', '$compile', '$templateRequest',
function ($animate, $sce, $compile, $templateRequest) {
  return {
    link: function(scope, elem, attrs) {
      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

      var changeCounter = 0,
        currentScope,
        previousElement,
        currentElement;

      var cleanupLastIncludeContent = function() {
        if (previousElement) {
          previousElement.remove();
          previousElement = null;
        }

        if (currentScope) {
          currentScope.$destroy();
          currentScope = null;
        }

        if (currentElement) {
          $animate.leave(currentElement).then(function() {
            previousElement = null;
          });
          previousElement = currentElement;
          currentElement = null;
        }
      };

      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
        var thisChangeId = ++changeCounter;

        if (src) {
          //set the 2nd param to true to ignore the template request error so that the inner
          //contents and scope can be cleaned up.
          $templateRequest(src, true).then(function(response) {
            if (thisChangeId !== changeCounter) { return; }
            var newScope = origScope.$new();
            var template = response;

            var clone = $compile(template)(newScope, function(clone) {
              cleanupLastIncludeContent();
              $animate.enter(clone, elem);
            });

            currentScope = newScope;
            currentElement = clone;

            currentScope.$emit('$includeContentLoaded', src);
          }, function() {
            if (thisChangeId === changeCounter) {
              cleanupLastIncludeContent();
              scope.$emit('$includeContentError', src);
            }
          });
          scope.$emit('$includeContentRequested', src);
        } else {
          cleanupLastIncludeContent();
        }
      });

      scope.$on('$destroy', cleanupLastIncludeContent);
    }
  };
}])

/**
 * Note that it's intentional that these classes are *not* applied through $animate.
 * They must not be animated as they're expected to be present on the tooltip on
 * initialization.
 */
.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      // need to set the primary position so the
      // arrow has space during position measure.
      // tooltip.positionTooltip()
      if (scope.placement) {
        // // There are no top-left etc... classes
        // // in TWBS, so we need the primary position.
        var position = $uibPosition.parsePlacement(scope.placement);
        element.addClass(position[0]);
      }

      if (scope.popupClass) {
        element.addClass(scope.popupClass);
      }

      if (scope.animation) {
        element.addClass(attrs.tooltipAnimationClass);
      }
    }
  };
}])

.directive('uibTooltipPopup', function() {
  return {
    restrict: 'A',
    scope: { content: '@' },
    templateUrl: 'uib/template/tooltip/tooltip-popup.html'
  };
})

.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
}])

.directive('uibTooltipTemplatePopup', function() {
  return {
    restrict: 'A',
    scope: { contentExp: '&', originScope: '&' },
    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
  };
})

.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}])

.directive('uibTooltipHtmlPopup', function() {
  return {
    restrict: 'A',
    scope: { contentExp: '&' },
    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
  };
})

.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, and selector delegatation.
 */
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])

.directive('uibPopoverTemplatePopup', function() {
  return {
    restrict: 'A',
    scope: { uibTitle: '@', contentExp: '&', originScope: '&' },
    templateUrl: 'uib/template/popover/popover-template.html'
  };
})

.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('uibPopoverHtmlPopup', function() {
  return {
    restrict: 'A',
    scope: { contentExp: '&', uibTitle: '@' },
    templateUrl: 'uib/template/popover/popover-html.html'
  };
})

.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('uibPopoverPopup', function() {
  return {
    restrict: 'A',
    scope: { uibTitle: '@', content: '@' },
    templateUrl: 'uib/template/popover/popover.html'
  };
})

.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopover', 'popover', 'click');
}]);

angular.module('ui.bootstrap.progressbar', [])

.constant('uibProgressConfig', {
  animate: true,
  max: 100
})

.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
  var self = this,
      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

  this.bars = [];
  $scope.max = getMaxOrDefault();

  this.addBar = function(bar, element, attrs) {
    if (!animate) {
      element.css({'transition': 'none'});
    }

    this.bars.push(bar);

    bar.max = getMaxOrDefault();
    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

    bar.$watch('value', function(value) {
      bar.recalculatePercentage();
    });

    bar.recalculatePercentage = function() {
      var totalPercentage = self.bars.reduce(function(total, bar) {
        bar.percent = +(100 * bar.value / bar.max).toFixed(2);
        return total + bar.percent;
      }, 0);

      if (totalPercentage > 100) {
        bar.percent -= totalPercentage - 100;
      }
    };

    bar.$on('$destroy', function() {
      element = null;
      self.removeBar(bar);
    });
  };

  this.removeBar = function(bar) {
    this.bars.splice(this.bars.indexOf(bar), 1);
    this.bars.forEach(function (bar) {
      bar.recalculatePercentage();
    });
  };

  //$attrs.$observe('maxParam', function(maxParam) {
  $scope.$watch('maxParam', function(maxParam) {
    self.bars.forEach(function(bar) {
      bar.max = getMaxOrDefault();
      bar.recalculatePercentage();
    });
  });

  function getMaxOrDefault () {
    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
  }
}])

.directive('uibProgress', function() {
  return {
    replace: true,
    transclude: true,
    controller: 'UibProgressController',
    require: 'uibProgress',
    scope: {
      maxParam: '=?max'
    },
    templateUrl: 'uib/template/progressbar/progress.html'
  };
})

.directive('uibBar', function() {
  return {
    replace: true,
    transclude: true,
    require: '^uibProgress',
    scope: {
      value: '=',
      type: '@'
    },
    templateUrl: 'uib/template/progressbar/bar.html',
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, element, attrs);
    }
  };
})

.directive('uibProgressbar', function() {
  return {
    replace: true,
    transclude: true,
    controller: 'UibProgressController',
    scope: {
      value: '=',
      maxParam: '=?max',
      type: '@'
    },
    templateUrl: 'uib/template/progressbar/progressbar.html',
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
    }
  };
});

angular.module('ui.bootstrap.rating', [])

.constant('uibRatingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null,
  enableReset: true,
  titles: ['one', 'two', 'three', 'four', 'five']
})

.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
  var ngModelCtrl = { $setViewValue: angular.noop },
    self = this;

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.push(function(value) {
      if (angular.isNumber(value) && value << 0 !== value) {
        value = Math.round(value);
      }

      return value;
    });

    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
    this.enableReset = angular.isDefined($attrs.enableReset) ?
      $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
      tmpTitles : ratingConfig.titles;

    var ratingStates = angular.isDefined($attrs.ratingStates) ?
      $scope.$parent.$eval($attrs.ratingStates) :
      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
    $scope.range = this.buildTemplateObjects(ratingStates);
  };

  this.buildTemplateObjects = function(states) {
    for (var i = 0, n = states.length; i < n; i++) {
      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
    }
    return states;
  };

  this.getTitle = function(index) {
    if (index >= this.titles.length) {
      return index + 1;
    }

    return this.titles[index];
  };

  $scope.rate = function(value) {
    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
      var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
      ngModelCtrl.$setViewValue(newViewValue);
      ngModelCtrl.$render();
    }
  };

  $scope.enter = function(value) {
    if (!$scope.readonly) {
      $scope.value = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.onLeave();
  };

  $scope.onKeydown = function(evt) {
    if (/(37|38|39|40)/.test(evt.which)) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
    }
  };

  this.render = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.title = self.getTitle($scope.value - 1);
  };
}])

.directive('uibRating', function() {
  return {
    require: ['uibRating', 'ngModel'],
    restrict: 'A',
    scope: {
      readonly: '=?readOnly',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'UibRatingController',
    templateUrl: 'uib/template/rating/rating.html',
    link: function(scope, element, attrs, ctrls) {
      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      ratingCtrl.init(ngModelCtrl);
    }
  };
});

angular.module('ui.bootstrap.tabs', [])

.controller('UibTabsetController', ['$scope', function ($scope) {
  var ctrl = this,
    oldIndex;
  ctrl.tabs = [];

  ctrl.select = function(index, evt) {
    if (!destroyed) {
      var previousIndex = findTabIndex(oldIndex);
      var previousSelected = ctrl.tabs[previousIndex];
      if (previousSelected) {
        previousSelected.tab.onDeselect({
          $event: evt,
          $selectedIndex: index
        });
        if (evt && evt.isDefaultPrevented()) {
          return;
        }
        previousSelected.tab.active = false;
      }

      var selected = ctrl.tabs[index];
      if (selected) {
        selected.tab.onSelect({
          $event: evt
        });
        selected.tab.active = true;
        ctrl.active = selected.index;
        oldIndex = selected.index;
      } else if (!selected && angular.isDefined(oldIndex)) {
        ctrl.active = null;
        oldIndex = null;
      }
    }
  };

  ctrl.addTab = function addTab(tab) {
    ctrl.tabs.push({
      tab: tab,
      index: tab.index
    });
    ctrl.tabs.sort(function(t1, t2) {
      if (t1.index > t2.index) {
        return 1;
      }

      if (t1.index < t2.index) {
        return -1;
      }

      return 0;
    });

    if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {
      var newActiveIndex = findTabIndex(tab.index);
      ctrl.select(newActiveIndex);
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index;
    for (var i = 0; i < ctrl.tabs.length; i++) {
      if (ctrl.tabs[i].tab === tab) {
        index = i;
        break;
      }
    }

    if (ctrl.tabs[index].index === ctrl.active) {
      var newActiveTabIndex = index === ctrl.tabs.length - 1 ?
        index - 1 : index + 1 % ctrl.tabs.length;
      ctrl.select(newActiveTabIndex);
    }

    ctrl.tabs.splice(index, 1);
  };

  $scope.$watch('tabset.active', function(val) {
    if (angular.isDefined(val) && val !== oldIndex) {
      ctrl.select(findTabIndex(val));
    }
  });

  var destroyed;
  $scope.$on('$destroy', function() {
    destroyed = true;
  });

  function findTabIndex(index) {
    for (var i = 0; i < ctrl.tabs.length; i++) {
      if (ctrl.tabs[i].index === index) {
        return i;
      }
    }
  }
}])

.directive('uibTabset', function() {
  return {
    transclude: true,
    replace: true,
    scope: {},
    bindToController: {
      active: '=?',
      type: '@'
    },
    controller: 'UibTabsetController',
    controllerAs: 'tabset',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/tabs/tabset.html';
    },
    link: function(scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ?
        scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ?
        scope.$parent.$eval(attrs.justified) : false;
    }
  };
})

.directive('uibTab', ['$parse', function($parse) {
  return {
    require: '^uibTabset',
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'uib/template/tabs/tab.html';
    },
    transclude: true,
    scope: {
      heading: '@',
      index: '=?',
      classes: '@?',
      onSelect: '&select', //This callback is called in contentHeadingTransclude
                          //once it inserts the tab's content into the dom
      onDeselect: '&deselect'
    },
    controller: function() {
      //Empty controller so other directives can require being 'under' a tab
    },
    controllerAs: 'tab',
    link: function(scope, elm, attrs, tabsetCtrl, transclude) {
      scope.disabled = false;
      if (attrs.disable) {
        scope.$parent.$watch($parse(attrs.disable), function(value) {
          scope.disabled = !! value;
        });
      }

      if (angular.isUndefined(attrs.index)) {
        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;
        } else {
          scope.index = 0;
        }
      }

      if (angular.isUndefined(attrs.classes)) {
        scope.classes = '';
      }

      scope.select = function(evt) {
        if (!scope.disabled) {
          var index;
          for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
            if (tabsetCtrl.tabs[i].tab === scope) {
              index = i;
              break;
            }
          }

          tabsetCtrl.select(index, evt);
        }
      };

      tabsetCtrl.addTab(scope);
      scope.$on('$destroy', function() {
        tabsetCtrl.removeTab(scope);
      });

      //We need to transclude later, once the content container is ready.
      //when this link happens, we're inside a tab heading.
      scope.$transcludeFn = transclude;
    }
  };
}])

.directive('uibTabHeadingTransclude', function() {
  return {
    restrict: 'A',
    require: '^uibTab',
    link: function(scope, elm) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
})

.directive('uibTabContentTransclude', function() {
  return {
    restrict: 'A',
    require: '^uibTabset',
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude 'em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };

  function isTabHeading(node) {
    return node.tagName && (
      node.hasAttribute('uib-tab-heading') ||
      node.hasAttribute('data-uib-tab-heading') ||
      node.hasAttribute('x-uib-tab-heading') ||
      node.tagName.toLowerCase() === 'uib-tab-heading' ||
      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
      node.tagName.toLowerCase() === 'x-uib-tab-heading' ||
      node.tagName.toLowerCase() === 'uib:tab-heading'
    );
  }
});

angular.module('ui.bootstrap.timepicker', [])

.constant('uibTimepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  secondStep: 1,
  showMeridian: true,
  showSeconds: false,
  meridians: null,
  readonlyInput: false,
  mousewheel: true,
  arrowkeys: true,
  showSpinners: true,
  templateUrl: 'uib/template/timepicker/timepicker.html'
})

.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
  var hoursModelCtrl, minutesModelCtrl, secondsModelCtrl;
  var selected = new Date(),
    watchers = [],
    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
    padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;

  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
  $element.removeAttr('tabindex');

  this.init = function(ngModelCtrl_, inputs) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.unshift(function(modelValue) {
      return modelValue ? new Date(modelValue) : null;
    });

    var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1),
        secondsInputEl = inputs.eq(2);

    hoursModelCtrl = hoursInputEl.controller('ngModel');
    minutesModelCtrl = minutesInputEl.controller('ngModel');
    secondsModelCtrl = secondsInputEl.controller('ngModel');

    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;

    if (mousewheel) {
      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    }

    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
    if (arrowkeys) {
      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    }

    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
  };

  var hourStep = timepickerConfig.hourStep;
  if ($attrs.hourStep) {
    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
      hourStep = +value;
    }));
  }

  var minuteStep = timepickerConfig.minuteStep;
  if ($attrs.minuteStep) {
    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
      minuteStep = +value;
    }));
  }

  var min;
  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
    var dt = new Date(value);
    min = isNaN(dt) ? undefined : dt;
  }));

  var max;
  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
    var dt = new Date(value);
    max = isNaN(dt) ? undefined : dt;
  }));

  var disabled = false;
  if ($attrs.ngDisabled) {
    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
      disabled = value;
    }));
  }

  $scope.noIncrementHours = function() {
    var incrementedSelected = addMinutes(selected, hourStep * 60);
    return disabled || incrementedSelected > max ||
      incrementedSelected < selected && incrementedSelected < min;
  };

  $scope.noDecrementHours = function() {
    var decrementedSelected = addMinutes(selected, -hourStep * 60);
    return disabled || decrementedSelected < min ||
      decrementedSelected > selected && decrementedSelected > max;
  };

  $scope.noIncrementMinutes = function() {
    var incrementedSelected = addMinutes(selected, minuteStep);
    return disabled || incrementedSelected > max ||
      incrementedSelected < selected && incrementedSelected < min;
  };

  $scope.noDecrementMinutes = function() {
    var decrementedSelected = addMinutes(selected, -minuteStep);
    return disabled || decrementedSelected < min ||
      decrementedSelected > selected && decrementedSelected > max;
  };

  $scope.noIncrementSeconds = function() {
    var incrementedSelected = addSeconds(selected, secondStep);
    return disabled || incrementedSelected > max ||
      incrementedSelected < selected && incrementedSelected < min;
  };

  $scope.noDecrementSeconds = function() {
    var decrementedSelected = addSeconds(selected, -secondStep);
    return disabled || decrementedSelected < min ||
      decrementedSelected > selected && decrementedSelected > max;
  };

  $scope.noToggleMeridian = function() {
    if (selected.getHours() < 12) {
      return disabled || addMinutes(selected, 12 * 60) > max;
    }

    return disabled || addMinutes(selected, -12 * 60) < min;
  };

  var secondStep = timepickerConfig.secondStep;
  if ($attrs.secondStep) {
    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
      secondStep = +value;
    }));
  }

  $scope.showSeconds = timepickerConfig.showSeconds;
  if ($attrs.showSeconds) {
    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
      $scope.showSeconds = !!value;
    }));
  }

  // 12H / 24H mode
  $scope.showMeridian = timepickerConfig.showMeridian;
  if ($attrs.showMeridian) {
    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
      $scope.showMeridian = !!value;

      if (ngModelCtrl.$error.time) {
        // Evaluate from template
        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
          selected.setHours(hours);
          refresh();
        }
      } else {
        updateTemplate();
      }
    }));
  }

  // Get $scope.hours in 24H mode if valid
  function getHoursFromTemplate() {
    var hours = +$scope.hours;
    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :
      hours >= 0 && hours < 24;
    if (!valid || $scope.hours === '') {
      return undefined;
    }

    if ($scope.showMeridian) {
      if (hours === 12) {
        hours = 0;
      }
      if ($scope.meridian === meridians[1]) {
        hours = hours + 12;
      }
    }
    return hours;
  }

  function getMinutesFromTemplate() {
    var minutes = +$scope.minutes;
    var valid = minutes >= 0 && minutes < 60;
    if (!valid || $scope.minutes === '') {
      return undefined;
    }
    return minutes;
  }

  function getSecondsFromTemplate() {
    var seconds = +$scope.seconds;
    return seconds >= 0 && seconds < 60 ? seconds : undefined;
  }

  function pad(value, noPad) {
    if (value === null) {
      return '';
    }

    return angular.isDefined(value) && value.toString().length < 2 && !noPad ?
      '0' + value : value.toString();
  }

  // Respond on mousewheel spin
  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
    var isScrollingUp = function(e) {
      if (e.originalEvent) {
        e = e.originalEvent;
      }
      //pick correct delta variable depending on event
      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
      return e.detail || delta > 0;
    };

    hoursInputEl.on('mousewheel wheel', function(e) {
      if (!disabled) {
        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
      }
      e.preventDefault();
    });

    minutesInputEl.on('mousewheel wheel', function(e) {
      if (!disabled) {
        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
      }
      e.preventDefault();
    });

     secondsInputEl.on('mousewheel wheel', function(e) {
      if (!disabled) {
        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
      }
      e.preventDefault();
    });
  };

  // Respond on up/down arrowkeys
  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
    hoursInputEl.on('keydown', function(e) {
      if (!disabled) {
        if (e.which === 38) { // up
          e.preventDefault();
          $scope.incrementHours();
          $scope.$apply();
        } else if (e.which === 40) { // down
          e.preventDefault();
          $scope.decrementHours();
          $scope.$apply();
        }
      }
    });

    minutesInputEl.on('keydown', function(e) {
      if (!disabled) {
        if (e.which === 38) { // up
          e.preventDefault();
          $scope.incrementMinutes();
          $scope.$apply();
        } else if (e.which === 40) { // down
          e.preventDefault();
          $scope.decrementMinutes();
          $scope.$apply();
        }
      }
    });

    secondsInputEl.on('keydown', function(e) {
      if (!disabled) {
        if (e.which === 38) { // up
          e.preventDefault();
          $scope.incrementSeconds();
          $scope.$apply();
        } else if (e.which === 40) { // down
          e.preventDefault();
          $scope.decrementSeconds();
          $scope.$apply();
        }
      }
    });
  };

  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
    if ($scope.readonlyInput) {
      $scope.updateHours = angular.noop;
      $scope.updateMinutes = angular.noop;
      $scope.updateSeconds = angular.noop;
      return;
    }

    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
      ngModelCtrl.$setViewValue(null);
      ngModelCtrl.$setValidity('time', false);
      if (angular.isDefined(invalidHours)) {
        $scope.invalidHours = invalidHours;
        if (hoursModelCtrl) {
          hoursModelCtrl.$setValidity('hours', false);
        }
      }

      if (angular.isDefined(invalidMinutes)) {
        $scope.invalidMinutes = invalidMinutes;
        if (minutesModelCtrl) {
          minutesModelCtrl.$setValidity('minutes', false);
        }
      }

      if (angular.isDefined(invalidSeconds)) {
        $scope.invalidSeconds = invalidSeconds;
        if (secondsModelCtrl) {
          secondsModelCtrl.$setValidity('seconds', false);
        }
      }
    };

    $scope.updateHours = function() {
      var hours = getHoursFromTemplate(),
        minutes = getMinutesFromTemplate();

      ngModelCtrl.$setDirty();

      if (angular.isDefined(hours) && angular.isDefined(minutes)) {
        selected.setHours(hours);
        selected.setMinutes(minutes);
        if (selected < min || selected > max) {
          invalidate(true);
        } else {
          refresh('h');
        }
      } else {
        invalidate(true);
      }
    };

    hoursInputEl.on('blur', function(e) {
      ngModelCtrl.$setTouched();
      if (modelIsEmpty()) {
        makeValid();
      } else if ($scope.hours === null || $scope.hours === '') {
        invalidate(true);
      } else if (!$scope.invalidHours && $scope.hours < 10) {
        $scope.$apply(function() {
          $scope.hours = pad($scope.hours, !padHours);
        });
      }
    });

    $scope.updateMinutes = function() {
      var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();

      ngModelCtrl.$setDirty();

      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
        selected.setHours(hours);
        selected.setMinutes(minutes);
        if (selected < min || selected > max) {
          invalidate(undefined, true);
        } else {
          refresh('m');
        }
      } else {
        invalidate(undefined, true);
      }
    };

    minutesInputEl.on('blur', function(e) {
      ngModelCtrl.$setTouched();
      if (modelIsEmpty()) {
        makeValid();
      } else if ($scope.minutes === null) {
        invalidate(undefined, true);
      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
        $scope.$apply(function() {
          $scope.minutes = pad($scope.minutes);
        });
      }
    });

    $scope.updateSeconds = function() {
      var seconds = getSecondsFromTemplate();

      ngModelCtrl.$setDirty();

      if (angular.isDefined(seconds)) {
        selected.setSeconds(seconds);
        refresh('s');
      } else {
        invalidate(undefined, undefined, true);
      }
    };

    secondsInputEl.on('blur', function(e) {
      if (modelIsEmpty()) {
        makeValid();
      } else if (!$scope.invalidSeconds && $scope.seconds < 10) {
        $scope.$apply( function() {
          $scope.seconds = pad($scope.seconds);
        });
      }
    });

  };

  this.render = function() {
    var date = ngModelCtrl.$viewValue;

    if (isNaN(date)) {
      ngModelCtrl.$setValidity('time', false);
      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
    } else {
      if (date) {
        selected = date;
      }

      if (selected < min || selected > max) {
        ngModelCtrl.$setValidity('time', false);
        $scope.invalidHours = true;
        $scope.invalidMinutes = true;
      } else {
        makeValid();
      }
      updateTemplate();
    }
  };

  // Call internally when we know that model is valid.
  function refresh(keyboardChange) {
    makeValid();
    ngModelCtrl.$setViewValue(new Date(selected));
    updateTemplate(keyboardChange);
  }

  function makeValid() {
    if (hoursModelCtrl) {
      hoursModelCtrl.$setValidity('hours', true);
    }

    if (minutesModelCtrl) {
      minutesModelCtrl.$setValidity('minutes', true);
    }

    if (secondsModelCtrl) {
      secondsModelCtrl.$setValidity('seconds', true);
    }

    ngModelCtrl.$setValidity('time', true);
    $scope.invalidHours = false;
    $scope.invalidMinutes = false;
    $scope.invalidSeconds = false;
  }

  function updateTemplate(keyboardChange) {
    if (!ngModelCtrl.$modelValue) {
      $scope.hours = null;
      $scope.minutes = null;
      $scope.seconds = null;
      $scope.meridian = meridians[0];
    } else {
      var hours = selected.getHours(),
        minutes = selected.getMinutes(),
        seconds = selected.getSeconds();

      if ($scope.showMeridian) {
        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system
      }

      $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
      if (keyboardChange !== 'm') {
        $scope.minutes = pad(minutes);
      }
      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];

      if (keyboardChange !== 's') {
        $scope.seconds = pad(seconds);
      }
      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
    }
  }

  function addSecondsToSelected(seconds) {
    selected = addSeconds(selected, seconds);
    refresh();
  }

  function addMinutes(selected, minutes) {
    return addSeconds(selected, minutes*60);
  }

  function addSeconds(date, seconds) {
    var dt = new Date(date.getTime() + seconds * 1000);
    var newDate = new Date(date);
    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
    return newDate;
  }

  function modelIsEmpty() {
    return ($scope.hours === null || $scope.hours === '') &&
      ($scope.minutes === null || $scope.minutes === '') &&
      (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
  }

  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

  $scope.incrementHours = function() {
    if (!$scope.noIncrementHours()) {
      addSecondsToSelected(hourStep * 60 * 60);
    }
  };

  $scope.decrementHours = function() {
    if (!$scope.noDecrementHours()) {
      addSecondsToSelected(-hourStep * 60 * 60);
    }
  };

  $scope.incrementMinutes = function() {
    if (!$scope.noIncrementMinutes()) {
      addSecondsToSelected(minuteStep * 60);
    }
  };

  $scope.decrementMinutes = function() {
    if (!$scope.noDecrementMinutes()) {
      addSecondsToSelected(-minuteStep * 60);
    }
  };

  $scope.incrementSeconds = function() {
    if (!$scope.noIncrementSeconds()) {
      addSecondsToSelected(secondStep);
    }
  };

  $scope.decrementSeconds = function() {
    if (!$scope.noDecrementSeconds()) {
      addSecondsToSelected(-secondStep);
    }
  };

  $scope.toggleMeridian = function() {
    var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();

    if (!$scope.noToggleMeridian()) {
      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
      } else {
        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
      }
    }
  };

  $scope.blur = function() {
    ngModelCtrl.$setTouched();
  };

  $scope.$on('$destroy', function() {
    while (watchers.length) {
      watchers.shift()();
    }
  });
}])

.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {
  return {
    require: ['uibTimepicker', '?^ngModel'],
    restrict: 'A',
    controller: 'UibTimepickerController',
    controllerAs: 'timepicker',
    scope: {},
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || uibTimepickerConfig.templateUrl;
    },
    link: function(scope, element, attrs, ctrls) {
      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (ngModelCtrl) {
        timepickerCtrl.init(ngModelCtrl, element.find('input'));
      }
    }
  };
}]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('uibTypeaheadParser', ['$parse', function($parse) {
    //                      000001111111100000000000002222222200000000000000003333333333333330000000000044444444000
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
      parse: function(input) {
        var match = input.match(TYPEAHEAD_REGEXP);
        if (!match) {
          throw new Error(
            'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
              ' but got "' + input + '".');
        }

        return {
          itemName: match[3],
          source: $parse(match[4]),
          viewMapper: $parse(match[2] || match[1]),
          modelMapper: $parse(match[1])
        };
      }
    };
  }])

  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',
    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
    var HOT_KEYS = [9, 13, 27, 38, 40];
    var eventDebounceTime = 200;
    var modelCtrl, ngModelOptions;
    //SUPPORTED ATTRIBUTES (OPTIONS)

    //minimal no of characters that needs to be entered before typeahead kicks-in
    var minLength = originalScope.$eval(attrs.typeaheadMinLength);
    if (!minLength && minLength !== 0) {
      minLength = 1;
    }

    originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
        minLength = !newVal && newVal !== 0 ? 1 : newVal;
    });

    //minimal wait time after last character typed before typeahead kicks-in
    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

    //should it restrict model values to the ones selected from the popup only?
    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
      isEditable = newVal !== false;
    });

    //binding to a variable that indicates if matches are being retrieved asynchronously
    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

    //a function to determine if an event should cause selection
    var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {
      var evt = vals.$event;
      return evt.which === 13 || evt.which === 9;
    };

    //a callback executed when a match is selected
    var onSelectCallback = $parse(attrs.typeaheadOnSelect);

    //should it select highlighted popup value when losing focus?
    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

    //binding to a variable that indicates if there were no results after the query is completed
    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

    var appendTo = attrs.typeaheadAppendTo ?
      originalScope.$eval(attrs.typeaheadAppendTo) : null;

    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

    //If input matches an item of the list exactly, select it automatically
    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

    //binding to a variable that indicates if dropdown is open
    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;

    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;

    //INTERNAL VARIABLES

    //model setter executed upon match selection
    var parsedModel = $parse(attrs.ngModel);
    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
    var $setModelValue = function(scope, newValue) {
      if (angular.isFunction(parsedModel(originalScope)) &&
        ngModelOptions.getOption('getterSetter')) {
        return invokeModelSetter(scope, {$$$p: newValue});
      }

      return parsedModel.assign(scope, newValue);
    };

    //expressions used by typeahead
    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);

    var hasFocus;

    //Used to avoid bug in iOS webview where iOS keyboard does not fire
    //mousedown & mouseup events
    //Issue #3699
    var selected;

    //create a child scope for the typeahead directive so we are not polluting original scope
    //with typeahead-specific data (matches, query etc.)
    var scope = originalScope.$new();
    var offDestroy = originalScope.$on('$destroy', function() {
      scope.$destroy();
    });
    scope.$on('$destroy', offDestroy);

    // WAI-ARIA
    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
    element.attr({
      'aria-autocomplete': 'list',
      'aria-expanded': false,
      'aria-owns': popupId
    });

    var inputsContainer, hintInputElem;
    //add read-only input to show hint
    if (showHint) {
      inputsContainer = angular.element('<div></div>');
      inputsContainer.css('position', 'relative');
      element.after(inputsContainer);
      hintInputElem = element.clone();
      hintInputElem.attr('placeholder', '');
      hintInputElem.attr('tabindex', '-1');
      hintInputElem.val('');
      hintInputElem.css({
        'position': 'absolute',
        'top': '0px',
        'left': '0px',
        'border-color': 'transparent',
        'box-shadow': 'none',
        'opacity': 1,
        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
        'color': '#999'
      });
      element.css({
        'position': 'relative',
        'vertical-align': 'top',
        'background-color': 'transparent'
      });

      if (hintInputElem.attr('id')) {
        hintInputElem.removeAttr('id'); // remove duplicate id if present.
      }
      inputsContainer.append(hintInputElem);
      hintInputElem.after(element);
    }

    //pop-up element used to display matches
    var popUpEl = angular.element('<div uib-typeahead-popup></div>');
    popUpEl.attr({
      id: popupId,
      matches: 'matches',
      active: 'activeIdx',
      select: 'select(activeIdx, evt)',
      'move-in-progress': 'moveInProgress',
      query: 'query',
      position: 'position',
      'assign-is-open': 'assignIsOpen(isOpen)',
      debounce: 'debounceUpdate'
    });
    //custom item template
    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
    }

    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
    }

    var resetHint = function() {
      if (showHint) {
        hintInputElem.val('');
      }
    };

    var resetMatches = function() {
      scope.matches = [];
      scope.activeIdx = -1;
      element.attr('aria-expanded', false);
      resetHint();
    };

    var getMatchId = function(index) {
      return popupId + '-option-' + index;
    };

    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
    // This attribute is added or removed automatically when the `activeIdx` changes.
    scope.$watch('activeIdx', function(index) {
      if (index < 0) {
        element.removeAttr('aria-activedescendant');
      } else {
        element.attr('aria-activedescendant', getMatchId(index));
      }
    });

    var inputIsExactMatch = function(inputValue, index) {
      if (scope.matches.length > index && inputValue) {
        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
      }

      return false;
    };

    var getMatchesAsync = function(inputValue, evt) {
      var locals = {$viewValue: inputValue};
      isLoadingSetter(originalScope, true);
      isNoResultsSetter(originalScope, false);
      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
        //it might happen that several async queries were in progress if a user were typing fast
        //but we are interested only in responses that correspond to the current view value
        var onCurrentRequest = inputValue === modelCtrl.$viewValue;
        if (onCurrentRequest && hasFocus) {
          if (matches && matches.length > 0) {
            scope.activeIdx = focusFirst ? 0 : -1;
            isNoResultsSetter(originalScope, false);
            scope.matches.length = 0;

            //transform labels
            for (var i = 0; i < matches.length; i++) {
              locals[parserResult.itemName] = matches[i];
              scope.matches.push({
                id: getMatchId(i),
                label: parserResult.viewMapper(scope, locals),
                model: matches[i]
              });
            }

            scope.query = inputValue;
            //position pop-up with matches - we need to re-calculate its position each time we are opening a window
            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
            //due to other elements being rendered
            recalculatePosition();

            element.attr('aria-expanded', true);

            //Select the single remaining option if user input matches
            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                $$debounce(function() {
                  scope.select(0, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
              } else {
                scope.select(0, evt);
              }
            }

            if (showHint) {
              var firstLabel = scope.matches[0].label;
              if (angular.isString(inputValue) &&
                inputValue.length > 0 &&
                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
              } else {
                hintInputElem.val('');
              }
            }
          } else {
            resetMatches();
            isNoResultsSetter(originalScope, true);
          }
        }
        if (onCurrentRequest) {
          isLoadingSetter(originalScope, false);
        }
      }, function() {
        resetMatches();
        isLoadingSetter(originalScope, false);
        isNoResultsSetter(originalScope, true);
      });
    };

    // bind events only if appendToBody params exist - performance feature
    if (appendToBody) {
      angular.element($window).on('resize', fireRecalculating);
      $document.find('body').on('scroll', fireRecalculating);
    }

    // Declare the debounced function outside recalculating for
    // proper debouncing
    var debouncedRecalculate = $$debounce(function() {
      // if popup is visible
      if (scope.matches.length) {
        recalculatePosition();
      }

      scope.moveInProgress = false;
    }, eventDebounceTime);

    // Default progress type
    scope.moveInProgress = false;

    function fireRecalculating() {
      if (!scope.moveInProgress) {
        scope.moveInProgress = true;
        scope.$digest();
      }

      debouncedRecalculate();
    }

    // recalculate actual position and set new values to scope
    // after digest loop is popup in right position
    function recalculatePosition() {
      scope.position = appendToBody ? $position.offset(element) : $position.position(element);
      scope.position.top += element.prop('offsetHeight');
    }

    //we need to propagate user's query so we can higlight matches
    scope.query = undefined;

    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
    var timeoutPromise;

    var scheduleSearchWithTimeout = function(inputValue) {
      timeoutPromise = $timeout(function() {
        getMatchesAsync(inputValue);
      }, waitTime);
    };

    var cancelPreviousTimeout = function() {
      if (timeoutPromise) {
        $timeout.cancel(timeoutPromise);
      }
    };

    resetMatches();

    scope.assignIsOpen = function (isOpen) {
      isOpenSetter(originalScope, isOpen);
    };

    scope.select = function(activeIdx, evt) {
      //called from within the $digest() cycle
      var locals = {};
      var model, item;

      selected = true;
      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
      model = parserResult.modelMapper(originalScope, locals);
      $setModelValue(originalScope, model);
      modelCtrl.$setValidity('editable', true);
      modelCtrl.$setValidity('parse', true);

      onSelectCallback(originalScope, {
        $item: item,
        $model: model,
        $label: parserResult.viewMapper(originalScope, locals),
        $event: evt
      });

      resetMatches();

      //return focus to the input element if a match was selected via a mouse click event
      // use timeout to avoid $rootScope:inprog error
      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
        $timeout(function() { element[0].focus(); }, 0, false);
      }
    };

    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
    element.on('keydown', function(evt) {
      //typeahead is open and an "interesting" key was pressed
      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
        return;
      }

      var shouldSelect = isSelectEvent(originalScope, {$event: evt});

      /**
       * if there's nothing selected (i.e. focusFirst) and enter or tab is hit
       * or
       * shift + tab is pressed to bring focus to the previous element
       * then clear the results
       */
      if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {
        resetMatches();
        scope.$digest();
        return;
      }

      evt.preventDefault();
      var target;
      switch (evt.which) {
        case 27: // escape
          evt.stopPropagation();

          resetMatches();
          originalScope.$digest();
          break;
        case 38: // up arrow
          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
          scope.$digest();
          target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
          target.parentNode.scrollTop = target.offsetTop;
          break;
        case 40: // down arrow
          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
          scope.$digest();
          target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];
          target.parentNode.scrollTop = target.offsetTop;
          break;
        default:
          if (shouldSelect) {
            scope.$apply(function() {
              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                $$debounce(function() {
                  scope.select(scope.activeIdx, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
              } else {
                scope.select(scope.activeIdx, evt);
              }
            });
          }
      }
    });

    element.on('focus', function (evt) {
      hasFocus = true;
      if (minLength === 0 && !modelCtrl.$viewValue) {
        $timeout(function() {
          getMatchesAsync(modelCtrl.$viewValue, evt);
        }, 0);
      }
    });

    element.on('blur', function(evt) {
      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
        selected = true;
        scope.$apply(function() {
          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
            $$debounce(function() {
              scope.select(scope.activeIdx, evt);
            }, scope.debounceUpdate.blur);
          } else {
            scope.select(scope.activeIdx, evt);
          }
        });
      }
      if (!isEditable && modelCtrl.$error.editable) {
        modelCtrl.$setViewValue();
        scope.$apply(function() {
          // Reset validity as we are clearing
          modelCtrl.$setValidity('editable', true);
          modelCtrl.$setValidity('parse', true);
        });
        element.val('');
      }
      hasFocus = false;
      selected = false;
    });

    // Keep reference to click handler to unbind it.
    var dismissClickHandler = function(evt) {
      // Issue #3973
      // Firefox treats right click as a click on document
      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
        resetMatches();
        if (!$rootScope.$$phase) {
          originalScope.$digest();
        }
      }
    };

    $document.on('click', dismissClickHandler);

    originalScope.$on('$destroy', function() {
      $document.off('click', dismissClickHandler);
      if (appendToBody || appendTo) {
        $popup.remove();
      }

      if (appendToBody) {
        angular.element($window).off('resize', fireRecalculating);
        $document.find('body').off('scroll', fireRecalculating);
      }
      // Prevent jQuery cache memory leak
      popUpEl.remove();

      if (showHint) {
          inputsContainer.remove();
      }
    });

    var $popup = $compile(popUpEl)(scope);

    if (appendToBody) {
      $document.find('body').append($popup);
    } else if (appendTo) {
      angular.element(appendTo).eq(0).append($popup);
    } else {
      element.after($popup);
    }

    this.init = function(_modelCtrl) {
      modelCtrl = _modelCtrl;
      ngModelOptions = extractOptions(modelCtrl);

      scope.debounceUpdate = $parse(ngModelOptions.getOption('debounce'))(originalScope);

      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
      modelCtrl.$parsers.unshift(function(inputValue) {
        hasFocus = true;

        if (minLength === 0 || inputValue && inputValue.length >= minLength) {
          if (waitTime > 0) {
            cancelPreviousTimeout();
            scheduleSearchWithTimeout(inputValue);
          } else {
            getMatchesAsync(inputValue);
          }
        } else {
          isLoadingSetter(originalScope, false);
          cancelPreviousTimeout();
          resetMatches();
        }

        if (isEditable) {
          return inputValue;
        }

        if (!inputValue) {
          // Reset in case user had typed something previously.
          modelCtrl.$setValidity('editable', true);
          return null;
        }

        modelCtrl.$setValidity('editable', false);
        return undefined;
      });

      modelCtrl.$formatters.push(function(modelValue) {
        var candidateViewValue, emptyViewValue;
        var locals = {};

        // The validity may be set to false via $parsers (see above) if
        // the model is restricted to selected values. If the model
        // is set manually it is considered to be valid.
        if (!isEditable) {
          modelCtrl.$setValidity('editable', true);
        }

        if (inputFormatter) {
          locals.$model = modelValue;
          return inputFormatter(originalScope, locals);
        }

        //it might happen that we don't have enough info to properly render input value
        //we need to check for this situation and simply return model value if we can't apply custom formatting
        locals[parserResult.itemName] = modelValue;
        candidateViewValue = parserResult.viewMapper(originalScope, locals);
        locals[parserResult.itemName] = undefined;
        emptyViewValue = parserResult.viewMapper(originalScope, locals);

        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
      });
    };

    function extractOptions(ngModelCtrl) {
      var ngModelOptions;

      if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing
        // guarantee a value
        ngModelOptions = ngModelCtrl.$options || {};

        // mimic 1.6+ api
        ngModelOptions.getOption = function (key) {
          return ngModelOptions[key];
        };
      } else { // in angular >=1.6 $options is always present
        ngModelOptions = ngModelCtrl.$options;
      }

      return ngModelOptions;
    }
  }])

  .directive('uibTypeahead', function() {
    return {
      controller: 'UibTypeaheadController',
      require: ['ngModel', 'uibTypeahead'],
      link: function(originalScope, element, attrs, ctrls) {
        ctrls[1].init(ctrls[0]);
      }
    };
  })

  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {
    return {
      scope: {
        matches: '=',
        query: '=',
        active: '=',
        position: '&',
        moveInProgress: '=',
        select: '&',
        assignIsOpen: '&',
        debounce: '&'
      },
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
      },
      link: function(scope, element, attrs) {
        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function() {
          var isDropdownOpen = scope.matches.length > 0;
          scope.assignIsOpen({ isOpen: isDropdownOpen });
          return isDropdownOpen;
        };

        scope.isActive = function(matchIdx) {
          return scope.active === matchIdx;
        };

        scope.selectActive = function(matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function(activeIdx, evt) {
          var debounce = scope.debounce();
          if (angular.isNumber(debounce) || angular.isObject(debounce)) {
            $$debounce(function() {
              scope.select({activeIdx: activeIdx, evt: evt});
            }, angular.isNumber(debounce) ? debounce : debounce['default']);
          } else {
            scope.select({activeIdx: activeIdx, evt: evt});
          }
        };
      }
    };
  }])

  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
    return {
      scope: {
        index: '=',
        match: '=',
        query: '='
      },
      link: function(scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
        $templateRequest(tplUrl).then(function(tplContent) {
          var tplEl = angular.element(tplContent.trim());
          element.replaceWith(tplEl);
          $compile(tplEl)(scope);
        });
      }
    };
  }])

  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has('$sanitize');

    function escapeRegexp(queryToEscape) {
      // Regex: capture the whole query string and replace it with the string that will be used to match
      // the results, for example if the capture is "a" the result will be \a
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }

    function containsHtml(matchItem) {
      return /<.*>/g.test(matchItem);
    }

    return function(matchItem, query) {
      if (!isSanitizePresent && containsHtml(matchItem)) {
        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
      }
      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
      if (!isSanitizePresent) {
        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
      }
      return matchItem;
    };
  }]);

angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/accordion/accordion-group.html",
    "<div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
    "  <h4 class=\"panel-title\">\n" +
    "    <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\" ng-disabled=\"isDisabled\" uib-tabindex-toggle><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
    "  </h4>\n" +
    "</div>\n" +
    "<div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" +
    "  <div class=\"panel-body\" ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/accordion/accordion.html",
    "<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
}]);

angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/alert/alert.html",
    "<button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" +
    "  <span aria-hidden=\"true\">&times;</span>\n" +
    "  <span class=\"sr-only\">Close</span>\n" +
    "</button>\n" +
    "<div ng-transclude></div>\n" +
    "");
}]);

angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/carousel/carousel.html",
    "<div class=\"carousel-inner\" ng-transclude></div>\n" +
    "<a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\n" +
    "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
    "  <span class=\"sr-only\">previous</span>\n" +
    "</a>\n" +
    "<a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\n" +
    "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
    "  <span class=\"sr-only\">next</span>\n" +
    "</a>\n" +
    "<ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
    "  <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
    "    <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
    "  </li>\n" +
    "</ol>\n" +
    "");
}]);

angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/carousel/slide.html",
    "<div class=\"text-center\" ng-transclude></div>\n" +
    "");
}]);

angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/datepicker.html",
    "<div ng-switch=\"datepickerMode\">\n" +
    "  <div uib-daypicker ng-switch-when=\"day\" tabindex=\"0\" class=\"uib-daypicker\"></div>\n" +
    "  <div uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\" class=\"uib-monthpicker\"></div>\n" +
    "  <div uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\" class=\"uib-yearpicker\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/day.html",
    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" +
    "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
    "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" +
    "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
    "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/month.html",
    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" +
    "      <th colspan=\"{{::yearHeaderColspan}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" +
    "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" class=\"btn btn-default\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepicker/year.html",
    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\n" +
    "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\" role=\"row\">\n" +
    "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" +
    "        id=\"{{::dt.uid}}\"\n" +
    "        ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" class=\"btn btn-default\"\n" +
    "          uib-is-class=\"\n" +
    "            'btn-info' for selectedDt,\n" +
    "            'active' for activeDt\n" +
    "            on dt\"\n" +
    "          ng-click=\"select(dt.date)\"\n" +
    "          ng-disabled=\"::dt.disabled\"\n" +
    "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("uib/template/datepickerPopup/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/datepickerPopup/popup.html",
    "<ul role=\"presentation\" class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
    "  <li ng-transclude></li>\n" +
    "  <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" +
    "    <span class=\"btn-group pull-left\">\n" +
    "      <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
    "      <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" +
    "    </span>\n" +
    "    <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" +
    "  </li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("uib/template/modal/window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/modal/window.html",
    "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" +
    "");
}]);

angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/pager/pager.html",
    "<li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" +
    "<li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" +
    "");
}]);

angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/pagination/pagination.html",
    "<li role=\"menuitem\" ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('first')}}</a></li>\n" +
    "<li role=\"menuitem\" ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\n" +
    "<li role=\"menuitem\" ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\" ng-disabled=\"ngDisabled&&!page.active\" uib-tabindex-toggle>{{page.text}}</a></li>\n" +
    "<li role=\"menuitem\" ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\n" +
    "<li role=\"menuitem\" ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText('last')}}</a></li>\n" +
    "");
}]);

angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-html-popup.html",
    "<div class=\"tooltip-arrow\"></div>\n" +
    "<div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
    "");
}]);

angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-popup.html",
    "<div class=\"tooltip-arrow\"></div>\n" +
    "<div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
    "");
}]);

angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tooltip/tooltip-template-popup.html",
    "<div class=\"tooltip-arrow\"></div>\n" +
    "<div class=\"tooltip-inner\"\n" +
    "  uib-tooltip-template-transclude=\"contentExp()\"\n" +
    "  tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
    "");
}]);

angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover-html.html",
    "<div class=\"arrow\"></div>\n" +
    "\n" +
    "<div class=\"popover-inner\">\n" +
    "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
    "    <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover-template.html",
    "<div class=\"arrow\"></div>\n" +
    "\n" +
    "<div class=\"popover-inner\">\n" +
    "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
    "    <div class=\"popover-content\"\n" +
    "      uib-tooltip-template-transclude=\"contentExp()\"\n" +
    "      tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/popover/popover.html",
    "<div class=\"arrow\"></div>\n" +
    "\n" +
    "<div class=\"popover-inner\">\n" +
    "    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" +
    "    <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/bar.html",
    "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
    "");
}]);

angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/progress.html",
    "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
}]);

angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/progressbar/progressbar.html",
    "<div class=\"progress\">\n" +
    "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/rating/rating.html",
    "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" +
    "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
    "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\"></i>\n" +
    "</span>\n" +
    "");
}]);

angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tabs/tab.html",
    "<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\n" +
    "  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/tabs/tabset.html",
    "<div>\n" +
    "  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
    "  <div class=\"tab-content\">\n" +
    "    <div class=\"tab-pane\"\n" +
    "         ng-repeat=\"tab in tabset.tabs\"\n" +
    "         ng-class=\"{active: tabset.active === tab.index}\"\n" +
    "         uib-tab-content-transclude=\"tab\">\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/timepicker/timepicker.html",
    "<table class=\"uib-timepicker\">\n" +
    "  <tbody>\n" +
    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
    "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td>&nbsp;</td>\n" +
    "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
    "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td ng-show=\"showMeridian\"></td>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" +
    "        <input type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" +
    "      </td>\n" +
    "      <td class=\"uib-separator\">:</td>\n" +
    "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
    "        <input type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" +
    "      </td>\n" +
    "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" +
    "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" +
    "        <input type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" +
    "      </td>\n" +
    "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" +
    "    </tr>\n" +
    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
    "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td>&nbsp;</td>\n" +
    "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
    "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td ng-show=\"showMeridian\"></td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/typeahead/typeahead-match.html",
    "<a href\n" +
    "   tabindex=\"-1\"\n" +
    "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" +
    "   ng-attr-title=\"{{match.label}}\"></a>\n" +
    "");
}]);

angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("uib/template/typeahead/typeahead-popup.html",
    "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
    "    <li class=\"uib-typeahead-match\" ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" +
    "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
    "    </li>\n" +
    "</ul>\n" +
    "");
}]);
angular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });
angular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });
angular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'); angular.$$uibPositionCss = true; });
angular.module('ui.bootstrap.datepickerPopup').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'); angular.$$uibDatepickerpopupCss = true; });
angular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });
angular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });
angular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * # Angular 1 Directives
 *
 * These are the directives included in UI-Router for Angular 1.
 * These directives are used in templates to create viewports and link/navigate to states.
 *
 * @ng1api
 * @preferred
 * @module directives
 */ /** for typedoc */
var angular_1 = __webpack_require__(10);
var core_1 = __webpack_require__(4);
/** @hidden */
function parseStateRef(ref) {
    var paramsOnly = ref.match(/^\s*({[^}]*})\s*$/), parsed;
    if (paramsOnly)
        ref = '(' + paramsOnly[1] + ')';
    parsed = ref.replace(/\n/g, " ").match(/^\s*([^(]*?)\s*(\((.*)\))?\s*$/);
    if (!parsed || parsed.length !== 4)
        throw new Error("Invalid state ref '" + ref + "'");
    return { state: parsed[1] || null, paramExpr: parsed[3] || null };
}
/** @hidden */
function stateContext(el) {
    var $uiView = el.parent().inheritedData('$uiView');
    var path = core_1.parse('$cfg.path')($uiView);
    return path ? core_1.tail(path).state.name : undefined;
}
/** @hidden */
function processedDef($state, $element, def) {
    var uiState = def.uiState || $state.current.name;
    var uiStateOpts = core_1.extend(defaultOpts($element, $state), def.uiStateOpts || {});
    var href = $state.href(uiState, def.uiStateParams, uiStateOpts);
    return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };
}
/** @hidden */
function getTypeInfo(el) {
    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
    var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
    var isForm = el[0].nodeName === "FORM";
    return {
        attr: isForm ? "action" : (isSvg ? 'xlink:href' : 'href'),
        isAnchor: el.prop("tagName").toUpperCase() === "A",
        clickable: !isForm
    };
}
/** @hidden */
function clickHook(el, $state, $timeout, type, getDef) {
    return function (e) {
        var button = e.which || e.button, target = getDef();
        if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
            // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
            var transition = $timeout(function () {
                $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);
            });
            e.preventDefault();
            // if the state has no URL, ignore one preventDefault from the <a> directive.
            var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
            e.preventDefault = function () {
                if (ignorePreventDefaultCount-- <= 0)
                    $timeout.cancel(transition);
            };
        }
    };
}
/** @hidden */
function defaultOpts(el, $state) {
    return {
        relative: stateContext(el) || $state.$current,
        inherit: true,
        source: "sref"
    };
}
/** @hidden */
function bindEvents(element, scope, hookFn, uiStateOpts) {
    var events;
    if (uiStateOpts) {
        events = uiStateOpts.events;
    }
    if (!core_1.isArray(events)) {
        events = ['click'];
    }
    var on = element.on ? 'on' : 'bind';
    for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {
        var event_1 = events_1[_i];
        element[on](event_1, hookFn);
    }
    scope.$on('$destroy', function () {
        var off = element.off ? 'off' : 'unbind';
        for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {
            var event_2 = events_2[_i];
            element[off](event_2, hookFn);
        }
    });
}
/**
 * `ui-sref`: A directive for linking to a state
 *
 * A directive which links to a state (and optionally, parameters).
 * When clicked, this directive activates the linked state with the supplied parameter values.
 *
 * ### Linked State
 * The attribute value of the `ui-sref` is the name of the state to link to.
 *
 * #### Example:
 * This will activate the `home` state when the link is clicked.
 * ```html
 * <a ui-sref="home">Home</a>
 * ```
 *
 * ### Relative Links
 * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).
 * You just need to be aware that the path is relative to the state that *created* the link.
 * This allows a state to create a relative `ui-sref` which always targets the same destination.
 *
 * #### Example:
 * Both these links are relative to the parent state, even when a child state is currently active.
 * ```html
 * <a ui-sref=".child1">child 1 state</a>
 * <a ui-sref=".child2">child 2 state</a>
 * ```
 *
 * This link activates the parent state.
 * ```html
 * <a ui-sref="^">Return</a>
 * ```
 *
 * ### hrefs
 * If the linked state has a URL, the directive will automatically generate and
 * update the `href` attribute (using the [[StateService.href]]  method).
 *
 * #### Example:
 * Assuming the `users` state has a url of `/users/`
 * ```html
 * <a ui-sref="users" href="/users/">Users</a>
 * ```
 *
 * ### Parameter Values
 * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.
 * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.
 * The content inside the parentheses is an expression, evaluated to the parameter values.
 *
 * #### Example:
 * This example renders a list of links to users.
 * The state's `userId` parameter value comes from each user's `user.id` property.
 * ```html
 * <li ng-repeat="user in users">
 *   <a ui-sref="users.detail({ userId: user.id })">{{ user.displayName }}</a>
 * </li>
 * ```
 *
 * Note:
 * The parameter values expression is `$watch`ed for updates.
 *
 * ### Transition Options
 * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.
 * Options are restricted to `location`, `inherit`, and `reload`.
 *
 * #### Example:
 * ```html
 * <a ui-sref="home" ui-sref-opts="{ reload: true }">Home</a>
 * ```
 *
 * ### Other DOM Events
 *
 * You can also customize which DOM events to respond to (instead of `click`) by
 * providing an `events` array in the `ui-sref-opts` attribute.
 *
 * #### Example:
 * ```html
 * <input type="text" ui-sref="contacts" ui-sref-opts="{ events: ['change', 'blur'] }">
 * ```
 *
 * ### Highlighting the active link
 * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.
 *
 * ### Examples
 * If you have the following template:
 *
 * ```html
 * <a ui-sref="home">Home</a>
 * <a ui-sref="about">About</a>
 * <a ui-sref="{page: 2}">Next page</a>
 *
 * <ul>
 *     <li ng-repeat="contact in contacts">
 *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
 *     </li>
 * </ul>
 * ```
 *
 * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:
 *
 * ```html
 * <a href="#/home" ui-sref="home">Home</a>
 * <a href="#/about" ui-sref="about">About</a>
 * <a href="#/contacts?page=2" ui-sref="{page: 2}">Next page</a>
 *
 * <ul>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
 *     </li>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
 *     </li>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
 *     </li>
 * </ul>
 *
 * <a href="#/home" ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
 * ```
 *
 * ### Notes
 *
 * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.
 * #### Example:
 * Sets the `lang` parameter to `en` and remains on the same state.
 *
 * ```html
 * <a ui-sref="{ lang: 'en' }">English</a>
 * ```
 *
 * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.
 *
 * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).
 * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.
 */
var uiSref;
uiSref = ['$uiRouter', '$timeout',
    function $StateRefDirective($uiRouter, $timeout) {
        var $state = $uiRouter.stateService;
        return {
            restrict: 'A',
            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
            link: function (scope, element, attrs, uiSrefActive) {
                var type = getTypeInfo(element);
                var active = uiSrefActive[1] || uiSrefActive[0];
                var unlinkInfoFn = null;
                var hookFn;
                var rawDef = {};
                var getDef = function () { return processedDef($state, element, rawDef); };
                var ref = parseStateRef(attrs.uiSref);
                rawDef.uiState = ref.state;
                rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};
                function update() {
                    var def = getDef();
                    if (unlinkInfoFn)
                        unlinkInfoFn();
                    if (active)
                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);
                    if (def.href != null)
                        attrs.$set(type.attr, def.href);
                }
                if (ref.paramExpr) {
                    scope.$watch(ref.paramExpr, function (val) {
                        rawDef.uiStateParams = core_1.extend({}, val);
                        update();
                    }, true);
                    rawDef.uiStateParams = core_1.extend({}, scope.$eval(ref.paramExpr));
                }
                update();
                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));
                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));
                if (!type.clickable)
                    return;
                hookFn = clickHook(element, $state, $timeout, type, getDef);
                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);
            }
        };
    }];
/**
 * `ui-state`: A fully dynamic directive for linking to a state
 *
 * A directive which links to a state (and optionally, parameters).
 * When clicked, this directive activates the linked state with the supplied parameter values.
 *
 * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**
 *
 * A directive which links to a state (and optionally, parameters).
 * When clicked, this directive activates the linked state with the supplied parameter values.
 *
 * ### Linked State
 * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.
 * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**
 *
 * #### Example:
 * Create a list of links.
 * ```html
 * <li ng-repeat="link in navlinks">
 *   <a ui-state="link.state">{{ link.displayName }}</a>
 * </li>
 * ```
 *
 * ### Relative Links
 * If the expression evaluates to a relative path, it is processed like [[uiSref]].
 * You just need to be aware that the path is relative to the state that *created* the link.
 * This allows a state to create relative `ui-state` which always targets the same destination.
 *
 * ### hrefs
 * If the linked state has a URL, the directive will automatically generate and
 * update the `href` attribute (using the [[StateService.href]]  method).
 *
 * ### Parameter Values
 * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.
 * Param values should be provided using the `ui-state-params` attribute.
 * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.
 *
 * #### Example:
 * This example renders a list of links with param values.
 * The state's `userId` parameter value comes from each user's `user.id` property.
 * ```html
 * <li ng-repeat="link in navlinks">
 *   <a ui-state="link.state" ui-state-params="link.params">{{ link.displayName }}</a>
 * </li>
 * ```
 *
 * ### Transition Options
 * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.
 * Options are restricted to `location`, `inherit`, and `reload`.
 * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.
 *
 * #### Example:
 * ```html
 * <a ui-state="returnto.state" ui-state-opts="{ reload: true }">Home</a>
 * ```
 *
 * ### Other DOM Events
 *
 * You can also customize which DOM events to respond to (instead of `click`) by
 * providing an `events` array in the `ui-state-opts` attribute.
 *
 * #### Example:
 * ```html
 * <input type="text" ui-state="contacts" ui-state-opts="{ events: ['change', 'blur'] }">
 * ```
 *
 * ### Highlighting the active link
 * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.
 *
 * ### Notes
 *
 * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.
 *   However, it might be simpler to use [[uiSref]] parameter-only links.
 *
 * #### Example:
 * Sets the `lang` parameter to `en` and remains on the same state.
 *
 * ```html
 * <a ui-state="" ui-state-params="{ lang: 'en' }">English</a>
 * ```
 *
 * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.
 * ```
 */
var uiState;
uiState = ['$uiRouter', '$timeout',
    function $StateRefDynamicDirective($uiRouter, $timeout) {
        var $state = $uiRouter.stateService;
        return {
            restrict: 'A',
            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
            link: function (scope, element, attrs, uiSrefActive) {
                var type = getTypeInfo(element);
                var active = uiSrefActive[1] || uiSrefActive[0];
                var unlinkInfoFn = null;
                var hookFn;
                var rawDef = {};
                var getDef = function () { return processedDef($state, element, rawDef); };
                var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];
                var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return (acc[attr] = core_1.noop, acc); }, {});
                function update() {
                    var def = getDef();
                    if (unlinkInfoFn)
                        unlinkInfoFn();
                    if (active)
                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);
                    if (def.href != null)
                        attrs.$set(type.attr, def.href);
                }
                inputAttrs.forEach(function (field) {
                    rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;
                    attrs.$observe(field, function (expr) {
                        watchDeregFns[field]();
                        watchDeregFns[field] = scope.$watch(expr, function (newval) {
                            rawDef[field] = newval;
                            update();
                        }, true);
                    });
                });
                update();
                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));
                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));
                if (!type.clickable)
                    return;
                hookFn = clickHook(element, $state, $timeout, type, getDef);
                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);
            }
        };
    }];
/**
 * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active
 *
 * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the
 * related directive's state is active (and remove them when it is inactive).
 *
 * The primary use-case is to highlight the active link in navigation menus,
 * distinguishing it from the inactive menu items.
 *
 * ### Linking to a `ui-sref` or `ui-state`
 * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.
 * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.
 *
 * ### Matching
 *
 * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.
 * This is a "fuzzy match" which uses [[StateService.includes]].
 *
 * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).
 * This is an "exact match" which uses [[StateService.is]].
 *
 * ### Parameter values
 * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.
 * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.
 *
 * #### Example:
 * ```html
 * <li ng-repeat="user in users" ui-sref-active="active">
 *   <a ui-sref="user.details({ userId: user.id })">{{ user.lastName }}</a>
 * </li>
 * ```
 *
 * ### Examples
 *
 * Given the following template:
 * #### Example:
 * ```html
 * <ul>
 *   <li ui-sref-active="active" class="item">
 *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
 *   </li>
 * </ul>
 * ```
 *
 * When the app state is `app.user` (or any child state),
 * and contains the state parameter "user" with value "bilbobaggins",
 * the resulting HTML will appear as (note the 'active' class):
 *
 * ```html
 * <ul>
 *   <li ui-sref-active="active" class="item active">
 *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
 *   </li>
 * </ul>
 * ```
 *
 * ### Glob mode
 *
 * It is possible to pass `ui-sref-active` an expression that evaluates to an object.
 * The objects keys represent active class names and values represent the respective state names/globs.
 * `ui-sref-active` will match if the current active state **includes** any of
 * the specified state names/globs, even the abstract ones.
 *
 * #### Example:
 * Given the following template, with "admin" being an abstract state:
 * ```html
 * <div ui-sref-active="{'active': 'admin.**'}">
 *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
 * </div>
 * ```
 *
 * When the current state is "admin.roles" the "active" class will be applied to both the <div> and <a> elements.
 * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.
 *
 * ### Notes:
 *
 * - The class name is interpolated **once** during the directives link time (any further changes to the
 * interpolated value are ignored).
 *
 * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`
 */
var uiSrefActive;
uiSrefActive = ['$state', '$stateParams', '$interpolate', '$uiRouter',
    function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {
        return {
            restrict: "A",
            controller: ['$scope', '$element', '$attrs',
                function ($scope, $element, $attrs) {
                    var states = [], activeEqClass, uiSrefActive;
                    // There probably isn't much point in $observing this
                    // uiSrefActive and uiSrefActiveEq share the same directive object with some
                    // slight difference in logic routing
                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);
                    try {
                        uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                    }
                    catch (e) {
                        // Do nothing. uiSrefActive is not a valid expression.
                        // Fall back to using $interpolate below
                    }
                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
                    if (core_1.isObject(uiSrefActive)) {
                        core_1.forEach(uiSrefActive, function (stateOrName, activeClass) {
                            if (core_1.isString(stateOrName)) {
                                var ref = parseStateRef(stateOrName);
                                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                            }
                        });
                    }
                    // Allow uiSref to communicate with uiSrefActive[Equals]
                    this.$$addStateInfo = function (newState, newParams) {
                        // we already got an explicit state provided by ui-sref-active, so we
                        // shadow the one that comes from ui-sref
                        if (core_1.isObject(uiSrefActive) && states.length > 0) {
                            return;
                        }
                        var deregister = addState(newState, newParams, uiSrefActive);
                        update();
                        return deregister;
                    };
                    function updateAfterTransition(trans) {
                        trans.promise.then(update);
                    }
                    $scope.$on('$stateChangeSuccess', update);
                    $scope.$on('$destroy', $uiRouter.transitionService.onStart({}, updateAfterTransition));
                    if ($uiRouter.globals.transition) {
                        updateAfterTransition($uiRouter.globals.transition);
                    }
                    function addState(stateName, stateParams, activeClass) {
                        var state = $state.get(stateName, stateContext($element));
                        var stateInfo = {
                            state: state || { name: stateName },
                            params: stateParams,
                            activeClass: activeClass
                        };
                        states.push(stateInfo);
                        return function removeState() {
                            core_1.removeFrom(states)(stateInfo);
                        };
                    }
                    // Update route state
                    function update() {
                        var splitClasses = function (str) {
                            return str.split(/\s/).filter(core_1.identity);
                        };
                        var getClasses = function (stateList) {
                            return stateList.map(function (x) { return x.activeClass; }).map(splitClasses).reduce(core_1.unnestR, []);
                        };
                        var allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(core_1.uniqR, []);
                        var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));
                        var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;
                        var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];
                        var addClasses = fuzzyClasses.concat(exactClasses).reduce(core_1.uniqR, []);
                        var removeClasses = allClasses.filter(function (cls) { return !core_1.inArray(addClasses, cls); });
                        $scope.$evalAsync(function () {
                            addClasses.forEach(function (className) { return $element.addClass(className); });
                            removeClasses.forEach(function (className) { return $element.removeClass(className); });
                        });
                    }
                    update();
                }]
        };
    }];
angular_1.ng.module('ui.router.state')
    .directive('uiSref', uiSref)
    .directive('uiSrefActive', uiSrefActive)
    .directive('uiSrefActiveEq', uiSrefActive)
    .directive('uiState', uiState);
//# sourceMappingURL=stateDirectives.js.map

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @ng1api
 * @module directives
 */ /** for typedoc */
var angular_1 = __webpack_require__(10);
var angular_2 = __webpack_require__(11);
var core_1 = __webpack_require__(4);
var views_1 = __webpack_require__(30);
var services_1 = __webpack_require__(29);
exports.uiView = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q',
    function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {
        function getRenderer(attrs, scope) {
            return {
                enter: function (element, target, cb) {
                    if (angular_1.ng.version.minor > 2) {
                        $animate.enter(element, null, target).then(cb);
                    }
                    else {
                        $animate.enter(element, null, target, cb);
                    }
                },
                leave: function (element, cb) {
                    if (angular_1.ng.version.minor > 2) {
                        $animate.leave(element).then(cb);
                    }
                    else {
                        $animate.leave(element, cb);
                    }
                }
            };
        }
        function configsEqual(config1, config2) {
            return config1 === config2;
        }
        var rootData = {
            $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },
            $uiView: {}
        };
        var directive = {
            count: 0,
            restrict: 'ECA',
            terminal: true,
            priority: 400,
            transclude: 'element',
            compile: function (tElement, tAttrs, $transclude) {
                return function (scope, $element, attrs) {
                    var previousEl, currentEl, currentScope, unregister, onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(attrs, scope), viewConfig = undefined, inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';
                    var activeUIView = {
                        $type: 'ng1',
                        id: directive.count++,
                        name: name,
                        fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + "." + name : name,
                        config: null,
                        configUpdated: configUpdatedCallback,
                        get creationContext() {
                            var fromParentTagConfig = core_1.parse('$cfg.viewDecl.$context')(inherited);
                            // Allow <ui-view name="foo"><ui-view name="bar"></ui-view></ui-view>
                            // See https://github.com/angular-ui/ui-router/issues/3355
                            var fromParentTag = core_1.parse('$uiView.creationContext')(inherited);
                            return fromParentTagConfig || fromParentTag;
                        }
                    };
                    core_1.trace.traceUIViewEvent("Linking", activeUIView);
                    function configUpdatedCallback(config) {
                        if (config && !(config instanceof views_1.Ng1ViewConfig))
                            return;
                        if (configsEqual(viewConfig, config))
                            return;
                        core_1.trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);
                        viewConfig = config;
                        updateView(config);
                    }
                    $element.data('$uiView', { $uiView: activeUIView });
                    updateView();
                    unregister = $view.registerUIView(activeUIView);
                    scope.$on("$destroy", function () {
                        core_1.trace.traceUIViewEvent("Destroying/Unregistering", activeUIView);
                        unregister();
                    });
                    function cleanupLastView() {
                        if (previousEl) {
                            core_1.trace.traceUIViewEvent("Removing (previous) el", previousEl.data('$uiView'));
                            previousEl.remove();
                            previousEl = null;
                        }
                        if (currentScope) {
                            core_1.trace.traceUIViewEvent("Destroying scope", activeUIView);
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentEl) {
                            var _viewData_1 = currentEl.data('$uiViewAnim');
                            core_1.trace.traceUIViewEvent("Animate out", _viewData_1);
                            renderer.leave(currentEl, function () {
                                _viewData_1.$$animLeave.resolve();
                                previousEl = null;
                            });
                            previousEl = currentEl;
                            currentEl = null;
                        }
                    }
                    function updateView(config) {
                        var newScope = scope.$new();
                        var animEnter = $q.defer(), animLeave = $q.defer();
                        var $uiViewData = {
                            $cfg: config,
                            $uiView: activeUIView,
                        };
                        var $uiViewAnim = {
                            $animEnter: animEnter.promise,
                            $animLeave: animLeave.promise,
                            $$animLeave: animLeave
                        };
                        /**
                         * @ngdoc event
                         * @name ui.router.state.directive:ui-view#$viewContentLoading
                         * @eventOf ui.router.state.directive:ui-view
                         * @eventType emits on ui-view directive scope
                         * @description
                         *
                         * Fired once the view **begins loading**, *before* the DOM is rendered.
                         *
                         * @param {Object} event Event object.
                         * @param {string} viewName Name of the view.
                         */
                        newScope.$emit('$viewContentLoading', name);
                        var cloned = $transclude(newScope, function (clone) {
                            clone.data('$uiViewAnim', $uiViewAnim);
                            clone.data('$uiView', $uiViewData);
                            renderer.enter(clone, $element, function onUIViewEnter() {
                                animEnter.resolve();
                                if (currentScope)
                                    currentScope.$emit('$viewContentAnimationEnded');
                                if (core_1.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                                    $uiViewScroll(clone);
                                }
                            });
                            cleanupLastView();
                        });
                        currentEl = cloned;
                        currentScope = newScope;
                        /**
                         * @ngdoc event
                         * @name ui.router.state.directive:ui-view#$viewContentLoaded
                         * @eventOf ui.router.state.directive:ui-view
                         * @eventType emits on ui-view directive scope
                         * @description           *
                         * Fired once the view is **loaded**, *after* the DOM is rendered.
                         *
                         * @param {Object} event Event object.
                         */
                        currentScope.$emit('$viewContentLoaded', config || viewConfig);
                        currentScope.$eval(onloadExp);
                    }
                };
            }
        };
        return directive;
    }];
$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];
/** @hidden */
function $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {
    var getControllerAs = core_1.parse('viewDecl.controllerAs');
    var getResolveAs = core_1.parse('viewDecl.resolveAs');
    return {
        restrict: 'ECA',
        priority: -400,
        compile: function (tElement) {
            var initial = tElement.html();
            tElement.empty();
            return function (scope, $element) {
                var data = $element.data('$uiView');
                if (!data) {
                    $element.html(initial);
                    $compile($element.contents())(scope);
                    return;
                }
                var cfg = data.$cfg || { viewDecl: {}, getTemplate: angular_2.noop };
                var resolveCtx = cfg.path && new core_1.ResolveContext(cfg.path);
                $element.html(cfg.getTemplate($element, resolveCtx) || initial);
                core_1.trace.traceUIViewFill(data.$uiView, $element.html());
                var link = $compile($element.contents());
                var controller = cfg.controller;
                var controllerAs = getControllerAs(cfg);
                var resolveAs = getResolveAs(cfg);
                var locals = resolveCtx && services_1.getLocals(resolveCtx);
                scope[resolveAs] = locals;
                if (controller) {
                    var controllerInstance = $controller(controller, core_1.extend({}, locals, { $scope: scope, $element: $element }));
                    if (controllerAs) {
                        scope[controllerAs] = controllerInstance;
                        scope[controllerAs][resolveAs] = locals;
                    }
                    // TODO: Use $view service as a central point for registering component-level hooks
                    // Then, when a component is created, tell the $view service, so it can invoke hooks
                    // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });
                    // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));
                    $element.data('$ngControllerController', controllerInstance);
                    $element.children().data('$ngControllerController', controllerInstance);
                    registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);
                }
                // Wait for the component to appear in the DOM
                if (core_1.isString(cfg.viewDecl.component)) {
                    var cmp_1 = cfg.viewDecl.component;
                    var kebobName = core_1.kebobString(cmp_1);
                    var tagRegexp_1 = new RegExp("^(x-|data-)?" + kebobName + "$", "i");
                    var getComponentController = function () {
                        var directiveEl = [].slice.call($element[0].children)
                            .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });
                        return directiveEl && angular_1.ng.element(directiveEl).data("$" + cmp_1 + "Controller");
                    };
                    var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {
                        if (!ctrlInstance)
                            return;
                        registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);
                        deregisterWatch_1();
                    });
                }
                link(scope);
            };
        }
    };
}
/** @hidden */
var hasComponentImpl = typeof angular_1.ng.module('ui.router')['component'] === 'function';
/** @hidden incrementing id */
var _uiCanExitId = 0;
/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */
function registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {
    // Call $onInit() ASAP
    if (core_1.isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl)) {
        controllerInstance.$onInit();
    }
    var viewState = core_1.tail(cfg.path).state.self;
    var hookOptions = { bind: controllerInstance };
    // Add component-level hook for onParamsChange
    if (core_1.isFunction(controllerInstance.uiOnParamsChanged)) {
        var resolveContext = new core_1.ResolveContext(cfg.path);
        var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;
        // Fire callback on any successful transition
        var paramsUpdated = function ($transition$) {
            // Exit early if the $transition$ is the same as the view was created within.
            // Exit early if the $transition$ will exit the state the view is for.
            if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)
                return;
            var toParams = $transition$.params("to");
            var fromParams = $transition$.params("from");
            var toSchema = $transition$.treeChanges().to.map(function (node) { return node.paramSchema; }).reduce(core_1.unnestR, []);
            var fromSchema = $transition$.treeChanges().from.map(function (node) { return node.paramSchema; }).reduce(core_1.unnestR, []);
            // Find the to params that have different values than the from params
            var changedToParams = toSchema.filter(function (param) {
                var idx = fromSchema.indexOf(param);
                return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);
            });
            // Only trigger callback if a to param has changed or is new
            if (changedToParams.length) {
                var changedKeys_1 = changedToParams.map(function (x) { return x.id; });
                // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.
                var newValues = core_1.filter(toParams, function (val, key) { return changedKeys_1.indexOf(key) !== -1; });
                controllerInstance.uiOnParamsChanged(newValues, $transition$);
            }
        };
        $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));
    }
    // Add component-level hook for uiCanExit
    if (core_1.isFunction(controllerInstance.uiCanExit)) {
        var id_1 = _uiCanExitId++;
        var cacheProp_1 = '_uiCanExitIds';
        // Returns true if a redirect transition already answered truthy
        var prevTruthyAnswer_1 = function (trans) {
            return !!trans && (trans[cacheProp_1] && trans[cacheProp_1][id_1] === true || prevTruthyAnswer_1(trans.redirectedFrom()));
        };
        // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition
        var wrappedHook = function (trans) {
            var promise, ids = trans[cacheProp_1] = trans[cacheProp_1] || {};
            if (!prevTruthyAnswer_1(trans)) {
                promise = $q.when(controllerInstance.uiCanExit(trans));
                promise.then(function (val) { return ids[id_1] = (val !== false); });
            }
            return promise;
        };
        var criteria = { exiting: viewState.name };
        $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));
    }
}
angular_1.ng.module('ui.router.state').directive('uiView', exports.uiView);
angular_1.ng.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
//# sourceMappingURL=viewDirective.js.map

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * # Angular 1 injectable services
 *
 * This is a list of the objects which can be injected using angular's injector.
 *
 * There are three different kind of injectable objects:
 *
 * ## **Provider** objects
 * #### injectable into a `.config()` block during configtime
 *
 * - [[$uiRouterProvider]]: The UI-Router instance
 * - [[$stateProvider]]: State registration
 * - [[$transitionsProvider]]: Transition hooks
 * - [[$urlServiceProvider]]: All URL related public APIs
 *
 * - [[$uiViewScrollProvider]]: Disable ui-router view scrolling
 * - [[$urlRouterProvider]]: (deprecated) Url matching rules
 * - [[$urlMatcherFactoryProvider]]: (deprecated) Url parsing config
 *
 * ## **Service** objects
 * #### injectable globally during runtime
 *
 * - [[$uiRouter]]: The UI-Router instance
 * - [[$trace]]: Enable transition trace/debug
 * - [[$transitions]]: Transition hooks
 * - [[$state]]: Imperative state related APIs
 * - [[$stateRegistry]]: State registration
 * - [[$urlService]]: All URL related public APIs
 * - [[$uiRouterGlobals]]: Global variables
 * - [[$uiViewScroll]]: Scroll an element into view
 *
 * - [[$stateParams]]: (deprecated) Global state param values
 * - [[$urlRouter]]: (deprecated) URL synchronization
 * - [[$urlMatcherFactory]]: (deprecated) URL parsing config
 *
 * ## **Per-Transition** objects
 *
 * - These kind of objects are injectable into:
 *   - Resolves ([[Ng1StateDeclaration.resolve]]),
 *   - Transition Hooks ([[TransitionService.onStart]], etc),
 *   - Routed Controllers ([[Ng1ViewDeclaration.controller]])
 *
 * #### Different instances are injected based on the [[Transition]]
 *
 * - [[$transition$]]: The current Transition object
 * - [[$stateParams]]: State param values for pending Transition (deprecated)
 * - Any resolve data defined using [[Ng1StateDeclaration.resolve]]
 *
 * @ng1api
 * @preferred
 * @module injectables
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The current (or pending) State Parameters
 *
 * An injectable global **Service Object** which holds the state parameters for the latest **SUCCESSFUL** transition.
 *
 * The values are not updated until *after* a `Transition` successfully completes.
 *
 * **Also:** an injectable **Per-Transition Object** object which holds the pending state parameters for the pending `Transition` currently running.
 *
 * ### Deprecation warning:
 *
 * The value injected for `$stateParams` is different depending on where it is injected.
 *
 * - When injected into an angular service, the object injected is the global **Service Object** with the parameter values for the latest successful `Transition`.
 * - When injected into transition hooks, resolves, or view controllers, the object is the **Per-Transition Object** with the parameter values for the running `Transition`.
 *
 * Because of these confusing details, this service is deprecated.
 *
 * ### Instead of using the global `$stateParams` service object,
 * inject [[$uiRouterGlobals]] and use [[UIRouterGlobals.params]]
 *
 * ```js
 * MyService.$inject = ['$uiRouterGlobals'];
 * function MyService($uiRouterGlobals) {
 *   return {
 *     paramValues: function () {
 *       return $uiRouterGlobals.params;
 *     }
 *   }
 * }
 * ```
 *
 * ### Instead of using the per-transition `$stateParams` object,
 * inject the current `Transition` (as [[$transition$]]) and use [[Transition.params]]
 *
 * ```js
 * MyController.$inject = ['$transition$'];
 * function MyController($transition$) {
 *   var username = $transition$.params().username;
 *   // .. do something with username
 * }
 * ```
 *
 * ---
 *
 * This object can be injected into other services.
 *
 * #### Deprecated Example:
 * ```js
 * SomeService.$inject = ['$http', '$stateParams'];
 * function SomeService($http, $stateParams) {
 *   return {
 *     getUser: function() {
 *       return $http.get('/api/users/' + $stateParams.username);
 *     }
 *   }
 * };
 * angular.service('SomeService', SomeService);
 * ```
 * @deprecated
 */
var $stateParams;
/**
 * Global UI-Router variables
 *
 * The router global state as a **Service Object** (injectable during runtime).
 *
 * This object contains globals such as the current state and current parameter values.
 */
var $uiRouterGlobals;
/**
 * The UI-Router instance
 *
 * The [[UIRouter]] singleton (the router instance) as a **Service Object** (injectable during runtime).
 *
 * This object is the UI-Router singleton instance, created by angular dependency injection during application bootstrap.
 * It has references to the other UI-Router services
 *
 * #### Note: This object is also exposed as [[$uiRouterProvider]] for injection during angular config time.
 */
var $uiRouter;
/**
 * The UI-Router instance
 *
 * The [[UIRouter]] singleton (the router instance) as a **Provider Object** (injectable during config phase).
 *
 * This object is the UI-Router singleton instance, created by angular dependency injection during application bootstrap.
 * It has references to the other UI-Router services
 *
 * #### Note: This object is also exposed as [[$uiRouter]] for injection during runtime.
 */
var $uiRouterProvider;
/**
 * Transition debug/tracing
 *
 * The [[Trace]] singleton as a **Service Object** (injectable during runtime).
 *
 * Enables or disables Transition tracing which can help to debug issues.
 */
var $trace;
/**
 * The Transition Service
 *
 * The [[TransitionService]] singleton as a **Service Object** (injectable during runtime).
 *
 * This angular service exposes the [[TransitionService]] singleton, which is primarily
 * used to register global transition hooks.
 *
 * #### Note: This object is also exposed as [[$transitionsProvider]] for injection during the config phase.
 */
var $transitions;
/**
 * The Transition Service
 *
 * The [[TransitionService]] singleton as a **Provider Object** (injectable during config phase)
 *
 * This angular service exposes the [[TransitionService]] singleton, which is primarily
 * used to register global transition hooks.
 *
 * #### Note: This object is also exposed as [[$transitions]] for injection during runtime.
 */
var $transitionsProvider;
/**
 * The current [[Transition]] object
 *
 * The current [[Transition]] object as a **Per-Transition Object** (injectable into Resolve, Hooks, Controllers)
 *
 * This object returns information about the current transition, including:
 *
 * - To/from states
 * - To/from parameters
 * - Transition options
 * - States being entered, exited, and retained
 * - Resolve data
 * - A Promise for the transition
 * - Any transition failure information
 * - An injector for both Service and Per-Transition Objects
 */
var $transition$;
/**
 * The State Service
 *
 * The [[StateService]] singleton as a **Service Object** (injectable during runtime).
 *
 * This service used to manage and query information on registered states.
 * It exposes state related APIs including:
 *
 * - Start a [[Transition]]
 * - Imperatively lazy load states
 * - Check if a state is currently active
 * - Look up states by name
 * - Build URLs for a state+parameters
 * - Configure the global Transition error handler
 *
 * This angular service exposes the [[StateService]] singleton.
 */
var $state;
/**
 * The State Registry
 *
 * The [[StateRegistry]] singleton as a **Service Object** (injectable during runtime).
 *
 * This service is used to register/deregister states.
 * It has state registration related APIs including:
 *
 * - Register/deregister states
 * - Listen for state registration/deregistration
 * - Get states by name
 * - Add state decorators (to customize the state creation process)
 *
 * #### Note: This object is also exposed as [[$stateRegistryProvider]] for injection during the config phase.
 */
var $stateRegistry;
/**
 * The State Registry
 *
 * The [[StateRegistry]] singleton as a **Provider Object** (injectable during config time).
 *
 * This service is used to register/deregister states.
 * It has state registration related APIs including:
 *
 * - Register/deregister states
 * - Listen for state registration/deregistration
 * - Get states by name
 * - Add state decorators (to customize the state creation process)
 *
 * #### Note: This object is also exposed as [[$stateRegistry]] for injection during runtime.
 */
var $stateRegistryProvider;
/**
 * The View Scroll provider
 *
 * The [[UIViewScrollProvider]] as a **Provider Object** (injectable during config time).
 *
 * This angular service exposes the [[UIViewScrollProvider]] singleton and is
 * used to disable UI-Router's scroll behavior.
 */
var $uiViewScrollProvider;
/**
 * The View Scroll function
 *
 * The View Scroll function as a **Service Object** (injectable during runtime).
 *
 * This is a function that scrolls an element into view.
 * The element is scrolled after a `$timeout` so the DOM has time to refresh.
 *
 * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,
 * this can be enabled by calling [[UIViewScrollProvider.useAnchorScroll]].
 *
 * Note: this function is used by the [[directives.uiView]] when the `autoscroll` expression evaluates to true.
 */
var $uiViewScroll;
/**
 * The StateProvider
 *
 * An angular1-only [[StateProvider]] as a **Provider Object** (injectable during config time).
 *
 * This angular service exposes the [[StateProvider]] singleton.
 *
 * The `StateProvider` is primarily used to register states or add custom state decorators.
 *
 * ##### Note: This provider is a ng1 vestige.
 * It is a passthrough to [[$stateRegistry]] and [[$state]].
 */
var $stateProvider;
/**
 * The URL Service Provider
 *
 * The [[UrlService]] singleton as a **Provider Object** (injectable during the angular config phase).
 *
 * A service used to configure and interact with the URL.
 * It has URL related APIs including:
 *
 * - register custom Parameter types `UrlService.config.type` ([[UrlConfigApi.type]])
 * - add URL rules: `UrlService.rules.when` ([[UrlRulesApi.when]])
 * - configure behavior when no url matches: `UrlService.rules.otherwise` ([[UrlRulesApi.otherwise]])
 * - delay initial URL synchronization [[UrlService.deferIntercept]].
 * - get or set the current url: [[UrlService.url]]
 *
 * ##### Note: This service can also be injected during runtime as [[$urlService]].
 */
var $urlServiceProvider;
/**
 * The URL Service
 *
 * The [[UrlService]] singleton as a **Service Object** (injectable during runtime).
 *
 * Note: This service can also be injected during the config phase as [[$urlServiceProvider]].
 *
 * Used to configure the URL.
 * It has URL related APIs including:
 *
 * - register custom Parameter types `UrlService.config.type` ([[UrlConfigApi.type]])
 * - add URL rules: `UrlService.rules.when` ([[UrlRulesApi.when]])
 * - configure behavior when no url matches: `UrlService.rules.otherwise` ([[UrlRulesApi.otherwise]])
 * - delay initial URL synchronization [[UrlService.deferIntercept]].
 * - get or set the current url: [[UrlService.url]]
 *
 * ##### Note: This service can also be injected during the config phase as [[$urlServiceProvider]].
 */
var $urlService;
/**
 * The URL Router Provider
 *
 * ### Deprecation warning: This object is now considered internal. Use [[$urlServiceProvider]] instead.
 *
 * The [[UrlRouter]] singleton as a **Provider Object** (injectable during config time).
 *
 * #### Note: This object is also exposed as [[$urlRouter]] for injection during runtime.
 *
 * @deprecated
 */
var $urlRouterProvider;
/**
 * The Url Router
 *
 * ### Deprecation warning: This object is now considered internal. Use [[$urlService]] instead.
 *
 * The [[UrlRouter]] singleton as a **Service Object** (injectable during runtime).
 *
 * #### Note: This object is also exposed as [[$urlRouterProvider]] for injection during angular config time.
 *
 * @deprecated
 */
var $urlRouter;
/**
 * The URL Matcher Factory
 *
 * ### Deprecation warning: This object is now considered internal. Use [[$urlService]] instead.
 *
 * The [[UrlMatcherFactory]] singleton as a **Service Object** (injectable during runtime).
 *
 * This service is used to set url mapping options, define custom parameter types, and create [[UrlMatcher]] objects.
 *
 * #### Note: This object is also exposed as [[$urlMatcherFactoryProvider]] for injection during angular config time.
 *
 * @deprecated
 */
var $urlMatcherFactory;
/**
 * The URL Matcher Factory
 *
 * ### Deprecation warning: This object is now considered internal. Use [[$urlService]] instead.
 *
 * The [[UrlMatcherFactory]] singleton as a **Provider Object** (injectable during config time).
 *
 * This service is used to set url mapping options, define custom parameter types, and create [[UrlMatcher]] objects.
 *
 * #### Note: This object is also exposed as [[$urlMatcherFactory]] for injection during runtime.
 *
 * @deprecated
 */
var $urlMatcherFactoryProvider;
//# sourceMappingURL=injectables.js.map

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(4);
/**
 * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service
 */
var Ng1LocationServices = (function () {
    function Ng1LocationServices($locationProvider) {
        // .onChange() registry
        this._urlListeners = [];
        this.$locationProvider = $locationProvider;
        var _lp = core_1.val($locationProvider);
        core_1.createProxyFunctions(_lp, this, _lp, ['hashPrefix']);
    }
    Ng1LocationServices.prototype.dispose = function () { };
    Ng1LocationServices.prototype.onChange = function (callback) {
        var _this = this;
        this._urlListeners.push(callback);
        return function () { return core_1.removeFrom(_this._urlListeners)(callback); };
    };
    Ng1LocationServices.prototype.html5Mode = function () {
        var html5Mode = this.$locationProvider.html5Mode();
        html5Mode = core_1.isObject(html5Mode) ? html5Mode.enabled : html5Mode;
        return html5Mode && this.$sniffer.history;
    };
    Ng1LocationServices.prototype.url = function (newUrl, replace, state) {
        if (replace === void 0) { replace = false; }
        if (newUrl)
            this.$location.url(newUrl);
        if (replace)
            this.$location.replace();
        if (state)
            this.$location.state(state);
        return this.$location.url();
    };
    Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser) {
        var _this = this;
        this.$location = $location;
        this.$sniffer = $sniffer;
        // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange
        $rootScope.$on("$locationChangeSuccess", function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });
        var _loc = core_1.val($location);
        var _browser = core_1.val($browser);
        // Bind these LocationService functions to $location
        core_1.createProxyFunctions(_loc, this, _loc, ["replace", "path", "search", "hash"]);
        // Bind these LocationConfig functions to $location
        core_1.createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);
        // Bind these LocationConfig functions to $browser
        core_1.createProxyFunctions(_browser, this, _browser, ['baseHref']);
    };
    /**
     * Applys ng1-specific path parameter encoding
     *
     * The Angular 1 `$location` service is a bit weird.
     * It doesn't allow slashes to be encoded/decoded bi-directionally.
     *
     * See the writeup at https://github.com/angular-ui/ui-router/issues/2598
     *
     * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F
     *
     * @param router
     */
    Ng1LocationServices.monkeyPatchPathParameterType = function (router) {
        var pathType = router.urlMatcherFactory.type('path');
        pathType.encode = function (val) {
            return val != null ? val.toString().replace(/(~|\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : val;
        };
        pathType.decode = function (val) {
            return val != null ? val.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : val;
        };
    };
    return Ng1LocationServices;
}());
exports.Ng1LocationServices = Ng1LocationServices;
//# sourceMappingURL=locationServices.js.map

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module ng1 */ /** for typedoc */
Object.defineProperty(exports, "__esModule", { value: true });
var angular_1 = __webpack_require__(10);
/**
 * `isState` Filter: truthy if the current state is the parameter
 *
 * Translates to [[StateService.is]] `$state.is("stateName")`.
 *
 * #### Example:
 * ```html
 * <div ng-if="'stateName' | isState">show if state is 'stateName'</div>
 * ```
 */
$IsStateFilter.$inject = ['$state'];
function $IsStateFilter($state) {
    var isFilter = function (state, params, options) {
        return $state.is(state, params, options);
    };
    isFilter.$stateful = true;
    return isFilter;
}
exports.$IsStateFilter = $IsStateFilter;
/**
 * `includedByState` Filter: truthy if the current state includes the parameter
 *
 * Translates to [[StateService.includes]]` $state.is("fullOrPartialStateName")`.
 *
 * #### Example:
 * ```html
 * <div ng-if="'fullOrPartialStateName' | includedByState">show if state includes 'fullOrPartialStateName'</div>
 * ```
 */
$IncludedByStateFilter.$inject = ['$state'];
function $IncludedByStateFilter($state) {
    var includesFilter = function (state, params, options) {
        return $state.includes(state, params, options);
    };
    includesFilter.$stateful = true;
    return includesFilter;
}
exports.$IncludedByStateFilter = $IncludedByStateFilter;
angular_1.ng.module('ui.router.state')
    .filter('isState', $IsStateFilter)
    .filter('includedByState', $IncludedByStateFilter);
//# sourceMappingURL=stateFilters.js.map

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module ng1 */ /** */
var core_1 = __webpack_require__(4);
var services_1 = __webpack_require__(29);
/**
 * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,
 * `onRetain` callback hooks on a [[Ng1StateDeclaration]].
 *
 * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
 * ensures that those hooks are injectable for @uirouter/angularjs (ng1).
 */
exports.getStateHookBuilder = function (hookName) {
    return function stateHookBuilder(state, parentFn) {
        var hook = state[hookName];
        var pathname = hookName === 'onExit' ? 'from' : 'to';
        function decoratedNg1Hook(trans, state) {
            var resolveContext = new core_1.ResolveContext(trans.treeChanges(pathname));
            var locals = core_1.extend(services_1.getLocals(resolveContext), { $state$: state, $transition$: trans });
            return core_1.services.$injector.invoke(hook, this, locals);
        }
        return hook ? decoratedNg1Hook : undefined;
    };
};
//# sourceMappingURL=onEnterExitRetain.js.map

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module view */
/** for typedoc */
var angular_1 = __webpack_require__(10);
var core_1 = __webpack_require__(4);
/**
 * Service which manages loading of templates from a ViewConfig.
 */
var TemplateFactory = (function () {
    function TemplateFactory() {
        var _this = this;
        /** @hidden */ this._useHttp = angular_1.ng.version.minor < 3;
        /** @hidden */ this.$get = ['$http', '$templateCache', '$injector', function ($http, $templateCache, $injector) {
                _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');
                _this.$http = $http;
                _this.$templateCache = $templateCache;
                return _this;
            }];
    }
    /** @hidden */
    TemplateFactory.prototype.useHttpService = function (value) {
        this._useHttp = value;
    };
    ;
    /**
     * Creates a template from a configuration object.
     *
     * @param config Configuration object for which to load a template.
     * The following properties are search in the specified order, and the first one
     * that is defined is used to create the template:
     *
     * @param params  Parameters to pass to the template function.
     * @param context The resolve context associated with the template's view
     *
     * @return {string|object}  The template html as a string, or a promise for
     * that string,or `null` if no template is configured.
     */
    TemplateFactory.prototype.fromConfig = function (config, params, context) {
        var defaultTemplate = "<ui-view></ui-view>";
        var asTemplate = function (result) { return core_1.services.$q.when(result).then(function (str) { return ({ template: str }); }); };
        var asComponent = function (result) { return core_1.services.$q.when(result).then(function (str) { return ({ component: str }); }); };
        return (core_1.isDefined(config.template) ? asTemplate(this.fromString(config.template, params)) :
            core_1.isDefined(config.templateUrl) ? asTemplate(this.fromUrl(config.templateUrl, params)) :
                core_1.isDefined(config.templateProvider) ? asTemplate(this.fromProvider(config.templateProvider, params, context)) :
                    core_1.isDefined(config.component) ? asComponent(config.component) :
                        core_1.isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) :
                            asTemplate(defaultTemplate));
    };
    ;
    /**
     * Creates a template from a string or a function returning a string.
     *
     * @param template html template as a string or function that returns an html template as a string.
     * @param params Parameters to pass to the template function.
     *
     * @return {string|object} The template html as a string, or a promise for that
     * string.
     */
    TemplateFactory.prototype.fromString = function (template, params) {
        return core_1.isFunction(template) ? template(params) : template;
    };
    ;
    /**
     * Loads a template from the a URL via `$http` and `$templateCache`.
     *
     * @param {string|Function} url url of the template to load, or a function
     * that returns a url.
     * @param {Object} params Parameters to pass to the url function.
     * @return {string|Promise.<string>} The template html as a string, or a promise
     * for that string.
     */
    TemplateFactory.prototype.fromUrl = function (url, params) {
        if (core_1.isFunction(url))
            url = url(params);
        if (url == null)
            return null;
        if (this._useHttp) {
            return this.$http.get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })
                .then(function (response) {
                return response.data;
            });
        }
        return this.$templateRequest(url);
    };
    ;
    /**
     * Creates a template by invoking an injectable provider function.
     *
     * @param provider Function to invoke via `locals`
     * @param {Function} injectFn a function used to invoke the template provider
     * @return {string|Promise.<string>} The template html as a string, or a promise
     * for that string.
     */
    TemplateFactory.prototype.fromProvider = function (provider, params, context) {
        var deps = core_1.services.$injector.annotate(provider);
        var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;
        var resolvable = new core_1.Resolvable("", providerFn, deps);
        return resolvable.get(context);
    };
    ;
    /**
     * Creates a component's template by invoking an injectable provider function.
     *
     * @param provider Function to invoke via `locals`
     * @param {Function} injectFn a function used to invoke the template provider
     * @return {string} The template html as a string: "<component-name input1='::$resolve.foo'></component-name>".
     */
    TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {
        var deps = core_1.services.$injector.annotate(provider);
        var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;
        var resolvable = new core_1.Resolvable("", providerFn, deps);
        return resolvable.get(context);
    };
    ;
    /**
     * Creates a template from a component's name
     *
     * This implements route-to-component.
     * It works by retrieving the component (directive) metadata from the injector.
     * It analyses the component's bindings, then constructs a template that instantiates the component.
     * The template wires input and output bindings to resolves or from the parent component.
     *
     * @param uiView {object} The parent ui-view (for binding outputs to callbacks)
     * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)
     * @param component {string} Component's name in camel case.
     * @param bindings An object defining the component's bindings: {foo: '<'}
     * @return {string} The template as a string: "<component-name input1='::$resolve.foo'></component-name>".
     */
    TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {
        bindings = bindings || {};
        // Bind once prefix
        var prefix = angular_1.ng.version.minor >= 3 ? "::" : "";
        // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`
        var kebob = function (camelCase) {
            var kebobed = core_1.kebobString(camelCase);
            return /^(x|data)-/.exec(kebobed) ? "x-" + kebobed : kebobed;
        };
        var attributeTpl = function (input) {
            var name = input.name, type = input.type;
            var attrName = kebob(name);
            // If the ui-view has an attribute which matches a binding on the routed component
            // then pass that attribute through to the routed component template.
            // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`
            if (uiView.attr(attrName) && !bindings[name])
                return attrName + "='" + uiView.attr(attrName) + "'";
            var resolveName = bindings[name] || name;
            // Pre-evaluate the expression for "@" bindings by enclosing in {{ }}
            // some-attr="{{ ::$resolve.someResolveName }}"
            if (type === '@')
                return attrName + "='{{" + prefix + "$resolve." + resolveName + "}}'";
            // Wire "&" callbacks to resolves that return a callback function
            // Get the result of the resolve (should be a function) and annotate it to get its arguments.
            // some-attr="$resolve.someResolveResultName(foo, bar)"
            if (type === '&') {
                var res = context.getResolvable(resolveName);
                var fn = res && res.data;
                var args = fn && core_1.services.$injector.annotate(fn) || [];
                // account for array style injection, i.e., ['foo', function(foo) {}]
                var arrayIdxStr = core_1.isArray(fn) ? "[" + (fn.length - 1) + "]" : '';
                return attrName + "='$resolve." + resolveName + arrayIdxStr + "(" + args.join(",") + ")'";
            }
            // some-attr="::$resolve.someResolveName"
            return attrName + "='" + prefix + "$resolve." + resolveName + "'";
        };
        var attrs = getComponentBindings(component).map(attributeTpl).join(" ");
        var kebobName = kebob(component);
        return "<" + kebobName + " " + attrs + "></" + kebobName + ">";
    };
    ;
    return TemplateFactory;
}());
exports.TemplateFactory = TemplateFactory;
// Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')
function getComponentBindings(name) {
    var cmpDefs = core_1.services.$injector.get(name + "Directive"); // could be multiple
    if (!cmpDefs || !cmpDefs.length)
        throw new Error("Unable to find component named '" + name + "'");
    return cmpDefs.map(getBindings).reduce(core_1.unnestR, []);
}
// Given a directive definition, find its object input attributes
// Use different properties, depending on the type of directive (component, bindToController, normal)
var getBindings = function (def) {
    if (core_1.isObject(def.bindToController))
        return scopeBindings(def.bindToController);
    return scopeBindings(def.scope);
};
// for ng 1.2 style, process the scope: { input: "=foo" }
// for ng 1.3 through ng 1.5, process the component's bindToController: { input: "=foo" } object
var scopeBindings = function (bindingsObj) { return Object.keys(bindingsObj || {})
    .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })
    .filter(function (tuple) { return core_1.isDefined(tuple) && core_1.isArray(tuple[1]); })
    .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); }); };
//# sourceMappingURL=templateFactory.js.map

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module ng1 */ /** */
var angular_1 = __webpack_require__(10);
/** @hidden */
function $ViewScrollProvider() {
    var useAnchorScroll = false;
    this.useAnchorScroll = function () {
        useAnchorScroll = true;
    };
    this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {
            if (useAnchorScroll) {
                return $anchorScroll;
            }
            return function ($element) {
                return $timeout(function () {
                    $element[0].scrollIntoView();
                }, 0, false);
            };
        }];
}
angular_1.ng.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
//# sourceMappingURL=viewScroll.js.map

/***/ }),
/* 96 */,
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _angular = __webpack_require__(11);

var _angular2 = _interopRequireDefault(_angular);

var _angularUiBootstrap = __webpack_require__(63);

var _angularUiBootstrap2 = _interopRequireDefault(_angularUiBootstrap);

var _angularUiRouter = __webpack_require__(64);

var _angularUiRouter2 = _interopRequireDefault(_angularUiRouter);

var _layout = __webpack_require__(65);

var _layout2 = _interopRequireDefault(_layout);

var _constants = __webpack_require__(66);

var _constants2 = _interopRequireDefault(_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_angular2.default.module('app', [_angularUiRouter2.default, _angularUiBootstrap2.default, _layout2.default, _constants2.default]).config(function ($stateProvider, $locationProvider) {

    //$locationProvider.hashPrefix('');

    var states = [{
        name: 'Home',
        url: '/',
        component: 'lzHome'
    }, {
        name: 'Contact',
        url: '/contact',
        component: 'lzContact'
    }, {
        name: 'About',
        url: '/about',
        component: 'lzAbout'
    }];

    states.forEach(function (state) {
        $stateProvider.state(state);
    });
});

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.headerComponent = undefined;

var _header = __webpack_require__(110);

var _header2 = _interopRequireDefault(_header);

var _header3 = __webpack_require__(58);

var _header4 = _interopRequireDefault(_header3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var headerComponent = exports.headerComponent = {
    bindings: {
        //inputs
        title: '@'
    },
    template: _header2.default,
    controller: _header4.default
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _header = __webpack_require__(98);

var _header2 = __webpack_require__(58);

var _header3 = _interopRequireDefault(_header2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = angular.module('layout.header', []).controller('headerCtrl', _header3.default).component('lzHeader', _header.headerComponent).name;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.aboutComponent = undefined;

var _about = __webpack_require__(59);

var _about2 = _interopRequireDefault(_about);

var _about3 = __webpack_require__(111);

var _about4 = _interopRequireDefault(_about3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var aboutComponent = exports.aboutComponent = {
    bindings: {},
    template: _about4.default,
    controller: _about2.default
};

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _about = __webpack_require__(100);

var _about2 = __webpack_require__(59);

var _about3 = _interopRequireDefault(_about2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = angular.module('layout.navigation.about', []).controller('aboutCtrl', _about3.default).component('lzAbout', _about.aboutComponent).name;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.contactComponent = undefined;

var _contact = __webpack_require__(112);

var _contact2 = _interopRequireDefault(_contact);

var _contact3 = __webpack_require__(60);

var _contact4 = _interopRequireDefault(_contact3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var contactComponent = exports.contactComponent = {
    bindings: {},
    template: _contact2.default,
    controller: _contact4.default
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _contact = __webpack_require__(102);

var _contact2 = __webpack_require__(60);

var _contact3 = _interopRequireDefault(_contact2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = angular.module('layout.navigation.contact', []).controller('contactCtrl', _contact3.default).component('lzContact', _contact.contactComponent).name;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.homeComponent = undefined;

var _home = __webpack_require__(113);

var _home2 = _interopRequireDefault(_home);

var _home3 = __webpack_require__(61);

var _home4 = _interopRequireDefault(_home3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var homeComponent = exports.homeComponent = {
    bindings: {},
    template: _home2.default,
    controller: _home4.default
};

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _home = __webpack_require__(104);

var _home2 = __webpack_require__(61);

var _home3 = _interopRequireDefault(_home2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = angular.module('layout.navigation.home', []).component('lzHome', _home.homeComponent).controller('homeCtrl', _home3.default).name;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.navigationComponent = undefined;

var _navigation = __webpack_require__(114);

var _navigation2 = _interopRequireDefault(_navigation);

var _navigation3 = __webpack_require__(62);

var _navigation4 = _interopRequireDefault(_navigation3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var navigationComponent = exports.navigationComponent = {
    bindings: {},
    template: _navigation2.default,
    controller: _navigation4.default
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _navigation = __webpack_require__(106);

var _navigation2 = __webpack_require__(62);

var _navigation3 = _interopRequireDefault(_navigation2);

var _contact = __webpack_require__(103);

var _contact2 = _interopRequireDefault(_contact);

var _about = __webpack_require__(101);

var _about2 = _interopRequireDefault(_about);

var _home = __webpack_require__(105);

var _home2 = _interopRequireDefault(_home);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = angular.module('layout.navigation', [_contact2.default, _about2.default, _home2.default]).controller('navigationCtrl', _navigation3.default).component('lzNavigation', _navigation.navigationComponent).name;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var states = exports.states = {
    mainNav: ['Home', 'Contact', 'About']
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _states = __webpack_require__(108);

exports.default = angular.module('widget.constants.states', []).constant('states', _states.states).name;

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = "<h1><a ui-sref=\"Home\">Resume</a></h1>\r\n\r\n";

/***/ }),
/* 111 */
/***/ (function(module, exports) {

module.exports = "\r\n<div class=\"about-body\">\r\n    <h1>About</h1>\r\n</div>\r\n";

/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = "<div class=\"container\" id=\"contact\">\r\n    <div class=\"row\">\r\n        <form>\r\n            <div class=\"form-group\">\r\n                <input type=\"text\" placeholder=\"Name\" required />\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <input type=\"email\" placeholder=\"Email\" required />\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <textarea name=\"comments\" placeholder=\"Message\" required></textarea>\r\n            </div>\r\n            <div class=\"form-group\">\r\n                <input type=\"submit\" value=\"Get in Contact!\" />\r\n            </div>\r\n        </form>\r\n    </div>\r\n</div>\r\n\r\n";

/***/ }),
/* 113 */
/***/ (function(module, exports) {

module.exports = "<div class=\"container\">\r\n    <p>Welcome to my homegrown resume sight. I know LinkedIn is for the cool kids so I'll provide my LinkedIn profile but please check out my cool projects!</p>\r\n</div>\r\n";

/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = "<nav class=\"navbar navbar-default\" role=\"navigation\">\r\n    <div class=\"navbar-header\">\r\n        <button type=\"button\" class=\"navbar-toggle\" ng-click=\"isNavCollapsed = !isNavCollapsed\">\r\n            <span class=\"sr-only\">Toggle navigation</span>\r\n            <span class=\"icon-bar\"></span>\r\n            <span class=\"icon-bar\"></span>\r\n            <span class=\"icon-bar\"></span>\r\n        </button>\r\n        <a class=\"navbar-brand\" ui-sref=\"Home\">Tam Mai</a>\r\n    </div>\r\n    <div class=\"collapse navbar-collapse push-right\" uib-collapse=\"isNavCollapsed\">\r\n        <ul class=\"nav navbar-nav\" ng-repeat=\"navItem in $ctrl.navItems\">\r\n            <li><a ui-sref=\"{{navItem}}\">{{navItem}}</a></li>\r\n        </ul>\r\n    </div>\r\n</nav>";

/***/ })
],[97]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3ByZWRpY2F0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9ob2YuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb3Jlc2VydmljZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vc3RyaW5ncy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3RyYWNlLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS90YXJnZXRTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcGFyYW1zL3BhcmFtLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2ludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9hbmd1bGFyLXVpLXJvdXRlci9saWIvYW5ndWxhci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcmVzb2x2ZS9yZXNvbHZhYmxlLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbkhvb2suanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9nbG9iLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3BhdGgvcGF0aEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdXJsL3VybE1hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvYmFzZUxvY2F0aW9uU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3F1ZXVlLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvcGFyYW1UeXBlLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL3BhdGhOb2RlLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9ob29rUmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL3NlcnZpY2VzLmpzIiwid2VicGFjazovLy8uLi9+L2FuZ3VsYXItdWktcm91dGVyL2xpYi9zdGF0ZWJ1aWxkZXJzL3ZpZXdzLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9nbG9iYWxzLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9sYXp5TG9hZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcGFyYW1zL3BhcmFtVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9zdGF0ZVBhcmFtcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcmVzb2x2ZS9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvc3RhdGVCdWlsZGVyLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZU1hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlUXVldWVNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZVJlZ2lzdHJ5LmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZVNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaG9va0J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbkV2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdXJsL3VybE1hdGNoZXJGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsUm91dGVyLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsUnVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdXJsL3VybFNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvYnJvd3NlckxvY2F0aW9uQ29uZmlnLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2hhc2hMb2NhdGlvblNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaW5qZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvbWVtb3J5TG9jYXRpb25Db25maWcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvbWVtb3J5TG9jYXRpb25TZXJ2aWNlLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL3B1c2hTdGF0ZUxvY2F0aW9uU2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9xLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92aWV3L3ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL3N0YXRlUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL3VybFJvdXRlclByb3ZpZGVyLmpzIiwid2VicGFjazovLy8uL2xheW91dC9oZWFkZXIvaGVhZGVyLmNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGF5b3V0L25hdmlnYXRpb24vYWJvdXQvYWJvdXQuY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9sYXlvdXQvbmF2aWdhdGlvbi9jb250YWN0L2NvbnRhY3QuY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9sYXlvdXQvbmF2aWdhdGlvbi9ob21lL2hvbWUuY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9sYXlvdXQvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLmNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYW5ndWxhci11aS1ib290c3RyYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL2xheW91dC9sYXlvdXQubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3dpZGdldC9jb25zdGFudHMvY29uc3RhbnRzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvY29yZVJlc29sdmFibGVzLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9pZ25vcmVkVHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvaW52YWxpZFRyYW5zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL29uRW50ZXJFeGl0UmV0YWluLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9yZWRpcmVjdFRvLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9yZXNvbHZlLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy91cGRhdGVHbG9iYWxzLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy91cmwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3ZpZXdzLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcGF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcmVzb2x2ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vQHVpcm91dGVyL2NvcmUvbGliL3VybC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9wbHVnaW5zLmpzIiwid2VicGFjazovLy8uLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92aWV3L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2FuZ3VsYXItdWktYm9vdHN0cmFwL2Rpc3QvdWktYm9vdHN0cmFwLXRwbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL2RpcmVjdGl2ZXMvc3RhdGVEaXJlY3RpdmVzLmpzIiwid2VicGFjazovLy8uLi9+L2FuZ3VsYXItdWktcm91dGVyL2xpYi9kaXJlY3RpdmVzL3ZpZXdEaXJlY3RpdmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL2luamVjdGFibGVzLmpzIiwid2VicGFjazovLy8uLi9+L2FuZ3VsYXItdWktcm91dGVyL2xpYi9sb2NhdGlvblNlcnZpY2VzLmpzIiwid2VicGFjazovLy8uLi9+L2FuZ3VsYXItdWktcm91dGVyL2xpYi9zdGF0ZUZpbHRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL3N0YXRlYnVpbGRlcnMvb25FbnRlckV4aXRSZXRhaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL3RlbXBsYXRlRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9hbmd1bGFyLXVpLXJvdXRlci9saWIvdmlld1Njcm9sbC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAubW9kdWxlLmpzIiwid2VicGFjazovLy8uL2xheW91dC9oZWFkZXIvaGVhZGVyLmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9sYXlvdXQvaGVhZGVyL2hlYWRlci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGF5b3V0L25hdmlnYXRpb24vYWJvdXQvYWJvdXQuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL2xheW91dC9uYXZpZ2F0aW9uL2Fib3V0L2Fib3V0Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9sYXlvdXQvbmF2aWdhdGlvbi9jb250YWN0L2NvbnRhY3QuY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL2xheW91dC9uYXZpZ2F0aW9uL2NvbnRhY3QvY29udGFjdC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGF5b3V0L25hdmlnYXRpb24vaG9tZS9ob21lLmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9sYXlvdXQvbmF2aWdhdGlvbi9ob21lL2hvbWUubW9kdWxlLmpzIiwid2VicGFjazovLy8uL2xheW91dC9uYXZpZ2F0aW9uL25hdmlnYXRpb24uY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL2xheW91dC9uYXZpZ2F0aW9uL25hdmlnYXRpb24ubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3dpZGdldC9jb25zdGFudHMvc3RhdGVzL3N0YXRlcy5jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vd2lkZ2V0L2NvbnN0YW50cy9zdGF0ZXMvc3RhdGVzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9sYXlvdXQvaGVhZGVyL2hlYWRlci5odG1sIiwid2VicGFjazovLy8uL2xheW91dC9uYXZpZ2F0aW9uL2Fib3V0L2Fib3V0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vbGF5b3V0L25hdmlnYXRpb24vY29udGFjdC9jb250YWN0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vbGF5b3V0L25hdmlnYXRpb24vaG9tZS9ob21lLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vbGF5b3V0L25hdmlnYXRpb24vbmF2aWdhdGlvbi5odG1sIl0sIm5hbWVzIjpbImhlYWRlckN0cmwiLCJ1aWJEYXRlUGFyc2VyIiwiJGN0cmwiLCJ1cGRhdGVUaXRsZSIsIm5hbWUiLCJ0aXRsZSIsImFib3V0Q3RybCIsIiRzdGF0ZSIsInRlc3QiLCJjb25zb2xlIiwibG9nIiwiY29udGFjdEN0cmwiLCJob21lQ3RybCIsIm5hdmlnYXRpb25DdHJsIiwic3RhdGVzIiwiJHJvb3RTY29wZSIsInN0YXRlIiwibmF2SXRlbXMiLCJtYWluTmF2IiwiJG9uIiwic3RhdGVUZW1wIiwic3RhdGV0ZXN0cGx6IiwiYW5ndWxhciIsIm1vZHVsZSIsImNvbmZpZyIsIiRzdGF0ZVByb3ZpZGVyIiwiJGxvY2F0aW9uUHJvdmlkZXIiLCJ1cmwiLCJjb21wb25lbnQiLCJmb3JFYWNoIiwiaGVhZGVyQ29tcG9uZW50IiwiYmluZGluZ3MiLCJ0ZW1wbGF0ZSIsImNvbnRyb2xsZXIiLCJhYm91dENvbXBvbmVudCIsImNvbnRhY3RDb21wb25lbnQiLCJob21lQ29tcG9uZW50IiwibmF2aWdhdGlvbkNvbXBvbmVudCIsImNvbnN0YW50Il0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7O0FDbFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7Ozs7Ozs7QUNqSEE7QUFDQSw4Q0FBOEMsY0FB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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUNBQXFDLEVBQUU7QUFDakU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZDQUE2QztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHVDQUF1QyxFQUFFO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlGQUFpRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaURBQWlELEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxnQkFBZ0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7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LE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUEseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FB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LE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQSwyRUFBMkUsV0FBVztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7O0FBRWxELHlEQUF5RCxRQUFROztBQUVqRSxpQ0FBaUMsUUFBUTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNENBQTRDO0FBQy9FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkRBQTJEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQ0FBZ0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkRBQTJEO0FBQzFGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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Qzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUE4QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJCQUEyQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkJBQTJCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUywyQkFBMkI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FB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QyxFQUFFO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG9DQUFvQyxFQUFFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7Ozs7Ozs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFmLEM7Ozs7Ozs7Ozs7Ozs7QUNBUDs7a0JBR2VJLFFBQVFDLE1BQVIsQ0FBZSx5QkFBZixFQUF5QyxFQUF6QyxFQUNWZSxRQURVLENBQ0QsUUFEQyxrQkFFVmxDLEk7Ozs7OztBQ0xMLG1FOzs7Ozs7QUNBQSxzRjs7Ozs7O0FDQUEsbXRCOzs7Ozs7QUNBQSwrTjs7Ozs7O0FDQUEsOHRCQUE4dEIsU0FBUyxLQUFLLFNBQVMsb0QiLCJmaWxlIjoiYXBwLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBSYW5kb20gdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBpbiB0aGUgVUktUm91dGVyIGNvZGVcclxuICpcclxuICogVGhlc2UgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgYnV0IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cclxuICpcclxuICogQHByZWZlcnJlZFxyXG4gKiBAbW9kdWxlIGNvbW1vblxyXG4gKi9cclxuLyoqIGZvciB0eXBlZG9jICovXHJcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi9wcmVkaWNhdGVzXCIpO1xyXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi9ob2ZcIik7XHJcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuL2NvcmVzZXJ2aWNlc1wiKTtcclxudmFyIHcgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHt9IDogd2luZG93O1xyXG52YXIgYW5ndWxhciA9IHcuYW5ndWxhciB8fCB7fTtcclxuZXhwb3J0cy5mcm9tSnNvbiA9IGFuZ3VsYXIuZnJvbUpzb24gfHwgSlNPTi5wYXJzZS5iaW5kKEpTT04pO1xyXG5leHBvcnRzLnRvSnNvbiA9IGFuZ3VsYXIudG9Kc29uIHx8IEpTT04uc3RyaW5naWZ5LmJpbmQoSlNPTik7XHJcbmV4cG9ydHMuY29weSA9IGFuZ3VsYXIuY29weSB8fCBfY29weTtcclxuZXhwb3J0cy5mb3JFYWNoID0gYW5ndWxhci5mb3JFYWNoIHx8IF9mb3JFYWNoO1xyXG5leHBvcnRzLmV4dGVuZCA9IE9iamVjdC5hc3NpZ24gfHwgX2V4dGVuZDtcclxuZXhwb3J0cy5lcXVhbHMgPSBhbmd1bGFyLmVxdWFscyB8fCBfZXF1YWxzO1xyXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7IHJldHVybiB4OyB9XHJcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcclxuZnVuY3Rpb24gbm9vcCgpIHsgfVxyXG5leHBvcnRzLm5vb3AgPSBub29wO1xyXG4vKipcclxuICogQnVpbGRzIHByb3h5IGZ1bmN0aW9ucyBvbiB0aGUgYHRvYCBvYmplY3Qgd2hpY2ggcGFzcyB0aHJvdWdoIHRvIHRoZSBgZnJvbWAgb2JqZWN0LlxyXG4gKlxyXG4gKiBGb3IgZWFjaCBrZXkgaW4gYGZuTmFtZXNgLCBjcmVhdGVzIGEgcHJveHkgZnVuY3Rpb24gb24gdGhlIGB0b2Agb2JqZWN0LlxyXG4gKiBUaGUgcHJveHkgZnVuY3Rpb24gY2FsbHMgdGhlIHJlYWwgZnVuY3Rpb24gb24gdGhlIGBmcm9tYCBvYmplY3QuXHJcbiAqXHJcbiAqXHJcbiAqICMjIyMgRXhhbXBsZTpcclxuICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYW4gbmV3IGNsYXNzIGluc3RhbmNlIHdob3NlIGZ1bmN0aW9ucyBhcmUgcHJlYm91bmQgdG8gdGhlIG5ldydkIG9iamVjdC5cclxuICogYGBganNcclxuICogY2xhc3MgRm9vIHtcclxuICogICBjb25zdHJ1Y3RvcihkYXRhKSB7XHJcbiAqICAgICAvLyBCaW5kcyBhbGwgZnVuY3Rpb25zIGZyb20gRm9vLnByb3RvdHlwZSB0byAndGhpcycsXHJcbiAqICAgICAvLyB0aGVuIGNvcGllcyB0aGVtIHRvICd0aGlzJ1xyXG4gKiAgICAgYmluZEZ1bmN0aW9ucyhGb28ucHJvdG90eXBlLCB0aGlzLCB0aGlzKTtcclxuICogICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIGxvZygpIHtcclxuICogICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YSk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIGxldCBteUZvbyA9IG5ldyBGb28oWzEsMiwzXSk7XHJcbiAqIHZhciBsb2dpdCA9IG15Rm9vLmxvZztcclxuICogbG9naXQoKTsgLy8gbG9ncyBbMSwgMiwgM10gZnJvbSB0aGUgbXlGb28gJ3RoaXMnIGluc3RhbmNlXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyMjIEV4YW1wbGU6XHJcbiAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIGEgYm91bmQgdmVyc2lvbiBvZiBhIHNlcnZpY2UgZnVuY3Rpb24sIGFuZCBjb3BpZXMgaXQgdG8gYW5vdGhlciBvYmplY3RcclxuICogYGBgXHJcbiAqXHJcbiAqIHZhciBTb21lU2VydmljZSA9IHtcclxuICogICB0aGlzLmRhdGEgPSBbMywgNCwgNV07XHJcbiAqICAgdGhpcy5sb2cgPSBmdW5jdGlvbigpIHtcclxuICogICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YSk7XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqXHJcbiAqIC8vIENvbnN0cnVjdG9yIGZuXHJcbiAqIGZ1bmN0aW9uIE90aGVyVGhpbmcoKSB7XHJcbiAqICAgLy8gQmluZHMgYWxsIGZ1bmN0aW9ucyBmcm9tIFNvbWVTZXJ2aWNlIHRvIFNvbWVTZXJ2aWNlLFxyXG4gKiAgIC8vIHRoZW4gY29waWVzIHRoZW0gdG8gJ3RoaXMnXHJcbiAqICAgYmluZEZ1bmN0aW9ucyhTb21lU2VydmljZSwgdGhpcywgU29tZVNlcnZpY2UpO1xyXG4gKiB9XHJcbiAqXHJcbiAqIGxldCBteU90aGVyVGhpbmcgPSBuZXcgT3RoZXJUaGluZygpO1xyXG4gKiBteU90aGVyVGhpbmcubG9nKCk7IC8vIGxvZ3MgWzMsIDQsIDVdIGZyb20gU29tZVNlcnZpY2UncyAndGhpcydcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBzb3VyY2UgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHNvdXJjZSBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9ucyB0byBiZSBib3VuZFxyXG4gKiBAcGFyYW0gdGFyZ2V0IEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgYm91bmQgZnVuY3Rpb25zXHJcbiAqIEBwYXJhbSBiaW5kIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBvYmplY3Qgd2hpY2ggdGhlIGZ1bmN0aW9ucyB3aWxsIGJlIGJvdW5kIHRvXHJcbiAqIEBwYXJhbSBmbk5hbWVzIFRoZSBmdW5jdGlvbiBuYW1lcyB3aGljaCB3aWxsIGJlIGJvdW5kIChEZWZhdWx0cyB0byBhbGwgdGhlIGZ1bmN0aW9ucyBmb3VuZCBvbiB0aGUgJ2Zyb20nIG9iamVjdClcclxuICogQHBhcmFtIGxhdGViaW5kIElmIHRydWUsIHRoZSBiaW5kaW5nIG9mIHRoZSBmdW5jdGlvbiBpcyBkZWxheWVkIHVudGlsIHRoZSBmaXJzdCB0aW1lIGl0J3MgaW52b2tlZFxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUHJveHlGdW5jdGlvbnMoc291cmNlLCB0YXJnZXQsIGJpbmQsIGZuTmFtZXMsIGxhdGViaW5kKSB7XHJcbiAgICBpZiAobGF0ZWJpbmQgPT09IHZvaWQgMCkgeyBsYXRlYmluZCA9IGZhbHNlOyB9XHJcbiAgICB2YXIgYmluZEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZuTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2UoKVtmbk5hbWVdLmJpbmQoYmluZCgpKTtcclxuICAgIH07XHJcbiAgICB2YXIgbWFrZUxhdGVSZWJpbmRGbiA9IGZ1bmN0aW9uIChmbk5hbWUpIHsgcmV0dXJuIGZ1bmN0aW9uIGxhdGVSZWJpbmRGdW5jdGlvbigpIHtcclxuICAgICAgICB0YXJnZXRbZm5OYW1lXSA9IGJpbmRGdW5jdGlvbihmbk5hbWUpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRbZm5OYW1lXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgfTsgfTtcclxuICAgIGZuTmFtZXMgPSBmbk5hbWVzIHx8IE9iamVjdC5rZXlzKHNvdXJjZSgpKTtcclxuICAgIHJldHVybiBmbk5hbWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBuYW1lKSB7XHJcbiAgICAgICAgYWNjW25hbWVdID0gbGF0ZWJpbmQgPyBtYWtlTGF0ZVJlYmluZEZuKG5hbWUpIDogYmluZEZ1bmN0aW9uKG5hbWUpO1xyXG4gICAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB0YXJnZXQpO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlUHJveHlGdW5jdGlvbnMgPSBjcmVhdGVQcm94eUZ1bmN0aW9ucztcclxuLyoqXHJcbiAqIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgaGVscGVyLlxyXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aGljaCBoYXMgYHBhcmVudGAgb2JqZWN0IGFzIGl0cyBwcm90b3R5cGUsIGFuZCB0aGVuIGNvcGllcyB0aGUgcHJvcGVydGllcyBmcm9tIGBleHRyYWAgb250byBpdFxyXG4gKi9cclxuZXhwb3J0cy5pbmhlcml0ID0gZnVuY3Rpb24gKHBhcmVudCwgZXh0cmEpIHtcclxuICAgIHJldHVybiBleHBvcnRzLmV4dGVuZChPYmplY3QuY3JlYXRlKHBhcmVudCksIGV4dHJhKTtcclxufTtcclxuLyoqXHJcbiAqIEdpdmVuIGFuIGFyZ3VtZW50cyBvYmplY3QsIGNvbnZlcnRzIHRoZSBhcmd1bWVudHMgYXQgaW5kZXggaWR4IGFuZCBhYm92ZSB0byBhbiBhcnJheS5cclxuICogVGhpcyBpcyBzaW1pbGFyIHRvIGVzNiByZXN0IHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIE9wdGlvbmFsbHksIHRoZSBhcmd1bWVudCBhdCBpbmRleCBpZHggbWF5IGl0c2VsZiBhbHJlYWR5IGJlIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSxcclxuICogZ2l2ZW4gZWl0aGVyOlxyXG4gKiAgICAgICAgYXJndW1lbnRzID0gWyBvYmosIFwiZm9vXCIsIFwiYmFyXCIgXVxyXG4gKiBvcjpcclxuICogICAgICAgIGFyZ3VtZW50cyA9IFsgb2JqLCBbXCJmb29cIiwgXCJiYXJcIl0gXVxyXG4gKiB0aGVuOlxyXG4gKiAgICAgICAgcmVzdEFyZ3MoYXJndW1lbnRzLCAxKSA9PSBbXCJmb29cIiwgXCJiYXJcIl1cclxuICpcclxuICogVGhpcyBhbGxvd3MgZnVuY3Rpb25zIGxpa2UgcGljaygpIHRvIGJlIGltcGxlbWVudGVkIHN1Y2ggdGhhdCBpdCBhbGxvd3MgZWl0aGVyIGEgYnVuY2hcclxuICogb2Ygc3RyaW5nIGFyZ3VtZW50cyAobGlrZSBlczYgcmVzdCBwYXJhbWV0ZXJzKSwgb3IgYSBzaW5nbGUgYXJyYXkgb2Ygc3RyaW5nczpcclxuICpcclxuICogZ2l2ZW46XHJcbiAqICAgICAgICB2YXIgb2JqID0geyBmb286IDEsIGJhcjogMiwgYmF6OiAzIH07XHJcbiAqIHRoZW46XHJcbiAqICAgICAgICBwaWNrKG9iaiwgXCJmb29cIiwgXCJiYXJcIik7ICAgLy8gcmV0dXJucyB7IGZvbzogMSwgYmFyOiAyIH1cclxuICogICAgICAgIHBpY2sob2JqLCBbXCJmb29cIiwgXCJiYXJcIl0pOyAvLyByZXR1cm5zIHsgZm9vOiAxLCBiYXI6IDIgfVxyXG4gKi9cclxudmFyIHJlc3RBcmdzID0gZnVuY3Rpb24gKGFyZ3MsIGlkeCkge1xyXG4gICAgaWYgKGlkeCA9PT0gdm9pZCAwKSB7IGlkeCA9IDA7IH1cclxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KEFycmF5LnByb3RvdHlwZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgaWR4KSk7XHJcbn07XHJcbi8qKiBHaXZlbiBhbiBhcnJheSwgcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgZm91bmQgaW4gdGhlIGFycmF5LCAodXNpbmcgaW5kZXhPZikgKi9cclxuZXhwb3J0cy5pbkFycmF5ID0gaG9mXzEuY3VycnkoX2luQXJyYXkpO1xyXG5mdW5jdGlvbiBfaW5BcnJheShhcnJheSwgb2JqKSB7XHJcbiAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihvYmopICE9PSAtMTtcclxufVxyXG5leHBvcnRzLl9pbkFycmF5ID0gX2luQXJyYXk7XHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBhcnJheSwgYW5kIGFuIGl0ZW0sIGlmIHRoZSBpdGVtIGlzIGZvdW5kIGluIHRoZSBhcnJheSwgaXQgcmVtb3ZlcyBpdCAoaW4tcGxhY2UpLlxyXG4gKiBUaGUgc2FtZSBhcnJheSBpcyByZXR1cm5lZFxyXG4gKi9cclxuZXhwb3J0cy5yZW1vdmVGcm9tID0gaG9mXzEuY3VycnkoX3JlbW92ZUZyb20pO1xyXG5mdW5jdGlvbiBfcmVtb3ZlRnJvbShhcnJheSwgb2JqKSB7XHJcbiAgICB2YXIgaWR4ID0gYXJyYXkuaW5kZXhPZihvYmopO1xyXG4gICAgaWYgKGlkeCA+PSAwKVxyXG4gICAgICAgIGFycmF5LnNwbGljZShpZHgsIDEpO1xyXG4gICAgcmV0dXJuIGFycmF5O1xyXG59XHJcbmV4cG9ydHMuX3JlbW92ZUZyb20gPSBfcmVtb3ZlRnJvbTtcclxuLyoqIHB1c2hlcyBhIHZhbHVlcyB0byBhbiBhcnJheSBhbmQgcmV0dXJucyB0aGUgdmFsdWUgKi9cclxuZXhwb3J0cy5wdXNoVG8gPSBob2ZfMS5jdXJyeShfcHVzaFRvKTtcclxuZnVuY3Rpb24gX3B1c2hUbyhhcnIsIHZhbCkge1xyXG4gICAgcmV0dXJuIChhcnIucHVzaCh2YWwpLCB2YWwpO1xyXG59XHJcbmV4cG9ydHMuX3B1c2hUbyA9IF9wdXNoVG87XHJcbi8qKiBHaXZlbiBhbiBhcnJheSBvZiAoZGVyZWdpc3RyYXRpb24pIGZ1bmN0aW9ucywgY2FsbHMgYWxsIGZ1bmN0aW9ucyBhbmQgcmVtb3ZlcyBlYWNoIG9uZSBmcm9tIHRoZSBzb3VyY2UgYXJyYXkgKi9cclxuZXhwb3J0cy5kZXJlZ0FsbCA9IGZ1bmN0aW9uIChmdW5jdGlvbnMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbnMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBmbigpO1xyXG4gICAgICAgIGV4cG9ydHMucmVtb3ZlRnJvbShmdW5jdGlvbnMsIGZuKTtcclxuICAgIH0pO1xyXG59O1xyXG4vKipcclxuICogQXBwbGllcyBhIHNldCBvZiBkZWZhdWx0cyB0byBhbiBvcHRpb25zIG9iamVjdC4gIFRoZSBvcHRpb25zIG9iamVjdCBpcyBmaWx0ZXJlZFxyXG4gKiB0byBvbmx5IHRob3NlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdHMgaW4gdGhlIGRlZmF1bHRzTGlzdC5cclxuICogRWFybGllciBvYmplY3RzIGluIHRoZSBkZWZhdWx0c0xpc3QgdGFrZSBwcmVjZWRlbmNlIHdoZW4gYXBwbHlpbmcgZGVmYXVsdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWZhdWx0cyhvcHRzKSB7XHJcbiAgICB2YXIgZGVmYXVsdHNMaXN0ID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGRlZmF1bHRzTGlzdFtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBfZGVmYXVsdHNMaXN0ID0gZGVmYXVsdHNMaXN0LmNvbmNhdCh7fSkucmV2ZXJzZSgpO1xyXG4gICAgdmFyIGRlZmF1bHRWYWxzID0gZXhwb3J0cy5leHRlbmQuYXBwbHkobnVsbCwgX2RlZmF1bHRzTGlzdCk7XHJcbiAgICByZXR1cm4gZXhwb3J0cy5leHRlbmQoe30sIGRlZmF1bHRWYWxzLCBwaWNrKG9wdHMgfHwge30sIE9iamVjdC5rZXlzKGRlZmF1bHRWYWxzKSkpO1xyXG59XHJcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcclxuLyoqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IG1lcmdlcyBlYWNoIGVsZW1lbnQgb2YgdGhlIGxpc3QgaW50byBhIHNpbmdsZSBvYmplY3QsIHVzaW5nIGV4dGVuZCAqL1xyXG5leHBvcnRzLm1lcmdlUiA9IGZ1bmN0aW9uIChtZW1vLCBpdGVtKSB7IHJldHVybiBleHBvcnRzLmV4dGVuZChtZW1vLCBpdGVtKTsgfTtcclxuLyoqXHJcbiAqIEZpbmRzIHRoZSBjb21tb24gYW5jZXN0b3IgcGF0aCBiZXR3ZWVuIHR3byBzdGF0ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaXJzdCBUaGUgZmlyc3Qgc3RhdGUuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWNvbmQgVGhlIHNlY29uZCBzdGF0ZS5cclxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGUgbmFtZXMgaW4gZGVzY2VuZGluZyBvcmRlciwgbm90IGluY2x1ZGluZyB0aGUgcm9vdC5cclxuICovXHJcbmZ1bmN0aW9uIGFuY2VzdG9ycyhmaXJzdCwgc2Vjb25kKSB7XHJcbiAgICB2YXIgcGF0aCA9IFtdO1xyXG4gICAgZm9yICh2YXIgbiBpbiBmaXJzdC5wYXRoKSB7XHJcbiAgICAgICAgaWYgKGZpcnN0LnBhdGhbbl0gIT09IHNlY29uZC5wYXRoW25dKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBwYXRoLnB1c2goZmlyc3QucGF0aFtuXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aDtcclxufVxyXG5leHBvcnRzLmFuY2VzdG9ycyA9IGFuY2VzdG9ycztcclxuLyoqXHJcbiAqIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqICMjIyMgRXhhbXBsZTpcclxuICogYGBgXHJcbiAqIHZhciBmb28gPSB7IGE6IDEsIGI6IDIsIGM6IDMgfTtcclxuICogdmFyIGFiID0gcGljayhmb28sIFsnYScsICdiJ10pOyAvLyB7IGE6IDEsIGI6IDIgfVxyXG4gKiBgYGBcclxuICogQHBhcmFtIG9iaiB0aGUgc291cmNlIG9iamVjdFxyXG4gKiBAcGFyYW0gcHJvcE5hbWVzIGFuIEFycmF5IG9mIHN0cmluZ3MsIHdoaWNoIGFyZSB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydHkgbmFtZXNcclxuICovXHJcbmZ1bmN0aW9uIHBpY2sob2JqLCBwcm9wTmFtZXMpIHtcclxuICAgIHZhciBvYmpDb3B5ID0ge307XHJcbiAgICBmb3IgKHZhciBwcm9wXzEgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKHByb3BOYW1lcy5pbmRleE9mKHByb3BfMSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIG9iakNvcHlbcHJvcF8xXSA9IG9ialtwcm9wXzFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvYmpDb3B5O1xyXG59XHJcbmV4cG9ydHMucGljayA9IHBpY2s7XHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb21pdHRpbmcgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiB2YXIgZm9vID0geyBhOiAxLCBiOiAyLCBjOiAzIH07XHJcbiAqIHZhciBhYiA9IG9taXQoZm9vLCBbJ2EnLCAnYiddKTsgLy8geyBjOiAzIH1cclxuICogYGBgXHJcbiAqIEBwYXJhbSBvYmogdGhlIHNvdXJjZSBvYmplY3RcclxuICogQHBhcmFtIHByb3BOYW1lcyBhbiBBcnJheSBvZiBzdHJpbmdzLCB3aGljaCBhcmUgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnR5IG5hbWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBvbWl0KG9iaiwgcHJvcE5hbWVzKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxyXG4gICAgICAgIC5maWx0ZXIoaG9mXzEubm90KGV4cG9ydHMuaW5BcnJheShwcm9wTmFtZXMpKSlcclxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkgeyByZXR1cm4gKGFjY1trZXldID0gb2JqW2tleV0sIGFjYyk7IH0sIHt9KTtcclxufVxyXG5leHBvcnRzLm9taXQgPSBvbWl0O1xyXG4vKipcclxuICogTWFwcyBhbiBhcnJheSwgb3Igb2JqZWN0IHRvIGEgcHJvcGVydHkgKGJ5IG5hbWUpXHJcbiAqL1xyXG5mdW5jdGlvbiBwbHVjayhjb2xsZWN0aW9uLCBwcm9wTmFtZSkge1xyXG4gICAgcmV0dXJuIG1hcChjb2xsZWN0aW9uLCBob2ZfMS5wcm9wKHByb3BOYW1lKSk7XHJcbn1cclxuZXhwb3J0cy5wbHVjayA9IHBsdWNrO1xyXG4vKiogRmlsdGVycyBhbiBBcnJheSBvciBhbiBPYmplY3QncyBwcm9wZXJ0aWVzIGJhc2VkIG9uIGEgcHJlZGljYXRlICovXHJcbmZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGFyciA9IHByZWRpY2F0ZXNfMS5pc0FycmF5KGNvbGxlY3Rpb24pLCByZXN1bHQgPSBhcnIgPyBbXSA6IHt9O1xyXG4gICAgdmFyIGFjY2VwdCA9IGFyciA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiByZXN1bHQucHVzaCh4KTsgfSA6IGZ1bmN0aW9uICh4LCBrZXkpIHsgcmV0dXJuIHJlc3VsdFtrZXldID0geDsgfTtcclxuICAgIGV4cG9ydHMuZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSwgaSkge1xyXG4gICAgICAgIGlmIChjYWxsYmFjayhpdGVtLCBpKSlcclxuICAgICAgICAgICAgYWNjZXB0KGl0ZW0sIGkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xyXG4vKiogRmluZHMgYW4gb2JqZWN0IGZyb20gYW4gYXJyYXksIG9yIGEgcHJvcGVydHkgb2YgYW4gb2JqZWN0LCB0aGF0IG1hdGNoZXMgYSBwcmVkaWNhdGUgKi9cclxuZnVuY3Rpb24gZmluZChjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGV4cG9ydHMuZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSwgaSkge1xyXG4gICAgICAgIGlmIChyZXN1bHQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoY2FsbGJhY2soaXRlbSwgaSkpXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGl0ZW07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZXhwb3J0cy5maW5kID0gZmluZDtcclxuLyoqIEdpdmVuIGFuIG9iamVjdCwgcmV0dXJucyBhIG5ldyBvYmplY3QsIHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgdHJhbnNmb3JtZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uICovXHJcbmV4cG9ydHMubWFwT2JqID0gbWFwO1xyXG4vKiogTWFwcyBhbiBhcnJheSBvciBvYmplY3QgcHJvcGVydGllcyB1c2luZyBhIGNhbGxiYWNrIGZ1bmN0aW9uICovXHJcbmZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHJlc3VsdCA9IHByZWRpY2F0ZXNfMS5pc0FycmF5KGNvbGxlY3Rpb24pID8gW10gOiB7fTtcclxuICAgIGV4cG9ydHMuZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSwgaSkgeyByZXR1cm4gcmVzdWx0W2ldID0gY2FsbGJhY2soaXRlbSwgaSk7IH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5leHBvcnRzLm1hcCA9IG1hcDtcclxuLyoqXHJcbiAqIEdpdmVuIGFuIG9iamVjdCwgcmV0dXJuIGl0cyBlbnVtZXJhYmxlIHByb3BlcnR5IHZhbHVlc1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBcclxuICpcclxuICogbGV0IGZvbyA9IHsgYTogMSwgYjogMiwgYzogMyB9XHJcbiAqIGxldCB2YWxzID0gdmFsdWVzKGZvbyk7IC8vIFsgMSwgMiwgMyBdXHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gb2JqW2tleV07IH0pO1xyXG59O1xyXG4vKipcclxuICogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGFsbCBvZiB0aGUgdmFsdWVzIGFyZSB0cnV0aHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBsZXQgdmFscyA9IFsgMSwgdHJ1ZSwge30sIFwiaGVsbG8gd29ybGRcIl07XHJcbiAqIHZhbHMucmVkdWNlKGFsbFRydWVSLCB0cnVlKTsgLy8gdHJ1ZVxyXG4gKlxyXG4gKiB2YWxzLnB1c2goMCk7XHJcbiAqIHZhbHMucmVkdWNlKGFsbFRydWVSLCB0cnVlKTsgLy8gZmFsc2VcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLmFsbFRydWVSID0gZnVuY3Rpb24gKG1lbW8sIGVsZW0pIHsgcmV0dXJuIG1lbW8gJiYgZWxlbTsgfTtcclxuLyoqXHJcbiAqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlIHZhbHVlcyBhcmUgdHJ1dGh5LlxyXG4gKlxyXG4gKiAgKiBAZXhhbXBsZVxyXG4gKiBgYGBcclxuICpcclxuICogbGV0IHZhbHMgPSBbIDAsIG51bGwsIHVuZGVmaW5lZCBdO1xyXG4gKiB2YWxzLnJlZHVjZShhbnlUcnVlUiwgdHJ1ZSk7IC8vIGZhbHNlXHJcbiAqXHJcbiAqIHZhbHMucHVzaChcImhlbGxvIHdvcmxkXCIpO1xyXG4gKiB2YWxzLnJlZHVjZShhbnlUcnVlUiwgdHJ1ZSk7IC8vIHRydWVcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLmFueVRydWVSID0gZnVuY3Rpb24gKG1lbW8sIGVsZW0pIHsgcmV0dXJuIG1lbW8gfHwgZWxlbTsgfTtcclxuLyoqXHJcbiAqIFJlZHVjZSBmdW5jdGlvbiB3aGljaCB1bi1uZXN0cyBhIHNpbmdsZSBsZXZlbCBvZiBhcnJheXNcclxuICogQGV4YW1wbGVcclxuICogYGBgXHJcbiAqXHJcbiAqIGxldCBpbnB1dCA9IFsgWyBcImFcIiwgXCJiXCIgXSwgWyBcImNcIiwgXCJkXCIgXSwgWyBbIFwiZG91YmxlXCIsIFwibmVzdGVkXCIgXSBdIF07XHJcbiAqIGlucHV0LnJlZHVjZSh1bm5lc3RSLCBbXSkgLy8gWyBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgWyBcImRvdWJsZSwgXCJuZXN0ZWRcIiBdIF1cclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnRzLnVubmVzdFIgPSBmdW5jdGlvbiAobWVtbywgZWxlbSkgeyByZXR1cm4gbWVtby5jb25jYXQoZWxlbSk7IH07XHJcbi8qKlxyXG4gKiBSZWR1Y2UgZnVuY3Rpb24gd2hpY2ggcmVjdXJzaXZlbHkgdW4tbmVzdHMgYWxsIGFycmF5c1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBcclxuICpcclxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcclxuICogaW5wdXQucmVkdWNlKHVubmVzdFIsIFtdKSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImRvdWJsZSwgXCJuZXN0ZWRcIiBdXHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5mbGF0dGVuUiA9IGZ1bmN0aW9uIChtZW1vLCBlbGVtKSB7XHJcbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzQXJyYXkoZWxlbSkgPyBtZW1vLmNvbmNhdChlbGVtLnJlZHVjZShleHBvcnRzLmZsYXR0ZW5SLCBbXSkpIDogcHVzaFIobWVtbywgZWxlbSk7XHJcbn07XHJcbi8qKlxyXG4gKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCBwdXNoZXMgYW4gb2JqZWN0IHRvIGFuIGFycmF5LCB0aGVuIHJldHVybnMgdGhlIGFycmF5LlxyXG4gKiBNb3N0bHkganVzdCBmb3IgW1tmbGF0dGVuUl1dIGFuZCBbW3VuaXFSXV1cclxuICovXHJcbmZ1bmN0aW9uIHB1c2hSKGFyciwgb2JqKSB7XHJcbiAgICBhcnIucHVzaChvYmopO1xyXG4gICAgcmV0dXJuIGFycjtcclxufVxyXG5leHBvcnRzLnB1c2hSID0gcHVzaFI7XHJcbi8qKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCBmaWx0ZXJzIG91dCBkdXBsaWNhdGVzICovXHJcbmV4cG9ydHMudW5pcVIgPSBmdW5jdGlvbiAoYWNjLCB0b2tlbikge1xyXG4gICAgcmV0dXJuIGV4cG9ydHMuaW5BcnJheShhY2MsIHRva2VuKSA/IGFjYyA6IHB1c2hSKGFjYywgdG9rZW4pO1xyXG59O1xyXG4vKipcclxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggYSBzaW5nbGUgbGV2ZWwgb2YgYXJyYXlzIHVubmVzdGVkLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBcclxuICpcclxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcclxuICogdW5uZXN0KGlucHV0KSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBbIFwiZG91YmxlLCBcIm5lc3RlZFwiIF0gXVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMudW5uZXN0ID0gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLnJlZHVjZShleHBvcnRzLnVubmVzdFIsIFtdKTsgfTtcclxuLyoqXHJcbiAqIFJldHVybiBhIGNvbXBsZXRlbHkgZmxhdHRlbmVkIHZlcnNpb24gb2YgYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBsZXQgaW5wdXQgPSBbIFsgXCJhXCIsIFwiYlwiIF0sIFsgXCJjXCIsIFwiZFwiIF0sIFsgWyBcImRvdWJsZVwiLCBcIm5lc3RlZFwiIF0gXSBdO1xyXG4gKiBmbGF0dGVuKGlucHV0KSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImRvdWJsZSwgXCJuZXN0ZWRcIiBdXHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0cy5mbGF0dGVuID0gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLnJlZHVjZShleHBvcnRzLmZsYXR0ZW5SLCBbXSk7IH07XHJcbi8qKlxyXG4gKiBHaXZlbiBhIC5maWx0ZXIgUHJlZGljYXRlLCBidWlsZHMgYSAuZmlsdGVyIFByZWRpY2F0ZSB3aGljaCB0aHJvd3MgYW4gZXJyb3IgaWYgYW55IGVsZW1lbnRzIGRvIG5vdCBwYXNzLlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBcclxuICpcclxuICogbGV0IGlzTnVtYmVyID0gKG9iaikgPT4gdHlwZW9mKG9iaikgPT09ICdudW1iZXInO1xyXG4gKiBsZXQgYWxsTnVtYmVycyA9IFsgMSwgMiwgMywgNCwgNSBdO1xyXG4gKiBhbGxOdW1iZXJzLmZpbHRlcihhc3NlcnRQcmVkaWNhdGUoaXNOdW1iZXIpKTsgLy9PS1xyXG4gKlxyXG4gKiBsZXQgb25lU3RyaW5nID0gWyAxLCAyLCAzLCA0LCBcIjVcIiBdO1xyXG4gKiBvbmVTdHJpbmcuZmlsdGVyKGFzc2VydFByZWRpY2F0ZShpc051bWJlciwgXCJOb3QgYWxsIG51bWJlcnNcIikpOyAvLyB0aHJvd3MgRXJyb3IoXCJcIk5vdCBhbGwgbnVtYmVyc1wiXCIpO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMuYXNzZXJ0UHJlZGljYXRlID0gYXNzZXJ0Rm47XHJcbi8qKlxyXG4gKiBHaXZlbiBhIC5tYXAgZnVuY3Rpb24sIGJ1aWxkcyBhIC5tYXAgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGVycm9yIGlmIGFueSBtYXBwZWQgZWxlbWVudHMgZG8gbm90IHBhc3MgYSB0cnV0aHluZXNzIHRlc3QuXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiB2YXIgZGF0YSA9IHsgZm9vOiAxLCBiYXI6IDIgfTtcclxuICpcclxuICogbGV0IGtleXMgPSBbICdmb28nLCAnYmFyJyBdXHJcbiAqIGxldCB2YWx1ZXMgPSBrZXlzLm1hcChhc3NlcnRNYXAoa2V5ID0+IGRhdGFba2V5XSwgXCJLZXkgbm90IGZvdW5kXCIpKTtcclxuICogLy8gdmFsdWVzIGlzIFsxLCAyXVxyXG4gKlxyXG4gKiBsZXQga2V5cyA9IFsgJ2ZvbycsICdiYXInLCAnYmF6JyBdXHJcbiAqIGxldCB2YWx1ZXMgPSBrZXlzLm1hcChhc3NlcnRNYXAoa2V5ID0+IGRhdGFba2V5XSwgXCJLZXkgbm90IGZvdW5kXCIpKTtcclxuICogLy8gdGhyb3dzIEVycm9yKFwiS2V5IG5vdCBmb3VuZFwiKVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMuYXNzZXJ0TWFwID0gYXNzZXJ0Rm47XHJcbmZ1bmN0aW9uIGFzc2VydEZuKHByZWRpY2F0ZU9yTWFwLCBlcnJNc2cpIHtcclxuICAgIGlmIChlcnJNc2cgPT09IHZvaWQgMCkgeyBlcnJNc2cgPSBcImFzc2VydCBmYWlsdXJlXCI7IH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHByZWRpY2F0ZU9yTWFwKG9iaik7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKGVyck1zZykgPyBlcnJNc2cob2JqKSA6IGVyck1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuYXNzZXJ0Rm4gPSBhc3NlcnRGbjtcclxuLyoqXHJcbiAqIExpa2UgXy5wYWlyczogR2l2ZW4gYW4gb2JqZWN0LCByZXR1cm5zIGFuIGFycmF5IG9mIGtleS92YWx1ZSBwYWlyc1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBcclxuICpcclxuICogcGFpcnMoeyBmb286IFwiRk9PXCIsIGJhcjogXCJCQVIgfSkgLy8gWyBbIFwiZm9vXCIsIFwiRk9PXCIgXSwgWyBcImJhclwiOiBcIkJBUlwiIF0gXVxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydHMucGFpcnMgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gW2tleSwgb2JqW2tleV1dOyB9KTtcclxufTtcclxuLyoqXHJcbiAqIEdpdmVuIHR3byBvciBtb3JlIHBhcmFsbGVsIGFycmF5cywgcmV0dXJucyBhbiBhcnJheSBvZiB0dXBsZXMgd2hlcmVcclxuICogZWFjaCB0dXBsZSBpcyBjb21wb3NlZCBvZiBbIGFbaV0sIGJbaV0sIC4uLiB6W2ldIF1cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgXHJcbiAqXHJcbiAqIGxldCBmb28gPSBbIDAsIDIsIDQsIDYgXTtcclxuICogbGV0IGJhciA9IFsgMSwgMywgNSwgNyBdO1xyXG4gKiBsZXQgYmF6ID0gWyAxMCwgMzAsIDUwLCA3MCBdO1xyXG4gKiBhcnJheVR1cGxlcyhmb28sIGJhcik7ICAgICAgIC8vIFsgWzAsIDFdLCBbMiwgM10sIFs0LCA1XSwgWzYsIDddIF1cclxuICogYXJyYXlUdXBsZXMoZm9vLCBiYXIsIGJheik7ICAvLyBbIFswLCAxLCAxMF0sIFsyLCAzLCAzMF0sIFs0LCA1LCA1MF0sIFs2LCA3LCA3MF0gXVxyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIGFycmF5VHVwbGVzKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIHZhciBtYXhBcnJheUxlbiA9IGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChtaW4sIGFycikgeyByZXR1cm4gTWF0aC5taW4oYXJyLmxlbmd0aCwgbWluKTsgfSwgOTAwNzE5OTI1NDc0MDk5MSk7IC8vIGFrYSAyXjUzIOKIkiAxIGFrYSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxyXG4gICAgdmFyIGksIHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG1heEFycmF5TGVuOyBpKyspIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGEgaG90IGZ1bmN0aW9uXHJcbiAgICAgICAgLy8gVW5yb2xsIHdoZW4gdGhlcmUgYXJlIDEtNCBhcmd1bWVudHNcclxuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthcmdzWzBdW2ldXSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goW2FyZ3NbMF1baV0sIGFyZ3NbMV1baV1dKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXSwgYXJnc1sxXVtpXSwgYXJnc1syXVtpXV0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthcmdzWzBdW2ldLCBhcmdzWzFdW2ldLCBhcmdzWzJdW2ldLCBhcmdzWzNdW2ldXSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFyZ3MubWFwKGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXJyYXlbaV07IH0pKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZXhwb3J0cy5hcnJheVR1cGxlcyA9IGFycmF5VHVwbGVzO1xyXG4vKipcclxuICogUmVkdWNlIGZ1bmN0aW9uIHdoaWNoIGJ1aWxkcyBhbiBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiBba2V5LCB2YWx1ZV0gcGFpcnMuXHJcbiAqXHJcbiAqIEVhY2ggaXRlcmF0aW9uIHNldHMgdGhlIGtleS92YWwgcGFpciBvbiB0aGUgbWVtbyBvYmplY3QsIHRoZW4gcmV0dXJucyB0aGUgbWVtbyBmb3IgdGhlIG5leHQgaXRlcmF0aW9uLlxyXG4gKlxyXG4gKiBFYWNoIGtleVZhbHVlVHVwbGUgc2hvdWxkIGJlIGFuIGFycmF5IHdpdGggdmFsdWVzIFsga2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkgXVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBcclxuICpcclxuICogdmFyIHBhaXJzID0gWyBbXCJmb29rZXlcIiwgXCJmb292YWxcIl0sIFtcImJhcmtleVwiLCBcImJhcnZhbFwiXSBdXHJcbiAqXHJcbiAqIHZhciBwYWlyc1RvT2JqID0gcGFpcnMucmVkdWNlKChtZW1vLCBwYWlyKSA9PiBhcHBseVBhaXJzKG1lbW8sIHBhaXIpLCB7fSlcclxuICogLy8gcGFpcnNUb09iaiA9PSB7IGZvb2tleTogXCJmb292YWxcIiwgYmFya2V5OiBcImJhcnZhbFwiIH1cclxuICpcclxuICogLy8gT3IsIG1vcmUgc2ltcGx5OlxyXG4gKiB2YXIgcGFpcnNUb09iaiA9IHBhaXJzLnJlZHVjZShhcHBseVBhaXJzLCB7fSlcclxuICogLy8gcGFpcnNUb09iaiA9PSB7IGZvb2tleTogXCJmb292YWxcIiwgYmFya2V5OiBcImJhcnZhbFwiIH1cclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBseVBhaXJzKG1lbW8sIGtleVZhbFR1cGxlKSB7XHJcbiAgICB2YXIga2V5LCB2YWx1ZTtcclxuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNBcnJheShrZXlWYWxUdXBsZSkpXHJcbiAgICAgICAga2V5ID0ga2V5VmFsVHVwbGVbMF0sIHZhbHVlID0ga2V5VmFsVHVwbGVbMV07XHJcbiAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc1N0cmluZyhrZXkpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGFyYW1ldGVycyB0byBhcHBseVBhaXJzXCIpO1xyXG4gICAgbWVtb1trZXldID0gdmFsdWU7XHJcbiAgICByZXR1cm4gbWVtbztcclxufVxyXG5leHBvcnRzLmFwcGx5UGFpcnMgPSBhcHBseVBhaXJzO1xyXG4vKiogR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkgKi9cclxuZnVuY3Rpb24gdGFpbChhcnIpIHtcclxuICAgIHJldHVybiBhcnIubGVuZ3RoICYmIGFyclthcnIubGVuZ3RoIC0gMV0gfHwgdW5kZWZpbmVkO1xyXG59XHJcbmV4cG9ydHMudGFpbCA9IHRhaWw7XHJcbi8qKlxyXG4gKiBzaGFsbG93IGNvcHkgZnJvbSBzcmMgdG8gZGVzdFxyXG4gKlxyXG4gKiBub3RlOiBUaGlzIGlzIGEgc2hhbGxvdyBjb3B5LCB3aGlsZSBhbmd1bGFyLmNvcHkgaXMgYSBkZWVwIGNvcHkuXHJcbiAqIHVpLXJvdXRlciB1c2VzIGBjb3B5YCBvbmx5IHRvIG1ha2UgY29waWVzIG9mIHN0YXRlIHBhcmFtZXRlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBfY29weShzcmMsIGRlc3QpIHtcclxuICAgIGlmIChkZXN0KVxyXG4gICAgICAgIE9iamVjdC5rZXlzKGRlc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZGVsZXRlIGRlc3Rba2V5XTsgfSk7XHJcbiAgICBpZiAoIWRlc3QpXHJcbiAgICAgICAgZGVzdCA9IHt9O1xyXG4gICAgcmV0dXJuIGV4cG9ydHMuZXh0ZW5kKGRlc3QsIHNyYyk7XHJcbn1cclxuLyoqIE5haXZlIGZvckVhY2ggaW1wbGVtZW50YXRpb24gd29ya3Mgd2l0aCBPYmplY3RzIG9yIEFycmF5cyAqL1xyXG5mdW5jdGlvbiBfZm9yRWFjaChvYmosIGNiLCBfdGhpcykge1xyXG4gICAgaWYgKHByZWRpY2F0ZXNfMS5pc0FycmF5KG9iaikpXHJcbiAgICAgICAgcmV0dXJuIG9iai5mb3JFYWNoKGNiLCBfdGhpcyk7XHJcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY2Iob2JqW2tleV0sIGtleSk7IH0pO1xyXG59XHJcbmZ1bmN0aW9uIF9leHRlbmQodG9PYmopIHtcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICBpZiAoIW9iailcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICB0b09ialtrZXlzW2pdXSA9IG9ialtrZXlzW2pdXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9PYmo7XHJcbn1cclxuZXhwb3J0cy5fZXh0ZW5kID0gX2V4dGVuZDtcclxuZnVuY3Rpb24gX2VxdWFscyhvMSwgbzIpIHtcclxuICAgIGlmIChvMSA9PT0gbzIpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAobzEgPT09IG51bGwgfHwgbzIgPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKG8xICE9PSBvMSAmJiBvMiAhPT0gbzIpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5hTiA9PT0gTmFOXHJcbiAgICB2YXIgdDEgPSB0eXBlb2YgbzEsIHQyID0gdHlwZW9mIG8yO1xyXG4gICAgaWYgKHQxICE9PSB0MiB8fCB0MSAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIHR1cCA9IFtvMSwgbzJdO1xyXG4gICAgaWYgKGhvZl8xLmFsbChwcmVkaWNhdGVzXzEuaXNBcnJheSkodHVwKSlcclxuICAgICAgICByZXR1cm4gX2FycmF5c0VxKG8xLCBvMik7XHJcbiAgICBpZiAoaG9mXzEuYWxsKHByZWRpY2F0ZXNfMS5pc0RhdGUpKHR1cCkpXHJcbiAgICAgICAgcmV0dXJuIG8xLmdldFRpbWUoKSA9PT0gbzIuZ2V0VGltZSgpO1xyXG4gICAgaWYgKGhvZl8xLmFsbChwcmVkaWNhdGVzXzEuaXNSZWdFeHApKHR1cCkpXHJcbiAgICAgICAgcmV0dXJuIG8xLnRvU3RyaW5nKCkgPT09IG8yLnRvU3RyaW5nKCk7XHJcbiAgICBpZiAoaG9mXzEuYWxsKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKSh0dXApKVxyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBtZWhcclxuICAgIHZhciBwcmVkaWNhdGVzID0gW3ByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uLCBwcmVkaWNhdGVzXzEuaXNBcnJheSwgcHJlZGljYXRlc18xLmlzRGF0ZSwgcHJlZGljYXRlc18xLmlzUmVnRXhwXTtcclxuICAgIGlmIChwcmVkaWNhdGVzLm1hcChob2ZfMS5hbnkpLnJlZHVjZShmdW5jdGlvbiAoYiwgZm4pIHsgcmV0dXJuIGIgfHwgISFmbih0dXApOyB9LCBmYWxzZSkpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIGtleSwga2V5cyA9IHt9O1xyXG4gICAgZm9yIChrZXkgaW4gbzEpIHtcclxuICAgICAgICBpZiAoIV9lcXVhbHMobzFba2V5XSwgbzJba2V5XSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBrZXlzW2tleV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZm9yIChrZXkgaW4gbzIpIHtcclxuICAgICAgICBpZiAoIWtleXNba2V5XSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gX2FycmF5c0VxKGExLCBhMikge1xyXG4gICAgaWYgKGExLmxlbmd0aCAhPT0gYTIubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBhcnJheVR1cGxlcyhhMSwgYTIpLnJlZHVjZShmdW5jdGlvbiAoYiwgdCkgeyByZXR1cm4gYiAmJiBfZXF1YWxzKHRbMF0sIHRbMV0pOyB9LCB0cnVlKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgc29ydCBmdW5jdGlvblxyXG4gKlxyXG4gKiBDcmVhdGVzIGEgc29ydCBmdW5jdGlvbiB3aGljaCBzb3J0cyBieSBhIG51bWVyaWMgcHJvcGVydHkuXHJcbiAqXHJcbiAqIFRoZSBgcHJvcEZuYCBzaG91bGQgcmV0dXJuIHRoZSBwcm9wZXJ0eSBhcyBhIG51bWJlciB3aGljaCBjYW4gYmUgc29ydGVkLlxyXG4gKlxyXG4gKiAjIyMjIEV4YW1wbGU6XHJcbiAqIFRoaXMgZXhhbXBsZSByZXR1cm5zIHRoZSBgcHJpb3JpdHlgIHByb3AuXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBzb3J0Zm4gPSBzb3J0Qnkob2JqID0+IG9iai5wcmlvcml0eSlcclxuICogLy8gZXF1aXZhbGVudCB0bzpcclxuICogdmFyIGxvbmdoYW5kU29ydEZuID0gKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xyXG4gKiBgYGBcclxuICpcclxuICogIyMjIyBFeGFtcGxlOlxyXG4gKiBUaGlzIGV4YW1wbGUgdXNlcyBbW3Byb3BdXVxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgc29ydGZuID0gc29ydEJ5KHByb3AoJ3ByaW9yaXR5JykpXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgYGNoZWNrRm5gIGNhbiBiZSB1c2VkIHRvIGV4Y2x1ZGUgb2JqZWN0cyBmcm9tIHNvcnRpbmcuXHJcbiAqXHJcbiAqICMjIyMgRXhhbXBsZTpcclxuICogVGhpcyBleGFtcGxlIG9ubHkgc29ydHMgb2JqZWN0cyB3aXRoIHR5cGUgPT09ICdGT08nXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBzb3J0Zm4gPSBzb3J0QnkocHJvcCgncHJpb3JpdHknKSwgcHJvcEVxKCd0eXBlJywgJ0ZPTycpKVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHByb3BGbiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcHJvcGVydHkgKGFzIGEgbnVtYmVyKVxyXG4gKiBAcGFyYW0gY2hlY2tGbiBhIHByZWRpY2F0ZVxyXG4gKlxyXG4gKiBAcmV0dXJuIGEgc29ydCBmdW5jdGlvbiBsaWtlOiBgKGEsIGIpID0+IChjaGVja0ZuKGEpICYmIGNoZWNrRm4oYikpID8gcHJvcEZuKGEpIC0gcHJvcEZuKGIpIDogMGBcclxuICovXHJcbmV4cG9ydHMuc29ydEJ5ID0gZnVuY3Rpb24gKHByb3BGbiwgY2hlY2tGbikge1xyXG4gICAgaWYgKGNoZWNrRm4gPT09IHZvaWQgMCkgeyBjaGVja0ZuID0gaG9mXzEudmFsKHRydWUpOyB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gKGNoZWNrRm4oYSkgJiYgY2hlY2tGbihiKSkgPyBwcm9wRm4oYSkgLSBwcm9wRm4oYikgOiAwO1xyXG4gICAgfTtcclxufTtcclxuLyoqXHJcbiAqIENvbXBvc2VzIGEgbGlzdCBvZiBzb3J0IGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiBDcmVhdGVzIGEgc29ydCBmdW5jdGlvbiBjb21wb3NlZCBvZiBtdWx0aXBsZSBzb3J0IGZ1bmN0aW9ucy5cclxuICogRWFjaCBzb3J0IGZ1bmN0aW9uIGlzIGludm9rZWQgaW4gc2VyaWVzLlxyXG4gKiBUaGUgZmlyc3Qgc29ydCBmdW5jdGlvbiB0byByZXR1cm4gbm9uLXplcm8gXCJ3aW5zXCIuXHJcbiAqXHJcbiAqIEBwYXJhbSBzb3J0Rm5zIGxpc3Qgb2Ygc29ydCBmdW5jdGlvbnNcclxuICovXHJcbmV4cG9ydHMuY29tcG9zZVNvcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc29ydEZucyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBzb3J0Rm5zW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcG9zZWRTb3J0KGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gc29ydEZucy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGZuKSB7IHJldHVybiBwcmV2IHx8IGZuKGEsIGIpOyB9LCAwKTtcclxuICAgIH07XHJcbn07XHJcbi8vIGlzc3VlICMyNjc2XHJcbmV4cG9ydHMuc2lsZW5jZVVuY2F1Z2h0SW5Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UpIHtcclxuICAgIHJldHVybiBwcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiAwOyB9KSAmJiBwcm9taXNlO1xyXG59O1xyXG5leHBvcnRzLnNpbGVudFJlamVjdGlvbiA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgcmV0dXJuIGV4cG9ydHMuc2lsZW5jZVVuY2F1Z2h0SW5Qcm9taXNlKGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLnJlamVjdChlcnJvcikpO1xyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL2NvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKiogUHJlZGljYXRlc1xyXG4gKlxyXG4gKiBUaGVzZSBwcmVkaWNhdGVzIHJldHVybiB0cnVlL2ZhbHNlIGJhc2VkIG9uIHRoZSBpbnB1dC5cclxuICogQWx0aG91Z2ggdGhlc2UgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgdGhleSBhcmUgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXHJcbiAqXHJcbiAqIEBtb2R1bGUgY29tbW9uX3ByZWRpY2F0ZXNcclxuICovXHJcbi8qKiAqL1xyXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi9ob2ZcIik7XHJcbnZhciBzdGF0ZU9iamVjdF8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3N0YXRlT2JqZWN0XCIpO1xyXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG52YXIgdGlzID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiB0eXBlb2YgKHgpID09PSB0OyB9OyB9O1xyXG5leHBvcnRzLmlzVW5kZWZpbmVkID0gdGlzKCd1bmRlZmluZWQnKTtcclxuZXhwb3J0cy5pc0RlZmluZWQgPSBob2ZfMS5ub3QoZXhwb3J0cy5pc1VuZGVmaW5lZCk7XHJcbmV4cG9ydHMuaXNOdWxsID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gPT09IG51bGw7IH07XHJcbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBob2ZfMS5vcihleHBvcnRzLmlzTnVsbCwgZXhwb3J0cy5pc1VuZGVmaW5lZCk7XHJcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IHRpcygnZnVuY3Rpb24nKTtcclxuZXhwb3J0cy5pc051bWJlciA9IHRpcygnbnVtYmVyJyk7XHJcbmV4cG9ydHMuaXNTdHJpbmcgPSB0aXMoJ3N0cmluZycpO1xyXG5leHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnOyB9O1xyXG5leHBvcnRzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xyXG5leHBvcnRzLmlzRGF0ZSA9IChmdW5jdGlvbiAoeCkgeyByZXR1cm4gdG9TdHIuY2FsbCh4KSA9PT0gJ1tvYmplY3QgRGF0ZV0nOyB9KTtcclxuZXhwb3J0cy5pc1JlZ0V4cCA9IChmdW5jdGlvbiAoeCkgeyByZXR1cm4gdG9TdHIuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7IH0pO1xyXG5leHBvcnRzLmlzU3RhdGUgPSBzdGF0ZU9iamVjdF8xLlN0YXRlT2JqZWN0LmlzU3RhdGU7XHJcbi8qKlxyXG4gKiBQcmVkaWNhdGUgd2hpY2ggY2hlY2tzIGlmIGEgdmFsdWUgaXMgaW5qZWN0YWJsZVxyXG4gKlxyXG4gKiBBIHZhbHVlIGlzIFwiaW5qZWN0YWJsZVwiIGlmIGl0IGlzIGEgZnVuY3Rpb24sIG9yIGlmIGl0IGlzIGFuIG5nMSBhcnJheS1ub3RhdGlvbi1zdHlsZSBhcnJheVxyXG4gKiB3aGVyZSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBhcnJheSBhcmUgU3RyaW5ncywgZXhjZXB0IHRoZSBsYXN0IG9uZSwgd2hpY2ggaXMgYSBGdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gaXNJbmplY3RhYmxlKHZhbCkge1xyXG4gICAgaWYgKGV4cG9ydHMuaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGgpIHtcclxuICAgICAgICB2YXIgaGVhZCA9IHZhbC5zbGljZSgwLCAtMSksIHRhaWwgPSB2YWwuc2xpY2UoLTEpO1xyXG4gICAgICAgIHJldHVybiAhKGhlYWQuZmlsdGVyKGhvZl8xLm5vdChleHBvcnRzLmlzU3RyaW5nKSkubGVuZ3RoIHx8IHRhaWwuZmlsdGVyKGhvZl8xLm5vdChleHBvcnRzLmlzRnVuY3Rpb24pKS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNGdW5jdGlvbih2YWwpO1xyXG59XHJcbmV4cG9ydHMuaXNJbmplY3RhYmxlID0gaXNJbmplY3RhYmxlO1xyXG4vKipcclxuICogUHJlZGljYXRlIHdoaWNoIGNoZWNrcyBpZiBhIHZhbHVlIGxvb2tzIGxpa2UgYSBQcm9taXNlXHJcbiAqXHJcbiAqIEl0IGlzIHByb2JhYmx5IGEgUHJvbWlzZSBpZiBpdCdzIGFuIG9iamVjdCwgYW5kIGl0IGhhcyBhIGB0aGVuYCBwcm9wZXJ0eSB3aGljaCBpcyBhIEZ1bmN0aW9uXHJcbiAqL1xyXG5leHBvcnRzLmlzUHJvbWlzZSA9IGhvZl8xLmFuZChleHBvcnRzLmlzT2JqZWN0LCBob2ZfMS5waXBlKGhvZl8xLnByb3AoJ3RoZW4nKSwgZXhwb3J0cy5pc0Z1bmN0aW9uKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWRpY2F0ZXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3ByZWRpY2F0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBIaWdoZXIgb3JkZXIgZnVuY3Rpb25zXHJcbiAqXHJcbiAqIFRoZXNlIHV0aWxpdHkgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgYnV0IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cclxuICpcclxuICogQG1vZHVsZSBjb21tb25faG9mXHJcbiAqLyAvKiogKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBmb3IgW1BhcnRpYWwgQXBwbGljYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BhcnRpYWxfYXBwbGljYXRpb24pIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cclxuICpcclxuICogR2l2ZW4gYSBmdW5jdGlvbiB3aXRoIE4gcGFyYW1ldGVycywgcmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IHN1cHBvcnRzIHBhcnRpYWwgYXBwbGljYXRpb24uXHJcbiAqIFRoZSBuZXcgZnVuY3Rpb24gYWNjZXB0cyBhbnl3aGVyZSBmcm9tIDEgdG8gTiBwYXJhbWV0ZXJzLiAgV2hlbiB0aGF0IGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIE0gcGFyYW1ldGVycyxcclxuICogd2hlcmUgTSBpcyBsZXNzIHRoYW4gTiwgaXQgcmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzLiAgSXQgY29udGludWVzIHRvXHJcbiAqIGFjY2VwdCBtb3JlIHBhcmFtZXRlcnMgdW50aWwgYWxsIE4gcGFyYW1ldGVycyBoYXZlIGJlZW4gc3VwcGxpZWQuXHJcbiAqXHJcbiAqXHJcbiAqIFRoaXMgY29udHJpdmVkIGV4YW1wbGUgdXNlcyBhIHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uIGFzIGFuIHByZWRpY2F0ZSwgd2hpY2ggcmV0dXJucyB0cnVlXHJcbiAqIGlmIGFuIG9iamVjdCBpcyBmb3VuZCBpbiBib3RoIGFycmF5cy5cclxuICogQGV4YW1wbGVcclxuICogYGBgXHJcbiAqIC8vIHJldHVybnMgdHJ1ZSBpZiBhbiBvYmplY3QgaXMgaW4gYm90aCBvZiB0aGUgdHdvIGFycmF5c1xyXG4gKiBmdW5jdGlvbiBpbkJvdGgoYXJyYXkxLCBhcnJheTIsIG9iamVjdCkge1xyXG4gKiAgIHJldHVybiBhcnJheTEuaW5kZXhPZihvYmplY3QpICE9PSAtMSAmJlxyXG4gKiAgICAgICAgICBhcnJheTIuaW5kZXhPZihvYmplY3QpICE9PSAxO1xyXG4gKiB9XHJcbiAqIGxldCBvYmoxLCBvYmoyLCBvYmozLCBvYmo0LCBvYmo1LCBvYmo2LCBvYmo3XHJcbiAqIGxldCBmb29zID0gW29iajEsIG9iajNdXHJcbiAqIGxldCBiYXJzID0gW29iajMsIG9iajQsIG9iajVdXHJcbiAqXHJcbiAqIC8vIEEgY3VycmllZCBcImNvcHlcIiBvZiBpbkJvdGhcclxuICogbGV0IGN1cnJpZWRJbkJvdGggPSBjdXJyeShpbkJvdGgpO1xyXG4gKiAvLyBQYXJ0aWFsbHkgYXBwbHkgYm90aCB0aGUgYXJyYXkxIGFuZCBhcnJheTJcclxuICogbGV0IGluRm9vc0FuZEJhcnMgPSBjdXJyaWVkSW5Cb3RoKGZvb3MsIGJhcnMpO1xyXG4gKlxyXG4gKiAvLyBTdXBwbHkgdGhlIGZpbmFsIGFyZ3VtZW50OyBzaW5jZSBhbGwgYXJndW1lbnRzIGFyZVxyXG4gKiAvLyBzdXBwbGllZCwgdGhlIG9yaWdpbmFsIGluQm90aCBmdW5jdGlvbiBpcyB0aGVuIGNhbGxlZC5cclxuICogbGV0IG9iajFJbkJvdGggPSBpbkZvb3NBbmRCYXJzKG9iajEpOyAvLyBmYWxzZVxyXG4gKlxyXG4gKiAvLyBVc2UgdGhlIGluRm9vc0FuZEJhcnMgYXMgYSBwcmVkaWNhdGUuXHJcbiAqIC8vIEZpbHRlciwgb24gZWFjaCBpdGVyYXRpb24sIHN1cHBsaWVzIHRoZSBmaW5hbCBhcmd1bWVudFxyXG4gKiBsZXQgYWxsT2JqcyA9IFsgb2JqMSwgb2JqMiwgb2JqMywgb2JqNCwgb2JqNSwgb2JqNiwgb2JqNyBdO1xyXG4gKiBsZXQgZm91bmRJbkJvdGggPSBhbGxPYmpzLmZpbHRlcihpbkZvb3NBbmRCYXJzKTsgLy8gWyBvYmozIF1cclxuICpcclxuICogYGBgXHJcbiAqXHJcbiAqIFN0b2xlbiBmcm9tOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQzOTQ3NDcvamF2YXNjcmlwdC1jdXJyeS1mdW5jdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0gZm5cclxuICogQHJldHVybnMgeyp8ZnVuY3Rpb24oKTogKCp8YW55KX1cclxuICovXHJcbmZ1bmN0aW9uIGN1cnJ5KGZuKSB7XHJcbiAgICB2YXIgaW5pdGlhbF9hcmdzID0gW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzLCBbMV0pO1xyXG4gICAgdmFyIGZ1bmNfYXJnc19sZW5ndGggPSBmbi5sZW5ndGg7XHJcbiAgICBmdW5jdGlvbiBjdXJyaWVkKGFyZ3MpIHtcclxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPj0gZnVuY19hcmdzX2xlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyaWVkKGFyZ3MuY29uY2F0KFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN1cnJpZWQoaW5pdGlhbF9hcmdzKTtcclxufVxyXG5leHBvcnRzLmN1cnJ5ID0gY3Vycnk7XHJcbi8qKlxyXG4gKiBHaXZlbiBhIHZhcmFyZ3MgbGlzdCBvZiBmdW5jdGlvbnMsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNvbXBvc2VzIHRoZSBhcmd1bWVudCBmdW5jdGlvbnMsIHJpZ2h0LXRvLWxlZnRcclxuICogZ2l2ZW46IGYoeCksIGcoeCksIGgoeClcclxuICogbGV0IGNvbXBvc2VkID0gY29tcG9zZShmLGcsaClcclxuICogdGhlbiwgY29tcG9zZWQgaXM6IGYoZyhoKHgpKSlcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XHJcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGkgPSBzdGFydCwgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB3aGlsZSAoaS0tKVxyXG4gICAgICAgICAgICByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNvbXBvc2UgPSBjb21wb3NlO1xyXG4vKipcclxuICogR2l2ZW4gYSB2YXJhcmdzIGxpc3Qgb2YgZnVuY3Rpb25zLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyBjb21wb3NlcyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zLCBsZWZ0LXRvLXJpZ2h0XHJcbiAqIGdpdmVuOiBmKHgpLCBnKHgpLCBoKHgpXHJcbiAqIGxldCBwaXBlZCA9IHBpcGUoZixnLGgpO1xyXG4gKiB0aGVuLCBwaXBlZCBpczogaChnKGYoeCkpKVxyXG4gKi9cclxuZnVuY3Rpb24gcGlwZSgpIHtcclxuICAgIHZhciBmdW5jcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBmdW5jc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLnJldmVyc2UoKSk7XHJcbn1cclxuZXhwb3J0cy5waXBlID0gcGlwZTtcclxuLyoqXHJcbiAqIEdpdmVuIGEgcHJvcGVydHkgbmFtZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGF0IHByb3BlcnR5IGZyb20gYW4gb2JqZWN0XHJcbiAqIGxldCBvYmogPSB7IGZvbzogMSwgbmFtZTogXCJibGFyZ1wiIH07XHJcbiAqIGxldCBnZXROYW1lID0gcHJvcChcIm5hbWVcIik7XHJcbiAqIGdldE5hbWUob2JqKSA9PT0gXCJibGFyZ1wiXHJcbiAqL1xyXG5leHBvcnRzLnByb3AgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmpbbmFtZV07IH07XHJcbn07XHJcbi8qKlxyXG4gKiBHaXZlbiBhIHByb3BlcnR5IG5hbWUgYW5kIGEgdmFsdWUsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBib29sZWFuIGJhc2VkIG9uIHdoZXRoZXJcclxuICogdGhlIHBhc3NlZCBvYmplY3QgaGFzIGEgcHJvcGVydHkgdGhhdCBtYXRjaGVzIHRoZSB2YWx1ZVxyXG4gKiBsZXQgb2JqID0geyBmb286IDEsIG5hbWU6IFwiYmxhcmdcIiB9O1xyXG4gKiBsZXQgZ2V0TmFtZSA9IHByb3BFcShcIm5hbWVcIiwgXCJibGFyZ1wiKTtcclxuICogZ2V0TmFtZShvYmopID09PSB0cnVlXHJcbiAqL1xyXG5leHBvcnRzLnByb3BFcSA9IGN1cnJ5KGZ1bmN0aW9uIChuYW1lLCB2YWwsIG9iaikgeyByZXR1cm4gb2JqICYmIG9ialtuYW1lXSA9PT0gdmFsOyB9KTtcclxuLyoqXHJcbiAqIEdpdmVuIGEgZG90dGVkIHByb3BlcnR5IG5hbWUsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBuZXN0ZWQgcHJvcGVydHkgZnJvbSBhbiBvYmplY3QsIG9yIHVuZGVmaW5lZFxyXG4gKiBsZXQgb2JqID0geyBpZDogMSwgbmVzdGVkT2JqOiB7IGZvbzogMSwgbmFtZTogXCJibGFyZ1wiIH0sIH07XHJcbiAqIGxldCBnZXROYW1lID0gcHJvcChcIm5lc3RlZE9iai5uYW1lXCIpO1xyXG4gKiBnZXROYW1lKG9iaikgPT09IFwiYmxhcmdcIlxyXG4gKiBsZXQgcHJvcE5vdEZvdW5kID0gcHJvcChcInRoaXMucHJvcGVydHkuZG9lc250LmV4aXN0XCIpO1xyXG4gKiBwcm9wTm90Rm91bmQob2JqKSA9PT0gdW5kZWZpbmVkXHJcbiAqL1xyXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHJldHVybiBwaXBlLmFwcGx5KG51bGwsIG5hbWUuc3BsaXQoXCIuXCIpLm1hcChleHBvcnRzLnByb3ApKTtcclxufTtcclxuLyoqXHJcbiAqIEdpdmVuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdHJ1dGh5IG9yIGZhbHNleSB2YWx1ZSwgcmV0dXJucyBhXHJcbiAqIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgb3Bwb3NpdGUgKGZhbHNleSBvciB0cnV0aHkpIHZhbHVlIGdpdmVuIHRoZSBzYW1lIGlucHV0c1xyXG4gKi9cclxuZXhwb3J0cy5ub3QgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhZm4uYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICB9O1xyXG59O1xyXG4vKipcclxuICogR2l2ZW4gdHdvIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0cnV0aHkgb3IgZmFsc2V5IHZhbHVlcywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnV0aHlcclxuICogaWYgYm90aCBmdW5jdGlvbnMgcmV0dXJuIHRydXRoeSBmb3IgdGhlIGdpdmVuIGFyZ3VtZW50c1xyXG4gKi9cclxuZnVuY3Rpb24gYW5kKGZuMSwgZm4yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm4xLmFwcGx5KG51bGwsIGFyZ3MpICYmIGZuMi5hcHBseShudWxsLCBhcmdzKTtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5hbmQgPSBhbmQ7XHJcbi8qKlxyXG4gKiBHaXZlbiB0d28gZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRydXRoeSBvciBmYWxzZXkgdmFsdWVzLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydXRoeVxyXG4gKiBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZ1bmN0aW9ucyByZXR1cm5zIHRydXRoeSBmb3IgdGhlIGdpdmVuIGFyZ3VtZW50c1xyXG4gKi9cclxuZnVuY3Rpb24gb3IoZm4xLCBmbjIpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmbjEuYXBwbHkobnVsbCwgYXJncykgfHwgZm4yLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLm9yID0gb3I7XHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhbGwgdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5IG1hdGNoIGEgcHJlZGljYXRlIGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSBmbjEgYSBwcmVkaWNhdGUgZnVuY3Rpb24gYGZuMWBcclxuICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbiBhcnJheSBhbmQgcmV0dXJucyB0cnVlIGlmIGBmbjFgIGlzIHRydWUgZm9yIGFsbCBlbGVtZW50cyBvZiB0aGUgYXJyYXlcclxuICovXHJcbmV4cG9ydHMuYWxsID0gZnVuY3Rpb24gKGZuMSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIpIHsgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKGIsIHgpIHsgcmV0dXJuIGIgJiYgISFmbjEoeCk7IH0sIHRydWUpOyB9O1xyXG59O1xyXG5leHBvcnRzLmFueSA9IGZ1bmN0aW9uIChmbjEpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChiLCB4KSB7IHJldHVybiBiIHx8ICEhZm4xKHgpOyB9LCBmYWxzZSk7IH07XHJcbn07XHJcbi8qKiBHaXZlbiBhIGNsYXNzLCByZXR1cm5zIGEgUHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgb2YgdGhhdCBjbGFzcyAqL1xyXG5leHBvcnRzLmlzID0gZnVuY3Rpb24gKGN0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgPT09IGN0b3IgfHwgb2JqIGluc3RhbmNlb2YgY3Rvcik7XHJcbiAgICB9O1xyXG59O1xyXG4vKiogR2l2ZW4gYSB2YWx1ZSwgcmV0dXJucyBhIFByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBhbm90aGVyIHZhbHVlIGlzID09PSBlcXVhbCB0byB0aGUgb3JpZ2luYWwgdmFsdWUgKi9cclxuZXhwb3J0cy5lcSA9IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgcmV0dXJuIHZhbCA9PT0gb3RoZXI7XHJcbn07IH07XHJcbi8qKiBHaXZlbiBhIHZhbHVlLCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgdmFsdWUgKi9cclxuZXhwb3J0cy52YWwgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdjsgfTsgfTtcclxuZnVuY3Rpb24gaW52b2tlKGZuTmFtZSwgYXJncykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqW2ZuTmFtZV0uYXBwbHkob2JqLCBhcmdzKTtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5pbnZva2UgPSBpbnZva2U7XHJcbi8qKlxyXG4gKiBTb3J0YSBsaWtlIFBhdHRlcm4gTWF0Y2hpbmcgKGEgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBjb25kaXRpb25hbCBjb25zdHJ1Y3QpXHJcbiAqXHJcbiAqIFNlZSBodHRwOi8vYzIuY29tL2NnaS93aWtpP1BhdHRlcm5NYXRjaGluZ1xyXG4gKlxyXG4gKiBUaGlzIGlzIGEgY29uZGl0aW9uYWwgY29uc3RydWN0IHdoaWNoIGFsbG93cyBhIHNlcmllcyBvZiBwcmVkaWNhdGVzIGFuZCBvdXRwdXQgZnVuY3Rpb25zXHJcbiAqIHRvIGJlIGNoZWNrZWQgYW5kIHRoZW4gYXBwbGllZC4gIEVhY2ggcHJlZGljYXRlIHJlY2VpdmVzIHRoZSBpbnB1dC4gIElmIHRoZSBwcmVkaWNhdGVcclxuICogcmV0dXJucyB0cnV0aHksIHRoZW4gaXRzIG1hdGNoaW5nIG91dHB1dCBmdW5jdGlvbiAobWFwcGluZyBmdW5jdGlvbikgaXMgcHJvdmlkZWQgd2l0aFxyXG4gKiB0aGUgaW5wdXQgYW5kLCB0aGVuIHRoZSByZXN1bHQgaXMgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEVhY2ggY29tYmluYXRpb24gKDItdHVwbGUpIG9mIHByZWRpY2F0ZSArIG91dHB1dCBmdW5jdGlvbiBzaG91bGQgYmUgcGxhY2VkIGluIGFuIGFycmF5XHJcbiAqIG9mIHNpemUgMjogWyBwcmVkaWNhdGUsIG1hcEZuIF1cclxuICpcclxuICogVGhlc2UgMi10dXBsZXMgc2hvdWxkIGJlIHB1dCBpbiBhbiBvdXRlciBhcnJheS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgXHJcbiAqXHJcbiAqIC8vIEhlcmUncyBhIDItdHVwbGUgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIGlzU3RyaW5nIHByZWRpY2F0ZVxyXG4gKiAvLyBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZGVzY3JpcHRpb24gb2YgdGhlIGlucHV0XHJcbiAqIGxldCBmaXJzdFR1cGxlID0gWyBhbmd1bGFyLmlzU3RyaW5nLCAoaW5wdXQpID0+IGBIZXJlcyB5b3VyIHN0cmluZyAke2lucHV0fWAgXTtcclxuICpcclxuICogLy8gU2Vjb25kIHR1cGxlOiBwcmVkaWNhdGUgXCJpc051bWJlclwiLCBtYXBmbiByZXR1cm5zIGEgZGVzY3JpcHRpb25cclxuICogbGV0IHNlY29uZFR1cGxlID0gWyBhbmd1bGFyLmlzTnVtYmVyLCAoaW5wdXQpID0+IGAoJHtpbnB1dH0pIFRoYXQncyBhIG51bWJlciFgIF07XHJcbiAqXHJcbiAqIGxldCB0aGlyZCA9IFsgKGlucHV0KSA9PiBpbnB1dCA9PT0gbnVsbCwgIChpbnB1dCkgPT4gYE9oLCBudWxsLi4uYCBdO1xyXG4gKlxyXG4gKiBsZXQgZm91cnRoID0gWyAoaW5wdXQpID0+IGlucHV0ID09PSB1bmRlZmluZWQsICAoaW5wdXQpID0+IGBub3RkZWZpbmVkYCBdO1xyXG4gKlxyXG4gKiBsZXQgZGVzY3JpcHRpb25PZiA9IHBhdHRlcm4oWyBmaXJzdFR1cGxlLCBzZWNvbmRUdXBsZSwgdGhpcmQsIGZvdXJ0aCBdKTtcclxuICpcclxuICogY29uc29sZS5sb2coZGVzY3JpcHRpb25PZih1bmRlZmluZWQpKTsgLy8gJ25vdGRlZmluZWQnXHJcbiAqIGNvbnNvbGUubG9nKGRlc2NyaXB0aW9uT2YoNTUpKTsgLy8gJyg1NSkgVGhhdCdzIGEgbnVtYmVyISdcclxuICogY29uc29sZS5sb2coZGVzY3JpcHRpb25PZihcImZvb1wiKSk7IC8vICdIZXJlJ3MgeW91ciBzdHJpbmcgZm9vJ1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHN0cnVjdCBBIDJEIGFycmF5LiAgRWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBzaG91bGQgYmUgYW4gYXJyYXksIGEgMi10dXBsZSxcclxuICogd2l0aCBhIFByZWRpY2F0ZSBhbmQgYSBtYXBwaW5nL291dHB1dCBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oYW55KTogKn1cclxuICovXHJcbmZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnVjdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoc3RydWN0W2ldWzBdKHgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cnVjdFtpXVsxXSh4KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucGF0dGVybiA9IHBhdHRlcm47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvZi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vaG9mLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMubm90SW1wbGVtZW50ZWQgPSBmdW5jdGlvbiAoZm5uYW1lKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoZm5uYW1lICsgXCIoKTogTm8gY29yZXNlcnZpY2VzIGltcGxlbWVudGF0aW9uIGZvciBVSS1Sb3V0ZXIgaXMgbG9hZGVkLlwiKTtcclxufTsgfTtcclxudmFyIHNlcnZpY2VzID0ge1xyXG4gICAgJHE6IHVuZGVmaW5lZCxcclxuICAgICRpbmplY3RvcjogdW5kZWZpbmVkLFxyXG59O1xyXG5leHBvcnRzLnNlcnZpY2VzID0gc2VydmljZXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmVzZXJ2aWNlcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vY29yZXNlcnZpY2VzLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogQGNvcmVhcGlcclxuICogQG1vZHVsZSBjb21tb25cclxuICovIC8qKiAqL1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21tb24vaW5kZXhcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXJhbXMvaW5kZXhcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXRoL2luZGV4XCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vcmVzb2x2ZS9pbmRleFwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlL2luZGV4XCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vdHJhbnNpdGlvbi9pbmRleFwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybC9pbmRleFwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3ZpZXcvaW5kZXhcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9nbG9iYWxzXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vcm91dGVyXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vdmFuaWxsYVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogRnVuY3Rpb25zIHRoYXQgbWFuaXB1bGF0ZSBzdHJpbmdzXHJcbiAqXHJcbiAqIEFsdGhvdWdoIHRoZXNlIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQsIHRoZXkgYXJlIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGNvbW1vbl9zdHJpbmdzXHJcbiAqLyAvKiogKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4vcHJlZGljYXRlc1wiKTtcclxudmFyIHJlamVjdEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnlcIik7XHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcclxudmFyIGhvZl8xID0gcmVxdWlyZShcIi4vaG9mXCIpO1xyXG52YXIgdHJhbnNpdGlvbl8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vdHJhbnNpdGlvblwiKTtcclxudmFyIHJlc29sdmFibGVfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmFibGVcIik7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHNob3J0ZW5lZCB0byBhIG1heGltdW0gbGVuZ3RoXHJcbiAqXHJcbiAqIElmIHRoZSBzdHJpbmcgaXMgYWxyZWFkeSBsZXNzIHRoYW4gdGhlIGBtYXhgIGxlbmd0aCwgcmV0dXJuIHRoZSBzdHJpbmcuXHJcbiAqIEVsc2UgcmV0dXJuIHRoZSBzdHJpbmcsIHNob3J0ZW5lZCB0byBgbWF4IC0gM2AgYW5kIGFwcGVuZCB0aHJlZSBkb3RzIChcIi4uLlwiKS5cclxuICpcclxuICogQHBhcmFtIG1heCB0aGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHN0cmluZyB0byByZXR1cm5cclxuICogQHBhcmFtIHN0ciB0aGUgaW5wdXQgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXhMZW5ndGgobWF4LCBzdHIpIHtcclxuICAgIGlmIChzdHIubGVuZ3RoIDw9IG1heClcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgbWF4IC0gMykgKyBcIi4uLlwiO1xyXG59XHJcbmV4cG9ydHMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xyXG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZywgd2l0aCBzcGFjZXMgYWRkZWQgdG8gdGhlIGVuZCwgdXAgdG8gYSBkZXNpcmVkIHN0ciBsZW5ndGhcclxuICpcclxuICogSWYgdGhlIHN0cmluZyBpcyBhbHJlYWR5IGxvbmdlciB0aGFuIHRoZSBkZXNpcmVkIGxlbmd0aCwgcmV0dXJuIHRoZSBzdHJpbmcuXHJcbiAqIEVsc2UgcmV0dXJucyB0aGUgc3RyaW5nLCB3aXRoIGV4dHJhIHNwYWNlcyBvbiB0aGUgZW5kLCBzdWNoIHRoYXQgaXQgcmVhY2hlcyBgbGVuZ3RoYCBjaGFyYWN0ZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBkZXNpcmVkIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHRvIHJldHVyblxyXG4gKiBAcGFyYW0gc3RyIHRoZSBpbnB1dCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIHBhZFN0cmluZyhsZW5ndGgsIHN0cikge1xyXG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsZW5ndGgpXHJcbiAgICAgICAgc3RyICs9IFwiIFwiO1xyXG4gICAgcmV0dXJuIHN0cjtcclxufVxyXG5leHBvcnRzLnBhZFN0cmluZyA9IHBhZFN0cmluZztcclxuZnVuY3Rpb24ga2Vib2JTdHJpbmcoY2FtZWxDYXNlKSB7XHJcbiAgICByZXR1cm4gY2FtZWxDYXNlXHJcbiAgICAgICAgLnJlcGxhY2UoL14oW0EtWl0pLywgZnVuY3Rpb24gKCQxKSB7IHJldHVybiAkMS50b0xvd2VyQ2FzZSgpOyB9KSAvLyByZXBsYWNlIGZpcnN0IGNoYXJcclxuICAgICAgICAucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAoJDEpIHsgcmV0dXJuIFwiLVwiICsgJDEudG9Mb3dlckNhc2UoKTsgfSk7IC8vIHJlcGxhY2UgcmVzdFxyXG59XHJcbmV4cG9ydHMua2Vib2JTdHJpbmcgPSBrZWJvYlN0cmluZztcclxuZnVuY3Rpb24gX3RvSnNvbihvYmopIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xyXG59XHJcbmZ1bmN0aW9uIF9mcm9tSnNvbihqc29uKSB7XHJcbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzU3RyaW5nKGpzb24pID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XHJcbn1cclxuZnVuY3Rpb24gcHJvbWlzZVRvU3RyaW5nKHApIHtcclxuICAgIHJldHVybiBcIlByb21pc2UoXCIgKyBKU09OLnN0cmluZ2lmeShwKSArIFwiKVwiO1xyXG59XHJcbmZ1bmN0aW9uIGZ1bmN0aW9uVG9TdHJpbmcoZm4pIHtcclxuICAgIHZhciBmblN0ciA9IGZuVG9TdHJpbmcoZm4pO1xyXG4gICAgdmFyIG5hbWVkRnVuY3Rpb25NYXRjaCA9IGZuU3RyLm1hdGNoKC9eKGZ1bmN0aW9uIFteIF0rXFwoW14pXSpcXCkpLyk7XHJcbiAgICB2YXIgdG9TdHIgPSBuYW1lZEZ1bmN0aW9uTWF0Y2ggPyBuYW1lZEZ1bmN0aW9uTWF0Y2hbMV0gOiBmblN0cjtcclxuICAgIHZhciBmbk5hbWUgPSBmblsnbmFtZSddIHx8IFwiXCI7XHJcbiAgICBpZiAoZm5OYW1lICYmIHRvU3RyLm1hdGNoKC9mdW5jdGlvbiBcXCgvKSkge1xyXG4gICAgICAgIHJldHVybiAnZnVuY3Rpb24gJyArIGZuTmFtZSArIHRvU3RyLnN1YnN0cig5KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0b1N0cjtcclxufVxyXG5leHBvcnRzLmZ1bmN0aW9uVG9TdHJpbmcgPSBmdW5jdGlvblRvU3RyaW5nO1xyXG5mdW5jdGlvbiBmblRvU3RyaW5nKGZuKSB7XHJcbiAgICB2YXIgX2ZuID0gcHJlZGljYXRlc18xLmlzQXJyYXkoZm4pID8gZm4uc2xpY2UoLTEpWzBdIDogZm47XHJcbiAgICByZXR1cm4gX2ZuICYmIF9mbi50b1N0cmluZygpIHx8IFwidW5kZWZpbmVkXCI7XHJcbn1cclxuZXhwb3J0cy5mblRvU3RyaW5nID0gZm5Ub1N0cmluZztcclxudmFyIHN0cmluZ2lmeVBhdHRlcm5GbiA9IG51bGw7XHJcbnZhciBzdHJpbmdpZnlQYXR0ZXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgaXNSZWplY3Rpb24gPSByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmlzUmVqZWN0aW9uUHJvbWlzZTtcclxuICAgIHN0cmluZ2lmeVBhdHRlcm5GbiA9IHN0cmluZ2lmeVBhdHRlcm5GbiB8fCBob2ZfMS5wYXR0ZXJuKFtcclxuICAgICAgICBbaG9mXzEubm90KHByZWRpY2F0ZXNfMS5pc0RlZmluZWQpLCBob2ZfMS52YWwoXCJ1bmRlZmluZWRcIildLFxyXG4gICAgICAgIFtwcmVkaWNhdGVzXzEuaXNOdWxsLCBob2ZfMS52YWwoXCJudWxsXCIpXSxcclxuICAgICAgICBbcHJlZGljYXRlc18xLmlzUHJvbWlzZSwgaG9mXzEudmFsKFwiW1Byb21pc2VdXCIpXSxcclxuICAgICAgICBbaXNSZWplY3Rpb24sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll90cmFuc2l0aW9uUmVqZWN0aW9uLnRvU3RyaW5nKCk7IH1dLFxyXG4gICAgICAgIFtob2ZfMS5pcyhyZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uKSwgaG9mXzEuaW52b2tlKFwidG9TdHJpbmdcIildLFxyXG4gICAgICAgIFtob2ZfMS5pcyh0cmFuc2l0aW9uXzEuVHJhbnNpdGlvbiksIGhvZl8xLmludm9rZShcInRvU3RyaW5nXCIpXSxcclxuICAgICAgICBbaG9mXzEuaXMocmVzb2x2YWJsZV8xLlJlc29sdmFibGUpLCBob2ZfMS5pbnZva2UoXCJ0b1N0cmluZ1wiKV0sXHJcbiAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc0luamVjdGFibGUsIGZ1bmN0aW9uVG9TdHJpbmddLFxyXG4gICAgICAgIFtob2ZfMS52YWwodHJ1ZSksIGNvbW1vbl8xLmlkZW50aXR5XVxyXG4gICAgXSk7XHJcbiAgICByZXR1cm4gc3RyaW5naWZ5UGF0dGVybkZuKHZhbHVlKTtcclxufTtcclxuZnVuY3Rpb24gc3RyaW5naWZ5KG8pIHtcclxuICAgIHZhciBzZWVuID0gW107XHJcbiAgICBmdW5jdGlvbiBmb3JtYXQodmFsKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc09iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YodmFsKSAhPT0gLTEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tjaXJjdWxhciByZWZdJztcclxuICAgICAgICAgICAgc2Vlbi5wdXNoKHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlQYXR0ZXJuKHZhbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobywgZnVuY3Rpb24gKGtleSwgdmFsKSB7IHJldHVybiBmb3JtYXQodmFsKTsgfSkucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO1xyXG59XHJcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xyXG4vKiogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgc3BsaXRzIGEgc3RyaW5nIG9uIGEgY2hhcmFjdGVyIG9yIHN1YnN0cmluZyAqL1xyXG5leHBvcnRzLmJlZm9yZUFmdGVyU3Vic3RyID0gZnVuY3Rpb24gKGNoYXIpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGlmICghc3RyKVxyXG4gICAgICAgIHJldHVybiBbXCJcIiwgXCJcIl07XHJcbiAgICB2YXIgaWR4ID0gc3RyLmluZGV4T2YoY2hhcik7XHJcbiAgICBpZiAoaWR4ID09PSAtMSlcclxuICAgICAgICByZXR1cm4gW3N0ciwgXCJcIl07XHJcbiAgICByZXR1cm4gW3N0ci5zdWJzdHIoMCwgaWR4KSwgc3RyLnN1YnN0cihpZHggKyAxKV07XHJcbn07IH07XHJcbi8qKlxyXG4gKiBTcGxpdHMgb24gYSBkZWxpbWl0ZXIsIGJ1dCByZXR1cm5zIHRoZSBkZWxpbWl0ZXJzIGluIHRoZSBhcnJheVxyXG4gKlxyXG4gKiAjIyMjIEV4YW1wbGU6XHJcbiAqIGBgYGpzXHJcbiAqIHZhciBzcGxpdE9uU2xhc2hlcyA9IHNwbGl0T25EZWxpbSgnLycpO1xyXG4gKiBzcGxpdE9uU2xhc2hlcyhcIi9mb29cIik7IC8vIFtcIi9cIiwgXCJmb29cIl1cclxuICogc3BsaXRPblNsYXNoZXMoXCIvZm9vL1wiKTsgLy8gW1wiL1wiLCBcImZvb1wiLCBcIi9cIl1cclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGxpdE9uRGVsaW0oZGVsaW0pIHtcclxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCIoXCIgKyBkZWxpbSArIFwiKVwiLCBcImdcIik7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgIHJldHVybiBzdHIuc3BsaXQocmUpLmZpbHRlcihjb21tb25fMS5pZGVudGl0eSk7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc3BsaXRPbkRlbGltID0gc3BsaXRPbkRlbGltO1xyXG47XHJcbi8qKlxyXG4gKiBSZWR1Y2UgZm4gdGhhdCBqb2lucyBuZWlnaGJvcmluZyBzdHJpbmdzXHJcbiAqXHJcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHN0cmluZ3MsIHJldHVybnMgYSBuZXcgYXJyYXlcclxuICogd2hlcmUgYWxsIG5laWdoYm9yaW5nIHN0cmluZ3MgaGF2ZSBiZWVuIGpvaW5lZC5cclxuICpcclxuICogIyMjIyBFeGFtcGxlOlxyXG4gKiBgYGBqc1xyXG4gKiBsZXQgYXJyID0gW1wiZm9vXCIsIFwiYmFyXCIsIDEsIFwiYmF6XCIsIFwiXCIsIFwicXV4XCIgXTtcclxuICogYXJyLnJlZHVjZShqb2luTmVpZ2hib3JzUiwgW10pIC8vIFtcImZvb2JhclwiLCAxLCBcImJhenF1eFwiIF1cclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBqb2luTmVpZ2hib3JzUihhY2MsIHgpIHtcclxuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoY29tbW9uXzEudGFpbChhY2MpKSAmJiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoeCkpXHJcbiAgICAgICAgcmV0dXJuIGFjYy5zbGljZSgwLCAtMSkuY29uY2F0KGNvbW1vbl8xLnRhaWwoYWNjKSArIHgpO1xyXG4gICAgcmV0dXJuIGNvbW1vbl8xLnB1c2hSKGFjYywgeCk7XHJcbn1cclxuZXhwb3J0cy5qb2luTmVpZ2hib3JzUiA9IGpvaW5OZWlnaGJvcnNSO1xyXG47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ3MuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3N0cmluZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqICMgVHJhbnNpdGlvbiB0cmFjaW5nIChkZWJ1ZylcclxuICpcclxuICogRW5hYmxlIHRyYW5zaXRpb24gdHJhY2luZyB0byBwcmludCB0cmFuc2l0aW9uIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLFxyXG4gKiBpbiBvcmRlciB0byBoZWxwIGRlYnVnIHlvdXIgYXBwbGljYXRpb24uXHJcbiAqIFRyYWNpbmcgbG9ncyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIFRyYW5zaXRpb24gdG8geW91ciBjb25zb2xlLlxyXG4gKlxyXG4gKiBUbyBlbmFibGUgdHJhY2luZywgaW1wb3J0IHRoZSBbW1RyYWNlXV0gc2luZ2xldG9uIGFuZCBlbmFibGUgb25lIG9yIG1vcmUgY2F0ZWdvcmllcy5cclxuICpcclxuICogIyMjIEVTNlxyXG4gKiBgYGBqc1xyXG4gKiBpbXBvcnQge3RyYWNlfSBmcm9tIFwidWktcm91dGVyLW5nMlwiOyAvLyBvciBcImFuZ3VsYXItdWktcm91dGVyXCJcclxuICogdHJhY2UuZW5hYmxlKDEsIDUpOyAvLyBUUkFOU0lUSU9OIGFuZCBWSUVXQ09ORklHXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyMgQ0pTXHJcbiAqIGBgYGpzXHJcbiAqIGxldCB0cmFjZSA9IHJlcXVpcmUoXCJhbmd1bGFyLXVpLXJvdXRlclwiKS50cmFjZTsgLy8gb3IgXCJ1aS1yb3V0ZXItbmcyXCJcclxuICogdHJhY2UuZW5hYmxlKFwiVFJBTlNJVElPTlwiLCBcIlZJRVdDT05GSUdcIik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyMgR2xvYmFsc1xyXG4gKiBgYGBqc1xyXG4gKiBsZXQgdHJhY2UgPSB3aW5kb3dbXCJhbmd1bGFyLXVpLXJvdXRlclwiXS50cmFjZTsgLy8gb3IgXCJ1aS1yb3V0ZXItbmcyXCJcclxuICogdHJhY2UuZW5hYmxlKCk7IC8vIFRyYWNlIGV2ZXJ5dGhpbmcgKHZlcnkgdmVyYm9zZSlcclxuICogYGBgXHJcbiAqXHJcbiAqICMjIyBBbmd1bGFyIDE6XHJcbiAqIGBgYGpzXHJcbiAqIGFwcC5ydW4oJHRyYWNlID0+ICR0cmFjZS5lbmFibGUoKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAY29yZWFwaVxyXG4gKiBAbW9kdWxlIHRyYWNlXHJcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cclxudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XHJcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XHJcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdzXCIpO1xyXG4vKiogQGhpZGRlbiAqL1xyXG5mdW5jdGlvbiB1aVZpZXdTdHJpbmcodmlld0RhdGEpIHtcclxuICAgIGlmICghdmlld0RhdGEpXHJcbiAgICAgICAgcmV0dXJuICd1aS12aWV3IChkZWZ1bmN0KSc7XHJcbiAgICByZXR1cm4gXCJbdWktdmlldyNcIiArIHZpZXdEYXRhLmlkICsgXCIgdGFnIFwiICtcclxuICAgICAgICAoXCJpbiB0ZW1wbGF0ZSBmcm9tICdcIiArICh2aWV3RGF0YS5jcmVhdGlvbkNvbnRleHQgJiYgdmlld0RhdGEuY3JlYXRpb25Db250ZXh0Lm5hbWUgfHwgJyhyb290KScpICsgXCInIHN0YXRlXTogXCIpICtcclxuICAgICAgICAoXCJmcW46ICdcIiArIHZpZXdEYXRhLmZxbiArIFwiJywgXCIpICtcclxuICAgICAgICAoXCJuYW1lOiAnXCIgKyB2aWV3RGF0YS5uYW1lICsgXCJAXCIgKyB2aWV3RGF0YS5jcmVhdGlvbkNvbnRleHQgKyBcIicpXCIpO1xyXG59XHJcbi8qKiBAaGlkZGVuICovXHJcbnZhciB2aWV3Q29uZmlnU3RyaW5nID0gZnVuY3Rpb24gKHZpZXdDb25maWcpIHtcclxuICAgIHJldHVybiBcIltWaWV3Q29uZmlnI1wiICsgdmlld0NvbmZpZy4kaWQgKyBcIiBmcm9tICdcIiArICh2aWV3Q29uZmlnLnZpZXdEZWNsLiRjb250ZXh0Lm5hbWUgfHwgJyhyb290KScpICsgXCInIHN0YXRlXTogdGFyZ2V0IHVpLXZpZXc6ICdcIiArIHZpZXdDb25maWcudmlld0RlY2wuJHVpVmlld05hbWUgKyBcIkBcIiArIHZpZXdDb25maWcudmlld0RlY2wuJHVpVmlld0NvbnRleHRBbmNob3IgKyBcIidcIjtcclxufTtcclxuLyoqIEBoaWRkZW4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplZENhdChpbnB1dCkge1xyXG4gICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc051bWJlcihpbnB1dCkgPyBDYXRlZ29yeVtpbnB1dF0gOiBDYXRlZ29yeVtDYXRlZ29yeVtpbnB1dF1dO1xyXG59XHJcbi8qKlxyXG4gKiBUcmFjZSBjYXRlZ29yaWVzIEVudW1cclxuICpcclxuICogRW5hYmxlIG9yIGRpc2FibGUgYSBjYXRlZ29yeSB1c2luZyBbW1RyYWNlLmVuYWJsZV1dIG9yIFtbVHJhY2UuZGlzYWJsZV1dXHJcbiAqXHJcbiAqIGB0cmFjZS5lbmFibGUoQ2F0ZWdvcnkuVFJBTlNJVElPTilgXHJcbiAqXHJcbiAqIFRoZXNlIGNhbiBhbHNvIGJlIHByb3ZpZGVkIHVzaW5nIGEgbWF0Y2hpbmcgc3RyaW5nLCBvciBwb3NpdGlvbiBvcmRpbmFsXHJcbiAqXHJcbiAqIGB0cmFjZS5lbmFibGUoXCJUUkFOU0lUSU9OXCIpYFxyXG4gKlxyXG4gKiBgdHJhY2UuZW5hYmxlKDEpYFxyXG4gKi9cclxudmFyIENhdGVnb3J5O1xyXG4oZnVuY3Rpb24gKENhdGVnb3J5KSB7XHJcbiAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIlJFU09MVkVcIl0gPSAwXSA9IFwiUkVTT0xWRVwiO1xyXG4gICAgQ2F0ZWdvcnlbQ2F0ZWdvcnlbXCJUUkFOU0lUSU9OXCJdID0gMV0gPSBcIlRSQU5TSVRJT05cIjtcclxuICAgIENhdGVnb3J5W0NhdGVnb3J5W1wiSE9PS1wiXSA9IDJdID0gXCJIT09LXCI7XHJcbiAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIlVJVklFV1wiXSA9IDNdID0gXCJVSVZJRVdcIjtcclxuICAgIENhdGVnb3J5W0NhdGVnb3J5W1wiVklFV0NPTkZJR1wiXSA9IDRdID0gXCJWSUVXQ09ORklHXCI7XHJcbn0pKENhdGVnb3J5ID0gZXhwb3J0cy5DYXRlZ29yeSB8fCAoZXhwb3J0cy5DYXRlZ29yeSA9IHt9KSk7XHJcbi8qKiBAaGlkZGVuICovIHZhciBfdGlkID0gaG9mXzEucGFyc2UoXCIkaWRcIik7XHJcbi8qKiBAaGlkZGVuICovIHZhciBfcmlkID0gaG9mXzEucGFyc2UoXCJyb3V0ZXIuJGlkXCIpO1xyXG4vKiogQGhpZGRlbiAqLyB2YXIgdHJhbnNMYmwgPSBmdW5jdGlvbiAodHJhbnMpIHsgcmV0dXJuIFwiVHJhbnNpdGlvbiAjXCIgKyBfdGlkKHRyYW5zKSArIFwiLVwiICsgX3JpZCh0cmFucyk7IH07XHJcbi8qKlxyXG4gKiBQcmludHMgVUktUm91dGVyIFRyYW5zaXRpb24gdHJhY2UgaW5mb3JtYXRpb24gdG8gdGhlIGNvbnNvbGUuXHJcbiAqL1xyXG52YXIgVHJhY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqIEBoaWRkZW4gKi9cclxuICAgIGZ1bmN0aW9uIFRyYWNlKCkge1xyXG4gICAgICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuYXBwcm94aW1hdGVEaWdlc3RzID0gMDtcclxuICAgIH1cclxuICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICBUcmFjZS5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uIChlbmFibGVkLCBjYXRlZ29yaWVzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIWNhdGVnb3JpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNhdGVnb3JpZXMgPSBPYmplY3Qua2V5cyhDYXRlZ29yeSlcclxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHBhcnNlSW50KGssIDEwKTsgfSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuICFpc05hTihrKTsgfSlcclxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gQ2F0ZWdvcnlba2V5XTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGVnb3JpZXMubWFwKG5vcm1hbGl6ZWRDYXQpLmZvckVhY2goZnVuY3Rpb24gKGNhdGVnb3J5KSB7IHJldHVybiBfdGhpcy5fZW5hYmxlZFtjYXRlZ29yeV0gPSBlbmFibGVkOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZXMgYSB0cmFjZSBbW0NhdGVnb3J5XV1cclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogdHJhY2UuZW5hYmxlKFwiVFJBTlNJVElPTlwiKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYXRlZ29yaWVzIGNhdGVnb3JpZXMgdG8gZW5hYmxlLiBJZiBgY2F0ZWdvcmllc2AgaXMgb21pdHRlZCwgYWxsIGNhdGVnb3JpZXMgYXJlIGVuYWJsZWQuXHJcbiAgICAgKiAgICAgICAgQWxzbyB0YWtlcyBzdHJpbmdzIChjYXRlZ29yeSBuYW1lKSBvciBvcmRpbmFsIChjYXRlZ29yeSBwb3NpdGlvbilcclxuICAgICAqL1xyXG4gICAgVHJhY2UucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2V0KHRydWUsIGNhdGVnb3JpZXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGlzYWJsZXMgYSB0cmFjZSBbW0NhdGVnb3J5XV1cclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogdHJhY2UuZGlzYWJsZShcIlZJRVdDT05GSUdcIik7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2F0ZWdvcmllcyBjYXRlZ29yaWVzIHRvIGRpc2FibGUuIElmIGBjYXRlZ29yaWVzYCBpcyBvbWl0dGVkLCBhbGwgY2F0ZWdvcmllcyBhcmUgZGlzYWJsZWQuXHJcbiAgICAgKiAgICAgICAgQWxzbyB0YWtlcyBzdHJpbmdzIChjYXRlZ29yeSBuYW1lKSBvciBvcmRpbmFsIChjYXRlZ29yeSBwb3NpdGlvbilcclxuICAgICAqL1xyXG4gICAgVHJhY2UucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NldChmYWxzZSwgY2F0ZWdvcmllcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGVuYWJsZWQgc3RhdGV1cyBvZiBhIFtbQ2F0ZWdvcnldXVxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiB0cmFjZS5lbmFibGVkKFwiVklFV0NPTkZJR1wiKTsgLy8gdHJ1ZSBvciBmYWxzZVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYm9vbGVhbiB0cnVlIGlmIHRoZSBjYXRlZ29yeSBpcyBlbmFibGVkXHJcbiAgICAgKi9cclxuICAgIFRyYWNlLnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZW5hYmxlZFtub3JtYWxpemVkQ2F0KGNhdGVnb3J5KV07XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cclxuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVRyYW5zaXRpb25TdGFydCA9IGZ1bmN0aW9uICh0cmFucykge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6IFN0YXJ0ZWQgIC0+IFwiICsgc3RyaW5nc18xLnN0cmluZ2lmeSh0cmFucykpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXHJcbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VUcmFuc2l0aW9uSWdub3JlZCA9IGZ1bmN0aW9uICh0cmFucykge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6IElnbm9yZWQgIDw+IFwiICsgc3RyaW5nc18xLnN0cmluZ2lmeSh0cmFucykpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXHJcbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VIb29rSW52b2NhdGlvbiA9IGZ1bmN0aW9uIChzdGVwLCB0cmFucywgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LkhPT0spKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIGV2ZW50ID0gaG9mXzEucGFyc2UoXCJ0cmFjZURhdGEuaG9va1R5cGVcIikob3B0aW9ucykgfHwgXCJpbnRlcm5hbFwiLCBjb250ZXh0ID0gaG9mXzEucGFyc2UoXCJ0cmFjZURhdGEuY29udGV4dC5zdGF0ZS5uYW1lXCIpKG9wdGlvbnMpIHx8IGhvZl8xLnBhcnNlKFwidHJhY2VEYXRhLmNvbnRleHRcIikob3B0aW9ucykgfHwgXCJ1bmtub3duXCIsIG5hbWUgPSBzdHJpbmdzXzEuZnVuY3Rpb25Ub1N0cmluZyhzdGVwLnJlZ2lzdGVyZWRIb29rLmNhbGxiYWNrKTtcclxuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogICBIb29rIC0+IFwiICsgZXZlbnQgKyBcIiBjb250ZXh0OiBcIiArIGNvbnRleHQgKyBcIiwgXCIgKyBzdHJpbmdzXzEubWF4TGVuZ3RoKDIwMCwgbmFtZSkpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXHJcbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VIb29rUmVzdWx0ID0gZnVuY3Rpb24gKGhvb2tSZXN1bHQsIHRyYW5zLCB0cmFuc2l0aW9uT3B0aW9ucykge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LkhPT0spKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6ICAgPC0gSG9vayByZXR1cm5lZDogXCIgKyBzdHJpbmdzXzEubWF4TGVuZ3RoKDIwMCwgc3RyaW5nc18xLnN0cmluZ2lmeShob29rUmVzdWx0KSkpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXHJcbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VSZXNvbHZlUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCB3aGVuLCB0cmFucykge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlJFU09MVkUpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6ICAgICAgICAgUmVzb2x2aW5nIFwiICsgcGF0aCArIFwiIChcIiArIHdoZW4gKyBcIilcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cclxuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVJlc29sdmFibGVSZXNvbHZlZCA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlLCB0cmFucykge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlJFU09MVkUpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6ICAgICAgICAgICAgICAgPC0gUmVzb2x2ZWQgIFwiICsgcmVzb2x2YWJsZSArIFwiIHRvOiBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBzdHJpbmdzXzEuc3RyaW5naWZ5KHJlc29sdmFibGUuZGF0YSkpKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xyXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlRXJyb3IgPSBmdW5jdGlvbiAocmVhc29uLCB0cmFucykge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6IDwtIFJlamVjdGVkIFwiICsgc3RyaW5nc18xLnN0cmluZ2lmeSh0cmFucykgKyBcIiwgcmVhc29uOiBcIiArIHJlYXNvbik7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cclxuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVN1Y2Nlc3MgPSBmdW5jdGlvbiAoZmluYWxTdGF0ZSwgdHJhbnMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5UUkFOU0lUSU9OKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiA8LSBTdWNjZXNzICBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodHJhbnMpICsgXCIsIGZpbmFsIHN0YXRlOiBcIiArIGZpbmFsU3RhdGUubmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cclxuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVVJVmlld0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCB2aWV3RGF0YSwgZXh0cmEpIHtcclxuICAgICAgICBpZiAoZXh0cmEgPT09IHZvaWQgMCkgeyBleHRyYSA9IFwiXCI7IH1cclxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5VSVZJRVcpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJ1aS12aWV3OiBcIiArIHN0cmluZ3NfMS5wYWRTdHJpbmcoMzAsIGV2ZW50KSArIFwiIFwiICsgdWlWaWV3U3RyaW5nKHZpZXdEYXRhKSArIGV4dHJhKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xyXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVUlWaWV3Q29uZmlnVXBkYXRlZCA9IGZ1bmN0aW9uICh2aWV3RGF0YSwgY29udGV4dCkge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlVJVklFVykpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLnRyYWNlVUlWaWV3RXZlbnQoXCJVcGRhdGluZ1wiLCB2aWV3RGF0YSwgXCIgd2l0aCBWaWV3Q29uZmlnIGZyb20gY29udGV4dD0nXCIgKyBjb250ZXh0ICsgXCInXCIpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXHJcbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VVSVZpZXdGaWxsID0gZnVuY3Rpb24gKHZpZXdEYXRhLCBodG1sKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVUlWSUVXKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMudHJhY2VVSVZpZXdFdmVudChcIkZpbGxcIiwgdmlld0RhdGEsIFwiIHdpdGg6IFwiICsgc3RyaW5nc18xLm1heExlbmd0aCgyMDAsIGh0bWwpKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xyXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVmlld1NlcnZpY2VFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdmlld0NvbmZpZykge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlZJRVdDT05GSUcpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJWSUVXQ09ORklHOiBcIiArIGV2ZW50ICsgXCIgXCIgKyB2aWV3Q29uZmlnU3RyaW5nKHZpZXdDb25maWcpKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xyXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdmlld0RhdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5WSUVXQ09ORklHKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVklFV0NPTkZJRzogXCIgKyBldmVudCArIFwiIFwiICsgdWlWaWV3U3RyaW5nKHZpZXdEYXRhKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRyYWNlO1xyXG59KCkpO1xyXG5leHBvcnRzLlRyYWNlID0gVHJhY2U7XHJcbi8qKlxyXG4gKiBUaGUgW1tUcmFjZV1dIHNpbmdsZXRvblxyXG4gKlxyXG4gKiAjIyMjIEV4YW1wbGU6XHJcbiAqIGBgYGpzXHJcbiAqIGltcG9ydCB7dHJhY2V9IGZyb20gXCJhbmd1bGFyLXVpLXJvdXRlclwiO1xyXG4gKiB0cmFjZS5lbmFibGUoMSwgNSk7XHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIHRyYWNlID0gbmV3IFRyYWNlKCk7XHJcbmV4cG9ydHMudHJhY2UgPSB0cmFjZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3RyYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogQGNvcmVhcGlcclxuICogQG1vZHVsZSBzdGF0ZVxyXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XHJcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XHJcbi8qKlxyXG4gKiBFbmNhcHN1bGF0ZSB0aGUgdGFyZ2V0IChkZXN0aW5hdGlvbikgc3RhdGUvcGFyYW1zL29wdGlvbnMgb2YgYSBbW1RyYW5zaXRpb25dXS5cclxuICpcclxuICogVGhpcyBjbGFzcyBpcyBmcmVxdWVudGx5IHVzZWQgdG8gcmVkaXJlY3QgYSB0cmFuc2l0aW9uIHRvIGEgbmV3IGRlc3RpbmF0aW9uLlxyXG4gKlxyXG4gKiBTZWU6XHJcbiAqXHJcbiAqIC0gW1tIb29rUmVzdWx0XV1cclxuICogLSBbW1RyYW5zaXRpb25Ib29rRm5dXVxyXG4gKiAtIFtbVHJhbnNpdGlvblNlcnZpY2Uub25TdGFydF1dXHJcbiAqXHJcbiAqIFRvIGNyZWF0ZSBhIGBUYXJnZXRTdGF0ZWAsIHVzZSBbW1N0YXRlU2VydmljZS50YXJnZXRdXS5cclxuICpcclxuICogLS0tXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3Mgd3JhcHM6XHJcbiAqXHJcbiAqIDEpIGFuIGlkZW50aWZpZXIgZm9yIGEgc3RhdGVcclxuICogMikgYSBzZXQgb2YgcGFyYW1ldGVyc1xyXG4gKiAzKSBhbmQgdHJhbnNpdGlvbiBvcHRpb25zXHJcbiAqIDQpIHRoZSByZWdpc3RlcmVkIHN0YXRlIG9iamVjdCAodGhlIFtbU3RhdGVEZWNsYXJhdGlvbl1dKVxyXG4gKlxyXG4gKiBNYW55IFVJLVJvdXRlciBBUElzIHN1Y2ggYXMgW1tTdGF0ZVNlcnZpY2UuZ29dXSB0YWtlIGEgW1tTdGF0ZU9yTmFtZV1dIGFyZ3VtZW50IHdoaWNoIGNhblxyXG4gKiBlaXRoZXIgYmUgYSAqc3RhdGUgb2JqZWN0KiAoYSBbW1N0YXRlRGVjbGFyYXRpb25dXSBvciBbW1N0YXRlT2JqZWN0XV0pIG9yIGEgKnN0YXRlIG5hbWUqIChhIHN0cmluZykuXHJcbiAqIFRoZSBgVGFyZ2V0U3RhdGVgIGNsYXNzIG5vcm1hbGl6ZXMgdGhvc2Ugb3B0aW9ucy5cclxuICpcclxuICogQSBgVGFyZ2V0U3RhdGVgIG1heSBiZSB2YWxpZCAodGhlIHN0YXRlIGJlaW5nIHRhcmdldGVkIGV4aXN0cyBpbiB0aGUgcmVnaXN0cnkpXHJcbiAqIG9yIGludmFsaWQgKHRoZSBzdGF0ZSBiZWluZyB0YXJnZXRlZCBpcyBub3QgcmVnaXN0ZXJlZCkuXHJcbiAqL1xyXG52YXIgVGFyZ2V0U3RhdGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgVGFyZ2V0U3RhdGUgY29uc3RydWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBEbyBub3QgY29uc3RydWN0IGEgYFRhcmdldFN0YXRlYCBtYW51YWxseS5cclxuICAgICAqIFRvIGNyZWF0ZSBhIGBUYXJnZXRTdGF0ZWAsIHVzZSB0aGUgW1tTdGF0ZVNlcnZpY2UudGFyZ2V0XV0gZmFjdG9yeSBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIF9pZGVudGlmaWVyIEFuIGlkZW50aWZpZXIgZm9yIGEgc3RhdGUuXHJcbiAgICAgKiAgICBFaXRoZXIgYSBmdWxseS1xdWFsaWZpZWQgc3RhdGUgbmFtZSwgb3IgdGhlIG9iamVjdCB1c2VkIHRvIGRlZmluZSB0aGUgc3RhdGUuXHJcbiAgICAgKiBAcGFyYW0gX2RlZmluaXRpb24gVGhlIGludGVybmFsIHN0YXRlIHJlcHJlc2VudGF0aW9uLCBpZiBleGlzdHMuXHJcbiAgICAgKiBAcGFyYW0gX3BhcmFtcyBQYXJhbWV0ZXJzIGZvciB0aGUgdGFyZ2V0IHN0YXRlXHJcbiAgICAgKiBAcGFyYW0gX29wdGlvbnMgVHJhbnNpdGlvbiBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbGFwaVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBUYXJnZXRTdGF0ZShfaWRlbnRpZmllciwgX2RlZmluaXRpb24sIF9wYXJhbXMsIF9vcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKF9vcHRpb25zID09PSB2b2lkIDApIHsgX29wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIHRoaXMuX2lkZW50aWZpZXIgPSBfaWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLl9kZWZpbml0aW9uID0gX2RlZmluaXRpb247XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IF9wYXJhbXMgfHwge307XHJcbiAgICB9XHJcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRoaXMgb2JqZWN0IHRhcmdldHMgKi9cclxuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uICYmIHRoaXMuX2RlZmluaXRpb24ubmFtZSB8fCB0aGlzLl9pZGVudGlmaWVyO1xyXG4gICAgfTtcclxuICAgIC8qKiBUaGUgaWRlbnRpZmllciB1c2VkIHdoZW4gY3JlYXRpbmcgdGhpcyBUYXJnZXRTdGF0ZSAqL1xyXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLmlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkZW50aWZpZXI7XHJcbiAgICB9O1xyXG4gICAgLyoqIFRoZSB0YXJnZXQgcGFyYW1ldGVyIHZhbHVlcyAqL1xyXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zO1xyXG4gICAgfTtcclxuICAgIC8qKiBUaGUgaW50ZXJuYWwgc3RhdGUgb2JqZWN0IChpZiBpdCB3YXMgZm91bmQpICovXHJcbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUuJHN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qKiBUaGUgaW50ZXJuYWwgc3RhdGUgZGVjbGFyYXRpb24gKGlmIGl0IHdhcyBmb3VuZCkgKi9cclxuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbiAmJiB0aGlzLl9kZWZpbml0aW9uLnNlbGY7XHJcbiAgICB9O1xyXG4gICAgLyoqIFRoZSB0YXJnZXQgb3B0aW9ucyAqL1xyXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XHJcbiAgICB9O1xyXG4gICAgLyoqIFRydWUgaWYgdGhlIHRhcmdldCBzdGF0ZSB3YXMgZm91bmQgKi9cclxuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5zZWxmKTtcclxuICAgIH07XHJcbiAgICAvKiogVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIHZhbGlkICovXHJcbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmVycm9yKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqIElmIHRoZSBvYmplY3QgaXMgaW52YWxpZCwgcmV0dXJucyB0aGUgcmVhc29uIHdoeSAqL1xyXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiYXNlID0gdGhpcy5vcHRpb25zKCkucmVsYXRpdmU7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uICYmICEhYmFzZSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGVOYW1lID0gYmFzZS5uYW1lID8gYmFzZS5uYW1lIDogYmFzZTtcclxuICAgICAgICAgICAgcmV0dXJuIFwiQ291bGQgbm90IHJlc29sdmUgJ1wiICsgdGhpcy5uYW1lKCkgKyBcIicgZnJvbSBzdGF0ZSAnXCIgKyBzdGF0ZU5hbWUgKyBcIidcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uKVxyXG4gICAgICAgICAgICByZXR1cm4gXCJObyBzdWNoIHN0YXRlICdcIiArIHRoaXMubmFtZSgpICsgXCInXCI7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uLnNlbGYpXHJcbiAgICAgICAgICAgIHJldHVybiBcIlN0YXRlICdcIiArIHRoaXMubmFtZSgpICsgXCInIGhhcyBhbiBpbnZhbGlkIGRlZmluaXRpb25cIjtcclxuICAgIH07XHJcbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiJ1wiICsgdGhpcy5uYW1lKCkgKyBcIidcIiArIGNvbW1vbl8xLnRvSnNvbih0aGlzLnBhcmFtcygpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGFyZ2V0U3RhdGU7XHJcbn0oKSk7XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBoYXMgYSBzdGF0ZSBwcm9wZXJ0eSB0aGF0IG1pZ2h0IGJlIGEgc3RhdGUgb3Igc3RhdGUgbmFtZSAqL1xyXG5UYXJnZXRTdGF0ZS5pc0RlZiA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHJldHVybiBvYmogJiYgb2JqLnN0YXRlICYmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcob2JqLnN0YXRlKSB8fCBwcmVkaWNhdGVzXzEuaXNTdHJpbmcob2JqLnN0YXRlLm5hbWUpKTtcclxufTtcclxuZXhwb3J0cy5UYXJnZXRTdGF0ZSA9IFRhcmdldFN0YXRlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YXJnZXRTdGF0ZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS90YXJnZXRTdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQGNvcmVhcGlcclxuICogQG1vZHVsZSBwYXJhbXNcclxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XHJcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XHJcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xyXG52YXIgcGFyYW1UeXBlXzEgPSByZXF1aXJlKFwiLi9wYXJhbVR5cGVcIik7XHJcbi8qKiBAaGlkZGVuICovIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG4vKiogQGhpZGRlbiAqLyB2YXIgaXNTaG9ydGhhbmQgPSBmdW5jdGlvbiAoY2ZnKSB7XHJcbiAgICByZXR1cm4gW1widmFsdWVcIiwgXCJ0eXBlXCIsIFwic3F1YXNoXCIsIFwiYXJyYXlcIiwgXCJkeW5hbWljXCJdLmZpbHRlcihoYXNPd24uYmluZChjZmcgfHwge30pKS5sZW5ndGggPT09IDA7XHJcbn07XHJcbi8qKiBAaW50ZXJuYWxhcGkgKi9cclxudmFyIERlZlR5cGU7XHJcbihmdW5jdGlvbiAoRGVmVHlwZSkge1xyXG4gICAgRGVmVHlwZVtEZWZUeXBlW1wiUEFUSFwiXSA9IDBdID0gXCJQQVRIXCI7XHJcbiAgICBEZWZUeXBlW0RlZlR5cGVbXCJTRUFSQ0hcIl0gPSAxXSA9IFwiU0VBUkNIXCI7XHJcbiAgICBEZWZUeXBlW0RlZlR5cGVbXCJDT05GSUdcIl0gPSAyXSA9IFwiQ09ORklHXCI7XHJcbn0pKERlZlR5cGUgPSBleHBvcnRzLkRlZlR5cGUgfHwgKGV4cG9ydHMuRGVmVHlwZSA9IHt9KSk7XHJcbi8qKiBAaGlkZGVuICovXHJcbmZ1bmN0aW9uIHVud3JhcFNob3J0aGFuZChjZmcpIHtcclxuICAgIGNmZyA9IGlzU2hvcnRoYW5kKGNmZykgJiYgeyB2YWx1ZTogY2ZnIH0gfHwgY2ZnO1xyXG4gICAgZ2V0U3RhdGljRGVmYXVsdFZhbHVlWydfX2NhY2hlYWJsZSddID0gdHJ1ZTtcclxuICAgIGZ1bmN0aW9uIGdldFN0YXRpY0RlZmF1bHRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gY2ZnLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChjZmcsIHtcclxuICAgICAgICAkJGZuOiBwcmVkaWNhdGVzXzEuaXNJbmplY3RhYmxlKGNmZy52YWx1ZSkgPyBjZmcudmFsdWUgOiBnZXRTdGF0aWNEZWZhdWx0VmFsdWUsXHJcbiAgICB9KTtcclxufVxyXG4vKiogQGhpZGRlbiAqL1xyXG5mdW5jdGlvbiBnZXRUeXBlKGNmZywgdXJsVHlwZSwgbG9jYXRpb24sIGlkLCBwYXJhbVR5cGVzKSB7XHJcbiAgICBpZiAoY2ZnLnR5cGUgJiYgdXJsVHlwZSAmJiB1cmxUeXBlLm5hbWUgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtICdcIiArIGlkICsgXCInIGhhcyB0d28gdHlwZSBjb25maWd1cmF0aW9ucy5cIik7XHJcbiAgICBpZiAoY2ZnLnR5cGUgJiYgdXJsVHlwZSAmJiB1cmxUeXBlLm5hbWUgPT09ICdzdHJpbmcnICYmIHBhcmFtVHlwZXMudHlwZShjZmcudHlwZSkpXHJcbiAgICAgICAgcmV0dXJuIHBhcmFtVHlwZXMudHlwZShjZmcudHlwZSk7XHJcbiAgICBpZiAodXJsVHlwZSlcclxuICAgICAgICByZXR1cm4gdXJsVHlwZTtcclxuICAgIGlmICghY2ZnLnR5cGUpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IGxvY2F0aW9uID09PSBEZWZUeXBlLkNPTkZJRyA/IFwiYW55XCIgOlxyXG4gICAgICAgICAgICBsb2NhdGlvbiA9PT0gRGVmVHlwZS5QQVRIID8gXCJwYXRoXCIgOlxyXG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIID8gXCJxdWVyeVwiIDogXCJzdHJpbmdcIjtcclxuICAgICAgICByZXR1cm4gcGFyYW1UeXBlcy50eXBlKHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNmZy50eXBlIGluc3RhbmNlb2YgcGFyYW1UeXBlXzEuUGFyYW1UeXBlID8gY2ZnLnR5cGUgOiBwYXJhbVR5cGVzLnR5cGUoY2ZnLnR5cGUpO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxhcGlcclxuICogcmV0dXJucyBmYWxzZSwgdHJ1ZSwgb3IgdGhlIHNxdWFzaCB2YWx1ZSB0byBpbmRpY2F0ZSB0aGUgXCJkZWZhdWx0IHBhcmFtZXRlciB1cmwgc3F1YXNoIHBvbGljeVwiLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U3F1YXNoUG9saWN5KGNvbmZpZywgaXNPcHRpb25hbCwgZGVmYXVsdFBvbGljeSkge1xyXG4gICAgdmFyIHNxdWFzaCA9IGNvbmZpZy5zcXVhc2g7XHJcbiAgICBpZiAoIWlzT3B0aW9uYWwgfHwgc3F1YXNoID09PSBmYWxzZSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoc3F1YXNoKSB8fCBzcXVhc2ggPT0gbnVsbClcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFBvbGljeTtcclxuICAgIGlmIChzcXVhc2ggPT09IHRydWUgfHwgcHJlZGljYXRlc18xLmlzU3RyaW5nKHNxdWFzaCkpXHJcbiAgICAgICAgcmV0dXJuIHNxdWFzaDtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3F1YXNoIHBvbGljeTogJ1wiICsgc3F1YXNoICsgXCInLiBWYWxpZCBwb2xpY2llczogZmFsc2UsIHRydWUsIG9yIGFyYml0cmFyeSBzdHJpbmdcIik7XHJcbn1cclxuLyoqIEBpbnRlcm5hbGFwaSAqL1xyXG5mdW5jdGlvbiBnZXRSZXBsYWNlKGNvbmZpZywgYXJyYXlNb2RlLCBpc09wdGlvbmFsLCBzcXVhc2gpIHtcclxuICAgIHZhciByZXBsYWNlLCBjb25maWd1cmVkS2V5cywgZGVmYXVsdFBvbGljeSA9IFtcclxuICAgICAgICB7IGZyb206IFwiXCIsIHRvOiAoaXNPcHRpb25hbCB8fCBhcnJheU1vZGUgPyB1bmRlZmluZWQgOiBcIlwiKSB9LFxyXG4gICAgICAgIHsgZnJvbTogbnVsbCwgdG86IChpc09wdGlvbmFsIHx8IGFycmF5TW9kZSA/IHVuZGVmaW5lZCA6IFwiXCIpIH0sXHJcbiAgICBdO1xyXG4gICAgcmVwbGFjZSA9IHByZWRpY2F0ZXNfMS5pc0FycmF5KGNvbmZpZy5yZXBsYWNlKSA/IGNvbmZpZy5yZXBsYWNlIDogW107XHJcbiAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKHNxdWFzaCkpXHJcbiAgICAgICAgcmVwbGFjZS5wdXNoKHsgZnJvbTogc3F1YXNoLCB0bzogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uZmlndXJlZEtleXMgPSBjb21tb25fMS5tYXAocmVwbGFjZSwgaG9mXzEucHJvcChcImZyb21cIikpO1xyXG4gICAgcmV0dXJuIGNvbW1vbl8xLmZpbHRlcihkZWZhdWx0UG9saWN5LCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gY29uZmlndXJlZEtleXMuaW5kZXhPZihpdGVtLmZyb20pID09PSAtMTsgfSkuY29uY2F0KHJlcGxhY2UpO1xyXG59XHJcbi8qKiBAaW50ZXJuYWxhcGkgKi9cclxudmFyIFBhcmFtID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhcmFtKGlkLCB0eXBlLCBjb25maWcsIGxvY2F0aW9uLCB1cmxNYXRjaGVyRmFjdG9yeSkge1xyXG4gICAgICAgIGNvbmZpZyA9IHVud3JhcFNob3J0aGFuZChjb25maWcpO1xyXG4gICAgICAgIHR5cGUgPSBnZXRUeXBlKGNvbmZpZywgdHlwZSwgbG9jYXRpb24sIGlkLCB1cmxNYXRjaGVyRmFjdG9yeS5wYXJhbVR5cGVzKTtcclxuICAgICAgICB2YXIgYXJyYXlNb2RlID0gZ2V0QXJyYXlNb2RlKCk7XHJcbiAgICAgICAgdHlwZSA9IGFycmF5TW9kZSA/IHR5cGUuJGFzQXJyYXkoYXJyYXlNb2RlLCBsb2NhdGlvbiA9PT0gRGVmVHlwZS5TRUFSQ0gpIDogdHlwZTtcclxuICAgICAgICB2YXIgaXNPcHRpb25hbCA9IGNvbmZpZy52YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSDtcclxuICAgICAgICB2YXIgZHluYW1pYyA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQoY29uZmlnLmR5bmFtaWMpID8gISFjb25maWcuZHluYW1pYyA6ICEhdHlwZS5keW5hbWljO1xyXG4gICAgICAgIHZhciByYXcgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGNvbmZpZy5yYXcpID8gISFjb25maWcucmF3IDogISF0eXBlLnJhdztcclxuICAgICAgICB2YXIgc3F1YXNoID0gZ2V0U3F1YXNoUG9saWN5KGNvbmZpZywgaXNPcHRpb25hbCwgdXJsTWF0Y2hlckZhY3RvcnkuZGVmYXVsdFNxdWFzaFBvbGljeSgpKTtcclxuICAgICAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2UoY29uZmlnLCBhcnJheU1vZGUsIGlzT3B0aW9uYWwsIHNxdWFzaCk7XHJcbiAgICAgICAgdmFyIGluaGVyaXQgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGNvbmZpZy5pbmhlcml0KSA/ICEhY29uZmlnLmluaGVyaXQgOiAhIXR5cGUuaW5oZXJpdDtcclxuICAgICAgICAvLyBhcnJheSBjb25maWc6IHBhcmFtIG5hbWUgKHBhcmFtW10pIG92ZXJyaWRlcyBkZWZhdWx0IHNldHRpbmdzLiAgZXhwbGljaXQgY29uZmlnIG92ZXJyaWRlcyBwYXJhbSBuYW1lLlxyXG4gICAgICAgIGZ1bmN0aW9uIGdldEFycmF5TW9kZSgpIHtcclxuICAgICAgICAgICAgdmFyIGFycmF5RGVmYXVsdHMgPSB7IGFycmF5OiAobG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIID8gXCJhdXRvXCIgOiBmYWxzZSkgfTtcclxuICAgICAgICAgICAgdmFyIGFycmF5UGFyYW1Ob21lbmNsYXR1cmUgPSBpZC5tYXRjaCgvXFxbXFxdJC8pID8geyBhcnJheTogdHJ1ZSB9IDoge307XHJcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQoYXJyYXlEZWZhdWx0cywgYXJyYXlQYXJhbU5vbWVuY2xhdHVyZSwgY29uZmlnKS5hcnJheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIHsgaWQ6IGlkLCB0eXBlOiB0eXBlLCBsb2NhdGlvbjogbG9jYXRpb24sIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwsIGR5bmFtaWM6IGR5bmFtaWMsIHJhdzogcmF3LCBzcXVhc2g6IHNxdWFzaCwgcmVwbGFjZTogcmVwbGFjZSwgaW5oZXJpdDogaW5oZXJpdCwgYXJyYXk6IGFycmF5TW9kZSwgY29uZmlnOiBjb25maWcgfSk7XHJcbiAgICB9XHJcbiAgICBQYXJhbS5wcm90b3R5cGUuaXNEZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc09wdGlvbmFsICYmIHRoaXMudHlwZS5lcXVhbHModGhpcy52YWx1ZSgpLCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBbSW50ZXJuYWxdIEdldHMgdGhlIGRlY29kZWQgcmVwcmVzZW50YXRpb24gb2YgYSB2YWx1ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZCwgb3RoZXJ3aXNlLCByZXR1cm5zIHRoZVxyXG4gICAgICogZGVmYXVsdCB2YWx1ZSwgd2hpY2ggbWF5IGJlIHRoZSByZXN1bHQgb2YgYW4gaW5qZWN0YWJsZSBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgUGFyYW0ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBbSW50ZXJuYWxdIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHBhcmFtZXRlciwgd2hpY2ggbWF5IGJlIGFuIGluamVjdGFibGUgZnVuY3Rpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGdldERlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLl9kZWZhdWx0VmFsdWVDYWNoZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZGVmYXVsdFZhbHVlQ2FjaGUuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoIWNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3RvcilcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluamVjdGFibGUgZnVuY3Rpb25zIGNhbm5vdCBiZSBjYWxsZWQgYXQgY29uZmlndXJhdGlvbiB0aW1lXCIpO1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLmludm9rZShfdGhpcy5jb25maWcuJCRmbik7XHJcbiAgICAgICAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIV90aGlzLnR5cGUuaXMoZGVmYXVsdFZhbHVlKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmF1bHQgdmFsdWUgKFwiICsgZGVmYXVsdFZhbHVlICsgXCIpIGZvciBwYXJhbWV0ZXIgJ1wiICsgX3RoaXMuaWQgKyBcIicgaXMgbm90IGFuIGluc3RhbmNlIG9mIFBhcmFtVHlwZSAoXCIgKyBfdGhpcy50eXBlLm5hbWUgKyBcIilcIik7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb25maWcuJCRmblsnX19jYWNoZWFibGUnXSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2RlZmF1bHRWYWx1ZUNhY2hlID0geyBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVwbGFjZVNwZWNpYWxWYWx1ZXMgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5yZXBsYWNlOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHR1cGxlID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR1cGxlLmZyb20gPT09IHZhbClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHVwbGUudG87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhbHVlID0gcmVwbGFjZVNwZWNpYWxWYWx1ZXModmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNVbmRlZmluZWQodmFsdWUpID8gZ2V0RGVmYXVsdFZhbHVlKCkgOiB0aGlzLnR5cGUuJG5vcm1hbGl6ZSh2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgUGFyYW0ucHJvdG90eXBlLmlzU2VhcmNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSDtcclxuICAgIH07XHJcbiAgICBQYXJhbS5wcm90b3R5cGUudmFsaWRhdGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gVGhlcmUgd2FzIG5vIHBhcmFtZXRlciB2YWx1ZSwgYnV0IHRoZSBwYXJhbSBpcyBvcHRpb25hbFxyXG4gICAgICAgIGlmICgocHJlZGljYXRlc18xLmlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkgJiYgdGhpcy5pc09wdGlvbmFsKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAvLyBUaGUgdmFsdWUgd2FzIG5vdCBvZiB0aGUgY29ycmVjdCBQYXJhbVR5cGUsIGFuZCBjb3VsZCBub3QgYmUgZGVjb2RlZCB0byB0aGUgY29ycmVjdCBQYXJhbVR5cGVcclxuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IHRoaXMudHlwZS4kbm9ybWFsaXplKHZhbHVlKTtcclxuICAgICAgICBpZiAoIXRoaXMudHlwZS5pcyhub3JtYWxpemVkKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIC8vIFRoZSB2YWx1ZSB3YXMgb2YgdGhlIGNvcnJlY3QgdHlwZSwgYnV0IHdoZW4gZW5jb2RlZCwgZGlkIG5vdCBtYXRjaCB0aGUgUGFyYW1UeXBlJ3MgcmVnZXhwXHJcbiAgICAgICAgdmFyIGVuY29kZWQgPSB0aGlzLnR5cGUuZW5jb2RlKG5vcm1hbGl6ZWQpO1xyXG4gICAgICAgIHJldHVybiAhKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhlbmNvZGVkKSAmJiAhdGhpcy50eXBlLnBhdHRlcm4uZXhlYyhlbmNvZGVkKSk7XHJcbiAgICB9O1xyXG4gICAgUGFyYW0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIntQYXJhbTpcIiArIHRoaXMuaWQgKyBcIiBcIiArIHRoaXMudHlwZSArIFwiIHNxdWFzaDogJ1wiICsgdGhpcy5zcXVhc2ggKyBcIicgb3B0aW9uYWw6IFwiICsgdGhpcy5pc09wdGlvbmFsICsgXCJ9XCI7XHJcbiAgICB9O1xyXG4gICAgUGFyYW0udmFsdWVzID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWVzKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIHBhcmFtVmFsdWVzID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYXJhbXNfMSA9IHBhcmFtczsgX2kgPCBwYXJhbXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zXzFbX2ldO1xyXG4gICAgICAgICAgICBwYXJhbVZhbHVlc1twYXJhbS5pZF0gPSBwYXJhbS52YWx1ZSh2YWx1ZXNbcGFyYW0uaWRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtVmFsdWVzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgW1tQYXJhbV1dIG9iamVjdHMgd2hpY2ggaGF2ZSBkaWZmZXJlbnQgcGFyYW0gdmFsdWVzXHJcbiAgICAgKlxyXG4gICAgICogRmlsdGVycyBhIGxpc3Qgb2YgW1tQYXJhbV1dIG9iamVjdHMgdG8gb25seSB0aG9zZSB3aG9zZSBwYXJhbWV0ZXIgdmFsdWVzIGRpZmZlciBpbiB0d28gcGFyYW0gdmFsdWUgb2JqZWN0c1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXJhbXM6IFRoZSBsaXN0IG9mIFBhcmFtIG9iamVjdHMgdG8gZmlsdGVyXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzMTogVGhlIGZpcnN0IHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzMjogdGhlIHNlY29uZCBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGFueSBQYXJhbSBvYmplY3RzIHdob3NlIHZhbHVlcyB3ZXJlIGRpZmZlcmVudCBiZXR3ZWVuIHZhbHVlczEgYW5kIHZhbHVlczJcclxuICAgICAqL1xyXG4gICAgUGFyYW0uY2hhbmdlZCA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlczEsIHZhbHVlczIpIHtcclxuICAgICAgICBpZiAodmFsdWVzMSA9PT0gdm9pZCAwKSB7IHZhbHVlczEgPSB7fTsgfVxyXG4gICAgICAgIGlmICh2YWx1ZXMyID09PSB2b2lkIDApIHsgdmFsdWVzMiA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhcGFyYW0udHlwZS5lcXVhbHModmFsdWVzMVtwYXJhbS5pZF0sIHZhbHVlczJbcGFyYW0uaWRdKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdHdvIHBhcmFtIHZhbHVlIG9iamVjdHMgYXJlIGVxdWFsIChmb3IgYSBzZXQgb2YgW1tQYXJhbV1dIG9iamVjdHMpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgbGlzdCBvZiBbW1BhcmFtXV0gb2JqZWN0cyB0byBjaGVja1xyXG4gICAgICogQHBhcmFtIHZhbHVlczEgVGhlIGZpcnN0IHNldCBvZiBwYXJhbSB2YWx1ZXNcclxuICAgICAqIEBwYXJhbSB2YWx1ZXMyIFRoZSBzZWNvbmQgc2V0IG9mIHBhcmFtIHZhbHVlc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHBhcmFtIHZhbHVlcyBpbiB2YWx1ZXMxIGFuZCB2YWx1ZXMyIGFyZSBlcXVhbFxyXG4gICAgICovXHJcbiAgICBQYXJhbS5lcXVhbHMgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZXMxLCB2YWx1ZXMyKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlczEgPT09IHZvaWQgMCkgeyB2YWx1ZXMxID0ge307IH1cclxuICAgICAgICBpZiAodmFsdWVzMiA9PT0gdm9pZCAwKSB7IHZhbHVlczIgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBQYXJhbS5jaGFuZ2VkKHBhcmFtcywgdmFsdWVzMSwgdmFsdWVzMikubGVuZ3RoID09PSAwO1xyXG4gICAgfTtcclxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgYSB0aGUgcGFyYW1ldGVyIHZhbHVlcyBhcmUgdmFsaWQsIGFjY29yZGluZyB0byB0aGUgUGFyYW0gZGVmaW5pdGlvbnMgKi9cclxuICAgIFBhcmFtLnZhbGlkYXRlcyA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlcykge1xyXG4gICAgICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0udmFsaWRhdGVzKHZhbHVlc1twYXJhbS5pZF0pOyB9KS5yZWR1Y2UoY29tbW9uXzEuYWxsVHJ1ZVIsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQYXJhbTtcclxufSgpKTtcclxuZXhwb3J0cy5QYXJhbSA9IFBhcmFtO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhbS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvcGFyYW0uanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFRyYW5zaXRpb25Ib29rUGhhc2U7XHJcbihmdW5jdGlvbiAoVHJhbnNpdGlvbkhvb2tQaGFzZSkge1xyXG4gICAgVHJhbnNpdGlvbkhvb2tQaGFzZVtUcmFuc2l0aW9uSG9va1BoYXNlW1wiQ1JFQVRFXCJdID0gMF0gPSBcIkNSRUFURVwiO1xyXG4gICAgVHJhbnNpdGlvbkhvb2tQaGFzZVtUcmFuc2l0aW9uSG9va1BoYXNlW1wiQkVGT1JFXCJdID0gMV0gPSBcIkJFRk9SRVwiO1xyXG4gICAgVHJhbnNpdGlvbkhvb2tQaGFzZVtUcmFuc2l0aW9uSG9va1BoYXNlW1wiUlVOXCJdID0gMl0gPSBcIlJVTlwiO1xyXG4gICAgVHJhbnNpdGlvbkhvb2tQaGFzZVtUcmFuc2l0aW9uSG9va1BoYXNlW1wiU1VDQ0VTU1wiXSA9IDNdID0gXCJTVUNDRVNTXCI7XHJcbiAgICBUcmFuc2l0aW9uSG9va1BoYXNlW1RyYW5zaXRpb25Ib29rUGhhc2VbXCJFUlJPUlwiXSA9IDRdID0gXCJFUlJPUlwiO1xyXG59KShUcmFuc2l0aW9uSG9va1BoYXNlID0gZXhwb3J0cy5UcmFuc2l0aW9uSG9va1BoYXNlIHx8IChleHBvcnRzLlRyYW5zaXRpb25Ib29rUGhhc2UgPSB7fSkpO1xyXG52YXIgVHJhbnNpdGlvbkhvb2tTY29wZTtcclxuKGZ1bmN0aW9uIChUcmFuc2l0aW9uSG9va1Njb3BlKSB7XHJcbiAgICBUcmFuc2l0aW9uSG9va1Njb3BlW1RyYW5zaXRpb25Ib29rU2NvcGVbXCJUUkFOU0lUSU9OXCJdID0gMF0gPSBcIlRSQU5TSVRJT05cIjtcclxuICAgIFRyYW5zaXRpb25Ib29rU2NvcGVbVHJhbnNpdGlvbkhvb2tTY29wZVtcIlNUQVRFXCJdID0gMV0gPSBcIlNUQVRFXCI7XHJcbn0pKFRyYW5zaXRpb25Ib29rU2NvcGUgPSBleHBvcnRzLlRyYW5zaXRpb25Ib29rU2NvcGUgfHwgKGV4cG9ydHMuVHJhbnNpdGlvbkhvb2tTY29wZSA9IHt9KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2ludGVyZmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbmdfZnJvbV9pbXBvcnQgPSByZXF1aXJlKFwiYW5ndWxhclwiKTtcclxudmFyIG5nX2Zyb21fZ2xvYmFsID0gYW5ndWxhcjtcclxuZXhwb3J0cy5uZyA9IChuZ19mcm9tX2ltcG9ydCAmJiBuZ19mcm9tX2ltcG9ydC5tb2R1bGUpID8gbmdfZnJvbV9pbXBvcnQgOiBuZ19mcm9tX2dsb2JhbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5ndWxhci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2FuZ3VsYXItdWktcm91dGVyL2xpYi9hbmd1bGFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQGNvcmVhcGlcclxuICogQG1vZHVsZSByZXNvbHZlXHJcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cclxudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XHJcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xyXG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJhY2VcIik7XHJcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3N0cmluZ3NcIik7XHJcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XHJcbi8vIFRPRE86IGV4cGxpY2l0bHkgbWFrZSB0aGlzIHVzZXIgY29uZmlndXJhYmxlXHJcbmV4cG9ydHMuZGVmYXVsdFJlc29sdmVQb2xpY3kgPSB7XHJcbiAgICB3aGVuOiBcIkxBWllcIixcclxuICAgIGFzeW5jOiBcIldBSVRcIlxyXG59O1xyXG4vKipcclxuICogVGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrIGZvciB0aGUgcmVzb2x2ZSBzeXN0ZW0uXHJcbiAqXHJcbiAqIFJlc29sdmFibGVzIGVuY2Fwc3VsYXRlIGEgc3RhdGUncyByZXNvbHZlJ3MgcmVzb2x2ZUZuLCB0aGUgcmVzb2x2ZUZuJ3MgZGVjbGFyZWQgZGVwZW5kZW5jaWVzLCB0aGUgd3JhcHBlZCAoLnByb21pc2UpLFxyXG4gKiBhbmQgdGhlIHVud3JhcHBlZC13aGVuLWNvbXBsZXRlICguZGF0YSkgcmVzdWx0IG9mIHRoZSByZXNvbHZlRm4uXHJcbiAqXHJcbiAqIFJlc29sdmFibGUuZ2V0KCkgZWl0aGVyIHJldHJpZXZlcyB0aGUgUmVzb2x2YWJsZSdzIGV4aXN0aW5nIHByb21pc2UsIG9yIGVsc2UgaW52b2tlcyByZXNvbHZlKCkgKHdoaWNoIGludm9rZXMgdGhlXHJcbiAqIHJlc29sdmVGbikgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBwcm9taXNlLlxyXG4gKlxyXG4gKiBSZXNvbHZhYmxlLmdldCgpIGFuZCBSZXNvbHZhYmxlLnJlc29sdmUoKSBib3RoIGV4ZWN1dGUgd2l0aGluIGEgY29udGV4dCBwYXRoLCB3aGljaCBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0XHJcbiAqIHBhcmFtZXRlciB0byB0aG9zZSBmbnMuXHJcbiAqL1xyXG52YXIgUmVzb2x2YWJsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZXNvbHZhYmxlKGFyZzEsIHJlc29sdmVGbiwgZGVwcywgcG9saWN5LCBkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIFJlc29sdmFibGUpIHtcclxuICAgICAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIGFyZzEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihyZXNvbHZlRm4pKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmcxID09IG51bGwgfHwgYXJnMSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZXcgUmVzb2x2YWJsZSgpOiB0b2tlbiBhcmd1bWVudCBpcyByZXF1aXJlZFwiKTtcclxuICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihyZXNvbHZlRm4pKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmV3IFJlc29sdmFibGUoKTogcmVzb2x2ZUZuIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuICAgICAgICAgICAgdGhpcy50b2tlbiA9IGFyZzE7XHJcbiAgICAgICAgICAgIHRoaXMucG9saWN5ID0gcG9saWN5O1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVGbiA9IHJlc29sdmVGbjtcclxuICAgICAgICAgICAgdGhpcy5kZXBzID0gZGVwcyB8fCBbXTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IGRhdGEgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5yZXNvbHZlZCA/IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4odGhpcy5kYXRhKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJlZGljYXRlc18xLmlzT2JqZWN0KGFyZzEpICYmIGFyZzEudG9rZW4gJiYgcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oYXJnMS5yZXNvbHZlRm4pKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXRlcmFsID0gYXJnMTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZhYmxlKGxpdGVyYWwudG9rZW4sIGxpdGVyYWwucmVzb2x2ZUZuLCBsaXRlcmFsLmRlcHMsIGxpdGVyYWwucG9saWN5LCBsaXRlcmFsLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFJlc29sdmFibGUucHJvdG90eXBlLmdldFBvbGljeSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgIHZhciB0aGlzUG9saWN5ID0gdGhpcy5wb2xpY3kgfHwge307XHJcbiAgICAgICAgdmFyIHN0YXRlUG9saWN5ID0gc3RhdGUgJiYgc3RhdGUucmVzb2x2ZVBvbGljeSB8fCB7fTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3aGVuOiB0aGlzUG9saWN5LndoZW4gfHwgc3RhdGVQb2xpY3kud2hlbiB8fCBleHBvcnRzLmRlZmF1bHRSZXNvbHZlUG9saWN5LndoZW4sXHJcbiAgICAgICAgICAgIGFzeW5jOiB0aGlzUG9saWN5LmFzeW5jIHx8IHN0YXRlUG9saWN5LmFzeW5jIHx8IGV4cG9ydHMuZGVmYXVsdFJlc29sdmVQb2xpY3kuYXN5bmMsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFzeW5jaHJvbm91c2x5IHJlc29sdmUgdGhpcyBSZXNvbHZhYmxlJ3MgZGF0YVxyXG4gICAgICpcclxuICAgICAqIEdpdmVuIGEgUmVzb2x2ZUNvbnRleHQgdGhhdCB0aGlzIFJlc29sdmFibGUgaXMgZm91bmQgaW46XHJcbiAgICAgKiBXYWl0IGZvciB0aGlzIFJlc29sdmFibGUncyBkZXBlbmRlbmNpZXMsIHRoZW4gaW52b2tlIHRoaXMgUmVzb2x2YWJsZSdzIGZ1bmN0aW9uXHJcbiAgICAgKiBhbmQgdXBkYXRlIHRoZSBSZXNvbHZhYmxlJ3Mgc3RhdGVcclxuICAgICAqL1xyXG4gICAgUmVzb2x2YWJsZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChyZXNvbHZlQ29udGV4dCwgdHJhbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciAkcSA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxO1xyXG4gICAgICAgIC8vIEdldHMgYWxsIGRlcGVuZGVuY2llcyBmcm9tIFJlc29sdmVDb250ZXh0IGFuZCB3YWl0IGZvciB0aGVtIHRvIGJlIHJlc29sdmVkXHJcbiAgICAgICAgdmFyIGdldFJlc29sdmFibGVEZXBlbmRlbmNpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkcS5hbGwocmVzb2x2ZUNvbnRleHQuZ2V0RGVwZW5kZW5jaWVzKF90aGlzKS5tYXAoZnVuY3Rpb24gKHJlc29sdmFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldChyZXNvbHZlQ29udGV4dCwgdHJhbnMpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBJbnZva2VzIHRoZSByZXNvbHZlIGZ1bmN0aW9uIHBhc3NpbmcgdGhlIHJlc29sdmVkIGRlcGVuZGVuY2llcyBhcyBhcmd1bWVudHNcclxuICAgICAgICB2YXIgaW52b2tlUmVzb2x2ZUZuID0gZnVuY3Rpb24gKHJlc29sdmVkRGVwcykge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucmVzb2x2ZUZuLmFwcGx5KG51bGwsIHJlc29sdmVkRGVwcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGb3IgUlhXQUlUIHBvbGljeTpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEdpdmVuIGFuIG9ic2VydmFibGUgcmV0dXJuZWQgZnJvbSBhIHJlc29sdmUgZnVuY3Rpb246XHJcbiAgICAgICAgICogLSBlbmFibGVzIC5jYWNoZSgpIG1vZGUgKHRoaXMgYWxsb3dzIG11bHRpY2FzdCBzdWJzY3JpYmVycylcclxuICAgICAgICAgKiAtIHRoZW4gY2FsbHMgdG9Qcm9taXNlKCkgKHRoaXMgdHJpZ2dlcnMgc3Vic2NyaWJlKCkgYW5kIHRodXMgZmV0Y2hlcylcclxuICAgICAgICAgKiAtIFdhaXRzIGZvciB0aGUgcHJvbWlzZSwgdGhlbiByZXR1cm4gdGhlIGNhY2hlZCBvYnNlcnZhYmxlIChub3QgdGhlIGZpcnN0IGVtaXR0ZWQgdmFsdWUpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciB3YWl0Rm9yUnggPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSQpIHtcclxuICAgICAgICAgICAgdmFyIGNhY2hlZCA9IG9ic2VydmFibGUkLmNhY2hlKDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkLnRha2UoMSkudG9Qcm9taXNlKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZWQ7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gSWYgdGhlIHJlc29sdmUgcG9saWN5IGlzIFJYV0FJVCwgd2FpdCBmb3IgdGhlIG9ic2VydmFibGUgdG8gZW1pdCBzb21ldGhpbmcuIG90aGVyd2lzZSBwYXNzIHRocm91Z2guXHJcbiAgICAgICAgdmFyIG5vZGUgPSByZXNvbHZlQ29udGV4dC5maW5kTm9kZSh0aGlzKTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBub2RlICYmIG5vZGUuc3RhdGU7XHJcbiAgICAgICAgdmFyIG1heWJlV2FpdEZvclJ4ID0gdGhpcy5nZXRQb2xpY3koc3RhdGUpLmFzeW5jID09PSBcIlJYV0FJVFwiID8gd2FpdEZvclJ4IDogY29tbW9uXzEuaWRlbnRpdHk7XHJcbiAgICAgICAgLy8gQWZ0ZXIgdGhlIGZpbmFsIHZhbHVlIGhhcyBiZWVuIHJlc29sdmVkLCB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSBSZXNvbHZhYmxlXHJcbiAgICAgICAgdmFyIGFwcGx5UmVzb2x2ZWRWYWx1ZSA9IGZ1bmN0aW9uIChyZXNvbHZlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRhdGEgPSByZXNvbHZlZFZhbHVlO1xyXG4gICAgICAgICAgICBfdGhpcy5yZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VSZXNvbHZhYmxlUmVzb2x2ZWQoX3RoaXMsIHRyYW5zKTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTZXRzIHRoZSBwcm9taXNlIHByb3BlcnR5IGZpcnN0LCB0aGVuIGdldHNSZXNvbHZhYmxlRGVwZW5kZW5jaWVzIGluIHRoZSBjb250ZXh0IG9mIHRoZSBwcm9taXNlIGNoYWluLiBBbHdheXMgd2FpdHMgb25lIHRpY2suXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZSA9ICRxLndoZW4oKVxyXG4gICAgICAgICAgICAudGhlbihnZXRSZXNvbHZhYmxlRGVwZW5kZW5jaWVzKVxyXG4gICAgICAgICAgICAudGhlbihpbnZva2VSZXNvbHZlRm4pXHJcbiAgICAgICAgICAgIC50aGVuKG1heWJlV2FpdEZvclJ4KVxyXG4gICAgICAgICAgICAudGhlbihhcHBseVJlc29sdmVkVmFsdWUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHByb21pc2UgZm9yIHRoaXMgUmVzb2x2YWJsZSdzIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogRmV0Y2hlcyB0aGUgZGF0YSBhbmQgcmV0dXJucyBhIHByb21pc2UuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBleGlzdGluZyBwcm9taXNlIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gZmV0Y2hlZCBvbmNlLlxyXG4gICAgICovXHJcbiAgICBSZXNvbHZhYmxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocmVzb2x2ZUNvbnRleHQsIHRyYW5zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZSB8fCB0aGlzLnJlc29sdmUocmVzb2x2ZUNvbnRleHQsIHRyYW5zKTtcclxuICAgIH07XHJcbiAgICBSZXNvbHZhYmxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJSZXNvbHZhYmxlKHRva2VuOiBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodGhpcy50b2tlbikgKyBcIiwgcmVxdWlyZXM6IFtcIiArIHRoaXMuZGVwcy5tYXAoc3RyaW5nc18xLnN0cmluZ2lmeSkgKyBcIl0pXCI7XHJcbiAgICB9O1xyXG4gICAgUmVzb2x2YWJsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZhYmxlKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNvbHZhYmxlO1xyXG59KCkpO1xyXG5SZXNvbHZhYmxlLmZyb21EYXRhID0gZnVuY3Rpb24gKHRva2VuLCBkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IFJlc29sdmFibGUodG9rZW4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGE7IH0sIG51bGwsIG51bGwsIGRhdGEpO1xyXG59O1xyXG5leHBvcnRzLlJlc29sdmFibGUgPSBSZXNvbHZhYmxlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZhYmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvcmVzb2x2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBjb3JlYXBpXHJcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxyXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXHJcblwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xyXG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xyXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcclxudmFyIFJlamVjdFR5cGU7XHJcbihmdW5jdGlvbiAoUmVqZWN0VHlwZSkge1xyXG4gICAgUmVqZWN0VHlwZVtSZWplY3RUeXBlW1wiU1VQRVJTRURFRFwiXSA9IDJdID0gXCJTVVBFUlNFREVEXCI7XHJcbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJBQk9SVEVEXCJdID0gM10gPSBcIkFCT1JURURcIjtcclxuICAgIFJlamVjdFR5cGVbUmVqZWN0VHlwZVtcIklOVkFMSURcIl0gPSA0XSA9IFwiSU5WQUxJRFwiO1xyXG4gICAgUmVqZWN0VHlwZVtSZWplY3RUeXBlW1wiSUdOT1JFRFwiXSA9IDVdID0gXCJJR05PUkVEXCI7XHJcbiAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJFUlJPUlwiXSA9IDZdID0gXCJFUlJPUlwiO1xyXG59KShSZWplY3RUeXBlID0gZXhwb3J0cy5SZWplY3RUeXBlIHx8IChleHBvcnRzLlJlamVjdFR5cGUgPSB7fSkpO1xyXG4vKiogQGhpZGRlbiAqLyB2YXIgaWQgPSAwO1xyXG52YXIgUmVqZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlamVjdGlvbih0eXBlLCBtZXNzYWdlLCBkZXRhaWwpIHtcclxuICAgICAgICB0aGlzLiRpZCA9IGlkKys7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRoaXMuZGV0YWlsID0gZGV0YWlsO1xyXG4gICAgfVxyXG4gICAgUmVqZWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGV0YWlsU3RyaW5nID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQgJiYgZC50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA/IGQudG9TdHJpbmcoKSA6IHN0cmluZ3NfMS5zdHJpbmdpZnkoZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZGV0YWlsID0gZGV0YWlsU3RyaW5nKHRoaXMuZGV0YWlsKTtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLCAkaWQgPSBfYS4kaWQsIHR5cGUgPSBfYS50eXBlLCBtZXNzYWdlID0gX2EubWVzc2FnZTtcclxuICAgICAgICByZXR1cm4gXCJUcmFuc2l0aW9uIFJlamVjdGlvbigkaWQ6IFwiICsgJGlkICsgXCIgdHlwZTogXCIgKyB0eXBlICsgXCIsIG1lc3NhZ2U6IFwiICsgbWVzc2FnZSArIFwiLCBkZXRhaWw6IFwiICsgZGV0YWlsICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgUmVqZWN0aW9uLnByb3RvdHlwZS50b1Byb21pc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChjb21tb25fMS5zaWxlbnRSZWplY3Rpb24odGhpcyksIHsgX3RyYW5zaXRpb25SZWplY3Rpb246IHRoaXMgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqIGlzIGEgcmVqZWN0ZWQgcHJvbWlzZSBjcmVhdGVkIGZyb20gdGhlIGBhc1Byb21pc2VgIGZhY3RvcnkgKi9cclxuICAgIFJlamVjdGlvbi5pc1JlamVjdGlvblByb21pc2UgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiAmJiAodHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nKSAmJiBob2ZfMS5pcyhSZWplY3Rpb24pKG9iai5fdHJhbnNpdGlvblJlamVjdGlvbik7XHJcbiAgICB9O1xyXG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIHRyYW5zaXRpb24gc3VwZXJzZWRlZCAqL1xyXG4gICAgUmVqZWN0aW9uLnN1cGVyc2VkZWQgPSBmdW5jdGlvbiAoZGV0YWlsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlRoZSB0cmFuc2l0aW9uIGhhcyBiZWVuIHN1cGVyc2VkZWQgYnkgYSBkaWZmZXJlbnQgdHJhbnNpdGlvblwiO1xyXG4gICAgICAgIHZhciByZWplY3Rpb24gPSBuZXcgUmVqZWN0aW9uKFJlamVjdFR5cGUuU1VQRVJTRURFRCwgbWVzc2FnZSwgZGV0YWlsKTtcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlZGlyZWN0ZWQpIHtcclxuICAgICAgICAgICAgcmVqZWN0aW9uLnJlZGlyZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVqZWN0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byByZWRpcmVjdGVkIHRyYW5zaXRpb24gKi9cclxuICAgIFJlamVjdGlvbi5yZWRpcmVjdGVkID0gZnVuY3Rpb24gKGRldGFpbCkge1xyXG4gICAgICAgIHJldHVybiBSZWplY3Rpb24uc3VwZXJzZWRlZChkZXRhaWwsIHsgcmVkaXJlY3RlZDogdHJ1ZSB9KTtcclxuICAgIH07XHJcbiAgICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gaW52YWxpZCB0cmFuc2l0aW9uICovXHJcbiAgICBSZWplY3Rpb24uaW52YWxpZCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcclxuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiVGhpcyB0cmFuc2l0aW9uIGlzIGludmFsaWRcIjtcclxuICAgICAgICByZXR1cm4gbmV3IFJlamVjdGlvbihSZWplY3RUeXBlLklOVkFMSUQsIG1lc3NhZ2UsIGRldGFpbCk7XHJcbiAgICB9O1xyXG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIGlnbm9yZWQgdHJhbnNpdGlvbiAqL1xyXG4gICAgUmVqZWN0aW9uLmlnbm9yZWQgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlRoZSB0cmFuc2l0aW9uIHdhcyBpZ25vcmVkXCI7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5JR05PUkVELCBtZXNzYWdlLCBkZXRhaWwpO1xyXG4gICAgfTtcclxuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byBhYm9ydGVkIHRyYW5zaXRpb24gKi9cclxuICAgIFJlamVjdGlvbi5hYm9ydGVkID0gZnVuY3Rpb24gKGRldGFpbCkge1xyXG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJUaGUgdHJhbnNpdGlvbiBoYXMgYmVlbiBhYm9ydGVkXCI7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5BQk9SVEVELCBtZXNzYWdlLCBkZXRhaWwpO1xyXG4gICAgfTtcclxuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byBhYm9ydGVkIHRyYW5zaXRpb24gKi9cclxuICAgIFJlamVjdGlvbi5lcnJvcmVkID0gZnVuY3Rpb24gKGRldGFpbCkge1xyXG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJUaGUgdHJhbnNpdGlvbiBlcnJvcmVkXCI7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5FUlJPUiwgbWVzc2FnZSwgZGV0YWlsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBSZWplY3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBOb3JtYWxpemVzIGEgdmFsdWUgYXMgYSBSZWplY3Rpb24uXHJcbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSBhIFJlamVjdGlvbiwgcmV0dXJucyBpdC5cclxuICAgICAqIE90aGVyd2lzZSwgd3JhcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIGFzIGEgUmVqZWN0aW9uIChSZWplY3Rpb24gdHlwZTogRVJST1IpLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGBkZXRhaWxgIGlmIGl0IGlzIGFscmVhZHkgYSBgUmVqZWN0aW9uYCwgZWxzZSByZXR1cm5zIGFuIEVSUk9SIFJlamVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgUmVqZWN0aW9uLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcclxuICAgICAgICByZXR1cm4gaG9mXzEuaXMoUmVqZWN0aW9uKShkZXRhaWwpID8gZGV0YWlsIDogUmVqZWN0aW9uLmVycm9yZWQoZGV0YWlsKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVqZWN0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLlJlamVjdGlvbiA9IFJlamVjdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVqZWN0RmFjdG9yeS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBAY29yZWFwaVxyXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cclxuICovXHJcbi8qKiBmb3IgdHlwZWRvYyAqL1xyXG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7XHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xyXG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xyXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xyXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcclxudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xyXG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcclxudmFyIHJlamVjdEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL3JlamVjdEZhY3RvcnlcIik7XHJcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3RhcmdldFN0YXRlXCIpO1xyXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICBjdXJyZW50OiBjb21tb25fMS5ub29wLFxyXG4gICAgdHJhbnNpdGlvbjogbnVsbCxcclxuICAgIHRyYWNlRGF0YToge30sXHJcbiAgICBiaW5kOiBudWxsLFxyXG59O1xyXG4vKiogQGhpZGRlbiAqL1xyXG52YXIgVHJhbnNpdGlvbkhvb2sgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbkhvb2sodHJhbnNpdGlvbiwgc3RhdGVDb250ZXh0LCByZWdpc3RlcmVkSG9vaywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcclxuICAgICAgICB0aGlzLnN0YXRlQ29udGV4dCA9IHN0YXRlQ29udGV4dDtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRIb29rID0gcmVnaXN0ZXJlZEhvb2s7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLmlzU3VwZXJzZWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnR5cGUuaG9va1BoYXNlID09PSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlLlJVTiAmJiAhX3RoaXMub3B0aW9ucy50cmFuc2l0aW9uLmlzQWN0aXZlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCBkZWZhdWx0T3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gcmVnaXN0ZXJlZEhvb2suZXZlbnRUeXBlO1xyXG4gICAgfVxyXG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLmxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbi5yb3V0ZXIuc3RhdGVTZXJ2aWNlLmRlZmF1bHRFcnJvckhhbmRsZXIoKShlcnIpO1xyXG4gICAgfTtcclxuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS5pbnZva2VIb29rID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGhvb2sgPSB0aGlzLnJlZ2lzdGVyZWRIb29rO1xyXG4gICAgICAgIGlmIChob29rLl9kZXJlZ2lzdGVyZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgbm90Q3VycmVudCA9IHRoaXMuZ2V0Tm90Q3VycmVudFJlamVjdGlvbigpO1xyXG4gICAgICAgIGlmIChub3RDdXJyZW50KVxyXG4gICAgICAgICAgICByZXR1cm4gbm90Q3VycmVudDtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlSG9va0ludm9jYXRpb24odGhpcywgdGhpcy50cmFuc2l0aW9uLCBvcHRpb25zKTtcclxuICAgICAgICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob29rLmNhbGxiYWNrLmNhbGwob3B0aW9ucy5iaW5kLCBfdGhpcy50cmFuc2l0aW9uLCBfdGhpcy5zdGF0ZUNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG5vcm1hbGl6ZUVyciA9IGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24ubm9ybWFsaXplKGVycikudG9Qcm9taXNlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob29rLmV2ZW50VHlwZS5nZXRFcnJvckhhbmRsZXIoX3RoaXMpKGVycik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaGFuZGxlUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaG9vay5ldmVudFR5cGUuZ2V0UmVzdWx0SGFuZGxlcihfdGhpcykocmVzdWx0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbnZva2VDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5zeW5jaHJvbm91cyAmJiBwcmVkaWNhdGVzXzEuaXNQcm9taXNlKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuY2F0Y2gobm9ybWFsaXplRXJyKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGhhbmRsZVJlc3VsdCwgaGFuZGxlRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgLy8gSWYgY2FsbGJhY2sgdGhyb3dzIChzeW5jaHJvbm91c2x5KVxyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IocmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5ub3JtYWxpemUoZXJyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaGFuZGxlcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgVHJhbnNpdGlvbiBIb29rLlxyXG4gICAgICpcclxuICAgICAqIEEgaG9vayBjYW4gcmV0dXJuIGZhbHNlIChjYW5jZWwpLCBhIFRhcmdldFN0YXRlIChyZWRpcmVjdCksXHJcbiAgICAgKiBvciBhIHByb21pc2UgKHdoaWNoIG1heSBsYXRlciByZXNvbHZlIHRvIGZhbHNlIG9yIGEgcmVkaXJlY3QpXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBhbHNvIGhhbmRsZXMgXCJ0cmFuc2l0aW9uIHN1cGVyc2VkZWRcIiAtLSB3aGVuIGEgbmV3IHRyYW5zaXRpb25cclxuICAgICAqIHdhcyBzdGFydGVkIHdoaWxlIHRoZSBob29rIHdhcyBzdGlsbCBydW5uaW5nXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS5oYW5kbGVIb29rUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG5vdEN1cnJlbnQgPSB0aGlzLmdldE5vdEN1cnJlbnRSZWplY3Rpb24oKTtcclxuICAgICAgICBpZiAobm90Q3VycmVudClcclxuICAgICAgICAgICAgcmV0dXJuIG5vdEN1cnJlbnQ7XHJcbiAgICAgICAgLy8gSG9vayByZXR1cm5lZCBhIHByb21pc2VcclxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzUHJvbWlzZShyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBwcm9taXNlLCB0aGVuIHJlcHJvY2VzcyB3aXRoIHRoZSByZXN1bHRpbmcgdmFsdWVcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIF90aGlzLmhhbmRsZUhvb2tSZXN1bHQodmFsKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VIb29rUmVzdWx0KHJlc3VsdCwgdGhpcy50cmFuc2l0aW9uLCB0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIC8vIEhvb2sgcmV0dXJuZWQgZmFsc2VcclxuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAvLyBBYm9ydCB0aGlzIFRyYW5zaXRpb25cclxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uYWJvcnRlZChcIkhvb2sgYWJvcnRlZCB0cmFuc2l0aW9uXCIpLnRvUHJvbWlzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXNUYXJnZXRTdGF0ZSA9IGhvZl8xLmlzKHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUpO1xyXG4gICAgICAgIC8vIGhvb2sgcmV0dXJuZWQgYSBUYXJnZXRTdGF0ZVxyXG4gICAgICAgIGlmIChpc1RhcmdldFN0YXRlKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgLy8gSGFsdCB0aGUgY3VycmVudCBUcmFuc2l0aW9uIGFuZCByZWRpcmVjdCAoYSBuZXcgVHJhbnNpdGlvbikgdG8gdGhlIFRhcmdldFN0YXRlLlxyXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5yZWRpcmVjdGVkKHJlc3VsdCkudG9Qcm9taXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgUmVqZWN0aW9uIHByb21pc2UgaWYgdGhlIHRyYW5zaXRpb24gaXMgbm8gbG9uZ2VyIGN1cnJlbnQgZHVlXHJcbiAgICAgKiB0byBhIHN0b3BwZWQgcm91dGVyIChkaXNwb3NlZCksIG9yIGEgbmV3IHRyYW5zaXRpb24gaGFzIHN0YXJ0ZWQgYW5kIHN1cGVyc2VkZWQgdGhpcyBvbmUuXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS5nZXROb3RDdXJyZW50UmVqZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnRyYW5zaXRpb24ucm91dGVyO1xyXG4gICAgICAgIC8vIFRoZSByb3V0ZXIgaXMgc3RvcHBlZFxyXG4gICAgICAgIGlmIChyb3V0ZXIuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmFib3J0ZWQoXCJVSVJvdXRlciBpbnN0YW5jZSAjXCIgKyByb3V0ZXIuJGlkICsgXCIgaGFzIGJlZW4gc3RvcHBlZCAoZGlzcG9zZWQpXCIpLnRvUHJvbWlzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uLl9hYm9ydGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmFib3J0ZWQoKS50b1Byb21pc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhpcyB0cmFuc2l0aW9uIGlzIG5vIGxvbmdlciBjdXJyZW50LlxyXG4gICAgICAgIC8vIEFub3RoZXIgdHJhbnNpdGlvbiBzdGFydGVkIHdoaWxlIHRoaXMgaG9vayB3YXMgc3RpbGwgcnVubmluZy5cclxuICAgICAgICBpZiAodGhpcy5pc1N1cGVyc2VkZWQoKSkge1xyXG4gICAgICAgICAgICAvLyBBYm9ydCB0aGlzIHRyYW5zaXRpb25cclxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uc3VwZXJzZWRlZCh0aGlzLm9wdGlvbnMuY3VycmVudCgpKS50b1Byb21pc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCByZWdpc3RlcmVkSG9vayA9IF9hLnJlZ2lzdGVyZWRIb29rO1xyXG4gICAgICAgIHZhciBldmVudCA9IGhvZl8xLnBhcnNlKFwidHJhY2VEYXRhLmhvb2tUeXBlXCIpKG9wdGlvbnMpIHx8IFwiaW50ZXJuYWxcIiwgY29udGV4dCA9IGhvZl8xLnBhcnNlKFwidHJhY2VEYXRhLmNvbnRleHQuc3RhdGUubmFtZVwiKShvcHRpb25zKSB8fCBob2ZfMS5wYXJzZShcInRyYWNlRGF0YS5jb250ZXh0XCIpKG9wdGlvbnMpIHx8IFwidW5rbm93blwiLCBuYW1lID0gc3RyaW5nc18xLmZuVG9TdHJpbmcocmVnaXN0ZXJlZEhvb2suY2FsbGJhY2spO1xyXG4gICAgICAgIHJldHVybiBldmVudCArIFwiIGNvbnRleHQ6IFwiICsgY29udGV4dCArIFwiLCBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBuYW1lKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoYWlucyB0b2dldGhlciBhbiBhcnJheSBvZiBUcmFuc2l0aW9uSG9va3MuXHJcbiAgICAgKlxyXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIFtbVHJhbnNpdGlvbkhvb2tdXSBvYmplY3RzLCBjaGFpbnMgdGhlbSB0b2dldGhlci5cclxuICAgICAqIEVhY2ggaG9vayBpcyBpbnZva2VkIGFmdGVyIHRoZSBwcmV2aW91cyBvbmUgY29tcGxldGVzLlxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiB2YXIgaG9va3M6IFRyYW5zaXRpb25Ib29rW10gPSBnZXRIb29rcygpO1xyXG4gICAgICogbGV0IHByb21pc2U6IFByb21pc2U8YW55PiA9IFRyYW5zaXRpb25Ib29rLmNoYWluKGhvb2tzKTtcclxuICAgICAqXHJcbiAgICAgKiBwcm9taXNlLnRoZW4oaGFuZGxlU3VjY2VzcywgaGFuZGxlRXJyb3IpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGhvb2tzIHRoZSBsaXN0IG9mIGhvb2tzIHRvIGNoYWluIHRvZ2V0aGVyXHJcbiAgICAgKiBAcGFyYW0gd2FpdEZvciBpZiBwcm92aWRlZCwgdGhlIGNoYWluIGlzIGAudGhlbigpYCdlZCBvZmYgdGhpcyBwcm9taXNlXHJcbiAgICAgKiBAcmV0dXJucyBhIGBQcm9taXNlYCBmb3Igc2VxdWVudGlhbGx5IGludm9raW5nIHRoZSBob29rcyAoaW4gb3JkZXIpXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25Ib29rLmNoYWluID0gZnVuY3Rpb24gKGhvb2tzLCB3YWl0Rm9yKSB7XHJcbiAgICAgICAgLy8gQ2hhaW4gdGhlIG5leHQgaG9vayBvZmYgdGhlIHByZXZpb3VzXHJcbiAgICAgICAgdmFyIGNyZWF0ZUhvb2tDaGFpblIgPSBmdW5jdGlvbiAocHJldiwgbmV4dEhvb2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXYudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBuZXh0SG9vay5pbnZva2VIb29rKCk7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGhvb2tzLnJlZHVjZShjcmVhdGVIb29rQ2hhaW5SLCB3YWl0Rm9yIHx8IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4oKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIGFsbCB0aGUgcHJvdmlkZWQgVHJhbnNpdGlvbkhvb2tzLCBpbiBvcmRlci5cclxuICAgICAqIEVhY2ggaG9vaydzIHJldHVybiB2YWx1ZSBpcyBjaGVja2VkLlxyXG4gICAgICogSWYgYW55IGhvb2sgcmV0dXJucyBhIHByb21pc2UsIHRoZW4gdGhlIHJlc3Qgb2YgdGhlIGhvb2tzIGFyZSBjaGFpbmVkIG9mZiB0aGF0IHByb21pc2UsIGFuZCB0aGUgcHJvbWlzZSBpcyByZXR1cm5lZC5cclxuICAgICAqIElmIG5vIGhvb2sgcmV0dXJucyBhIHByb21pc2UsIHRoZW4gYWxsIGhvb2tzIGFyZSBwcm9jZXNzZWQgc3luY2hyb25vdXNseS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaG9va3MgdGhlIGxpc3Qgb2YgVHJhbnNpdGlvbkhvb2tzIHRvIGludm9rZVxyXG4gICAgICogQHBhcmFtIGRvbmVDYWxsYmFjayBhIGNhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCBhZnRlciBhbGwgdGhlIGhvb2tzIGhhdmUgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGFzeW5jIHJlc3VsdCwgb3IgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkhvb2suaW52b2tlSG9va3MgPSBmdW5jdGlvbiAoaG9va3MsIGRvbmVDYWxsYmFjaykge1xyXG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGhvb2tzLmxlbmd0aDsgaWR4KyspIHtcclxuICAgICAgICAgICAgdmFyIGhvb2tSZXN1bHQgPSBob29rc1tpZHhdLmludm9rZUhvb2soKTtcclxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1Byb21pc2UoaG9va1Jlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmdIb29rcyA9IGhvb2tzLnNsaWNlKGlkeCArIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zaXRpb25Ib29rLmNoYWluKHJlbWFpbmluZ0hvb2tzLCBob29rUmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGRvbmVDYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjaygpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUnVuIGFsbCBUcmFuc2l0aW9uSG9va3MsIGlnbm9yaW5nIHRoZWlyIHJldHVybiB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbkhvb2sucnVuQWxsSG9va3MgPSBmdW5jdGlvbiAoaG9va3MpIHtcclxuICAgICAgICBob29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBob29rLmludm9rZUhvb2soKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRyYW5zaXRpb25Ib29rO1xyXG59KCkpO1xyXG4vKipcclxuICogVGhlc2UgR2V0UmVzdWx0SGFuZGxlcihzKSBhcmUgdXNlZCBieSBbW2ludm9rZUhvb2tdXSBiZWxvd1xyXG4gKiBFYWNoIEhvb2tUeXBlIGNob29zZXMgYSBHZXRSZXN1bHRIYW5kbGVyIChTZWU6IFtbVHJhbnNpdGlvblNlcnZpY2UuX2RlZmluZUNvcmVFdmVudHNdXSlcclxuICovXHJcblRyYW5zaXRpb25Ib29rLkhBTkRMRV9SRVNVTFQgPSBmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgcmV0dXJuIGhvb2suaGFuZGxlSG9va1Jlc3VsdChyZXN1bHQpO1xyXG59OyB9O1xyXG4vKipcclxuICogSWYgdGhlIHJlc3VsdCBpcyBhIHByb21pc2UgcmVqZWN0aW9uLCBsb2cgaXQuXHJcbiAqIE90aGVyd2lzZSwgaWdub3JlIHRoZSByZXN1bHQuXHJcbiAqL1xyXG5UcmFuc2l0aW9uSG9vay5MT0dfUkVKRUNURURfUkVTVUxUID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgIHByZWRpY2F0ZXNfMS5pc1Byb21pc2UocmVzdWx0KSAmJiByZXN1bHQuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIHJldHVybiBob29rLmxvZ0Vycm9yKHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24ubm9ybWFsaXplKGVycikpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59OyB9O1xyXG4vKipcclxuICogVGhlc2UgR2V0RXJyb3JIYW5kbGVyKHMpIGFyZSB1c2VkIGJ5IFtbaW52b2tlSG9va11dIGJlbG93XHJcbiAqIEVhY2ggSG9va1R5cGUgY2hvb3NlcyBhIEdldEVycm9ySGFuZGxlciAoU2VlOiBbW1RyYW5zaXRpb25TZXJ2aWNlLl9kZWZpbmVDb3JlRXZlbnRzXV0pXHJcbiAqL1xyXG5UcmFuc2l0aW9uSG9vay5MT0dfRVJST1IgPSBmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICByZXR1cm4gaG9vay5sb2dFcnJvcihlcnJvcik7XHJcbn07IH07XHJcblRyYW5zaXRpb25Ib29rLlJFSkVDVF9FUlJPUiA9IGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgIHJldHVybiBjb21tb25fMS5zaWxlbnRSZWplY3Rpb24oZXJyb3IpO1xyXG59OyB9O1xyXG5UcmFuc2l0aW9uSG9vay5USFJPV19FUlJPUiA9IGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgIHRocm93IGVycm9yO1xyXG59OyB9O1xyXG5leHBvcnRzLlRyYW5zaXRpb25Ib29rID0gVHJhbnNpdGlvbkhvb2s7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zaXRpb25Ib29rLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbkhvb2suanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxhcGlcclxuICogQG1vZHVsZSB2YW5pbGxhXHJcbiAqL1xyXG4vKiogKi9cclxudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2luZGV4XCIpO1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIGJlZm9yZUFmdGVyU3Vic3RyID0gZnVuY3Rpb24gKGNoYXIpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGlmICghc3RyKVxyXG4gICAgICAgIHJldHVybiBbXCJcIiwgXCJcIl07XHJcbiAgICB2YXIgaWR4ID0gc3RyLmluZGV4T2YoY2hhcik7XHJcbiAgICBpZiAoaWR4ID09PSAtMSlcclxuICAgICAgICByZXR1cm4gW3N0ciwgXCJcIl07XHJcbiAgICByZXR1cm4gW3N0ci5zdWJzdHIoMCwgaWR4KSwgc3RyLnN1YnN0cihpZHggKyAxKV07XHJcbn07IH07XHJcbmV4cG9ydHMuc3BsaXRIYXNoID0gYmVmb3JlQWZ0ZXJTdWJzdHIoXCIjXCIpO1xyXG5leHBvcnRzLnNwbGl0UXVlcnkgPSBiZWZvcmVBZnRlclN1YnN0cihcIj9cIik7XHJcbmV4cG9ydHMuc3BsaXRFcXVhbCA9IGJlZm9yZUFmdGVyU3Vic3RyKFwiPVwiKTtcclxuZXhwb3J0cy50cmltSGFzaFZhbCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ciA/IHN0ci5yZXBsYWNlKC9eIy8sIFwiXCIpIDogXCJcIjsgfTtcclxuZXhwb3J0cy5rZXlWYWxzVG9PYmplY3RSID0gZnVuY3Rpb24gKGFjY3VtLCBfYSkge1xyXG4gICAgdmFyIGtleSA9IF9hWzBdLCB2YWwgPSBfYVsxXTtcclxuICAgIGlmICghYWNjdW0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgIGFjY3VtW2tleV0gPSB2YWw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpbmRleF8xLmlzQXJyYXkoYWNjdW1ba2V5XSkpIHtcclxuICAgICAgICBhY2N1bVtrZXldLnB1c2godmFsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY3VtW2tleV0gPSBbYWNjdW1ba2V5XSwgdmFsXTtcclxuICAgIH1cclxuICAgIHJldHVybiBhY2N1bTtcclxufTtcclxuZXhwb3J0cy5nZXRQYXJhbXMgPSBmdW5jdGlvbiAocXVlcnlTdHJpbmcpIHtcclxuICAgIHJldHVybiBxdWVyeVN0cmluZy5zcGxpdChcIiZcIikuZmlsdGVyKGNvbW1vbl8xLmlkZW50aXR5KS5tYXAoZXhwb3J0cy5zcGxpdEVxdWFsKS5yZWR1Y2UoZXhwb3J0cy5rZXlWYWxzVG9PYmplY3RSLCB7fSk7XHJcbn07XHJcbmZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xyXG4gICAgdmFyIG9yRW1wdHlTdHJpbmcgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCB8fCBcIlwiOyB9O1xyXG4gICAgdmFyIF9hID0gZXhwb3J0cy5zcGxpdEhhc2godXJsKS5tYXAob3JFbXB0eVN0cmluZyksIGJlZm9yZWhhc2ggPSBfYVswXSwgaGFzaCA9IF9hWzFdO1xyXG4gICAgdmFyIF9iID0gZXhwb3J0cy5zcGxpdFF1ZXJ5KGJlZm9yZWhhc2gpLm1hcChvckVtcHR5U3RyaW5nKSwgcGF0aCA9IF9iWzBdLCBzZWFyY2ggPSBfYlsxXTtcclxuICAgIHJldHVybiB7IHBhdGg6IHBhdGgsIHNlYXJjaDogc2VhcmNoLCBoYXNoOiBoYXNoLCB1cmw6IHVybCB9O1xyXG59XHJcbmV4cG9ydHMucGFyc2VVcmwgPSBwYXJzZVVybDtcclxuZXhwb3J0cy5idWlsZFVybCA9IGZ1bmN0aW9uIChsb2MpIHtcclxuICAgIHZhciBwYXRoID0gbG9jLnBhdGgoKTtcclxuICAgIHZhciBzZWFyY2hPYmplY3QgPSBsb2Muc2VhcmNoKCk7XHJcbiAgICB2YXIgaGFzaCA9IGxvYy5oYXNoKCk7XHJcbiAgICB2YXIgc2VhcmNoID0gT2JqZWN0LmtleXMoc2VhcmNoT2JqZWN0KS5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBwYXJhbSA9IHNlYXJjaE9iamVjdFtrZXldO1xyXG4gICAgICAgIHZhciB2YWxzID0gaW5kZXhfMS5pc0FycmF5KHBhcmFtKSA/IHBhcmFtIDogW3BhcmFtXTtcclxuICAgICAgICByZXR1cm4gdmFscy5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4ga2V5ICsgXCI9XCIgKyB2YWw7IH0pO1xyXG4gICAgfSkucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKS5qb2luKFwiJlwiKTtcclxuICAgIHJldHVybiBwYXRoICsgKHNlYXJjaCA/IFwiP1wiICsgc2VhcmNoIDogXCJcIikgKyAoaGFzaCA/IFwiI1wiICsgaGFzaCA6IFwiXCIpO1xyXG59O1xyXG5mdW5jdGlvbiBsb2NhdGlvblBsdWdpbkZhY3RvcnkobmFtZSwgaXNIdG1sNSwgc2VydmljZUNsYXNzLCBjb25maWd1cmF0aW9uQ2xhc3MpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocm91dGVyKSB7XHJcbiAgICAgICAgdmFyIHNlcnZpY2UgPSByb3V0ZXIubG9jYXRpb25TZXJ2aWNlID0gbmV3IHNlcnZpY2VDbGFzcyhyb3V0ZXIpO1xyXG4gICAgICAgIHZhciBjb25maWd1cmF0aW9uID0gcm91dGVyLmxvY2F0aW9uQ29uZmlnID0gbmV3IGNvbmZpZ3VyYXRpb25DbGFzcyhyb3V0ZXIsIGlzSHRtbDUpO1xyXG4gICAgICAgIGZ1bmN0aW9uIGRpc3Bvc2Uocm91dGVyKSB7XHJcbiAgICAgICAgICAgIHJvdXRlci5kaXNwb3NlKHNlcnZpY2UpO1xyXG4gICAgICAgICAgICByb3V0ZXIuZGlzcG9zZShjb25maWd1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgc2VydmljZTogc2VydmljZSwgY29uZmlndXJhdGlvbjogY29uZmlndXJhdGlvbiwgZGlzcG9zZTogZGlzcG9zZSB9O1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmxvY2F0aW9uUGx1Z2luRmFjdG9yeSA9IGxvY2F0aW9uUGx1Z2luRmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEBjb3JlYXBpXHJcbiAqIEBtb2R1bGUgY29yZVxyXG4gKi9cclxuLyoqXHJcbiAqIE1hdGNoZXMgc3RhdGUgbmFtZXMgdXNpbmcgZ2xvYi1saWtlIHBhdHRlcm4gc3RyaW5ncy5cclxuICpcclxuICogR2xvYnMgY2FuIGJlIHVzZWQgaW4gc3BlY2lmaWMgQVBJcyBpbmNsdWRpbmc6XHJcbiAqXHJcbiAqIC0gW1tTdGF0ZVNlcnZpY2UuaXNdXVxyXG4gKiAtIFtbU3RhdGVTZXJ2aWNlLmluY2x1ZGVzXV1cclxuICogLSBUaGUgZmlyc3QgYXJndW1lbnQgdG8gSG9vayBSZWdpc3RyYXRpb24gZnVuY3Rpb25zIGxpa2UgW1tUcmFuc2l0aW9uU2VydmljZS5vblN0YXJ0XV1cclxuICogICAgLSBbW0hvb2tNYXRjaENyaXRlcmlhXV0gYW5kIFtbSG9va01hdGNoQ3JpdGVyaW9uXV1cclxuICpcclxuICogQSBgR2xvYmAgc3RyaW5nIGlzIGEgcGF0dGVybiB3aGljaCBtYXRjaGVzIHN0YXRlIG5hbWVzLlxyXG4gKiBOZXN0ZWQgc3RhdGUgbmFtZXMgYXJlIHNwbGl0IGludG8gc2VnbWVudHMgKHNlcGFyYXRlZCBieSBhIGRvdCkgd2hlbiBwcm9jZXNzaW5nLlxyXG4gKiBUaGUgc3RhdGUgbmFtZWQgYGZvby5iYXIuYmF6YCBpcyBzcGxpdCBpbnRvIHRocmVlIHNlZ21lbnRzIFsnZm9vJywgJ2JhcicsICdiYXonXVxyXG4gKlxyXG4gKiBHbG9icyB3b3JrIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nIHJ1bGVzOlxyXG4gKlxyXG4gKiAjIyMgRXhhY3QgbWF0Y2g6XHJcbiAqXHJcbiAqIFRoZSBnbG9iIGAnQS5CJ2AgbWF0Y2hlcyB0aGUgc3RhdGUgbmFtZWQgZXhhY3RseSBgJ0EuQidgLlxyXG4gKlxyXG4gKiB8IEdsb2IgICAgICAgIHxNYXRjaGVzIHN0YXRlcyBuYW1lZHxEb2VzIG5vdCBtYXRjaCBzdGF0ZSBuYW1lZHxcclxuICogfDotLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS18XHJcbiAqIHwgYCdBJ2AgICAgICAgfCBgJ0EnYCAgICAgICAgICAgICAgIHwgYCdCJ2AgLCBgJ0EuQydgICAgICAgfFxyXG4gKiB8IGAnQS5CJ2AgICAgIHwgYCdBLkInYCAgICAgICAgICAgICB8IGAnQSdgICwgYCdBLkIuQydgICAgIHxcclxuICogfCBgJ2ZvbydgICAgICB8IGAnZm9vJ2AgICAgICAgICAgICAgfCBgJ0ZPTydgICwgYCdmb28uYmFyJ2B8XHJcbiAqXHJcbiAqICMjIyBTaW5nbGUgc3RhciAoYCpgKVxyXG4gKlxyXG4gKiBBIHNpbmdsZSBzdGFyIChgKmApIGlzIGEgd2lsZGNhcmQgdGhhdCBtYXRjaGVzIGV4YWN0bHkgb25lIHNlZ21lbnQuXHJcbiAqXHJcbiAqIHwgR2xvYiAgICAgICAgfE1hdGNoZXMgc3RhdGVzIG5hbWVkICB8RG9lcyBub3QgbWF0Y2ggc3RhdGUgbmFtZWQgfFxyXG4gKiB8Oi0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcclxuICogfCBgJyonYCAgICAgICB8IGAnQSdgICwgYCdaJ2AgICAgICAgIHwgYCdBLkInYCAsIGAnWi5ZLlgnYCAgICAgICB8XHJcbiAqIHwgYCdBLionYCAgICAgfCBgJ0EuQidgICwgYCdBLkMnYCAgICB8IGAnQSdgICwgYCdBLkIuQydgICAgICAgICAgfFxyXG4gKiB8IGAnQS4qLionYCAgIHwgYCdBLkIuQydgICwgYCdBLlguWSdgfCBgJ0EnYCwgYCdBLkInYCAsIGAnWi5ZLlgnYHxcclxuICpcclxuICogIyMjIERvdWJsZSBzdGFyIChgKipgKVxyXG4gKlxyXG4gKiBBIGRvdWJsZSBzdGFyIChgJyoqJ2ApIGlzIGEgd2lsZGNhcmQgdGhhdCBtYXRjaGVzICp6ZXJvIG9yIG1vcmUgc2VnbWVudHMqXHJcbiAqXHJcbiAqIHwgR2xvYiAgICAgICAgfE1hdGNoZXMgc3RhdGVzIG5hbWVkICAgICAgICAgICAgICAgICAgICAgICAgICAgfERvZXMgbm90IG1hdGNoIHN0YXRlIG5hbWVkICAgICAgICAgfFxyXG4gKiB8Oi0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcclxuICogfCBgJyoqJ2AgICAgICB8IGAnQSdgICwgYCdBLkInYCwgYCdaLlkuWCdgICAgICAgICAgICAgICAgICAgICB8IChtYXRjaGVzIGFsbCBzdGF0ZXMpICAgICAgICAgICAgICB8XHJcbiAqIHwgYCdBLioqJ2AgICAgfCBgJ0EnYCAsIGAnQS5CJ2AgLCBgJ0EuQy5YJ2AgICAgICAgICAgICAgICAgICAgfCBgJ1ouWS5YJ2AgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiB8IGAnKiouWCdgICAgIHwgYCdYJ2AgLCBgJ0EuWCdgICwgYCdaLlkuWCdgICAgICAgICAgICAgICAgICAgIHwgYCdBJ2AgLCBgJ0EubG9naW4uWidgICAgICAgICAgICAgIHxcclxuICogfCBgJ0EuKiouWCdgICB8IGAnQS5YJ2AgLCBgJ0EuQi5YJ2AgLCBgJ0EuQi5DLlgnYCAgICAgICAgICAgICB8IGAnQSdgICwgYCdBLkIuQydgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG52YXIgR2xvYiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBHbG9iKHRleHQpIHtcclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgICAgIHRoaXMuZ2xvYiA9IHRleHQuc3BsaXQoJy4nKTtcclxuICAgICAgICB2YXIgcmVnZXhwU3RyaW5nID0gdGhpcy50ZXh0LnNwbGl0KCcuJylcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWcgPT09ICcqKicpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyg/OnwoPzpcXFxcLlteLl0qKSopJztcclxuICAgICAgICAgICAgaWYgKHNlZyA9PT0gJyonKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcLlteLl0qJztcclxuICAgICAgICAgICAgcmV0dXJuICdcXFxcLicgKyBzZWc7XHJcbiAgICAgICAgfSkuam9pbignJyk7XHJcbiAgICAgICAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKFwiXlwiICsgcmVnZXhwU3RyaW5nICsgXCIkXCIpO1xyXG4gICAgfVxyXG4gICAgR2xvYi5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwLnRlc3QoJy4nICsgbmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGhhcyBnbG9iLWxpa2UgY2hhcmFjdGVycyBpbiBpdCAqL1xyXG4gICAgR2xvYi5pcyA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuICEhL1shLCpdKy8uZXhlYyh0ZXh0KTtcclxuICAgIH07XHJcbiAgICAvKiogUmV0dXJucyBhIGdsb2IgZnJvbSB0aGUgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBzdHJpbmcgaXNuJ3QgR2xvYi1saWtlICovXHJcbiAgICBHbG9iLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgIHJldHVybiBHbG9iLmlzKHRleHQpID8gbmV3IEdsb2IodGV4dCkgOiBudWxsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBHbG9iO1xyXG59KCkpO1xyXG5leHBvcnRzLkdsb2IgPSBHbG9iO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9nbG9iLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqIEBtb2R1bGUgY29tbW9uICovIC8qKiBmb3IgdHlwZWRvYyAqL1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21tb25cIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb3Jlc2VydmljZXNcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9nbG9iXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vaG9mXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vcHJlZGljYXRlc1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3F1ZXVlXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3RyaW5nc1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYWNlXCIpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuLyoqIEBtb2R1bGUgcGF0aCAqLyAvKiogZm9yIHR5cGVkb2MgKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XHJcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3RhcmdldFN0YXRlXCIpO1xyXG52YXIgcGF0aE5vZGVfMSA9IHJlcXVpcmUoXCIuL3BhdGhOb2RlXCIpO1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBjb250YWlucyBmdW5jdGlvbnMgd2hpY2ggY29udmVydCBUYXJnZXRTdGF0ZXMsIE5vZGVzIGFuZCBwYXRocyBmcm9tIG9uZSB0eXBlIHRvIGFub3RoZXIuXHJcbiAqL1xyXG52YXIgUGF0aFV0aWxzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhdGhVdGlscygpIHtcclxuICAgIH1cclxuICAgIC8qKiBHaXZlbiBhIFBhdGhOb2RlW10sIGNyZWF0ZSBhbiBUYXJnZXRTdGF0ZSAqL1xyXG4gICAgUGF0aFV0aWxzLm1ha2VUYXJnZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gY29tbW9uXzEudGFpbChwYXRoKS5zdGF0ZTtcclxuICAgICAgICByZXR1cm4gbmV3IHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUoc3RhdGUsIHN0YXRlLCBwYXRoLm1hcChob2ZfMS5wcm9wKFwicGFyYW1WYWx1ZXNcIikpLnJlZHVjZShjb21tb25fMS5tZXJnZVIsIHt9KSk7XHJcbiAgICB9O1xyXG4gICAgUGF0aFV0aWxzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xyXG4gICAgICAgIHZhciB0b1BhcmFtcyA9IHRhcmdldFN0YXRlLnBhcmFtcygpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRTdGF0ZS4kc3RhdGUoKS5wYXRoLm1hcChmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIG5ldyBwYXRoTm9kZV8xLlBhdGhOb2RlKHN0YXRlKS5hcHBseVJhd1BhcmFtcyh0b1BhcmFtcyk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKiBHaXZlbiBhIGZyb21QYXRoOiBQYXRoTm9kZVtdIGFuZCBhIFRhcmdldFN0YXRlLCBidWlsZHMgYSB0b1BhdGg6IFBhdGhOb2RlW10gKi9cclxuICAgIFBhdGhVdGlscy5idWlsZFRvUGF0aCA9IGZ1bmN0aW9uIChmcm9tUGF0aCwgdGFyZ2V0U3RhdGUpIHtcclxuICAgICAgICB2YXIgdG9QYXRoID0gUGF0aFV0aWxzLmJ1aWxkUGF0aCh0YXJnZXRTdGF0ZSk7XHJcbiAgICAgICAgaWYgKHRhcmdldFN0YXRlLm9wdGlvbnMoKS5pbmhlcml0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQYXRoVXRpbHMuaW5oZXJpdFBhcmFtcyhmcm9tUGF0aCwgdG9QYXRoLCBPYmplY3Qua2V5cyh0YXJnZXRTdGF0ZS5wYXJhbXMoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9QYXRoO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBWaWV3Q29uZmlnIG9iamVjdHMgYW5kIGFkZHMgdG8gbm9kZXMuXHJcbiAgICAgKlxyXG4gICAgICogT24gZWFjaCBbW1BhdGhOb2RlXV0sIGNyZWF0ZXMgVmlld0NvbmZpZyBvYmplY3RzIGZyb20gdGhlIHZpZXdzOiBwcm9wZXJ0eSBvZiB0aGUgbm9kZSdzIHN0YXRlXHJcbiAgICAgKi9cclxuICAgIFBhdGhVdGlscy5hcHBseVZpZXdDb25maWdzID0gZnVuY3Rpb24gKCR2aWV3LCBwYXRoLCBzdGF0ZXMpIHtcclxuICAgICAgICAvLyBPbmx5IGFwcGx5IHRoZSB2aWV3Q29uZmlncyB0byB0aGUgbm9kZXMgZm9yIHRoZSBnaXZlbiBzdGF0ZXNcclxuICAgICAgICBwYXRoLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gY29tbW9uXzEuaW5BcnJheShzdGF0ZXMsIG5vZGUuc3RhdGUpOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3RGVjbHMgPSBjb21tb25fMS52YWx1ZXMobm9kZS5zdGF0ZS52aWV3cyB8fCB7fSk7XHJcbiAgICAgICAgICAgIHZhciBzdWJQYXRoID0gUGF0aFV0aWxzLnN1YlBhdGgocGF0aCwgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4gPT09IG5vZGU7IH0pO1xyXG4gICAgICAgICAgICB2YXIgdmlld0NvbmZpZ3MgPSB2aWV3RGVjbHMubWFwKGZ1bmN0aW9uICh2aWV3KSB7IHJldHVybiAkdmlldy5jcmVhdGVWaWV3Q29uZmlnKHN1YlBhdGgsIHZpZXcpOyB9KTtcclxuICAgICAgICAgICAgbm9kZS52aWV3cyA9IHZpZXdDb25maWdzLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIGZyb21QYXRoIGFuZCBhIHRvUGF0aCwgcmV0dXJucyBhIG5ldyB0byBwYXRoIHdoaWNoIGluaGVyaXRzIHBhcmFtZXRlcnMgZnJvbSB0aGUgZnJvbVBhdGhcclxuICAgICAqXHJcbiAgICAgKiBGb3IgYSBwYXJhbWV0ZXIgaW4gYSBub2RlIHRvIGJlIGluaGVyaXRlZCBmcm9tIHRoZSBmcm9tIHBhdGg6XHJcbiAgICAgKiAtIFRoZSB0b1BhdGgncyBub2RlIG11c3QgaGF2ZSBhIG1hdGNoaW5nIG5vZGUgaW4gdGhlIGZyb21QYXRoIChieSBzdGF0ZSkuXHJcbiAgICAgKiAtIFRoZSBwYXJhbWV0ZXIgbmFtZSBtdXN0IG5vdCBiZSBmb3VuZCBpbiB0aGUgdG9LZXlzIHBhcmFtZXRlciBhcnJheS5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiB0aGUga2V5cyBwcm92aWRlZCBpbiB0b0tleXMgYXJlIGludGVuZGVkIHRvIGJlIHRob3NlIHBhcmFtIGtleXMgZXhwbGljaXRseSBzcGVjaWZpZWQgYnkgc29tZVxyXG4gICAgICogY2FsbGVyLCBmb3IgaW5zdGFuY2UsICRzdGF0ZS50cmFuc2l0aW9uVG8oLi4uLCB0b1BhcmFtcykuICBJZiBhIGtleSB3YXMgZm91bmQgaW4gdG9QYXJhbXMsXHJcbiAgICAgKiBpdCBpcyBub3QgaW5oZXJpdGVkIGZyb20gdGhlIGZyb21QYXRoLlxyXG4gICAgICovXHJcbiAgICBQYXRoVXRpbHMuaW5oZXJpdFBhcmFtcyA9IGZ1bmN0aW9uIChmcm9tUGF0aCwgdG9QYXRoLCB0b0tleXMpIHtcclxuICAgICAgICBpZiAodG9LZXlzID09PSB2b2lkIDApIHsgdG9LZXlzID0gW107IH1cclxuICAgICAgICBmdW5jdGlvbiBub2RlUGFyYW1WYWxzKHBhdGgsIHN0YXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gY29tbW9uXzEuZmluZChwYXRoLCBob2ZfMS5wcm9wRXEoJ3N0YXRlJywgc3RhdGUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh7fSwgbm9kZSAmJiBub2RlLnBhcmFtVmFsdWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5vSW5oZXJpdCA9IGZyb21QYXRoLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5wYXJhbVNjaGVtYTsgfSlcclxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFwYXJhbS5pbmhlcml0OyB9KVxyXG4gICAgICAgICAgICAubWFwKGhvZl8xLnByb3AoJ2lkJykpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdpdmVuIGFuIFtbUGF0aE5vZGVdXSBcInRvTm9kZVwiLCByZXR1cm4gYSBuZXcgW1tQYXRoTm9kZV1dIHdpdGggcGFyYW0gdmFsdWVzIGluaGVyaXRlZCBmcm9tIHRoZVxyXG4gICAgICAgICAqIG1hdGNoaW5nIG5vZGUgaW4gZnJvbVBhdGguICBPbmx5IGluaGVyaXQga2V5cyB0aGF0IGFyZW4ndCBmb3VuZCBpbiBcInRvS2V5c1wiIGZyb20gdGhlIG5vZGUgaW4gXCJmcm9tUGF0aFwiXCJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBtYWtlSW5oZXJpdGVkUGFyYW1zTm9kZSh0b05vZGUpIHtcclxuICAgICAgICAgICAgLy8gQWxsIHBhcmFtIHZhbHVlcyBmb3IgdGhlIG5vZGUgKG1heSBpbmNsdWRlIGRlZmF1bHQga2V5L3ZhbHMsIHdoZW4ga2V5IHdhcyBub3QgZm91bmQgaW4gdG9QYXJhbXMpXHJcbiAgICAgICAgICAgIHZhciB0b1BhcmFtVmFscyA9IGNvbW1vbl8xLmV4dGVuZCh7fSwgdG9Ob2RlICYmIHRvTm9kZS5wYXJhbVZhbHVlcyk7XHJcbiAgICAgICAgICAgIC8vIGxpbWl0ZWQgdG8gb25seSB0aG9zZSBrZXlzIGZvdW5kIGluIHRvUGFyYW1zXHJcbiAgICAgICAgICAgIHZhciBpbmNvbWluZ1BhcmFtVmFscyA9IGNvbW1vbl8xLnBpY2sodG9QYXJhbVZhbHMsIHRvS2V5cyk7XHJcbiAgICAgICAgICAgIHRvUGFyYW1WYWxzID0gY29tbW9uXzEub21pdCh0b1BhcmFtVmFscywgdG9LZXlzKTtcclxuICAgICAgICAgICAgdmFyIGZyb21QYXJhbVZhbHMgPSBjb21tb25fMS5vbWl0KG5vZGVQYXJhbVZhbHMoZnJvbVBhdGgsIHRvTm9kZS5zdGF0ZSkgfHwge30sIG5vSW5oZXJpdCk7XHJcbiAgICAgICAgICAgIC8vIGV4dGVuZCB0b1BhcmFtVmFscyB3aXRoIGFueSBmcm9tUGFyYW1WYWxzLCB0aGVuIG92ZXJyaWRlIGFueSBvZiB0aG9zZSB0aG9zZSB3aXRoIGluY29taW5nUGFyYW1WYWxzXHJcbiAgICAgICAgICAgIHZhciBvd25QYXJhbVZhbHMgPSBjb21tb25fMS5leHRlbmQodG9QYXJhbVZhbHMsIGZyb21QYXJhbVZhbHMsIGluY29taW5nUGFyYW1WYWxzKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXRoTm9kZV8xLlBhdGhOb2RlKHRvTm9kZS5zdGF0ZSkuYXBwbHlSYXdQYXJhbXMob3duUGFyYW1WYWxzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIHBhcmFtIGtleXMgc3BlY2lmaWVkIGJ5IHRoZSBpbmNvbWluZyB0b1BhcmFtc1xyXG4gICAgICAgIHJldHVybiB0b1BhdGgubWFwKG1ha2VJbmhlcml0ZWRQYXJhbXNOb2RlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSB0cmVlIGNoYW5nZXMgKGVudGVyaW5nLCBleGl0aW5nKSBiZXR3ZWVuIGEgZnJvbVBhdGggYW5kIHRvUGF0aC5cclxuICAgICAqL1xyXG4gICAgUGF0aFV0aWxzLnRyZWVDaGFuZ2VzID0gZnVuY3Rpb24gKGZyb21QYXRoLCB0b1BhdGgsIHJlbG9hZFN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGtlZXAgPSAwLCBtYXggPSBNYXRoLm1pbihmcm9tUGF0aC5sZW5ndGgsIHRvUGF0aC5sZW5ndGgpO1xyXG4gICAgICAgIHZhciBub2Rlc01hdGNoID0gZnVuY3Rpb24gKG5vZGUxLCBub2RlMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTEuZXF1YWxzKG5vZGUyLCBQYXRoVXRpbHMubm9uRHluYW1pY1BhcmFtcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB3aGlsZSAoa2VlcCA8IG1heCAmJiBmcm9tUGF0aFtrZWVwXS5zdGF0ZSAhPT0gcmVsb2FkU3RhdGUgJiYgbm9kZXNNYXRjaChmcm9tUGF0aFtrZWVwXSwgdG9QYXRoW2tlZXBdKSkge1xyXG4gICAgICAgICAgICBrZWVwKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKiBHaXZlbiBhIHJldGFpbmVkIG5vZGUsIHJldHVybiBhIG5ldyBub2RlIHdoaWNoIHVzZXMgdGhlIHRvIG5vZGUncyBwYXJhbSB2YWx1ZXMgKi9cclxuICAgICAgICBmdW5jdGlvbiBhcHBseVRvUGFyYW1zKHJldGFpbmVkTm9kZSwgaWR4KSB7XHJcbiAgICAgICAgICAgIHZhciBjbG9uZWQgPSBwYXRoTm9kZV8xLlBhdGhOb2RlLmNsb25lKHJldGFpbmVkTm9kZSk7XHJcbiAgICAgICAgICAgIGNsb25lZC5wYXJhbVZhbHVlcyA9IHRvUGF0aFtpZHhdLnBhcmFtVmFsdWVzO1xyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZnJvbSwgcmV0YWluZWQsIGV4aXRpbmcsIGVudGVyaW5nLCB0bztcclxuICAgICAgICBmcm9tID0gZnJvbVBhdGg7XHJcbiAgICAgICAgcmV0YWluZWQgPSBmcm9tLnNsaWNlKDAsIGtlZXApO1xyXG4gICAgICAgIGV4aXRpbmcgPSBmcm9tLnNsaWNlKGtlZXApO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyByZXRhaW5lZCBwYXRoICh3aXRoIHNoYWxsb3cgY29waWVzIG9mIG5vZGVzKSB3aGljaCBoYXZlIHRoZSBwYXJhbXMgb2YgdGhlIHRvUGF0aCBtYXBwZWRcclxuICAgICAgICB2YXIgcmV0YWluZWRXaXRoVG9QYXJhbXMgPSByZXRhaW5lZC5tYXAoYXBwbHlUb1BhcmFtcyk7XHJcbiAgICAgICAgZW50ZXJpbmcgPSB0b1BhdGguc2xpY2Uoa2VlcCk7XHJcbiAgICAgICAgdG8gPSAocmV0YWluZWRXaXRoVG9QYXJhbXMpLmNvbmNhdChlbnRlcmluZyk7XHJcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbSwgdG86IHRvLCByZXRhaW5lZDogcmV0YWluZWQsIGV4aXRpbmc6IGV4aXRpbmcsIGVudGVyaW5nOiBlbnRlcmluZyB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBwYXRoIHdoaWNoIGlzOiB0aGUgc3VicGF0aCBvZiB0aGUgZmlyc3QgcGF0aCB3aGljaCBtYXRjaGVzIHRoZSBzZWNvbmQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbmV3IHBhdGggc3RhcnRzIGZyb20gcm9vdCBhbmQgY29udGFpbnMgYW55IG5vZGVzIHRoYXQgbWF0Y2ggdGhlIG5vZGVzIGluIHRoZSBzZWNvbmQgcGF0aC5cclxuICAgICAqIEl0IHN0b3BzIGJlZm9yZSB0aGUgZmlyc3Qgbm9uLW1hdGNoaW5nIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogTm9kZXMgYXJlIGNvbXBhcmVkIHVzaW5nIHRoZWlyIHN0YXRlIHByb3BlcnR5IGFuZCB0aGVpciBwYXJhbWV0ZXIgdmFsdWVzLlxyXG4gICAgICogSWYgYSBgcGFyYW1zRm5gIGlzIHByb3ZpZGVkLCBvbmx5IHRoZSBbW1BhcmFtXV0gcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY29uc2lkZXJlZCB3aGVuIGNvbXBhcmluZyBub2Rlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aEEgdGhlIGZpcnN0IHBhdGhcclxuICAgICAqIEBwYXJhbSBwYXRoQiB0aGUgc2Vjb25kIHBhdGhcclxuICAgICAqIEBwYXJhbSBwYXJhbXNGbiBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHBhcmFtZXRlcnMgdG8gY29uc2lkZXIgd2hlbiBjb21wYXJpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBQYXRoTm9kZXMgZnJvbSB0aGUgZmlyc3QgcGF0aCB3aGljaCBtYXRjaCB0aGUgbm9kZXMgaW4gdGhlIHNlY29uZCBwYXRoXHJcbiAgICAgKi9cclxuICAgIFBhdGhVdGlscy5tYXRjaGluZyA9IGZ1bmN0aW9uIChwYXRoQSwgcGF0aEIsIHBhcmFtc0ZuKSB7XHJcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgdHVwbGVzID0gY29tbW9uXzEuYXJyYXlUdXBsZXMocGF0aEEsIHBhdGhCKTtcclxuICAgICAgICByZXR1cm4gdHVwbGVzLnJlZHVjZShmdW5jdGlvbiAobWF0Y2hpbmcsIF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlQSA9IF9hWzBdLCBub2RlQiA9IF9hWzFdO1xyXG4gICAgICAgICAgICBkb25lID0gZG9uZSB8fCAhbm9kZUEuZXF1YWxzKG5vZGVCLCBwYXJhbXNGbik7XHJcbiAgICAgICAgICAgIHJldHVybiBkb25lID8gbWF0Y2hpbmcgOiBtYXRjaGluZy5jb25jYXQobm9kZUEpO1xyXG4gICAgICAgIH0sIFtdKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0d28gcGF0aHMgYXJlIGlkZW50aWNhbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aEFcclxuICAgICAqIEBwYXJhbSBwYXRoQlxyXG4gICAgICogQHBhcmFtIHBhcmFtc0ZuIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgcGFyYW1ldGVycyB0byBjb25zaWRlciB3aGVuIGNvbXBhcmluZ1xyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdGhlIHN0YXRlcyBhbmQgcGFyYW1ldGVyIHZhbHVlcyBmb3IgYm90aCBwYXRocyBhcmUgaWRlbnRpY2FsXHJcbiAgICAgKi9cclxuICAgIFBhdGhVdGlscy5lcXVhbHMgPSBmdW5jdGlvbiAocGF0aEEsIHBhdGhCLCBwYXJhbXNGbikge1xyXG4gICAgICAgIHJldHVybiBwYXRoQS5sZW5ndGggPT09IHBhdGhCLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICBQYXRoVXRpbHMubWF0Y2hpbmcocGF0aEEsIHBhdGhCLCBwYXJhbXNGbikubGVuZ3RoID09PSBwYXRoQS5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBzdWJwYXRoIG9mIGEgcGF0aCwgd2hpY2ggc3RvcHMgYXQgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGVcclxuICAgICAqXHJcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBub2RlcywgcmV0dXJucyBhIHN1YnNldCBvZiB0aGUgYXJyYXkgc3RhcnRpbmcgZnJvbSB0aGUgZmlyc3Qgbm9kZSxcclxuICAgICAqIHN0b3BwaW5nIHdoZW4gdGhlIGZpcnN0IG5vZGUgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIGEgcGF0aCBvZiBbW1BhdGhOb2RlXV1zXHJcbiAgICAgKiBAcGFyYW0gcHJlZGljYXRlIGEgW1tQcmVkaWNhdGVdXSBmbiB0aGF0IG1hdGNoZXMgW1tQYXRoTm9kZV1dc1xyXG4gICAgICogQHJldHVybnMgYSBzdWJwYXRoIHVwIHRvIHRoZSBtYXRjaGluZyBub2RlLCBvciB1bmRlZmluZWQgaWYgbm8gbWF0Y2ggaXMgZm91bmRcclxuICAgICAqL1xyXG4gICAgUGF0aFV0aWxzLnN1YlBhdGggPSBmdW5jdGlvbiAocGF0aCwgcHJlZGljYXRlKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBjb21tb25fMS5maW5kKHBhdGgsIHByZWRpY2F0ZSk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRJZHggPSBwYXRoLmluZGV4T2Yobm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRJZHggPT09IC0xID8gdW5kZWZpbmVkIDogcGF0aC5zbGljZSgwLCBlbGVtZW50SWR4ICsgMSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBhdGhVdGlscztcclxufSgpKTtcclxuUGF0aFV0aWxzLm5vbkR5bmFtaWNQYXJhbXMgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUuc3RhdGUucGFyYW1ldGVycyh7IGluaGVyaXQ6IGZhbHNlIH0pXHJcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFwYXJhbS5keW5hbWljOyB9KTtcclxufTtcclxuLyoqIEdldHMgdGhlIHJhdyBwYXJhbWV0ZXIgdmFsdWVzIGZyb20gYSBwYXRoICovXHJcblBhdGhVdGlscy5wYXJhbVZhbHVlcyA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZSkgeyByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKGFjYywgbm9kZS5wYXJhbVZhbHVlcyk7IH0sIHt9KTtcclxufTtcclxuZXhwb3J0cy5QYXRoVXRpbHMgPSBQYXRoVXRpbHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGhGYWN0b3J5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3BhdGgvcGF0aEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKiBAbW9kdWxlIHJlc29sdmUgKi9cclxuLyoqIGZvciB0eXBlZG9jICovXHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xyXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcclxudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xyXG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcclxudmFyIGludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpO1xyXG52YXIgcmVzb2x2YWJsZV8xID0gcmVxdWlyZShcIi4vcmVzb2x2YWJsZVwiKTtcclxudmFyIHBhdGhGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vcGF0aC9wYXRoRmFjdG9yeVwiKTtcclxudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcclxudmFyIHdoZW4gPSBpbnRlcmZhY2VfMS5yZXNvbHZlUG9saWNpZXMud2hlbjtcclxudmFyIEFMTF9XSEVOUyA9IFt3aGVuLkVBR0VSLCB3aGVuLkxBWlldO1xyXG52YXIgRUFHRVJfV0hFTlMgPSBbd2hlbi5FQUdFUl07XHJcbmV4cG9ydHMuTkFUSVZFX0lOSkVDVE9SX1RPS0VOID0gXCJOYXRpdmUgSW5qZWN0b3JcIjtcclxuLyoqXHJcbiAqIEVuY2Fwc3VsYXRlcyBEZXBlbmRlbmN5IEluamVjdGlvbiBmb3IgYSBwYXRoIG9mIG5vZGVzXHJcbiAqXHJcbiAqIFVJLVJvdXRlciBzdGF0ZXMgYXJlIG9yZ2FuaXplZCBhcyBhIHRyZWUuXHJcbiAqIEEgbmVzdGVkIHN0YXRlIGhhcyBhIHBhdGggb2YgYW5jZXN0b3JzIHRvIHRoZSByb290IG9mIHRoZSB0cmVlLlxyXG4gKiBXaGVuIGEgc3RhdGUgaXMgYmVpbmcgYWN0aXZhdGVkLCBlYWNoIGVsZW1lbnQgaW4gdGhlIHBhdGggaXMgd3JhcHBlZCBhcyBhIFtbUGF0aE5vZGVdXS5cclxuICogQSBgUGF0aE5vZGVgIGlzIGEgc3RhdGVmdWwgb2JqZWN0IHRoYXQgaG9sZHMgdGhpbmdzIGxpa2UgcGFyYW1ldGVycyBhbmQgcmVzb2x2YWJsZXMgZm9yIHRoZSBzdGF0ZSBiZWluZyBhY3RpdmF0ZWQuXHJcbiAqXHJcbiAqIFRoZSBSZXNvbHZlQ29udGV4dCBjbG9zZXMgb3ZlciB0aGUgW1tQYXRoTm9kZV1dcywgYW5kIHByb3ZpZGVzIERJIGZvciB0aGUgbGFzdCBub2RlIGluIHRoZSBwYXRoLlxyXG4gKi9cclxudmFyIFJlc29sdmVDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlc29sdmVDb250ZXh0KF9wYXRoKSB7XHJcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xyXG4gICAgfVxyXG4gICAgLyoqIEdldHMgYWxsIHRoZSB0b2tlbnMgZm91bmQgaW4gdGhlIHJlc29sdmUgY29udGV4dCwgZGUtZHVwbGljYXRlZCAqL1xyXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmdldFRva2VucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZSkgeyByZXR1cm4gYWNjLmNvbmNhdChub2RlLnJlc29sdmFibGVzLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci50b2tlbjsgfSkpOyB9LCBbXSkucmVkdWNlKGNvbW1vbl8xLnVuaXFSLCBbXSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBSZXNvbHZhYmxlIHRoYXQgbWF0Y2hlcyB0aGUgdG9rZW5cclxuICAgICAqXHJcbiAgICAgKiBHZXRzIHRoZSBsYXN0IFJlc29sdmFibGUgdGhhdCBtYXRjaGVzIHRoZSB0b2tlbiBpbiB0aGlzIGNvbnRleHQsIG9yIHVuZGVmaW5lZC5cclxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBpdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBSZXNvbHZlQ29udGV4dFxyXG4gICAgICovXHJcbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuZ2V0UmVzb2x2YWJsZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgIHZhciBtYXRjaGluZyA9IHRoaXMuX3BhdGgubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnJlc29sdmFibGVzOyB9KVxyXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnRva2VuID09PSB0b2tlbjsgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnRhaWwobWF0Y2hpbmcpO1xyXG4gICAgfTtcclxuICAgIC8qKiBSZXR1cm5zIHRoZSBbW1Jlc29sdmVQb2xpY3ldXSBmb3IgdGhlIGdpdmVuIFtbUmVzb2x2YWJsZV1dICovXHJcbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuZ2V0UG9saWN5ID0gZnVuY3Rpb24gKHJlc29sdmFibGUpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZmluZE5vZGUocmVzb2x2YWJsZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0UG9saWN5KG5vZGUuc3RhdGUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIFJlc29sdmVDb250ZXh0IHRoYXQgaW5jbHVkZXMgYSBwb3J0aW9uIG9mIHRoaXMgb25lXHJcbiAgICAgKlxyXG4gICAgICogR2l2ZW4gYSBzdGF0ZSwgdGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBSZXNvbHZlQ29udGV4dCBmcm9tIHRoaXMgb25lLlxyXG4gICAgICogVGhlIG5ldyBjb250ZXh0IHN0YXJ0cyBhdCB0aGUgZmlyc3Qgbm9kZSAocm9vdCkgYW5kIHN0b3BzIGF0IHRoZSBub2RlIGZvciB0aGUgYHN0YXRlYCBwYXJhbWV0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIyBXaHlcclxuICAgICAqXHJcbiAgICAgKiBXaGVuIGEgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLCB0aGUgbm9kZXMgaW4gdGhlIFwiVG8gUGF0aFwiIGFyZSBpbmplY3RlZCBmcm9tIGEgUmVzb2x2ZUNvbnRleHQuXHJcbiAgICAgKiBBIFJlc29sdmVDb250ZXh0IGNsb3NlcyBvdmVyIGEgcGF0aCBvZiBbW1BhdGhOb2RlXV1zIGFuZCBwcm9jZXNzZXMgdGhlIHJlc29sdmFibGVzLlxyXG4gICAgICogVGhlIFwiVG8gU3RhdGVcIiBjYW4gaW5qZWN0IHZhbHVlcyBmcm9tIGl0cyBvd24gcmVzb2x2YWJsZXMsIGFzIHdlbGwgYXMgdGhvc2UgZnJvbSBhbGwgaXRzIGFuY2VzdG9yIHN0YXRlJ3MgKG5vZGUncykuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG5hcnJvd2VyIGNvbnRleHQgd2hlbiBpbmplY3RpbmcgYW5jZXN0b3Igbm9kZXMuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBsZXQgQUJDRCA9IG5ldyBSZXNvbHZlQ29udGV4dChbQSwgQiwgQywgRF0pO2BcclxuICAgICAqXHJcbiAgICAgKiBHaXZlbiBhIHBhdGggYFtBLCBCLCBDLCBEXWAsIHdoZXJlIGBBYCwgYEJgLCBgQ2AgYW5kIGBEYCBhcmUgbm9kZXMgZm9yIHN0YXRlcyBgYWAsIGBiYCwgYGNgLCBgZGA6XHJcbiAgICAgKiBXaGVuIGluamVjdGluZyBgRGAsIGBEYCBzaG91bGQgaGF2ZSBhY2Nlc3MgdG8gYWxsIHJlc29sdmFibGVzIGZyb20gYEFgLCBgQmAsIGBDYCwgYERgLlxyXG4gICAgICogSG93ZXZlciwgYEJgIHNob3VsZCBvbmx5IGJlIGFibGUgdG8gYWNjZXNzIHJlc29sdmFibGVzIGZyb20gYEFgLCBgQmAuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiByZXNvbHZpbmcgZm9yIHRoZSBgQmAgbm9kZSwgZmlyc3QgdGFrZSB0aGUgZnVsbCBcIlRvIFBhdGhcIiBDb250ZXh0IGBbQSxCLEMsRF1gIGFuZCBsaW1pdCB0byB0aGUgc3VicGF0aCBgW0EsQl1gLlxyXG4gICAgICogYGxldCBBQiA9IEFCQ0Quc3ViY29udGV4dChhKWBcclxuICAgICAqL1xyXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLnN1YkNvbnRleHQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVDb250ZXh0KHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLnN1YlBhdGgodGhpcy5fcGF0aCwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc3RhdGUgPT09IHN0YXRlOyB9KSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIFJlc29sdmFibGVzIHRvIHRoZSBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgc3RhdGVcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGFkZHMgYSBbW1Jlc29sdmFibGVdXSAoZ2VuZXJhbGx5IG9uZSBjcmVhdGVkIG9uIHRoZSBmbHk7IG5vdCBkZWNsYXJlZCBvbiBhIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV0gYmxvY2spLlxyXG4gICAgICogVGhlIHJlc29sdmFibGUgaXMgYWRkZWQgdG8gdGhlIG5vZGUgbWF0Y2hpbmcgdGhlIGBzdGF0ZWAgcGFyYW1ldGVyLlxyXG4gICAgICpcclxuICAgICAqIFRoZXNlIG5ldyByZXNvbHZhYmxlcyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgZmV0Y2hlZC5cclxuICAgICAqIFRoZSBjYWxsaW5nIGNvZGUgc2hvdWxkIGVpdGhlciBmZXRjaCB0aGVtLCBmZXRjaCBzb21ldGhpbmcgdGhhdCBkZXBlbmRzIG9uIHRoZW0sXHJcbiAgICAgKiBvciByZWx5IG9uIFtbcmVzb2x2ZVBhdGhdXSBiZWluZyBjYWxsZWQgd2hlbiBzb21lIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogZWFjaCByZXNvbHZhYmxlJ3MgW1tSZXNvbHZlUG9saWN5XV0gaXMgbWVyZ2VkIHdpdGggdGhlIHN0YXRlJ3MgcG9saWN5LCBhbmQgdGhlIGdsb2JhbCBkZWZhdWx0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuZXdSZXNvbHZhYmxlcyB0aGUgbmV3IFJlc29sdmFibGVzXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVXNlZCB0byBmaW5kIHRoZSBub2RlIHRvIHB1dCB0aGUgcmVzb2x2YWJsZSBvblxyXG4gICAgICovXHJcbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuYWRkUmVzb2x2YWJsZXMgPSBmdW5jdGlvbiAobmV3UmVzb2x2YWJsZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBjb21tb25fMS5maW5kKHRoaXMuX3BhdGgsIGhvZl8xLnByb3BFcSgnc3RhdGUnLCBzdGF0ZSkpO1xyXG4gICAgICAgIHZhciBrZXlzID0gbmV3UmVzb2x2YWJsZXMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnRva2VuOyB9KTtcclxuICAgICAgICBub2RlLnJlc29sdmFibGVzID0gbm9kZS5yZXNvbHZhYmxlcy5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIGtleXMuaW5kZXhPZihyLnRva2VuKSA9PT0gLTE7IH0pLmNvbmNhdChuZXdSZXNvbHZhYmxlcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcmVzb2x2ZWQgcGF0aCBFbGVtZW50IHByb21pc2VzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHdoZW5cclxuICAgICAqIEBwYXJhbSB0cmFuc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pnxhbnl9XHJcbiAgICAgKi9cclxuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5yZXNvbHZlUGF0aCA9IGZ1bmN0aW9uICh3aGVuLCB0cmFucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHdoZW4gPT09IHZvaWQgMCkgeyB3aGVuID0gXCJMQVpZXCI7IH1cclxuICAgICAgICAvLyBUaGlzIG9wdGlvbiBkZXRlcm1pbmVzIHdoaWNoICd3aGVuJyBwb2xpY3kgUmVzb2x2YWJsZXMgd2UgYXJlIGFib3V0IHRvIGZldGNoLlxyXG4gICAgICAgIHZhciB3aGVuT3B0aW9uID0gY29tbW9uXzEuaW5BcnJheShBTExfV0hFTlMsIHdoZW4pID8gd2hlbiA6IFwiTEFaWVwiO1xyXG4gICAgICAgIC8vIElmIHRoZSBjYWxsZXIgc3BlY2lmaWVkIEVBR0VSLCBvbmx5IHRoZSBFQUdFUiBSZXNvbHZhYmxlcyBhcmUgZmV0Y2hlZC5cclxuICAgICAgICAvLyBpZiB0aGUgY2FsbGVyIHNwZWNpZmllZCBMQVpZLCBib3RoIEVBR0VSIGFuZCBMQVpZIFJlc29sdmFibGVzIGFyZSBmZXRjaGVkLmBcclxuICAgICAgICB2YXIgbWF0Y2hlZFdoZW5zID0gd2hlbk9wdGlvbiA9PT0gaW50ZXJmYWNlXzEucmVzb2x2ZVBvbGljaWVzLndoZW4uRUFHRVIgPyBFQUdFUl9XSEVOUyA6IEFMTF9XSEVOUztcclxuICAgICAgICAvLyBnZXQgdGhlIHN1YnBhdGggdG8gdGhlIHN0YXRlIGFyZ3VtZW50LCBpZiBwcm92aWRlZFxyXG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VSZXNvbHZlUGF0aCh0aGlzLl9wYXRoLCB3aGVuLCB0cmFucyk7XHJcbiAgICAgICAgdmFyIG1hdGNoZXNQb2xpY3kgPSBmdW5jdGlvbiAoYWNjZXB0ZWRWYWxzLCB3aGVuT3JBc3luYykge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5pbkFycmF5KGFjY2VwdGVkVmFscywgX3RoaXMuZ2V0UG9saWN5KHJlc29sdmFibGUpW3doZW5PckFzeW5jXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUcmlnZ2VyIGFsbCB0aGUgKG1hdGNoaW5nKSBSZXNvbHZhYmxlcyBpbiB0aGUgcGF0aFxyXG4gICAgICAgIC8vIFJlZHVjZSBhbGwgdGhlIFwiV0FJVFwiIFJlc29sdmFibGVzIGludG8gYW4gYXJyYXlcclxuICAgICAgICB2YXIgcHJvbWlzZXMgPSB0aGlzLl9wYXRoLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlUmVzb2x2YWJsZXMgPSBub2RlLnJlc29sdmFibGVzLmZpbHRlcihtYXRjaGVzUG9saWN5KG1hdGNoZWRXaGVucywgJ3doZW4nKSk7XHJcbiAgICAgICAgICAgIHZhciBub3dhaXQgPSBub2RlUmVzb2x2YWJsZXMuZmlsdGVyKG1hdGNoZXNQb2xpY3koWydOT1dBSVQnXSwgJ2FzeW5jJykpO1xyXG4gICAgICAgICAgICB2YXIgd2FpdCA9IG5vZGVSZXNvbHZhYmxlcy5maWx0ZXIoaG9mXzEubm90KG1hdGNoZXNQb2xpY3koWydOT1dBSVQnXSwgJ2FzeW5jJykpKTtcclxuICAgICAgICAgICAgLy8gRm9yIHRoZSBtYXRjaGluZyBSZXNvbHZhYmxlcywgc3RhcnQgdGhlaXIgYXN5bmMgZmV0Y2ggcHJvY2Vzcy5cclxuICAgICAgICAgICAgdmFyIHN1YkNvbnRleHQgPSBfdGhpcy5zdWJDb250ZXh0KG5vZGUuc3RhdGUpO1xyXG4gICAgICAgICAgICB2YXIgZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuZ2V0KHN1YkNvbnRleHQsIHRyYW5zKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAoeyB0b2tlbjogci50b2tlbiwgdmFsdWU6IHZhbHVlIH0pOyB9KTsgfTtcclxuICAgICAgICAgICAgbm93YWl0LmZvckVhY2goZ2V0UmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQod2FpdC5tYXAoZ2V0UmVzdWx0KSk7XHJcbiAgICAgICAgfSwgW10pO1xyXG4gICAgICAgIC8vIFdhaXQgZm9yIGFsbCB0aGUgXCJXQUlUXCIgcmVzb2x2YWJsZXNcclxuICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEuYWxsKHByb21pc2VzKTtcclxuICAgIH07XHJcbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuaW5qZWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luamVjdG9yIHx8ICh0aGlzLl9pbmplY3RvciA9IG5ldyBVSUluamVjdG9ySW1wbCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmZpbmROb2RlID0gZnVuY3Rpb24gKHJlc29sdmFibGUpIHtcclxuICAgICAgICByZXR1cm4gY29tbW9uXzEuZmluZCh0aGlzLl9wYXRoLCBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gY29tbW9uXzEuaW5BcnJheShub2RlLnJlc29sdmFibGVzLCByZXNvbHZhYmxlKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBhc3luYyBkZXBlbmRlbmNpZXMgb2YgYSBSZXNvbHZhYmxlXHJcbiAgICAgKlxyXG4gICAgICogR2l2ZW4gYSBSZXNvbHZhYmxlLCByZXR1cm5zIGl0cyBkZXBlbmRlbmNpZXMgYXMgYSBSZXNvbHZhYmxlW11cclxuICAgICAqL1xyXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmdldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZmluZE5vZGUocmVzb2x2YWJsZSk7XHJcbiAgICAgICAgLy8gRmluZCB3aGljaCBvdGhlciByZXNvbHZhYmxlcyBhcmUgXCJ2aXNpYmxlXCIgdG8gdGhlIGByZXNvbHZhYmxlYCBhcmd1bWVudFxyXG4gICAgICAgIC8vIHN1YnBhdGggc3RvcHBpbmcgYXQgcmVzb2x2YWJsZSdzIG5vZGUsIG9yIHRoZSB3aG9sZSBwYXRoIChpZiB0aGUgcmVzb2x2YWJsZSBpc24ndCBpbiB0aGUgcGF0aClcclxuICAgICAgICB2YXIgc3ViUGF0aCA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLnN1YlBhdGgodGhpcy5fcGF0aCwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPT09IG5vZGU7IH0pIHx8IHRoaXMuX3BhdGg7XHJcbiAgICAgICAgdmFyIGF2YWlsYWJsZVJlc29sdmFibGVzID0gc3ViUGF0aFxyXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5vZGUpIHsgcmV0dXJuIGFjYy5jb25jYXQobm9kZS5yZXNvbHZhYmxlcyk7IH0sIFtdKSAvL2FsbCBvZiBzdWJwYXRoJ3MgcmVzb2x2YWJsZXNcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMgIT09IHJlc29sdmFibGU7IH0pOyAvLyBmaWx0ZXIgb3V0IHRoZSBgcmVzb2x2YWJsZWAgYXJndW1lbnRcclxuICAgICAgICB2YXIgZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmcgPSBhdmFpbGFibGVSZXNvbHZhYmxlcy5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudG9rZW4gPT09IHRva2VuOyB9KTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS50YWlsKG1hdGNoaW5nKTtcclxuICAgICAgICAgICAgdmFyIGZyb21JbmplY3RvciA9IF90aGlzLmluamVjdG9yKCkuZ2V0TmF0aXZlKHRva2VuKTtcclxuICAgICAgICAgICAgaWYgKCFmcm9tSW5qZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIERlcGVuZGVuY3kgSW5qZWN0aW9uIHRva2VuOiBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodG9rZW4pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHRva2VuLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmcm9tSW5qZWN0b3I7IH0sIFtdLCBmcm9tSW5qZWN0b3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZGVwcy5tYXAoZ2V0RGVwZW5kZW5jeSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc29sdmVDb250ZXh0O1xyXG59KCkpO1xyXG5leHBvcnRzLlJlc29sdmVDb250ZXh0ID0gUmVzb2x2ZUNvbnRleHQ7XHJcbnZhciBVSUluamVjdG9ySW1wbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVSUluamVjdG9ySW1wbChjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLm5hdGl2ZSA9IHRoaXMuZ2V0KGV4cG9ydHMuTkFUSVZFX0lOSkVDVE9SX1RPS0VOKSB8fCBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3I7XHJcbiAgICB9XHJcbiAgICBVSUluamVjdG9ySW1wbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICAgICAgdmFyIHJlc29sdmFibGUgPSB0aGlzLmNvbnRleHQuZ2V0UmVzb2x2YWJsZSh0b2tlbik7XHJcbiAgICAgICAgaWYgKHJlc29sdmFibGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5nZXRQb2xpY3kocmVzb2x2YWJsZSkuYXN5bmMgPT09ICdOT1dBSVQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQodGhpcy5jb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXJlc29sdmFibGUucmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc29sdmFibGUgYXN5bmMgLmdldCgpIG5vdCBjb21wbGV0ZTpcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkocmVzb2x2YWJsZS50b2tlbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZhYmxlLmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZSAmJiB0aGlzLm5hdGl2ZS5nZXQodG9rZW4pO1xyXG4gICAgfTtcclxuICAgIFVJSW5qZWN0b3JJbXBsLnByb3RvdHlwZS5nZXRBc3luYyA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgIHZhciByZXNvbHZhYmxlID0gdGhpcy5jb250ZXh0LmdldFJlc29sdmFibGUodG9rZW4pO1xyXG4gICAgICAgIGlmIChyZXNvbHZhYmxlKVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQodGhpcy5jb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbih0aGlzLm5hdGl2ZS5nZXQodG9rZW4pKTtcclxuICAgIH07XHJcbiAgICBVSUluamVjdG9ySW1wbC5wcm90b3R5cGUuZ2V0TmF0aXZlID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlICYmIHRoaXMubmF0aXZlLmdldCh0b2tlbik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFVJSW5qZWN0b3JJbXBsO1xyXG59KCkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlQ29udGV4dC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL3Jlc29sdmVDb250ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQGNvcmVhcGlcclxuICogQG1vZHVsZSB0cmFuc2l0aW9uXHJcbiAqL1xyXG4vKiogZm9yIHR5cGVkb2MgKi9cclxudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xyXG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcclxudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XHJcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XHJcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xyXG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7IC8vIGhhcyBvciBpcyB1c2luZ1xyXG52YXIgdHJhbnNpdGlvbkhvb2tfMSA9IHJlcXVpcmUoXCIuL3RyYW5zaXRpb25Ib29rXCIpO1xyXG52YXIgaG9va1JlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9ob29rUmVnaXN0cnlcIik7XHJcbnZhciBob29rQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vaG9va0J1aWxkZXJcIik7XHJcbnZhciBwYXRoRmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL3BhdGgvcGF0aEZhY3RvcnlcIik7XHJcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3RhcmdldFN0YXRlXCIpO1xyXG52YXIgcGFyYW1fMSA9IHJlcXVpcmUoXCIuLi9wYXJhbXMvcGFyYW1cIik7XHJcbnZhciByZXNvbHZhYmxlXzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZhYmxlXCIpO1xyXG52YXIgcmVzb2x2ZUNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmVDb250ZXh0XCIpO1xyXG4vKiogQGhpZGRlbiAqL1xyXG52YXIgc3RhdGVTZWxmID0gaG9mXzEucHJvcChcInNlbGZcIik7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNpdGlvbiBiZXR3ZWVuIHR3byBzdGF0ZXMuXHJcbiAqXHJcbiAqIFdoZW4gbmF2aWdhdGluZyB0byBhIHN0YXRlLCB3ZSBhcmUgdHJhbnNpdGlvbmluZyAqKmZyb20qKiB0aGUgY3VycmVudCBzdGF0ZSAqKnRvKiogdGhlIG5ldyBzdGF0ZS5cclxuICpcclxuICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRvL2Zyb20gc3RhdGVzLCBwYXJhbWV0ZXJzLCByZXNvbHZlcy5cclxuICogSXQgaGFzIGluZm9ybWF0aW9uIGFib3V0IGFsbCBzdGF0ZXMgYmVpbmcgZW50ZXJlZCBhbmQgZXhpdGVkIGFzIGEgcmVzdWx0IG9mIHRoZSB0cmFuc2l0aW9uLlxyXG4gKi9cclxudmFyIFRyYW5zaXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRyYW5zaXRpb24gb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSB0YXJnZXQgc3RhdGUgaXMgbm90IHZhbGlkLCBhbiBlcnJvciBpcyB0aHJvd24uXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsYXBpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBwYXRoIG9mIFtbUGF0aE5vZGVdXXMgZnJvbSB3aGljaCB0aGUgdHJhbnNpdGlvbiBpcyBsZWF2aW5nLiAgVGhlIGxhc3Qgbm9kZSBpbiB0aGUgYGZyb21QYXRoYFxyXG4gICAgICogICAgICAgIGVuY2Fwc3VsYXRlcyB0aGUgXCJmcm9tIHN0YXRlXCIuXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgVGhlIHRhcmdldCBzdGF0ZSBhbmQgcGFyYW1ldGVycyBiZWluZyB0cmFuc2l0aW9uZWQgdG8gKGFsc28sIHRoZSB0cmFuc2l0aW9uIG9wdGlvbnMpXHJcbiAgICAgKiBAcGFyYW0gcm91dGVyIFRoZSBbW1VJUm91dGVyXV0gaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbihmcm9tUGF0aCwgdGFyZ2V0U3RhdGUsIHJvdXRlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cclxuICAgICAgICB0aGlzLl9kZWZlcnJlZCA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLmRlZmVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBwcm9taXNlIGlzIHJlc29sdmVkIG9yIHJlamVjdGVkIGJhc2VkIG9uIHRoZSBvdXRjb21lIG9mIHRoZSBUcmFuc2l0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogV2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZFxyXG4gICAgICAgICAqIFdoZW4gdGhlIHRyYW5zaXRpb24gaXMgdW5zdWNjZXNzZnVsLCB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIHRoZSBbW1JlamVjdGlvbl1dIG9yIGphdmFzY3JpcHQgZXJyb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLl9kZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgICAgIC8qKiBAaGlkZGVuIEhvbGRzIHRoZSBob29rIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbnMgc3VjaCBhcyB0aG9zZSBwYXNzZWQgdG8gVHJhbnNpdGlvbi5vblN0YXJ0KCkgKi9cclxuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkSG9va3MgPSB7fTtcclxuICAgICAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgICAgIHRoaXMuX2hvb2tCdWlsZGVyID0gbmV3IGhvb2tCdWlsZGVyXzEuSG9va0J1aWxkZXIodGhpcyk7XHJcbiAgICAgICAgLyoqIENoZWNrcyBpZiB0aGlzIHRyYW5zaXRpb24gaXMgY3VycmVudGx5IGFjdGl2ZS9ydW5uaW5nLiAqL1xyXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5yb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uID09PSBfdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xyXG4gICAgICAgIHRoaXMuX3RhcmdldFN0YXRlID0gdGFyZ2V0U3RhdGU7XHJcbiAgICAgICAgaWYgKCF0YXJnZXRTdGF0ZS52YWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0YXJnZXRTdGF0ZS5lcnJvcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3VycmVudCgpIGlzIGFzc3VtZWQgdG8gY29tZSBmcm9tIHRhcmdldFN0YXRlLm9wdGlvbnMsIGJ1dCBwcm92aWRlIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gb3RoZXJ3aXNlLlxyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBjb21tb25fMS5leHRlbmQoeyBjdXJyZW50OiBob2ZfMS52YWwodGhpcykgfSwgdGFyZ2V0U3RhdGUub3B0aW9ucygpKTtcclxuICAgICAgICB0aGlzLiRpZCA9IHJvdXRlci50cmFuc2l0aW9uU2VydmljZS5fdHJhbnNpdGlvbkNvdW50Kys7XHJcbiAgICAgICAgdmFyIHRvUGF0aCA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLmJ1aWxkVG9QYXRoKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fdHJlZUNoYW5nZXMgPSBwYXRoRmFjdG9yeV8xLlBhdGhVdGlscy50cmVlQ2hhbmdlcyhmcm9tUGF0aCwgdG9QYXRoLCB0aGlzLl9vcHRpb25zLnJlbG9hZFN0YXRlKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZVRyYW5zaXRpb25Ib29rUmVnRm5zKCk7XHJcbiAgICAgICAgdmFyIG9uQ3JlYXRlSG9va3MgPSB0aGlzLl9ob29rQnVpbGRlci5idWlsZEhvb2tzRm9yUGhhc2UoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEUpO1xyXG4gICAgICAgIHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suaW52b2tlSG9va3Mob25DcmVhdGVIb29rcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSk7XHJcbiAgICAgICAgdGhpcy5hcHBseVZpZXdDb25maWdzKHJvdXRlcik7XHJcbiAgICB9XHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUub25CZWZvcmUgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkV4aXQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUub25SZXRhaW4gPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUub25FbnRlciA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkZpbmlzaCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xyXG4gICAgLyoqIEBoaWRkZW5cclxuICAgICAqIENyZWF0ZXMgdGhlIHRyYW5zaXRpb24tbGV2ZWwgaG9vayByZWdpc3RyYXRpb24gZnVuY3Rpb25zXHJcbiAgICAgKiAod2hpY2ggY2FuIHRoZW4gYmUgdXNlZCB0byByZWdpc3RlciBob29rcylcclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuY3JlYXRlVHJhbnNpdGlvbkhvb2tSZWdGbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJvdXRlci50cmFuc2l0aW9uU2VydmljZS5fcGx1Z2luYXBpLl9nZXRFdmVudHMoKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLmhvb2tQaGFzZSAhPT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEU7IH0pXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBob29rUmVnaXN0cnlfMS5tYWtlRXZlbnQoX3RoaXMsIF90aGlzLnJvdXRlci50cmFuc2l0aW9uU2VydmljZSwgdHlwZSk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cclxuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmdldEhvb2tzID0gZnVuY3Rpb24gKGhvb2tOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyZWRIb29rc1tob29rTmFtZV07XHJcbiAgICB9O1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuYXBwbHlWaWV3Q29uZmlncyA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcclxuICAgICAgICB2YXIgZW50ZXJpbmdTdGF0ZXMgPSB0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc3RhdGU7IH0pO1xyXG4gICAgICAgIHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLmFwcGx5Vmlld0NvbmZpZ3Mocm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLiR2aWV3LCB0aGlzLl90cmVlQ2hhbmdlcy50bywgZW50ZXJpbmdTdGF0ZXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsYXBpXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgdGhlIGludGVybmFsIGZyb20gW1N0YXRlXSBvYmplY3RcclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuJGZyb20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnRhaWwodGhpcy5fdHJlZUNoYW5nZXMuZnJvbSkuc3RhdGU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxhcGlcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgaW50ZXJuYWwgdG8gW1N0YXRlXSBvYmplY3RcclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuJHRvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBjb21tb25fMS50YWlsKHRoaXMuX3RyZWVDaGFuZ2VzLnRvKS5zdGF0ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFwiZnJvbSBzdGF0ZVwiXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgdGhhdCB0aGUgdHJhbnNpdGlvbiBpcyBjb21pbmcgKmZyb20qLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBzdGF0ZSBkZWNsYXJhdGlvbiBvYmplY3QgZm9yIHRoZSBUcmFuc2l0aW9uJ3MgKFwiZnJvbSBzdGF0ZVwiKS5cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZnJvbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kZnJvbSgpLnNlbGY7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBcInRvIHN0YXRlXCJcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSB0aGF0IHRoZSB0cmFuc2l0aW9uIGlzIGdvaW5nICp0byouXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdCBmb3IgdGhlIFRyYW5zaXRpb24ncyB0YXJnZXQgc3RhdGUgKFwidG8gc3RhdGVcIikuXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiR0bygpLnNlbGY7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBUYXJnZXQgU3RhdGVcclxuICAgICAqXHJcbiAgICAgKiBBIHRyYW5zaXRpb24ncyBbW1RhcmdldFN0YXRlXV0gZW5jYXBzdWxhdGVzIHRoZSBbW3RvXV0gc3RhdGUsIHRoZSBbW3BhcmFtc11dLCBhbmQgdGhlIFtbb3B0aW9uc11dIGFzIGEgc2luZ2xlIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgW1tUYXJnZXRTdGF0ZV1dIG9mIHRoaXMgVHJhbnNpdGlvblxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50YXJnZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0U3RhdGU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIHRyYW5zaXRpb25zIGFyZSBlcXVpdmFsZW50LlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAoY29tcGFyZSkge1xyXG4gICAgICAgIGlmIChjb21wYXJlIGluc3RhbmNlb2YgVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBBbHNvIGNvbXBhcmUgcGFyYW1ldGVyc1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pcyh7IHRvOiBjb21wYXJlLiR0bygpLm5hbWUsIGZyb206IGNvbXBhcmUuJGZyb20oKS5uYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gISgoY29tcGFyZS50byAmJiAhaG9va1JlZ2lzdHJ5XzEubWF0Y2hTdGF0ZSh0aGlzLiR0bygpLCBjb21wYXJlLnRvKSkgfHxcclxuICAgICAgICAgICAgKGNvbXBhcmUuZnJvbSAmJiAhaG9va1JlZ2lzdHJ5XzEubWF0Y2hTdGF0ZSh0aGlzLiRmcm9tKCksIGNvbXBhcmUuZnJvbSkpKTtcclxuICAgIH07XHJcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAocGF0aG5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aG5hbWUgPT09IHZvaWQgMCkgeyBwYXRobmFtZSA9IFwidG9cIjsgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHRoaXMuX3RyZWVDaGFuZ2VzW3BhdGhuYW1lXS5tYXAoaG9mXzEucHJvcChcInBhcmFtVmFsdWVzXCIpKS5yZWR1Y2UoY29tbW9uXzEubWVyZ2VSLCB7fSkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIFtbVUlJbmplY3Rvcl1dIERlcGVuZGVuY3kgSW5qZWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIGEgRGVwZW5kZW5jeSBJbmplY3RvciBmb3IgdGhlIFRyYW5zaXRpb24ncyB0YXJnZXQgc3RhdGUgKHRvIHN0YXRlKS5cclxuICAgICAqIFRoZSBpbmplY3RvciBwcm92aWRlcyByZXNvbHZlIHZhbHVlcyB3aGljaCB0aGUgdGFyZ2V0IHN0YXRlIGhhcyBhY2Nlc3MgdG8uXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGBVSUluamVjdG9yYCBjYW4gYWxzbyBwcm92aWRlIHZhbHVlcyBmcm9tIHRoZSBuYXRpdmUgcm9vdC9nbG9iYWwgaW5qZWN0b3IgKG5nMS9uZzIpLlxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAub25FbnRlcih7IGVudGVyaW5nOiAnbXlTdGF0ZScgfSwgdHJhbnMgPT4ge1xyXG4gICAgICogICB2YXIgbXlSZXNvbHZlVmFsdWUgPSB0cmFucy5pbmplY3RvcigpLmdldCgnbXlSZXNvbHZlJyk7XHJcbiAgICAgKiAgIC8vIEluamVjdCBhIGdsb2JhbCBzZXJ2aWNlIGZyb20gdGhlIGdsb2JhbC9uYXRpdmUgaW5qZWN0b3IgKGlmIGl0IGV4aXN0cylcclxuICAgICAqICAgdmFyIE15U2VydmljZSA9IHRyYW5zLmluamVjdG9yKCkuZ2V0KCdNeVNlcnZpY2UnKTtcclxuICAgICAqIH0pXHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBJbiBzb21lIGNhc2VzIChzdWNoIGFzIGBvbkJlZm9yZWApLCB5b3UgbWF5IG5lZWQgYWNjZXNzIHRvIHNvbWUgcmVzb2x2ZSBkYXRhIGJ1dCBpdCBoYXMgbm90IHlldCBiZWVuIGZldGNoZWQuXHJcbiAgICAgKiBZb3UgY2FuIHVzZSBbW1VJSW5qZWN0b3IuZ2V0QXN5bmNdXSB0byBnZXQgYSBwcm9taXNlIGZvciB0aGUgZGF0YS5cclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAub25CZWZvcmUoe30sIHRyYW5zID0+IHtcclxuICAgICAqICAgcmV0dXJuIHRyYW5zLmluamVjdG9yKCkuZ2V0QXN5bmMoJ215UmVzb2x2ZScpLnRoZW4obXlSZXNvbHZlVmFsdWUgPT5cclxuICAgICAqICAgICByZXR1cm4gbXlSZXNvbHZlVmFsdWUgIT09ICdBQk9SVCc7XHJcbiAgICAgKiAgIH0pO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBJZiBhIGBzdGF0ZWAgaXMgcHJvdmlkZWQsIHRoZSBpbmplY3RvciB0aGF0IGlzIHJldHVybmVkIHdpbGwgYmUgbGltaXRlZCB0byByZXNvbHZlIHZhbHVlcyB0aGF0IHRoZSBwcm92aWRlZCBzdGF0ZSBoYXMgYWNjZXNzIHRvLlxyXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIGJvdGggYSBwYXJlbnQgc3RhdGUgYGZvb2AgYW5kIGEgY2hpbGQgc3RhdGUgYGZvby5iYXJgIGhhdmUgYm90aCBkZWZpbmVkIGEgcmVzb2x2ZSBzdWNoIGFzIGBkYXRhYC5cclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAub25FbnRlcih7IHRvOiAnZm9vLmJhcicgfSwgdHJhbnMgPT4ge1xyXG4gICAgICogICAvLyByZXR1cm5zIHJlc3VsdCBvZiBgZm9vYCBzdGF0ZSdzIGBkYXRhYCByZXNvbHZlXHJcbiAgICAgKiAgIC8vIGV2ZW4gdGhvdWdoIGBmb28uYmFyYCBhbHNvIGhhcyBhIGBkYXRhYCByZXNvbHZlXHJcbiAgICAgKiAgIHZhciBmb29EYXRhID0gdHJhbnMuaW5qZWN0b3IoJ2ZvbycpLmdldCgnZGF0YScpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBJZiB5b3UgbmVlZCByZXNvbHZlIGRhdGEgZnJvbSB0aGUgZXhpdGluZyBzdGF0ZXMsIHBhc3MgYCdmcm9tJ2AgYXMgYHBhdGhOYW1lYC5cclxuICAgICAqIFRoZSByZXNvbHZlIGRhdGEgZnJvbSB0aGUgYGZyb21gIHBhdGggd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAub25FeGl0KHsgZXhpdGluZzogJ2Zvby5iYXInIH0sIHRyYW5zID0+IHtcclxuICAgICAqICAgLy8gR2V0cyB0aGUgcmVzb2x2ZSB2YWx1ZSBvZiBgZGF0YWAgZnJvbSB0aGUgZXhpdGluZyBzdGF0ZS5cclxuICAgICAqICAgdmFyIGZvb0RhdGEgPSB0cmFucy5pbmplY3RvcihudWxsLCAnZm9vLmJhcicpLmdldCgnZGF0YScpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIExpbWl0cyB0aGUgcmVzb2x2ZXMgcHJvdmlkZWQgdG8gb25seSB0aGUgcmVzb2x2ZXMgdGhlIHByb3ZpZGVkIHN0YXRlIGhhcyBhY2Nlc3MgdG8uXHJcbiAgICAgKiBAcGFyYW0gcGF0aE5hbWUgRGVmYXVsdDogYCd0bydgOiBDaG9vc2VzIHRoZSBwYXRoIGZvciB3aGljaCB0byBjcmVhdGUgdGhlIGluamVjdG9yLiBVc2UgdGhpcyB0byBhY2Nlc3MgcmVzb2x2ZXMgZm9yIGBleGl0aW5nYCBzdGF0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYSBbW1VJSW5qZWN0b3JdXVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5pbmplY3RvciA9IGZ1bmN0aW9uIChzdGF0ZSwgcGF0aE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aE5hbWUgPT09IHZvaWQgMCkgeyBwYXRoTmFtZSA9IFwidG9cIjsgfVxyXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5fdHJlZUNoYW5nZXNbcGF0aE5hbWVdO1xyXG4gICAgICAgIGlmIChzdGF0ZSlcclxuICAgICAgICAgICAgcGF0aCA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLnN1YlBhdGgocGF0aCwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc3RhdGUgPT09IHN0YXRlIHx8IG5vZGUuc3RhdGUubmFtZSA9PT0gc3RhdGU7IH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgcmVzb2x2ZUNvbnRleHRfMS5SZXNvbHZlQ29udGV4dChwYXRoKS5pbmplY3RvcigpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgYXZhaWxhYmxlIHJlc29sdmUgdG9rZW5zIChrZXlzKVxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggW1tpbmplY3Rvcl1dIHRvIGluc3BlY3QgdGhlIHJlc29sdmUgdmFsdWVzXHJcbiAgICAgKiBhdmFpbGFibGUgdG8gdGhlIFRyYW5zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyByZXR1cm5zIGFsbCB0aGUgdG9rZW5zIGRlZmluZWQgb24gW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSBibG9ja3MsIGZvciB0aGUgc3RhdGVzXHJcbiAgICAgKiBpbiB0aGUgVHJhbnNpdGlvbidzIFtbVHJlZUNoYW5nZXMudG9dXSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIFRoaXMgZXhhbXBsZSBsb2dzIGFsbCByZXNvbHZlIHZhbHVlc1xyXG4gICAgICogYGBganNcclxuICAgICAqIGxldCB0b2tlbnMgPSB0cmFucy5nZXRSZXNvbHZlVG9rZW5zKCk7XHJcbiAgICAgKiB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiBjb25zb2xlLmxvZyh0b2tlbiArIFwiID0gXCIgKyB0cmFucy5pbmplY3RvcigpLmdldCh0b2tlbikpKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIHByb21pc2VzIGZvciBlYWNoIHJlc29sdmUgdmFsdWUuXHJcbiAgICAgKiBUaGlzIHRyaWdnZXJzIGZldGNoZXMgb2YgcmVzb2x2ZXMgKGlmIGFueSBoYXZlIG5vdCB5ZXQgYmVlbiBmZXRjaGVkKS5cclxuICAgICAqIFdoZW4gYWxsIHByb21pc2VzIGhhdmUgYWxsIHNldHRsZWQsIGl0IGxvZ3MgdGhlIHJlc29sdmUgdmFsdWVzLlxyXG4gICAgICogYGBganNcclxuICAgICAqIGxldCB0b2tlbnMgPSB0cmFucy5nZXRSZXNvbHZlVG9rZW5zKCk7XHJcbiAgICAgKiBsZXQgcHJvbWlzZSA9IHRva2Vucy5tYXAodG9rZW4gPT4gdHJhbnMuaW5qZWN0b3IoKS5nZXRBc3luYyh0b2tlbikpO1xyXG4gICAgICogUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4odmFsdWVzID0+IGNvbnNvbGUubG9nKFwiUmVzb2x2ZWQgdmFsdWVzOiBcIiArIHZhbHVlcykpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogQW5ndWxhciAxIHVzZXJzIHdob3VsZCB1c2UgYCRxLmFsbCgpYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRobmFtZSByZXNvbHZlIGNvbnRleHQncyBwYXRoIG5hbWUgKGUuZy4sIGB0b2Agb3IgYGZyb21gKVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHJlc29sdmUgdG9rZW5zIChrZXlzKVxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5nZXRSZXNvbHZlVG9rZW5zID0gZnVuY3Rpb24gKHBhdGhuYW1lKSB7XHJcbiAgICAgICAgaWYgKHBhdGhuYW1lID09PSB2b2lkIDApIHsgcGF0aG5hbWUgPSBcInRvXCI7IH1cclxuICAgICAgICByZXR1cm4gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQodGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdKS5nZXRUb2tlbnMoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIER5bmFtaWNhbGx5IGFkZHMgYSBuZXcgW1tSZXNvbHZhYmxlXV0gKGkuZS4sIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV0pIHRvIHRoaXMgdHJhbnNpdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiAjIyMjIEV4YW1wbGU6XHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogdHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoe30sIHRyYW5zaXRpb24gPT4ge1xyXG4gICAgICogICB0cmFuc2l0aW9uLmFkZFJlc29sdmFibGUoe1xyXG4gICAgICogICAgIHRva2VuOiAnbXlSZXNvbHZlJyxcclxuICAgICAqICAgICBkZXBzOiBbJ015U2VydmljZSddLFxyXG4gICAgICogICAgIHJlc29sdmVGbjogbXlTZXJ2aWNlID0+IG15U2VydmljZS5nZXREYXRhKClcclxuICAgICAqICAgfSk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXNvbHZhYmxlIGEgW1tSZXNvbHZhYmxlTGl0ZXJhbF1dIG9iamVjdCAob3IgYSBbW1Jlc29sdmFibGVdXSlcclxuICAgICAqIEBwYXJhbSBzdGF0ZSB0aGUgc3RhdGUgaW4gdGhlIFwidG8gcGF0aFwiIHdoaWNoIHNob3VsZCByZWNlaXZlIHRoZSBuZXcgcmVzb2x2ZSAob3RoZXJ3aXNlLCB0aGUgcm9vdCBzdGF0ZSlcclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuYWRkUmVzb2x2YWJsZSA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlLCBzdGF0ZSkge1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7IHN0YXRlID0gXCJcIjsgfVxyXG4gICAgICAgIHJlc29sdmFibGUgPSBob2ZfMS5pcyhyZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSkocmVzb2x2YWJsZSkgPyByZXNvbHZhYmxlIDogbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHJlc29sdmFibGUpO1xyXG4gICAgICAgIHZhciBzdGF0ZU5hbWUgPSAodHlwZW9mIHN0YXRlID09PSBcInN0cmluZ1wiKSA/IHN0YXRlIDogc3RhdGUubmFtZTtcclxuICAgICAgICB2YXIgdG9wYXRoID0gdGhpcy5fdHJlZUNoYW5nZXMudG87XHJcbiAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBjb21tb25fMS5maW5kKHRvcGF0aCwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc3RhdGUubmFtZSA9PT0gc3RhdGVOYW1lOyB9KTtcclxuICAgICAgICB2YXIgcmVzb2x2ZUNvbnRleHQgPSBuZXcgcmVzb2x2ZUNvbnRleHRfMS5SZXNvbHZlQ29udGV4dCh0b3BhdGgpO1xyXG4gICAgICAgIHJlc29sdmVDb250ZXh0LmFkZFJlc29sdmFibGVzKFtyZXNvbHZhYmxlXSwgdGFyZ2V0Tm9kZS5zdGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB0cmFuc2l0aW9uIGZyb20gd2hpY2ggdGhpcyB0cmFuc2l0aW9uIHdhcyByZWRpcmVjdGVkLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBjdXJyZW50IHRyYW5zaXRpb24gaXMgYSByZWRpcmVjdCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgdHJhbnNpdGlvbiB0aGF0IHdhcyByZWRpcmVjdGVkLlxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiBsZXQgdHJhbnNpdGlvbkEgPSAkc3RhdGUuZ28oJ0EnKS50cmFuc2l0aW9uXHJcbiAgICAgKiB0cmFuc2l0aW9uQS5vblN0YXJ0KHt9LCAoKSA9PiAkc3RhdGUudGFyZ2V0KCdCJykpO1xyXG4gICAgICogJHRyYW5zaXRpb25zLm9uU3VjY2Vzcyh7IHRvOiAnQicgfSwgKHRyYW5zKSA9PiB7XHJcbiAgICAgKiAgIHRyYW5zLnRvKCkubmFtZSA9PT0gJ0InOyAvLyB0cnVlXHJcbiAgICAgKiAgIHRyYW5zLnJlZGlyZWN0ZWRGcm9tKCkgPT09IHRyYW5zaXRpb25BOyAvLyB0cnVlXHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyBUcmFuc2l0aW9uLCBvciBudWxsIGlmIHRoaXMgVHJhbnNpdGlvbiBpcyBub3QgdGhlIHJlc3VsdCBvZiBhIHJlZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnJlZGlyZWN0ZWRGcm9tID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnJlZGlyZWN0ZWRGcm9tIHx8IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIGluIGEgcmVkaXJlY3QgY2hhaW5cclxuICAgICAqXHJcbiAgICAgKiBBIHRyYW5zaXRpb24gbWlnaHQgYmVsb25nIHRvIGEgbG9uZyBjaGFpbiBvZiBtdWx0aXBsZSByZWRpcmVjdHMuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3YWxrcyB0aGUgW1tyZWRpcmVjdGVkRnJvbV1dIGNoYWluIGJhY2sgdG8gdGhlIG9yaWdpbmFsIChmaXJzdCkgdHJhbnNpdGlvbiBpbiB0aGUgY2hhaW4uXHJcbiAgICAgKlxyXG4gICAgICogIyMjIyBFeGFtcGxlOlxyXG4gICAgICogYGBganNcclxuICAgICAqIC8vIHN0YXRlc1xyXG4gICAgICogcmVnaXN0cnkucmVnaXN0ZXIoeyBuYW1lOiAnQScsIHJlZGlyZWN0VG86ICdCJyB9KTtcclxuICAgICAqIHJlZ2lzdHJ5LnJlZ2lzdGVyKHsgbmFtZTogJ0InLCByZWRpcmVjdFRvOiAnQycgfSk7XHJcbiAgICAgKiByZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdDJywgcmVkaXJlY3RUbzogJ0QnIH0pO1xyXG4gICAgICogcmVnaXN0cnkucmVnaXN0ZXIoeyBuYW1lOiAnRCcgfSk7XHJcbiAgICAgKlxyXG4gICAgICogbGV0IHRyYW5zaXRpb25BID0gJHN0YXRlLmdvKCdBJykudHJhbnNpdGlvblxyXG4gICAgICpcclxuICAgICAqICR0cmFuc2l0aW9ucy5vblN1Y2Nlc3MoeyB0bzogJ0QnIH0sICh0cmFucykgPT4ge1xyXG4gICAgICogICB0cmFucy50bygpLm5hbWUgPT09ICdEJzsgLy8gdHJ1ZVxyXG4gICAgICogICB0cmFucy5yZWRpcmVjdGVkRnJvbSgpLnRvKCkubmFtZSA9PT0gJ0MnOyAvLyB0cnVlXHJcbiAgICAgKiAgIHRyYW5zLm9yaWdpbmFsVHJhbnNpdGlvbigpID09PSB0cmFuc2l0aW9uQTsgLy8gdHJ1ZVxyXG4gICAgICogICB0cmFucy5vcmlnaW5hbFRyYW5zaXRpb24oKS50bygpLm5hbWUgPT09ICdBJzsgLy8gdHJ1ZVxyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgb3JpZ2luYWwgVHJhbnNpdGlvbiB0aGF0IHN0YXJ0ZWQgYSByZWRpcmVjdCBjaGFpblxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vcmlnaW5hbFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJmID0gdGhpcy5yZWRpcmVjdGVkRnJvbSgpO1xyXG4gICAgICAgIHJldHVybiAocmYgJiYgcmYub3JpZ2luYWxUcmFuc2l0aW9uKCkpIHx8IHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHRyYW5zaXRpb24gb3B0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHRoZSBvcHRpb25zIGZvciB0aGlzIFRyYW5zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgZW50ZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZXMgdGhhdCB3aWxsIGJlIGVudGVyZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZW50ZXJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZywgaG9mXzEucHJvcCgnc3RhdGUnKSkubWFwKHN0YXRlU2VsZik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgZXhpdGVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlcyB0aGF0IHdpbGwgYmUgZXhpdGVkIGR1cmluZyB0aGlzIHRyYW5zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmV4aXRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5leGl0aW5nLCBob2ZfMS5wcm9wKCdzdGF0ZScpKS5tYXAoc3RhdGVTZWxmKS5yZXZlcnNlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgcmV0YWluZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGVzIHRoYXQgYXJlIGFscmVhZHkgZW50ZXJlZCBmcm9tIGEgcHJldmlvdXMgVHJhbnNpdGlvbiwgdGhhdCB3aWxsIG5vdCBiZVxyXG4gICAgICogICAgZXhpdGVkIGR1cmluZyB0aGlzIFRyYW5zaXRpb25cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUucmV0YWluZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5yZXRhaW5lZCwgaG9mXzEucHJvcCgnc3RhdGUnKSkubWFwKHN0YXRlU2VsZik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIFtbVmlld0NvbmZpZ11dcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBUcmFuc2l0aW9uXHJcbiAgICAgKlxyXG4gICAgICogRWFjaCBzdGF0ZSBjYW4gZGVmaW5lIG9uZSBvciBtb3JlIHZpZXdzICh0ZW1wbGF0ZS9jb250cm9sbGVyKSwgd2hpY2ggYXJlIGVuY2Fwc3VsYXRlZCBhcyBgVmlld0NvbmZpZ2Agb2JqZWN0cy5cclxuICAgICAqIFRoaXMgbWV0aG9kIGZldGNoZXMgdGhlIGBWaWV3Q29uZmlnc2AgZm9yIGEgZ2l2ZW4gcGF0aCBpbiB0aGUgVHJhbnNpdGlvbiAoZS5nLiwgXCJ0b1wiIG9yIFwiZW50ZXJpbmdcIikuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGhuYW1lIHRoZSBuYW1lIG9mIHRoZSBwYXRoIHRvIGZldGNoIHZpZXdzIGZvcjpcclxuICAgICAqICAgKGAndG8nYCwgYCdmcm9tJ2AsIGAnZW50ZXJpbmcnYCwgYCdleGl0aW5nJ2AsIGAncmV0YWluZWQnYClcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBJZiBwcm92aWRlZCwgb25seSByZXR1cm5zIHRoZSBgVmlld0NvbmZpZ2BzIGZvciBhIHNpbmdsZSBzdGF0ZSBpbiB0aGUgcGF0aFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGEgbGlzdCBvZiBWaWV3Q29uZmlnIG9iamVjdHMgZm9yIHRoZSBnaXZlbiBwYXRoLlxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS52aWV3cyA9IGZ1bmN0aW9uIChwYXRobmFtZSwgc3RhdGUpIHtcclxuICAgICAgICBpZiAocGF0aG5hbWUgPT09IHZvaWQgMCkgeyBwYXRobmFtZSA9IFwiZW50ZXJpbmdcIjsgfVxyXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdO1xyXG4gICAgICAgIHBhdGggPSAhc3RhdGUgPyBwYXRoIDogcGF0aC5maWx0ZXIoaG9mXzEucHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGgubWFwKGhvZl8xLnByb3AoXCJ2aWV3c1wiKSkuZmlsdGVyKGNvbW1vbl8xLmlkZW50aXR5KS5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pO1xyXG4gICAgfTtcclxuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnRyZWVDaGFuZ2VzID0gZnVuY3Rpb24gKHBhdGhuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lID8gdGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdIDogdGhpcy5fdHJlZUNoYW5nZXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRyYW5zaXRpb24gdGhhdCBpcyBhIHJlZGlyZWN0aW9uIG9mIHRoZSBjdXJyZW50IG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHRyYW5zaXRpb24gY2FuIGJlIHJldHVybmVkIGZyb20gYSBbW1RyYW5zaXRpb25TZXJ2aWNlXV0gaG9vayB0b1xyXG4gICAgICogcmVkaXJlY3QgYSB0cmFuc2l0aW9uIHRvIGEgbmV3IHN0YXRlIGFuZC9vciBzZXQgb2YgcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxhcGlcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgbmV3IFtbVHJhbnNpdGlvbl1dIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5yZWRpcmVjdCA9IGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xyXG4gICAgICAgIHZhciByZWRpcmVjdHMgPSAxLCB0cmFucyA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKCh0cmFucyA9IHRyYW5zLnJlZGlyZWN0ZWRGcm9tKCkpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKCsrcmVkaXJlY3RzID4gMjApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbWFueSBjb25zZWN1dGl2ZSBUcmFuc2l0aW9uIHJlZGlyZWN0cyAoMjArKVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlZGlyZWN0T3B0cyA9IHsgcmVkaXJlY3RlZEZyb206IHRoaXMsIHNvdXJjZTogXCJyZWRpcmVjdFwiIH07XHJcbiAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gd2FzIGNhdXNlZCBieSBVUkwgc3luYywgdGhlbiB1c2UgeyBsb2NhdGlvbjogJ3JlcGxhY2UnIH1cclxuICAgICAgICAvLyBvbiB0aGUgbmV3IHRyYW5zaXRpb24gKHVubGVzcyB0aGUgdGFyZ2V0IHN0YXRlIGV4cGxpY2l0bHkgc3BlY2lmaWVzIGxvY2F0aW9uOiBmYWxzZSkuXHJcbiAgICAgICAgLy8gVGhpcyBjYXVzZXMgdGhlIG9yaWdpbmFsIHVybCB0byBiZSByZXBsYWNlZCB3aXRoIHRoZSB1cmwgZm9yIHRoZSByZWRpcmVjdCB0YXJnZXRcclxuICAgICAgICAvLyBzbyB0aGUgb3JpZ2luYWwgdXJsIGRpc2FwcGVhcnMgZnJvbSB0aGUgYnJvd3NlciBoaXN0b3J5LlxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMoKS5zb3VyY2UgPT09ICd1cmwnICYmIHRhcmdldFN0YXRlLm9wdGlvbnMoKS5sb2NhdGlvbiAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmVkaXJlY3RPcHRzLmxvY2F0aW9uID0gJ3JlcGxhY2UnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IGNvbW1vbl8xLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKCksIHRhcmdldFN0YXRlLm9wdGlvbnMoKSwgcmVkaXJlY3RPcHRzKTtcclxuICAgICAgICB0YXJnZXRTdGF0ZSA9IG5ldyB0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKHRhcmdldFN0YXRlLmlkZW50aWZpZXIoKSwgdGFyZ2V0U3RhdGUuJHN0YXRlKCksIHRhcmdldFN0YXRlLnBhcmFtcygpLCBuZXdPcHRpb25zKTtcclxuICAgICAgICB2YXIgbmV3VHJhbnNpdGlvbiA9IHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLmNyZWF0ZSh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tLCB0YXJnZXRTdGF0ZSk7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsRW50ZXJpbmdOb2RlcyA9IHRoaXMuX3RyZWVDaGFuZ2VzLmVudGVyaW5nO1xyXG4gICAgICAgIHZhciByZWRpcmVjdEVudGVyaW5nTm9kZXMgPSBuZXdUcmFuc2l0aW9uLl90cmVlQ2hhbmdlcy5lbnRlcmluZztcclxuICAgICAgICAvLyAtLS0gUmUtdXNlIHJlc29sdmUgZGF0YSBmcm9tIG9yaWdpbmFsIHRyYW5zaXRpb24gLS0tXHJcbiAgICAgICAgLy8gV2hlbiByZWRpcmVjdGluZyBmcm9tIGEgcGFyZW50IHN0YXRlIHRvIGEgY2hpbGQgc3RhdGUgd2hlcmUgdGhlIHBhcmVudCBwYXJhbWV0ZXIgdmFsdWVzIGhhdmVuJ3QgY2hhbmdlZFxyXG4gICAgICAgIC8vIChiZWNhdXNlIG9mIHRoZSByZWRpcmVjdCksIHRoZSByZXNvbHZlcyBmZXRjaGVkIGJ5IHRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIGFyZSBzdGlsbCB2YWxpZCBpbiB0aGVcclxuICAgICAgICAvLyByZWRpcmVjdGVkIHRyYW5zaXRpb24uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUaGlzIGFsbG93cyB5b3UgdG8gZGVmaW5lIGEgcmVkaXJlY3Qgb24gYSBwYXJlbnQgc3RhdGUgd2hpY2ggZGVwZW5kcyBvbiBhbiBhc3luYyByZXNvbHZlIHZhbHVlLlxyXG4gICAgICAgIC8vIFlvdSBjYW4gd2FpdCBmb3IgdGhlIHJlc29sdmUsIHRoZW4gcmVkaXJlY3QgdG8gYSBjaGlsZCBzdGF0ZSBiYXNlZCBvbiB0aGUgcmVzdWx0LlxyXG4gICAgICAgIC8vIFRoZSByZWRpcmVjdGVkIHRyYW5zaXRpb24gZG9lcyBub3QgaGF2ZSB0byByZS1mZXRjaCB0aGUgcmVzb2x2ZS5cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICB2YXIgbm9kZUlzUmVsb2FkaW5nID0gZnVuY3Rpb24gKHJlbG9hZFN0YXRlKSB7IHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVsb2FkU3RhdGUgJiYgbm9kZS5zdGF0ZS5pbmNsdWRlc1tyZWxvYWRTdGF0ZS5uYW1lXTtcclxuICAgICAgICB9OyB9O1xyXG4gICAgICAgIC8vIEZpbmQgYW55IFwiZW50ZXJpbmdcIiBub2RlcyBpbiB0aGUgcmVkaXJlY3QgcGF0aCB0aGF0IG1hdGNoIHRoZSBvcmlnaW5hbCBwYXRoIGFuZCBhcmVuJ3QgYmVpbmcgcmVsb2FkZWRcclxuICAgICAgICB2YXIgbWF0Y2hpbmdFbnRlcmluZ05vZGVzID0gcGF0aEZhY3RvcnlfMS5QYXRoVXRpbHMubWF0Y2hpbmcocmVkaXJlY3RFbnRlcmluZ05vZGVzLCBvcmlnaW5hbEVudGVyaW5nTm9kZXMsIHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLm5vbkR5bmFtaWNQYXJhbXMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoaG9mXzEubm90KG5vZGVJc1JlbG9hZGluZyh0YXJnZXRTdGF0ZS5vcHRpb25zKCkucmVsb2FkU3RhdGUpKSk7XHJcbiAgICAgICAgLy8gVXNlIHRoZSBleGlzdGluZyAocG9zc2libHkgcHJlLXJlc29sdmVkKSByZXNvbHZhYmxlcyBmb3IgdGhlIG1hdGNoaW5nIGVudGVyaW5nIG5vZGVzLlxyXG4gICAgICAgIG1hdGNoaW5nRW50ZXJpbmdOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpZHgpIHtcclxuICAgICAgICAgICAgbm9kZS5yZXNvbHZhYmxlcyA9IG9yaWdpbmFsRW50ZXJpbmdOb2Rlc1tpZHhdLnJlc29sdmFibGVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXdUcmFuc2l0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaGlkZGVuIElmIGEgdHJhbnNpdGlvbiBkb2Vzbid0IGV4aXQvZW50ZXIgYW55IHN0YXRlcywgcmV0dXJucyBhbnkgW1tQYXJhbV1dIHdob3NlIHZhbHVlIGNoYW5nZWQgKi9cclxuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLl9jaGFuZ2VkUGFyYW1zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0YyA9IHRoaXMuX3RyZWVDaGFuZ2VzO1xyXG4gICAgICAgIC8qKiBSZXR1cm4gdW5kZWZpbmVkIGlmIGl0J3Mgbm90IGEgXCJkeW5hbWljXCIgdHJhbnNpdGlvbiwgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29ucyAqL1xyXG4gICAgICAgIC8vIElmIHVzZXIgZXhwbGljaXRseSB3YW50cyBhIHJlbG9hZFxyXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnJlbG9hZClcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAvLyBJZiBhbnkgc3RhdGVzIGFyZSBleGl0aW5nIG9yIGVudGVyaW5nXHJcbiAgICAgICAgaWYgKHRjLmV4aXRpbmcubGVuZ3RoIHx8IHRjLmVudGVyaW5nLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAvLyBJZiB0by9mcm9tIHBhdGggbGVuZ3RocyBkaWZmZXJcclxuICAgICAgICBpZiAodGMudG8ubGVuZ3RoICE9PSB0Yy5mcm9tLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAvLyBJZiB0aGUgdG8vZnJvbSBwYXRocyBhcmUgZGlmZmVyZW50XHJcbiAgICAgICAgdmFyIHBhdGhzRGlmZmVyID0gY29tbW9uXzEuYXJyYXlUdXBsZXModGMudG8sIHRjLmZyb20pXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiB0dXBsZVswXS5zdGF0ZSAhPT0gdHVwbGVbMV0uc3RhdGU7IH0pXHJcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEuYW55VHJ1ZVIsIGZhbHNlKTtcclxuICAgICAgICBpZiAocGF0aHNEaWZmZXIpXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gRmluZCBhbnkgcGFyYW1ldGVyIHZhbHVlcyB0aGF0IGRpZmZlclxyXG4gICAgICAgIHZhciBub2RlU2NoZW1hcyA9IHRjLnRvLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5wYXJhbVNjaGVtYTsgfSk7XHJcbiAgICAgICAgdmFyIF9hID0gW3RjLnRvLCB0Yy5mcm9tXS5tYXAoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHBhdGgubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnBhcmFtVmFsdWVzOyB9KTsgfSksIHRvVmFsdWVzID0gX2FbMF0sIGZyb21WYWx1ZXMgPSBfYVsxXTtcclxuICAgICAgICB2YXIgdHVwbGVzID0gY29tbW9uXzEuYXJyYXlUdXBsZXMobm9kZVNjaGVtYXMsIHRvVmFsdWVzLCBmcm9tVmFsdWVzKTtcclxuICAgICAgICByZXR1cm4gdHVwbGVzLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IF9hWzBdLCB0b1ZhbHMgPSBfYVsxXSwgZnJvbVZhbHMgPSBfYVsyXTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtXzEuUGFyYW0uY2hhbmdlZChzY2hlbWEsIHRvVmFscywgZnJvbVZhbHMpO1xyXG4gICAgICAgIH0pLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zaXRpb24gaXMgZHluYW1pYy5cclxuICAgICAqXHJcbiAgICAgKiBBIHRyYW5zaXRpb24gaXMgZHluYW1pYyBpZiBubyBzdGF0ZXMgYXJlIGVudGVyZWQgbm9yIGV4aXRlZCwgYnV0IGF0IGxlYXN0IG9uZSBkeW5hbWljIHBhcmFtZXRlciBoYXMgY2hhbmdlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBUcmFuc2l0aW9uIGlzIGR5bmFtaWNcclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZHluYW1pYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZWRQYXJhbXMoKTtcclxuICAgICAgICByZXR1cm4gIWNoYW5nZXMgPyBmYWxzZSA6IGNoYW5nZXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmR5bmFtaWM7IH0pLnJlZHVjZShjb21tb25fMS5hbnlUcnVlUiwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGlnbm9yZWQuXHJcbiAgICAgKlxyXG4gICAgICogQSB0cmFuc2l0aW9uIGlzIGlnbm9yZWQgaWYgbm8gc3RhdGVzIGFyZSBlbnRlcmVkIG5vciBleGl0ZWQsIGFuZCBubyBwYXJhbWV0ZXIgdmFsdWVzIGhhdmUgY2hhbmdlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBUcmFuc2l0aW9uIGlzIGlnbm9yZWQuXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmlnbm9yZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5faWdub3JlZFJlYXNvbigpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5faWdub3JlZFJlYXNvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGVuZGluZyA9IHRoaXMucm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbjtcclxuICAgICAgICB2YXIgcmVsb2FkU3RhdGUgPSB0aGlzLl9vcHRpb25zLnJlbG9hZFN0YXRlO1xyXG4gICAgICAgIHZhciBzYW1lID0gZnVuY3Rpb24gKHBhdGhBLCBwYXRoQikge1xyXG4gICAgICAgICAgICBpZiAocGF0aEEubGVuZ3RoICE9PSBwYXRoQi5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGluZyA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLm1hdGNoaW5nKHBhdGhBLCBwYXRoQik7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoQS5sZW5ndGggPT09IG1hdGNoaW5nLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gIXJlbG9hZFN0YXRlIHx8ICFub2RlLnN0YXRlLmluY2x1ZGVzW3JlbG9hZFN0YXRlLm5hbWVdOyB9KS5sZW5ndGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgbmV3VEMgPSB0aGlzLnRyZWVDaGFuZ2VzKCk7XHJcbiAgICAgICAgdmFyIHBlbmRUQyA9IHBlbmRpbmcgJiYgcGVuZGluZy50cmVlQ2hhbmdlcygpO1xyXG4gICAgICAgIGlmIChwZW5kVEMgJiYgc2FtZShwZW5kVEMudG8sIG5ld1RDLnRvKSAmJiBzYW1lKHBlbmRUQy5leGl0aW5nLCBuZXdUQy5leGl0aW5nKSlcclxuICAgICAgICAgICAgcmV0dXJuIFwiU2FtZUFzUGVuZGluZ1wiO1xyXG4gICAgICAgIGlmIChuZXdUQy5leGl0aW5nLmxlbmd0aCA9PT0gMCAmJiBuZXdUQy5lbnRlcmluZy5sZW5ndGggPT09IDAgJiYgc2FtZShuZXdUQy5mcm9tLCBuZXdUQy50bykpXHJcbiAgICAgICAgICAgIHJldHVybiBcIlNhbWVBc0N1cnJlbnRcIjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgdGhlIHRyYW5zaXRpb25cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBnZW5lcmFsbHkgY2FsbGVkIGZyb20gdGhlIFtbU3RhdGVTZXJ2aWNlLnRyYW5zaXRpb25Ub11dXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsYXBpXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlIGZvciBhIHN1Y2Nlc3NmdWwgdHJhbnNpdGlvbi5cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJ1bkFsbEhvb2tzID0gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5ydW5BbGxIb29rcztcclxuICAgICAgICAvLyBHZXRzIHRyYW5zaXRpb24gaG9va3MgYXJyYXkgZm9yIHRoZSBnaXZlbiBwaGFzZVxyXG4gICAgICAgIHZhciBnZXRIb29rc0ZvciA9IGZ1bmN0aW9uIChwaGFzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2hvb2tCdWlsZGVyLmJ1aWxkSG9va3NGb3JQaGFzZShwaGFzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBXaGVuIHRoZSBjaGFpbiBpcyBjb21wbGV0ZSwgdGhlbiByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWRcclxuICAgICAgICB2YXIgdHJhbnNpdGlvblN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VTdWNjZXNzKF90aGlzLiR0bygpLCBfdGhpcyk7XHJcbiAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICBfdGhpcy5fZGVmZXJyZWQucmVzb2x2ZShfdGhpcy50bygpKTtcclxuICAgICAgICAgICAgcnVuQWxsSG9va3MoZ2V0SG9va3NGb3IoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5TVUNDRVNTKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdHJhbnNpdGlvbkVycm9yID0gZnVuY3Rpb24gKHJlYXNvbikge1xyXG4gICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlRXJyb3IocmVhc29uLCBfdGhpcyk7XHJcbiAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX2RlZmVycmVkLnJlamVjdChyZWFzb24pO1xyXG4gICAgICAgICAgICBfdGhpcy5fZXJyb3IgPSByZWFzb247XHJcbiAgICAgICAgICAgIHJ1bkFsbEhvb2tzKGdldEhvb2tzRm9yKGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuRVJST1IpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBydW5UcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBXYWl0IHRvIGJ1aWxkIHRoZSBSVU4gaG9vayBjaGFpbiB1bnRpbCB0aGUgQkVGT1JFIGhvb2tzIGFyZSBkb25lXHJcbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIGEgQkVGT1JFIGhvb2sgdG8gZHluYW1pY2FsbHkgYWRkIGFkZGl0aW9uYWwgUlVOIGhvb2tzIHZpYSB0aGUgVHJhbnNpdGlvbiBvYmplY3QuXHJcbiAgICAgICAgICAgIHZhciBhbGxSdW5Ib29rcyA9IGdldEhvb2tzRm9yKGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuUlVOKTtcclxuICAgICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKHVuZGVmaW5lZCk7IH07XHJcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzKGFsbFJ1bkhvb2tzLCBkb25lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBnbG9iYWxzID0gX3RoaXMucm91dGVyLmdsb2JhbHM7XHJcbiAgICAgICAgICAgIGdsb2JhbHMubGFzdFN0YXJ0ZWRUcmFuc2l0aW9uSWQgPSBfdGhpcy4kaWQ7XHJcbiAgICAgICAgICAgIGdsb2JhbHMudHJhbnNpdGlvbiA9IF90aGlzO1xyXG4gICAgICAgICAgICBnbG9iYWxzLnRyYW5zaXRpb25IaXN0b3J5LmVucXVldWUoX3RoaXMpO1xyXG4gICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVHJhbnNpdGlvblN0YXJ0KF90aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4odW5kZWZpbmVkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBhbGxCZWZvcmVIb29rcyA9IGdldEhvb2tzRm9yKGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuQkVGT1JFKTtcclxuICAgICAgICB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzKGFsbEJlZm9yZUhvb2tzLCBzdGFydFRyYW5zaXRpb24pXHJcbiAgICAgICAgICAgIC50aGVuKHJ1blRyYW5zaXRpb24pXHJcbiAgICAgICAgICAgIC50aGVuKHRyYW5zaXRpb25TdWNjZXNzLCB0cmFuc2l0aW9uRXJyb3IpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIFRyYW5zaXRpb24gaXMgdmFsaWRcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBUcmFuc2l0aW9uIGlzIHZhbGlkXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnZhbGlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5lcnJvcigpIHx8IHRoaXMuc3VjY2VzcyAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWJvcnRzIHRoaXMgdHJhbnNpdGlvblxyXG4gICAgICpcclxuICAgICAqIEltcGVyYXRpdmUgQVBJIHRvIGFib3J0IGEgVHJhbnNpdGlvbi5cclxuICAgICAqIFRoaXMgb25seSBhcHBsaWVzIHRvIFRyYW5zaXRpb25zIHRoYXQgYXJlIG5vdCB5ZXQgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdCBzZXQgZmxhZyBpZiB0aGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGNvbXBsZXRlXHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1VuZGVmaW5lZCh0aGlzLnN1Y2Nlc3MpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBUcmFuc2l0aW9uIGVycm9yIHJlYXNvbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGUgdHJhbnNpdGlvbiBpcyBpbnZhbGlkIChhbmQgY291bGQgbm90IGJlIHJ1biksIHJldHVybnMgdGhlIHJlYXNvbiB0aGUgdHJhbnNpdGlvbiBpcyBpbnZhbGlkLlxyXG4gICAgICogSWYgdGhlIHRyYW5zaXRpb24gd2FzIHZhbGlkIGFuZCByYW4sIGJ1dCB3YXMgbm90IHN1Y2Nlc3NmdWwsIHJldHVybnMgdGhlIHJlYXNvbiB0aGUgdHJhbnNpdGlvbiBmYWlsZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYW4gZXJyb3IgbWVzc2FnZSBleHBsYWluaW5nIHdoeSB0aGUgdHJhbnNpdGlvbiBpcyBpbnZhbGlkLCBvciB0aGUgcmVhc29uIHRoZSB0cmFuc2l0aW9uIGZhaWxlZC5cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy4kdG8oKTtcclxuICAgICAgICBpZiAoc3RhdGUuc2VsZi5hYnN0cmFjdClcclxuICAgICAgICAgICAgcmV0dXJuIFwiQ2Fubm90IHRyYW5zaXRpb24gdG8gYWJzdHJhY3Qgc3RhdGUgJ1wiICsgc3RhdGUubmFtZSArIFwiJ1wiO1xyXG4gICAgICAgIGlmICghcGFyYW1fMS5QYXJhbS52YWxpZGF0ZXMoc3RhdGUucGFyYW1ldGVycygpLCB0aGlzLnBhcmFtcygpKSlcclxuICAgICAgICAgICAgcmV0dXJuIFwiUGFyYW0gdmFsdWVzIG5vdCB2YWxpZCBmb3Igc3RhdGUgJ1wiICsgc3RhdGUubmFtZSArIFwiJ1wiO1xyXG4gICAgICAgIGlmICh0aGlzLnN1Y2Nlc3MgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNpdGlvblxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUcmFuc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmcm9tU3RhdGVPck5hbWUgPSB0aGlzLmZyb20oKTtcclxuICAgICAgICB2YXIgdG9TdGF0ZU9yTmFtZSA9IHRoaXMudG8oKTtcclxuICAgICAgICB2YXIgYXZvaWRFbXB0eUhhc2ggPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocGFyYW1zW1wiI1wiXSAhPT0gbnVsbCAmJiBwYXJhbXNbXCIjXCJdICE9PSB1bmRlZmluZWQpID8gcGFyYW1zIDogY29tbW9uXzEub21pdChwYXJhbXMsIFtcIiNcIl0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gKFgpIG1lYW5zIHRoZSB0byBzdGF0ZSBpcyBpbnZhbGlkLlxyXG4gICAgICAgIHZhciBpZCA9IHRoaXMuJGlkLCBmcm9tID0gcHJlZGljYXRlc18xLmlzT2JqZWN0KGZyb21TdGF0ZU9yTmFtZSkgPyBmcm9tU3RhdGVPck5hbWUubmFtZSA6IGZyb21TdGF0ZU9yTmFtZSwgZnJvbVBhcmFtcyA9IGNvbW1vbl8xLnRvSnNvbihhdm9pZEVtcHR5SGFzaCh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tLm1hcChob2ZfMS5wcm9wKCdwYXJhbVZhbHVlcycpKS5yZWR1Y2UoY29tbW9uXzEubWVyZ2VSLCB7fSkpKSwgdG9WYWxpZCA9IHRoaXMudmFsaWQoKSA/IFwiXCIgOiBcIihYKSBcIiwgdG8gPSBwcmVkaWNhdGVzXzEuaXNPYmplY3QodG9TdGF0ZU9yTmFtZSkgPyB0b1N0YXRlT3JOYW1lLm5hbWUgOiB0b1N0YXRlT3JOYW1lLCB0b1BhcmFtcyA9IGNvbW1vbl8xLnRvSnNvbihhdm9pZEVtcHR5SGFzaCh0aGlzLnBhcmFtcygpKSk7XHJcbiAgICAgICAgcmV0dXJuIFwiVHJhbnNpdGlvbiNcIiArIGlkICsgXCIoICdcIiArIGZyb20gKyBcIidcIiArIGZyb21QYXJhbXMgKyBcIiAtPiBcIiArIHRvVmFsaWQgKyBcIidcIiArIHRvICsgXCInXCIgKyB0b1BhcmFtcyArIFwiIClcIjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVHJhbnNpdGlvbjtcclxufSgpKTtcclxuLyoqIEBoaWRkZW4gKi9cclxuVHJhbnNpdGlvbi5kaVRva2VuID0gVHJhbnNpdGlvbjtcclxuZXhwb3J0cy5UcmFuc2l0aW9uID0gVHJhbnNpdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNpdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3RyYW5zaXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBAY29yZWFwaVxyXG4gKiBAbW9kdWxlIHVybFxyXG4gKi9cclxuLyoqIGZvciB0eXBlZG9jICovXHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xyXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcclxudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcclxudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi4vcGFyYW1zL3BhcmFtXCIpO1xyXG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xyXG4vKiogQGhpZGRlbiAqL1xyXG5mdW5jdGlvbiBxdW90ZVJlZ0V4cChzdHJpbmcsIHBhcmFtKSB7XHJcbiAgICB2YXIgc3Vycm91bmRQYXR0ZXJuID0gWycnLCAnJ10sIHJlc3VsdCA9IHN0cmluZy5yZXBsYWNlKC9bXFxcXFxcW1xcXVxcXiQqKz8uKCl8e31dL2csIFwiXFxcXCQmXCIpO1xyXG4gICAgaWYgKCFwYXJhbSlcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgc3dpdGNoIChwYXJhbS5zcXVhc2gpIHtcclxuICAgICAgICBjYXNlIGZhbHNlOlxyXG4gICAgICAgICAgICBzdXJyb3VuZFBhdHRlcm4gPSBbJygnLCAnKScgKyAocGFyYW0uaXNPcHRpb25hbCA/ICc/JyA6ICcnKV07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgdHJ1ZTpcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xcLyQvLCAnJyk7XHJcbiAgICAgICAgICAgIHN1cnJvdW5kUGF0dGVybiA9IFsnKD86XFwvKCcsICcpfFxcLyk/J107XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHN1cnJvdW5kUGF0dGVybiA9IFtcIihcIiArIHBhcmFtLnNxdWFzaCArIFwifFwiLCAnKT8nXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0ICsgc3Vycm91bmRQYXR0ZXJuWzBdICsgcGFyYW0udHlwZS5wYXR0ZXJuLnNvdXJjZSArIHN1cnJvdW5kUGF0dGVyblsxXTtcclxufVxyXG4vKiogQGhpZGRlbiAqL1xyXG52YXIgbWVtb2l6ZVRvID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgZm4pIHtcclxuICAgIHJldHVybiBvYmpbcHJvcF0gPSBvYmpbcHJvcF0gfHwgZm4oKTtcclxufTtcclxuLyoqIEBoaWRkZW4gKi9cclxudmFyIHNwbGl0T25TbGFzaCA9IHN0cmluZ3NfMS5zcGxpdE9uRGVsaW0oJy8nKTtcclxuLyoqXHJcbiAqIE1hdGNoZXMgVVJMcyBhZ2FpbnN0IHBhdHRlcm5zLlxyXG4gKlxyXG4gKiBNYXRjaGVzIFVSTHMgYWdhaW5zdCBwYXR0ZXJucyBhbmQgZXh0cmFjdHMgbmFtZWQgcGFyYW1ldGVycyBmcm9tIHRoZSBwYXRoIG9yIHRoZSBzZWFyY2hcclxuICogcGFydCBvZiB0aGUgVVJMLlxyXG4gKlxyXG4gKiBBIFVSTCBwYXR0ZXJuIGNvbnNpc3RzIG9mIGEgcGF0aCBwYXR0ZXJuLCBvcHRpb25hbGx5IGZvbGxvd2VkIGJ5ICc/JyBhbmQgYSBsaXN0IG9mIHNlYXJjaCAocXVlcnkpXHJcbiAqIHBhcmFtZXRlcnMuIE11bHRpcGxlIHNlYXJjaCBwYXJhbWV0ZXIgbmFtZXMgYXJlIHNlcGFyYXRlZCBieSAnJicuIFNlYXJjaCBwYXJhbWV0ZXJzXHJcbiAqIGRvIG5vdCBpbmZsdWVuY2Ugd2hldGhlciBvciBub3QgYSBVUkwgaXMgbWF0Y2hlZCwgYnV0IHRoZWlyIHZhbHVlcyBhcmUgcGFzc2VkIHRocm91Z2ggaW50b1xyXG4gKiB0aGUgbWF0Y2hlZCBwYXJhbWV0ZXJzIHJldHVybmVkIGJ5IFtbVXJsTWF0Y2hlci5leGVjXV0uXHJcbiAqXHJcbiAqIC0gKlBhdGggcGFyYW1ldGVycyogYXJlIGRlZmluZWQgdXNpbmcgY3VybHkgYnJhY2UgcGxhY2Vob2xkZXJzIChgL3NvbWVwYXRoL3twYXJhbX1gKVxyXG4gKiBvciBjb2xvbiBwbGFjZWhvbGRlcnMgKGAvc29tZVBhdGgvOnBhcmFtYCkuXHJcbiAqXHJcbiAqIC0gKkEgcGFyYW1ldGVyIFJlZ0V4cCogbWF5IGJlIGRlZmluZWQgZm9yIGEgcGFyYW0gYWZ0ZXIgYSBjb2xvblxyXG4gKiAoYC9zb21lUGF0aC97cGFyYW06W2EtekEtWjAtOV0rfWApIGluIGEgY3VybHkgYnJhY2UgcGxhY2Vob2xkZXIuXHJcbiAqIFRoZSByZWdleHAgbXVzdCBtYXRjaCBmb3IgdGhlIHVybCB0byBiZSBtYXRjaGVkLlxyXG4gKiBTaG91bGQgdGhlIHJlZ2V4cCBpdHNlbGYgY29udGFpbiBjdXJseSBicmFjZXMsIHRoZXkgbXVzdCBiZSBpbiBtYXRjaGVkIHBhaXJzIG9yIGVzY2FwZWQgd2l0aCBhIGJhY2tzbGFzaC5cclxuICpcclxuICogTm90ZTogYSBSZWdFeHAgcGFyYW1ldGVyIHdpbGwgZW5jb2RlIGl0cyB2YWx1ZSB1c2luZyBlaXRoZXIgW1tQYXJhbVR5cGVzLnBhdGhdXSBvciBbW1BhcmFtVHlwZXMucXVlcnldXS5cclxuICpcclxuICogLSAqQ3VzdG9tIHBhcmFtZXRlciB0eXBlcyogbWF5IGFsc28gYmUgc3BlY2lmaWVkIGFmdGVyIGEgY29sb24gKGAvc29tZVBhdGgve3BhcmFtOmludH1gKSBpbiBjdXJseSBicmFjZSBwYXJhbWV0ZXJzLlxyXG4gKiAgIFNlZSBbW1VybE1hdGNoZXJGYWN0b3J5LnR5cGVdXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICpcclxuICogLSAqQ2F0Y2gtYWxsIHBhcmFtZXRlcnMqIGFyZSBkZWZpbmVkIHVzaW5nIGFuIGFzdGVyaXNrIHBsYWNlaG9sZGVyIChgL3NvbWVwYXRoLypjYXRjaGFsbHBhcmFtYCkuXHJcbiAqICAgQSBjYXRjaC1hbGwgKiBwYXJhbWV0ZXIgdmFsdWUgd2lsbCBjb250YWluIHRoZSByZW1haW5kZXIgb2YgdGhlIFVSTC5cclxuICpcclxuICogLS0tXHJcbiAqXHJcbiAqIFBhcmFtZXRlciBuYW1lcyBtYXkgY29udGFpbiBvbmx5IHdvcmQgY2hhcmFjdGVycyAobGF0aW4gbGV0dGVycywgZGlnaXRzLCBhbmQgdW5kZXJzY29yZSkgYW5kXHJcbiAqIG11c3QgYmUgdW5pcXVlIHdpdGhpbiB0aGUgcGF0dGVybiAoYWNyb3NzIGJvdGggcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMpLlxyXG4gKiBBIHBhdGggcGFyYW1ldGVyIG1hdGNoZXMgYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gJy8nLiBGb3IgY2F0Y2gtYWxsXHJcbiAqIHBsYWNlaG9sZGVycyB0aGUgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlcyBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXHJcbiAqXHJcbiAqIEV4YW1wbGVzOlxyXG4gKlxyXG4gKiAqIGAnL2hlbGxvLydgIC0gTWF0Y2hlcyBvbmx5IGlmIHRoZSBwYXRoIGlzIGV4YWN0bHkgJy9oZWxsby8nLiBUaGVyZSBpcyBubyBzcGVjaWFsIHRyZWF0bWVudCBmb3JcclxuICogICB0cmFpbGluZyBzbGFzaGVzLCBhbmQgcGF0dGVybnMgaGF2ZSB0byBtYXRjaCB0aGUgZW50aXJlIHBhdGgsIG5vdCBqdXN0IGEgcHJlZml4LlxyXG4gKiAqIGAnL3VzZXIvOmlkJ2AgLSBNYXRjaGVzICcvdXNlci9ib2InIG9yICcvdXNlci8xMjM0ISEhJyBvciBldmVuICcvdXNlci8nIGJ1dCBub3QgJy91c2VyJyBvclxyXG4gKiAgICcvdXNlci9ib2IvZGV0YWlscycuIFRoZSBzZWNvbmQgcGF0aCBzZWdtZW50IHdpbGwgYmUgY2FwdHVyZWQgYXMgdGhlIHBhcmFtZXRlciAnaWQnLlxyXG4gKiAqIGAnL3VzZXIve2lkfSdgIC0gU2FtZSBhcyB0aGUgcHJldmlvdXMgZXhhbXBsZSwgYnV0IHVzaW5nIGN1cmx5IGJyYWNlIHN5bnRheC5cclxuICogKiBgJy91c2VyL3tpZDpbXi9dKn0nYCAtIFNhbWUgYXMgdGhlIHByZXZpb3VzIGV4YW1wbGUuXHJcbiAqICogYCcvdXNlci97aWQ6WzAtOWEtZkEtRl17MSw4fX0nYCAtIFNpbWlsYXIgdG8gdGhlIHByZXZpb3VzIGV4YW1wbGUsIGJ1dCBvbmx5IG1hdGNoZXMgaWYgdGhlIGlkXHJcbiAqICAgcGFyYW1ldGVyIGNvbnNpc3RzIG9mIDEgdG8gOCBoZXggZGlnaXRzLlxyXG4gKiAqIGAnL2ZpbGVzL3twYXRoOi4qfSdgIC0gTWF0Y2hlcyBhbnkgVVJMIHN0YXJ0aW5nIHdpdGggJy9maWxlcy8nIGFuZCBjYXB0dXJlcyB0aGUgcmVzdCBvZiB0aGVcclxuICogICBwYXRoIGludG8gdGhlIHBhcmFtZXRlciAncGF0aCcuXHJcbiAqICogYCcvZmlsZXMvKnBhdGgnYCAtIGRpdHRvLlxyXG4gKiAqIGAnL2NhbGVuZGFyL3tzdGFydDpkYXRlfSdgIC0gTWF0Y2hlcyBcIi9jYWxlbmRhci8yMDE0LTExLTEyXCIgKGJlY2F1c2UgdGhlIHBhdHRlcm4gZGVmaW5lZFxyXG4gKiAgIGluIHRoZSBidWlsdC1pbiAgYGRhdGVgIFBhcmFtVHlwZSBtYXRjaGVzIGAyMDE0LTExLTEyYCkgYW5kIHByb3ZpZGVzIGEgRGF0ZSBvYmplY3QgaW4gJHN0YXRlUGFyYW1zLnN0YXJ0XHJcbiAqXHJcbiAqL1xyXG52YXIgVXJsTWF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIGNvbXBpbGUgaW50byBhIG1hdGNoZXIuXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1UeXBlcyBUaGUgW1tQYXJhbVR5cGVzXV0gcmVnaXN0cnlcclxuICAgICAqIEBwYXJhbSBjb25maWcgIEEgY29uZmlndXJhdGlvbiBvYmplY3RcclxuICAgICAqIC0gYGNhc2VJbnNlbnNpdGl2ZWAgLSBgdHJ1ZWAgaWYgVVJMIG1hdGNoaW5nIHNob3VsZCBiZSBjYXNlIGluc2Vuc2l0aXZlLCBvdGhlcndpc2UgYGZhbHNlYCwgdGhlIGRlZmF1bHQgdmFsdWUgKGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KSBpcyBgZmFsc2VgLlxyXG4gICAgICogLSBgc3RyaWN0YCAtIGBmYWxzZWAgaWYgbWF0Y2hpbmcgYWdhaW5zdCBhIFVSTCB3aXRoIGEgdHJhaWxpbmcgc2xhc2ggc2hvdWxkIGJlIHRyZWF0ZWQgYXMgZXF1aXZhbGVudCB0byBhIFVSTCB3aXRob3V0IGEgdHJhaWxpbmcgc2xhc2gsIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVXJsTWF0Y2hlcihwYXR0ZXJuLCBwYXJhbVR5cGVzLCBwYXJhbUZhY3RvcnksIGNvbmZpZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cclxuICAgICAgICB0aGlzLl9jYWNoZSA9IHsgcGF0aDogW3RoaXNdIH07XHJcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cclxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICAgICAgdGhpcy5fcGFyYW1zID0gW107XHJcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cclxuICAgICAgICB0aGlzLl9zZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICAgICAgdGhpcy5fY29tcGlsZWQgPSBbXTtcclxuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29tbW9uXzEuZGVmYXVsdHModGhpcy5jb25maWcsIHtcclxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcclxuICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxyXG4gICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBwYXJhbU1hcDogY29tbW9uXzEuaWRlbnRpdHlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBGaW5kIGFsbCBwbGFjZWhvbGRlcnMgYW5kIGNyZWF0ZSBhIGNvbXBpbGVkIHBhdHRlcm4sIHVzaW5nIGVpdGhlciBjbGFzc2ljIG9yIGN1cmx5IHN5bnRheDpcclxuICAgICAgICAvLyAgICcqJyBuYW1lXHJcbiAgICAgICAgLy8gICAnOicgbmFtZVxyXG4gICAgICAgIC8vICAgJ3snIG5hbWUgJ30nXHJcbiAgICAgICAgLy8gICAneycgbmFtZSAnOicgcmVnZXhwICd9J1xyXG4gICAgICAgIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gaXMgc29tZXdoYXQgY29tcGxpY2F0ZWQgZHVlIHRvIHRoZSBuZWVkIHRvIGFsbG93IGN1cmx5IGJyYWNlc1xyXG4gICAgICAgIC8vIGluc2lkZSB0aGUgcmVndWxhciBleHByZXNzaW9uLiBUaGUgcGxhY2Vob2xkZXIgcmVnZXhwIGJyZWFrcyBkb3duIGFzIGZvbGxvd3M6XHJcbiAgICAgICAgLy8gICAgKFs6Kl0pKFtcXHdcXFtcXF1dKykgICAgICAgICAgICAgIC0gY2xhc3NpYyBwbGFjZWhvbGRlciAoJDEgLyAkMikgKHNlYXJjaCB2ZXJzaW9uIGhhcyAtIGZvciBzbmFrZS1jYXNlKVxyXG4gICAgICAgIC8vICAgIFxceyhbXFx3XFxbXFxdXSspKD86XFw6XFxzKiggLi4uICkpP1xcfSAgLSBjdXJseSBicmFjZSBwbGFjZWhvbGRlciAoJDMpIHdpdGggb3B0aW9uYWwgcmVnZXhwL3R5cGUgLi4uICgkNCkgKHNlYXJjaCB2ZXJzaW9uIGhhcyAtIGZvciBzbmFrZS1jYXNlXHJcbiAgICAgICAgLy8gICAgKD86IC4uLiB8IC4uLiB8IC4uLiApKyAgICAgICAgIC0gdGhlIHJlZ2V4cCBjb25zaXN0cyBvZiBhbnkgbnVtYmVyIG9mIGF0b21zLCBhbiBhdG9tIGJlaW5nIGVpdGhlclxyXG4gICAgICAgIC8vICAgIFtee31cXFxcXSsgICAgICAgICAgICAgICAgICAgICAgIC0gYW55dGhpbmcgb3RoZXIgdGhhbiBjdXJseSBicmFjZXMgb3IgYmFja3NsYXNoXHJcbiAgICAgICAgLy8gICAgXFxcXC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBhIGJhY2tzbGFzaCBlc2NhcGVcclxuICAgICAgICAvLyAgICBcXHsoPzpbXnt9XFxcXF0rfFxcXFwuKSpcXH0gICAgICAgICAgLSBhIG1hdGNoZWQgc2V0IG9mIGN1cmx5IGJyYWNlcyBjb250YWluaW5nIG90aGVyIGF0b21zXHJcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gLyhbOipdKShbXFx3XFxbXFxdXSspfFxceyhbXFx3XFxbXFxdXSspKD86XFw6XFxzKigoPzpbXnt9XFxcXF0rfFxcXFwufFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSkrKSk/XFx9L2csIHNlYXJjaFBsYWNlaG9sZGVyID0gLyhbOl0/KShbXFx3XFxbXFxdLi1dKyl8XFx7KFtcXHdcXFtcXF0uLV0rKSg/OlxcOlxccyooKD86W157fVxcXFxdK3xcXFxcLnxcXHsoPzpbXnt9XFxcXF0rfFxcXFwuKSpcXH0pKykpP1xcfS9nLCBsYXN0ID0gMCwgbSwgcGF0dGVybnMgPSBbXTtcclxuICAgICAgICB2YXIgY2hlY2tQYXJhbUVycm9ycyA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICBpZiAoIVVybE1hdGNoZXIubmFtZVZhbGlkYXRvci50ZXN0KGlkKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyYW1ldGVyIG5hbWUgJ1wiICsgaWQgKyBcIicgaW4gcGF0dGVybiAnXCIgKyBwYXR0ZXJuICsgXCInXCIpO1xyXG4gICAgICAgICAgICBpZiAoY29tbW9uXzEuZmluZChfdGhpcy5fcGFyYW1zLCBob2ZfMS5wcm9wRXEoJ2lkJywgaWQpKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZSAnXCIgKyBpZCArIFwiJyBpbiBwYXR0ZXJuICdcIiArIHBhdHRlcm4gKyBcIidcIik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTcGxpdCBpbnRvIHN0YXRpYyBzZWdtZW50cyBzZXBhcmF0ZWQgYnkgcGF0aCBwYXJhbWV0ZXIgcGxhY2Vob2xkZXJzLlxyXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgaXMgYWx3YXlzIDEgbW9yZSB0aGFuIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycy5cclxuICAgICAgICB2YXIgbWF0Y2hEZXRhaWxzID0gZnVuY3Rpb24gKG0sIGlzU2VhcmNoKSB7XHJcbiAgICAgICAgICAgIC8vIElFWzc4XSByZXR1cm5zICcnIGZvciB1bm1hdGNoZWQgZ3JvdXBzIGluc3RlYWQgb2YgbnVsbFxyXG4gICAgICAgICAgICB2YXIgaWQgPSBtWzJdIHx8IG1bM107XHJcbiAgICAgICAgICAgIHZhciByZWdleHAgPSBpc1NlYXJjaCA/IG1bNF0gOiBtWzRdIHx8IChtWzFdID09PSAnKicgPyAnLionIDogbnVsbCk7XHJcbiAgICAgICAgICAgIHZhciBtYWtlUmVnZXhwVHlwZSA9IGZ1bmN0aW9uIChyZWdleHApIHsgcmV0dXJuIGNvbW1vbl8xLmluaGVyaXQocGFyYW1UeXBlcy50eXBlKGlzU2VhcmNoID8gXCJxdWVyeVwiIDogXCJwYXRoXCIpLCB7XHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBuZXcgUmVnRXhwKHJlZ2V4cCwgX3RoaXMuY29uZmlnLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgfSk7IH07XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgICAgICByZWdleHA6IHJlZ2V4cCxcclxuICAgICAgICAgICAgICAgIGNmZzogX3RoaXMuY29uZmlnLnBhcmFtc1tpZF0sXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50OiBwYXR0ZXJuLnN1YnN0cmluZyhsYXN0LCBtLmluZGV4KSxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICFyZWdleHAgPyBudWxsIDogcGFyYW1UeXBlcy50eXBlKHJlZ2V4cCkgfHwgbWFrZVJlZ2V4cFR5cGUocmVnZXhwKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHAsIHNlZ21lbnQ7XHJcbiAgICAgICAgd2hpbGUgKChtID0gcGxhY2Vob2xkZXIuZXhlYyhwYXR0ZXJuKSkpIHtcclxuICAgICAgICAgICAgcCA9IG1hdGNoRGV0YWlscyhtLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChwLnNlZ21lbnQuaW5kZXhPZignPycpID49IDApXHJcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gd2UncmUgaW50byB0aGUgc2VhcmNoIHBhcnRcclxuICAgICAgICAgICAgY2hlY2tQYXJhbUVycm9ycyhwLmlkKTtcclxuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLnB1c2gocGFyYW1GYWN0b3J5LmZyb21QYXRoKHAuaWQsIHAudHlwZSwgdGhpcy5jb25maWcucGFyYW1NYXAocC5jZmcsIGZhbHNlKSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50cy5wdXNoKHAuc2VnbWVudCk7XHJcbiAgICAgICAgICAgIHBhdHRlcm5zLnB1c2goW3Auc2VnbWVudCwgY29tbW9uXzEudGFpbCh0aGlzLl9wYXJhbXMpXSk7XHJcbiAgICAgICAgICAgIGxhc3QgPSBwbGFjZWhvbGRlci5sYXN0SW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlZ21lbnQgPSBwYXR0ZXJuLnN1YnN0cmluZyhsYXN0KTtcclxuICAgICAgICAvLyBGaW5kIGFueSBzZWFyY2ggcGFyYW1ldGVyIG5hbWVzIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBsYXN0IHNlZ21lbnRcclxuICAgICAgICB2YXIgaSA9IHNlZ21lbnQuaW5kZXhPZignPycpO1xyXG4gICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgICAgdmFyIHNlYXJjaCA9IHNlZ21lbnQuc3Vic3RyaW5nKGkpO1xyXG4gICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudC5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2gubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGFzdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG0gPSBzZWFyY2hQbGFjZWhvbGRlci5leGVjKHNlYXJjaCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IG1hdGNoRGV0YWlscyhtLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja1BhcmFtRXJyb3JzKHAuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5wdXNoKHBhcmFtRmFjdG9yeS5mcm9tU2VhcmNoKHAuaWQsIHAudHlwZSwgdGhpcy5jb25maWcucGFyYW1NYXAocC5jZmcsIHRydWUpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IHBsYWNlaG9sZGVyLmxhc3RJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiA/JlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NlZ21lbnRzLnB1c2goc2VnbWVudCk7XHJcbiAgICAgICAgdGhpcy5fY29tcGlsZWQgPSBwYXR0ZXJucy5tYXAoZnVuY3Rpb24gKHBhdHRlcm4pIHsgcmV0dXJuIHF1b3RlUmVnRXhwLmFwcGx5KG51bGwsIHBhdHRlcm4pOyB9KS5jb25jYXQocXVvdGVSZWdFeHAoc2VnbWVudCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbmNhdGVuYXRlZCBVcmxNYXRjaGVyXHJcbiAgICAgKlxyXG4gICAgICogQnVpbGRzIGEgbmV3IFVybE1hdGNoZXIgYnkgYXBwZW5kaW5nIGFub3RoZXIgVXJsTWF0Y2hlciB0byB0aGlzIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIEEgYFVybE1hdGNoZXJgIGluc3RhbmNlIHRvIGFwcGVuZCBhcyBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IGBVcmxNYXRjaGVyYC5cclxuICAgICAqL1xyXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2godXJsKTtcclxuICAgICAgICB1cmwuX2NhY2hlID0ge1xyXG4gICAgICAgICAgICBwYXRoOiB0aGlzLl9jYWNoZS5wYXRoLmNvbmNhdCh1cmwpLFxyXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXHJcbiAgICAgICAgICAgIHBhdHRlcm46IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5pc1Jvb3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLnBhdGhbMF0gPT09IHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqIFJldHVybnMgdGhlIGlucHV0IHBhdHRlcm4gc3RyaW5nICovXHJcbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXR0ZXJuO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgdGhlIHNwZWNpZmllZCB1cmwvcGF0aCBhZ2FpbnN0IHRoaXMgbWF0Y2hlci5cclxuICAgICAqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gdXJsIG1hdGNoZXMgdGhpcyBtYXRjaGVyJ3MgcGF0dGVybiwgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhcHR1cmVkXHJcbiAgICAgKiBwYXJhbWV0ZXIgdmFsdWVzLiAgUmV0dXJucyBudWxsIGlmIHRoZSBwYXRoIGRvZXMgbm90IG1hdGNoLlxyXG4gICAgICpcclxuICAgICAqIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgdGhlIHZhbHVlc1xyXG4gICAgICogb2YgYW55IHNlYXJjaCBwYXJhbWV0ZXJzIHRoYXQgYXJlIG1lbnRpb25lZCBpbiB0aGUgcGF0dGVybiwgYnV0IHRoZWlyIHZhbHVlIG1heSBiZSBudWxsIGlmXHJcbiAgICAgKiB0aGV5IGFyZSBub3QgcHJlc2VudCBpbiBgc2VhcmNoYC4gVGhpcyBtZWFucyB0aGF0IHNlYXJjaCBwYXJhbWV0ZXJzIGFyZSBhbHdheXMgdHJlYXRlZFxyXG4gICAgICogYXMgb3B0aW9uYWwuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIyBFeGFtcGxlOlxyXG4gICAgICogYGBganNcclxuICAgICAqIG5ldyBVcmxNYXRjaGVyKCcvdXNlci97aWR9P3EmcicpLmV4ZWMoJy91c2VyL2JvYicsIHtcclxuICAgICAqICAgeDogJzEnLCBxOiAnaGVsbG8nXHJcbiAgICAgKiB9KTtcclxuICAgICAqIC8vIHJldHVybnMgeyBpZDogJ2JvYicsIHE6ICdoZWxsbycsIHI6IG51bGwgfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggICAgVGhlIFVSTCBwYXRoIHRvIG1hdGNoLCBlLmcuIGAkbG9jYXRpb24ucGF0aCgpYC5cclxuICAgICAqIEBwYXJhbSBzZWFyY2ggIFVSTCBzZWFyY2ggcGFyYW1ldGVycywgZS5nLiBgJGxvY2F0aW9uLnNlYXJjaCgpYC5cclxuICAgICAqIEBwYXJhbSBoYXNoICAgIFVSTCBoYXNoIGUuZy4gYCRsb2NhdGlvbi5oYXNoKClgLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FwdHVyZWQgcGFyYW1ldGVyIHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChwYXRoLCBzZWFyY2gsIGhhc2gsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChzZWFyY2ggPT09IHZvaWQgMCkgeyBzZWFyY2ggPSB7fTsgfVxyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIG1hdGNoID0gbWVtb2l6ZVRvKHRoaXMuX2NhY2hlLCAncGF0dGVybicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoW1xyXG4gICAgICAgICAgICAgICAgJ14nLFxyXG4gICAgICAgICAgICAgICAgY29tbW9uXzEudW5uZXN0KF90aGlzLl9jYWNoZS5wYXRoLm1hcChob2ZfMS5wcm9wKCdfY29tcGlsZWQnKSkpLmpvaW4oJycpLFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuY29uZmlnLnN0cmljdCA9PT0gZmFsc2UgPyAnXFwvPycgOiAnJyxcclxuICAgICAgICAgICAgICAgICckJ1xyXG4gICAgICAgICAgICBdLmpvaW4oJycpLCBfdGhpcy5jb25maWcuY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogdW5kZWZpbmVkKTtcclxuICAgICAgICB9KS5leGVjKHBhdGgpO1xyXG4gICAgICAgIGlmICghbWF0Y2gpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIC8vb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHsgaXNvbGF0ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgdmFyIGFsbFBhcmFtcyA9IHRoaXMucGFyYW1ldGVycygpLCBwYXRoUGFyYW1zID0gYWxsUGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFwYXJhbS5pc1NlYXJjaCgpOyB9KSwgc2VhcmNoUGFyYW1zID0gYWxsUGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLmlzU2VhcmNoKCk7IH0pLCBuUGF0aFNlZ21lbnRzID0gdGhpcy5fY2FjaGUucGF0aC5tYXAoZnVuY3Rpb24gKHVybG0pIHsgcmV0dXJuIHVybG0uX3NlZ21lbnRzLmxlbmd0aCAtIDE7IH0pLnJlZHVjZShmdW5jdGlvbiAoYSwgeCkgeyByZXR1cm4gYSArIHg7IH0pLCB2YWx1ZXMgPSB7fTtcclxuICAgICAgICBpZiAoblBhdGhTZWdtZW50cyAhPT0gbWF0Y2gubGVuZ3RoIC0gMSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5iYWxhbmNlZCBjYXB0dXJlIGdyb3VwIGluIHJvdXRlICdcIiArIHRoaXMucGF0dGVybiArIFwiJ1wiKTtcclxuICAgICAgICBmdW5jdGlvbiBkZWNvZGVQYXRoQXJyYXkoc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHZhciByZXZlcnNlU3RyaW5nID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpOyB9O1xyXG4gICAgICAgICAgICB2YXIgdW5xdW90ZURhc2hlcyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxcLS9nLCBcIi1cIik7IH07XHJcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IHJldmVyc2VTdHJpbmcoc3RyaW5nKS5zcGxpdCgvLSg/IVxcXFwpLyk7XHJcbiAgICAgICAgICAgIHZhciBhbGxSZXZlcnNlZCA9IGNvbW1vbl8xLm1hcChzcGxpdCwgcmV2ZXJzZVN0cmluZyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5tYXAoYWxsUmV2ZXJzZWQsIHVucXVvdGVEYXNoZXMpLnJldmVyc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGF0aFNlZ21lbnRzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtID0gcGF0aFBhcmFtc1tpXTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbaSArIDFdO1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFyYW0gdmFsdWUgbWF0Y2hlcyBhIHByZS1yZXBsYWNlIHBhaXIsIHJlcGxhY2UgdGhlIHZhbHVlIGJlZm9yZSBkZWNvZGluZy5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJhbS5yZXBsYWNlLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0ucmVwbGFjZVtqXS5mcm9tID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtLnJlcGxhY2Vbal0udG87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHBhcmFtLmFycmF5ID09PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVQYXRoQXJyYXkodmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtLnR5cGUuZGVjb2RlKHZhbHVlKTtcclxuICAgICAgICAgICAgdmFsdWVzW3BhcmFtLmlkXSA9IHBhcmFtLnZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VhcmNoUGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlYXJjaFtwYXJhbS5pZF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyYW0ucmVwbGFjZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJlcGxhY2Vbal0uZnJvbSA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJhbS5yZXBsYWNlW2pdLnRvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSlcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyYW0udHlwZS5kZWNvZGUodmFsdWUpO1xyXG4gICAgICAgICAgICB2YWx1ZXNbcGFyYW0uaWRdID0gcGFyYW0udmFsdWUodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChoYXNoKVxyXG4gICAgICAgICAgICB2YWx1ZXNbXCIjXCJdID0gaGFzaDtcclxuICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGhpZGRlblxyXG4gICAgICogUmV0dXJucyBhbGwgdGhlIFtbUGFyYW1dXSBvYmplY3RzIG9mIGFsbCBwYXRoIGFuZCBzZWFyY2ggcGFyYW1ldGVycyBvZiB0aGlzIHBhdHRlcm4gaW4gb3JkZXIgb2YgYXBwZWFyYW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFBhcmFtPn0gIEFuIGFycmF5IG9mIFtbUGFyYW1dXSBvYmplY3RzLiBNdXN0IGJlIHRyZWF0ZWQgYXMgcmVhZC1vbmx5LiBJZiB0aGVcclxuICAgICAqICAgIHBhdHRlcm4gaGFzIG5vIHBhcmFtZXRlcnMsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxyXG4gICAgICovXHJcbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxyXG4gICAgICAgIGlmIChvcHRzLmluaGVyaXQgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zO1xyXG4gICAgICAgIHJldHVybiBjb21tb25fMS51bm5lc3QodGhpcy5fY2FjaGUucGF0aC5tYXAoZnVuY3Rpb24gKG1hdGNoZXIpIHsgcmV0dXJuIG1hdGNoZXIuX3BhcmFtczsgfSkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGhpZGRlblxyXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBwYXJhbWV0ZXIgZnJvbSB0aGlzIFVybE1hdGNoZXIgYnkgaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWRcclxuICAgICAqIEBwYXJhbSBvcHRzXHJcbiAgICAgKiBAcmV0dXJucyB7VHxQYXJhbXxhbnl8Ym9vbGVhbnxVcmxNYXRjaGVyfG51bGx9XHJcbiAgICAgKi9cclxuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLnBhcmFtZXRlciA9IGZ1bmN0aW9uIChpZCwgb3B0cykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cclxuICAgICAgICB2YXIgZmluZFBhcmFtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMuX3BhcmFtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5pZCA9PT0gaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fY2FjaGUucGFyZW50O1xyXG4gICAgICAgIHJldHVybiBmaW5kUGFyYW0oKSB8fCAob3B0cy5pbmhlcml0ICE9PSBmYWxzZSAmJiBwYXJlbnQgJiYgcGFyZW50LnBhcmFtZXRlcihpZCwgb3B0cykpIHx8IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGlucHV0IHBhcmFtZXRlciB2YWx1ZXMgYWdhaW5zdCB0aGlzIFVybE1hdGNoZXJcclxuICAgICAqXHJcbiAgICAgKiBDaGVja3MgYW4gb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZSB0aGVpciBjb3JyZWN0bmVzcyBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtZXRlclxyXG4gICAgICogdHlwZXMgb2YgdGhpcyBgVXJsTWF0Y2hlcmAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZS5cclxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYHRydWVgIGlmIGBwYXJhbXNgIHZhbGlkYXRlcywgb3RoZXJ3aXNlIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLnZhbGlkYXRlcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuICAgICAgICB2YXIgdmFsaWRQYXJhbVZhbCA9IGZ1bmN0aW9uIChwYXJhbSwgdmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhcGFyYW0gfHwgcGFyYW0udmFsaWRhdGVzKHZhbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XHJcbiAgICAgICAgLy8gSSdtIG5vdCBzdXJlIHdoeSB0aGlzIGNoZWNrcyBvbmx5IHRoZSBwYXJhbSBrZXlzIHBhc3NlZCBpbiwgYW5kIG5vdCBhbGwgdGhlIHBhcmFtcyBrbm93biB0byB0aGUgbWF0Y2hlclxyXG4gICAgICAgIHZhciBwYXJhbVNjaGVtYSA9IHRoaXMucGFyYW1ldGVycygpLmZpbHRlcihmdW5jdGlvbiAocGFyYW1EZWYpIHsgcmV0dXJuIHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShwYXJhbURlZi5pZCk7IH0pO1xyXG4gICAgICAgIHJldHVybiBwYXJhbVNjaGVtYS5tYXAoZnVuY3Rpb24gKHBhcmFtRGVmKSB7IHJldHVybiB2YWxpZFBhcmFtVmFsKHBhcmFtRGVmLCBwYXJhbXNbcGFyYW1EZWYuaWRdKTsgfSkucmVkdWNlKGNvbW1vbl8xLmFsbFRydWVSLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgc2V0IG9mIHBhcmFtZXRlciB2YWx1ZXMsIGNyZWF0ZXMgYSBVUkwgZnJvbSB0aGlzIFVybE1hdGNoZXIuXHJcbiAgICAgKlxyXG4gICAgICogQ3JlYXRlcyBhIFVSTCB0aGF0IG1hdGNoZXMgdGhpcyBwYXR0ZXJuIGJ5IHN1YnN0aXR1dGluZyB0aGUgc3BlY2lmaWVkIHZhbHVlc1xyXG4gICAgICogZm9yIHRoZSBwYXRoIGFuZCBzZWFyY2ggcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiAjIyMjIEV4YW1wbGU6XHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0/cScpLmZvcm1hdCh7IGlkOidib2InLCBxOid5ZXMnIH0pO1xyXG4gICAgICogLy8gcmV0dXJucyAnL3VzZXIvYm9iP3E9eWVzJ1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAgdGhlIHZhbHVlcyB0byBzdWJzdGl0dXRlIGZvciB0aGUgcGFyYW1ldGVycyBpbiB0aGlzIHBhdHRlcm4uXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgZm9ybWF0dGVkIFVSTCAocGF0aCBhbmQgb3B0aW9uYWxseSBzZWFyY2ggcGFydCkuXHJcbiAgICAgKi9cclxuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcclxuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0ge307IH1cclxuICAgICAgICAvLyBCdWlsZCB0aGUgZnVsbCBwYXRoIG9mIFVybE1hdGNoZXJzIChpbmNsdWRpbmcgYWxsIHBhcmVudCBVcmxNYXRjaGVycylcclxuICAgICAgICB2YXIgdXJsTWF0Y2hlcnMgPSB0aGlzLl9jYWNoZS5wYXRoO1xyXG4gICAgICAgIC8vIEV4dHJhY3QgYWxsIHRoZSBzdGF0aWMgc2VnbWVudHMgYW5kIFBhcmFtcyAocHJvY2Vzc2VkIGFzIFBhcmFtRGV0YWlscylcclxuICAgICAgICAvLyBpbnRvIGFuIG9yZGVyZWQgYXJyYXlcclxuICAgICAgICB2YXIgcGF0aFNlZ21lbnRzQW5kUGFyYW1zID0gdXJsTWF0Y2hlcnMubWFwKFVybE1hdGNoZXIucGF0aFNlZ21lbnRzQW5kUGFyYW1zKVxyXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoeCkgPyB4IDogZ2V0RGV0YWlscyh4KTsgfSk7XHJcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgcXVlcnkgcGFyYW1zIGludG8gYSBzZXBhcmF0ZSBhcnJheVxyXG4gICAgICAgIHZhciBxdWVyeVBhcmFtcyA9IHVybE1hdGNoZXJzLm1hcChVcmxNYXRjaGVyLnF1ZXJ5UGFyYW1zKVxyXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxyXG4gICAgICAgICAgICAubWFwKGdldERldGFpbHMpO1xyXG4gICAgICAgIHZhciBpc0ludmFsaWQgPSBmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLmlzVmFsaWQgPT09IGZhbHNlOyB9O1xyXG4gICAgICAgIGlmIChwYXRoU2VnbWVudHNBbmRQYXJhbXMuY29uY2F0KHF1ZXJ5UGFyYW1zKS5maWx0ZXIoaXNJbnZhbGlkKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdpdmVuIGEgUGFyYW0sIGFwcGxpZXMgdGhlIHBhcmFtZXRlciB2YWx1ZSwgdGhlbiByZXR1cm5zIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGl0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0RGV0YWlscyhwYXJhbSkge1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gdHlwZWQgdmFsdWVcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyYW0udmFsdWUodmFsdWVzW3BhcmFtLmlkXSk7XHJcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gcGFyYW0udmFsaWRhdGVzKHZhbHVlKTtcclxuICAgICAgICAgICAgdmFyIGlzRGVmYXVsdFZhbHVlID0gcGFyYW0uaXNEZWZhdWx0VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBpbiBzcXVhc2ggbW9kZSBmb3IgdGhlIHBhcmFtZXRlclxyXG4gICAgICAgICAgICB2YXIgc3F1YXNoID0gaXNEZWZhdWx0VmFsdWUgPyBwYXJhbS5zcXVhc2ggOiBmYWxzZTtcclxuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIFBhcmFtZXRlcidzIFR5cGUgdG8gZW5jb2RlIHRoZSB2YWx1ZVxyXG4gICAgICAgICAgICB2YXIgZW5jb2RlZCA9IHBhcmFtLnR5cGUuZW5jb2RlKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcGFyYW06IHBhcmFtLCB2YWx1ZTogdmFsdWUsIGlzVmFsaWQ6IGlzVmFsaWQsIGlzRGVmYXVsdFZhbHVlOiBpc0RlZmF1bHRWYWx1ZSwgc3F1YXNoOiBzcXVhc2gsIGVuY29kZWQ6IGVuY29kZWQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQnVpbGQgdXAgdGhlIHBhdGgtcG9ydGlvbiBmcm9tIHRoZSBsaXN0IG9mIHN0YXRpYyBzZWdtZW50cyBhbmQgcGFyYW1ldGVyc1xyXG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gcGF0aFNlZ21lbnRzQW5kUGFyYW1zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB4KSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGEgc3RhdGljIHNlZ21lbnQgKGEgcmF3IHN0cmluZyk7IGp1c3QgYXBwZW5kIGl0XHJcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoeCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgeDtcclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCdzIGEgUGFyYW1EZXRhaWxzLlxyXG4gICAgICAgICAgICB2YXIgc3F1YXNoID0geC5zcXVhc2gsIGVuY29kZWQgPSB4LmVuY29kZWQsIHBhcmFtID0geC5wYXJhbTtcclxuICAgICAgICAgICAgLy8gSWYgc3F1YXNoIGlzID09PSB0cnVlLCB0cnkgdG8gcmVtb3ZlIGEgc2xhc2ggZnJvbSB0aGUgcGF0aFxyXG4gICAgICAgICAgICBpZiAoc3F1YXNoID09PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY2MubWF0Y2goL1xcLyQvKSkgPyBhY2Muc2xpY2UoMCwgLTEpIDogYWNjO1xyXG4gICAgICAgICAgICAvLyBJZiBzcXVhc2ggaXMgYSBzdHJpbmcsIHVzZSB0aGUgc3RyaW5nIGZvciB0aGUgcGFyYW0gdmFsdWVcclxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzcXVhc2gpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIHNxdWFzaDtcclxuICAgICAgICAgICAgaWYgKHNxdWFzaCAhPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjOyAvLyA/XHJcbiAgICAgICAgICAgIGlmIChlbmNvZGVkID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIHBhcmFtZXRlciB2YWx1ZSBpcyBhbiBhcnJheSwgZW5jb2RlIHRoZSB2YWx1ZSB1c2luZyBlbmNvZGVEYXNoZXNcclxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0FycmF5KGVuY29kZWQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIGNvbW1vbl8xLm1hcChlbmNvZGVkLCBVcmxNYXRjaGVyLmVuY29kZURhc2hlcykuam9pbihcIi1cIik7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdHlwZSBpcyBcInJhd1wiLCB0aGVuIGRvIG5vdCBlbmNvZGVVUklDb21wb25lbnRcclxuICAgICAgICAgICAgaWYgKHBhcmFtLnJhdylcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyBlbmNvZGVkO1xyXG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIHZhbHVlXHJcbiAgICAgICAgICAgIHJldHVybiBhY2MgKyBlbmNvZGVVUklDb21wb25lbnQoZW5jb2RlZCk7XHJcbiAgICAgICAgfSwgXCJcIik7XHJcbiAgICAgICAgLy8gQnVpbGQgdGhlIHF1ZXJ5IHN0cmluZyBieSBhcHBseWluZyBwYXJhbWV0ZXIgdmFsdWVzIChhcnJheSBvciByZWd1bGFyKVxyXG4gICAgICAgIC8vIHRoZW4gbWFwcGluZyB0byBrZXk9dmFsdWUsIHRoZW4gZmxhdHRlbmluZyBhbmQgam9pbmluZyB1c2luZyBcIiZcIlxyXG4gICAgICAgIHZhciBxdWVyeVN0cmluZyA9IHF1ZXJ5UGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW1EZXRhaWxzKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtRGV0YWlscy5wYXJhbSwgc3F1YXNoID0gcGFyYW1EZXRhaWxzLnNxdWFzaCwgZW5jb2RlZCA9IHBhcmFtRGV0YWlscy5lbmNvZGVkLCBpc0RlZmF1bHRWYWx1ZSA9IHBhcmFtRGV0YWlscy5pc0RlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgaWYgKGVuY29kZWQgPT0gbnVsbCB8fCAoaXNEZWZhdWx0VmFsdWUgJiYgc3F1YXNoICE9PSBmYWxzZSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzQXJyYXkoZW5jb2RlZCkpXHJcbiAgICAgICAgICAgICAgICBlbmNvZGVkID0gW2VuY29kZWRdO1xyXG4gICAgICAgICAgICBpZiAoZW5jb2RlZC5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICghcGFyYW0ucmF3KVxyXG4gICAgICAgICAgICAgICAgZW5jb2RlZCA9IGNvbW1vbl8xLm1hcChlbmNvZGVkLCBlbmNvZGVVUklDb21wb25lbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlZC5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gcGFyYW0uaWQgKyBcIj1cIiArIHZhbDsgfSk7XHJcbiAgICAgICAgfSkuZmlsdGVyKGNvbW1vbl8xLmlkZW50aXR5KS5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pLmpvaW4oXCImXCIpO1xyXG4gICAgICAgIC8vIENvbmNhdCB0aGUgcGF0aHN0cmluZyB3aXRoIHRoZSBxdWVyeVN0cmluZyAoaWYgZXhpc3RzKSBhbmQgdGhlIGhhc2hTdHJpbmcgKGlmIGV4aXN0cylcclxuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyArIChxdWVyeVN0cmluZyA/IFwiP1wiICsgcXVlcnlTdHJpbmcgOiBcIlwiKSArICh2YWx1ZXNbXCIjXCJdID8gXCIjXCIgKyB2YWx1ZXNbXCIjXCJdIDogXCJcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBoaWRkZW4gKi9cclxuICAgIFVybE1hdGNoZXIuZW5jb2RlRGFzaGVzID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC8tL2csIGZ1bmN0aW9uIChjKSB7IHJldHVybiBcIiU1QyVcIiArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBoaWRkZW4gR2l2ZW4gYSBtYXRjaGVyLCByZXR1cm4gYW4gYXJyYXkgd2l0aCB0aGUgbWF0Y2hlcidzIHBhdGggc2VnbWVudHMgYW5kIHBhdGggcGFyYW1zLCBpbiBvcmRlciAqL1xyXG4gICAgVXJsTWF0Y2hlci5wYXRoU2VnbWVudHNBbmRQYXJhbXMgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xyXG4gICAgICAgIHZhciBzdGF0aWNTZWdtZW50cyA9IG1hdGNoZXIuX3NlZ21lbnRzO1xyXG4gICAgICAgIHZhciBwYXRoUGFyYW1zID0gbWF0Y2hlci5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5sb2NhdGlvbiA9PT0gcGFyYW1fMS5EZWZUeXBlLlBBVEg7IH0pO1xyXG4gICAgICAgIHJldHVybiBjb21tb25fMS5hcnJheVR1cGxlcyhzdGF0aWNTZWdtZW50cywgcGF0aFBhcmFtcy5jb25jYXQodW5kZWZpbmVkKSlcclxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0gXCJcIiAmJiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHgpOyB9KTtcclxuICAgIH07XHJcbiAgICAvKiogQGhpZGRlbiBHaXZlbiBhIG1hdGNoZXIsIHJldHVybiBhbiBhcnJheSB3aXRoIHRoZSBtYXRjaGVyJ3MgcXVlcnkgcGFyYW1zICovXHJcbiAgICBVcmxNYXRjaGVyLnF1ZXJ5UGFyYW1zID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlci5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5sb2NhdGlvbiA9PT0gcGFyYW1fMS5EZWZUeXBlLlNFQVJDSDsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlIHR3byBVcmxNYXRjaGVyc1xyXG4gICAgICpcclxuICAgICAqIFRoaXMgY29tcGFyaXNvbiBmdW5jdGlvbiBjb252ZXJ0cyBhIFVybE1hdGNoZXIgaW50byBzdGF0aWMgYW5kIGR5bmFtaWMgcGF0aCBzZWdtZW50cy5cclxuICAgICAqIEVhY2ggc3RhdGljIHBhdGggc2VnbWVudCBpcyBhIHN0YXRpYyBzdHJpbmcgYmV0d2VlbiBhIHBhdGggc2VwYXJhdG9yIChzbGFzaCBjaGFyYWN0ZXIpLlxyXG4gICAgICogRWFjaCBkeW5hbWljIHNlZ21lbnQgaXMgYSBwYXRoIHBhcmFtZXRlci5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgY29tcGFyaXNvbiBmdW5jdGlvbiBzb3J0cyBzdGF0aWMgc2VnbWVudHMgYmVmb3JlIGR5bmFtaWMgb25lcy5cclxuICAgICAqL1xyXG4gICAgVXJsTWF0Y2hlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUdXJuIGEgVXJsTWF0Y2hlciBhbmQgYWxsIGl0cyBwYXJlbnQgbWF0Y2hlcnMgaW50byBhbiBhcnJheVxyXG4gICAgICAgICAqIG9mIHNsYXNoIGxpdGVyYWxzICcvJywgc3RyaW5nIGxpdGVyYWxzLCBhbmQgUGFyYW0gb2JqZWN0c1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBleGFtcGxlIG1hdGNoZXIgbWF0Y2hlcyBzdHJpbmdzIGxpa2UgXCIvZm9vLzpwYXJhbS90YWlsXCI6XHJcbiAgICAgICAgICogdmFyIG1hdGNoZXIgPSAkdW1mLmNvbXBpbGUoXCIvZm9vXCIpLmFwcGVuZCgkdW1mLmNvbXBpbGUoXCIvOnBhcmFtXCIpKS5hcHBlbmQoJHVtZi5jb21waWxlKFwiL1wiKSkuYXBwZW5kKCR1bWYuY29tcGlsZShcInRhaWxcIikpO1xyXG4gICAgICAgICAqIHZhciByZXN1bHQgPSBzZWdtZW50cyhtYXRjaGVyKTsgLy8gWyAnLycsICdmb28nLCAnLycsIFBhcmFtLCAnLycsICd0YWlsJyBdXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBDYWNoZXMgdGhlIHJlc3VsdCBhcyBgbWF0Y2hlci5fY2FjaGUuc2VnbWVudHNgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIuX2NhY2hlLnNlZ21lbnRzID0gbWF0Y2hlci5fY2FjaGUuc2VnbWVudHMgfHxcclxuICAgICAgICAgICAgICAgIG1hdGNoZXIuX2NhY2hlLnBhdGgubWFwKFVybE1hdGNoZXIucGF0aFNlZ21lbnRzQW5kUGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShzdHJpbmdzXzEuam9pbk5laWdoYm9yc1IsIFtdKVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc1N0cmluZyh4KSA/IHNwbGl0T25TbGFzaCh4KSA6IHg7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBzb3J0IHdlaWdodCBmb3IgZWFjaCBzZWdtZW50IG9mIGEgVXJsTWF0Y2hlclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQ2FjaGVzIHRoZSByZXN1bHQgYXMgYG1hdGNoZXIuX2NhY2hlLndlaWdodHNgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIHdlaWdodHMgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlci5fY2FjaGUud2VpZ2h0cyA9IG1hdGNoZXIuX2NhY2hlLndlaWdodHMgfHxcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzKG1hdGNoZXIpLm1hcChmdW5jdGlvbiAoc2VnbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvcnQgc2xhc2hlcyBmaXJzdCwgdGhlbiBzdGF0aWMgc3RyaW5ncywgdGhlIFBhcmFtc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50ID09PSAnLycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc2VnbWVudCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgcGFyYW1fMS5QYXJhbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBjbXAsIGksIHBhaXJzID0gY29tbW9uXzEuYXJyYXlUdXBsZXMod2VpZ2h0cyhhKSwgd2VpZ2h0cyhiKSk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IHBhaXJzW2ldWzBdIC0gcGFpcnNbaV1bMV07XHJcbiAgICAgICAgICAgIGlmIChjbXAgIT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVXJsTWF0Y2hlcjtcclxufSgpKTtcclxuLyoqIEBoaWRkZW4gKi9cclxuVXJsTWF0Y2hlci5uYW1lVmFsaWRhdG9yID0gL15cXHcrKFstLl0rXFx3KykqKD86XFxbXFxdKT8kLztcclxuZXhwb3J0cy5VcmxNYXRjaGVyID0gVXJsTWF0Y2hlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsTWF0Y2hlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsTWF0Y2hlci5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxhcGlcclxuICogQG1vZHVsZSB2YW5pbGxhXHJcbiAqLyAvKiogKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xyXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxuLyoqIEEgYmFzZSBgTG9jYXRpb25TZXJ2aWNlc2AgKi9cclxudmFyIEJhc2VMb2NhdGlvblNlcnZpY2VzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJhc2VMb2NhdGlvblNlcnZpY2VzKHJvdXRlciwgZmlyZUFmdGVyVXBkYXRlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmZpcmVBZnRlclVwZGF0ZSA9IGZpcmVBZnRlclVwZGF0ZTtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lciA9IGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuIF90aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIGNiKGV2dCk7IH0pOyB9O1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaGFzaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEucGFyc2VVcmwoX3RoaXMuX2dldCgpKS5oYXNoOyB9O1xyXG4gICAgICAgIHRoaXMucGF0aCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEucGFyc2VVcmwoX3RoaXMuX2dldCgpKS5wYXRoOyB9O1xyXG4gICAgICAgIHRoaXMuc2VhcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5nZXRQYXJhbXModXRpbHNfMS5wYXJzZVVybChfdGhpcy5fZ2V0KCkpLnNlYXJjaCk7IH07XHJcbiAgICAgICAgdGhpcy5fbG9jYXRpb24gPSB3aW5kb3cgJiYgd2luZG93LmxvY2F0aW9uO1xyXG4gICAgICAgIHRoaXMuX2hpc3RvcnkgPSB3aW5kb3cgJiYgd2luZG93Lmhpc3Rvcnk7XHJcbiAgICB9XHJcbiAgICBCYXNlTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24gKHVybCwgcmVwbGFjZSkge1xyXG4gICAgICAgIGlmIChyZXBsYWNlID09PSB2b2lkIDApIHsgcmVwbGFjZSA9IHRydWU7IH1cclxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzRGVmaW5lZCh1cmwpICYmIHVybCAhPT0gdGhpcy5fZ2V0KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0KG51bGwsIG51bGwsIHVybCwgcmVwbGFjZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZpcmVBZnRlclVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2dF8xID0gY29tbW9uXzEuZXh0ZW5kKG5ldyBFdmVudChcImxvY2F0aW9uY2hhbmdlXCIpLCB7IHVybDogdXJsIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYihldnRfMSk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1dGlsc18xLmJ1aWxkVXJsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEJhc2VMb2NhdGlvblNlcnZpY2VzLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goY2IpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21tb25fMS5yZW1vdmVGcm9tKF90aGlzLl9saXN0ZW5lcnMsIGNiKTsgfTtcclxuICAgIH07XHJcbiAgICBCYXNlTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcclxuICAgICAgICBjb21tb25fMS5kZXJlZ0FsbCh0aGlzLl9saXN0ZW5lcnMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCYXNlTG9jYXRpb25TZXJ2aWNlcztcclxufSgpKTtcclxuZXhwb3J0cy5CYXNlTG9jYXRpb25TZXJ2aWNlcyA9IEJhc2VMb2NhdGlvblNlcnZpY2VzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlTG9jYXRpb25TZXJ2aWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvYmFzZUxvY2F0aW9uU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBAbW9kdWxlIGNvbW1vblxyXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFF1ZXVlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFF1ZXVlKF9pdGVtcywgX2xpbWl0KSB7XHJcbiAgICAgICAgaWYgKF9pdGVtcyA9PT0gdm9pZCAwKSB7IF9pdGVtcyA9IFtdOyB9XHJcbiAgICAgICAgaWYgKF9saW1pdCA9PT0gdm9pZCAwKSB7IF9saW1pdCA9IG51bGw7IH1cclxuICAgICAgICB0aGlzLl9pdGVtcyA9IF9pdGVtcztcclxuICAgICAgICB0aGlzLl9saW1pdCA9IF9saW1pdDtcclxuICAgIH1cclxuICAgIFF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLl9pdGVtcztcclxuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIGlmICh0aGlzLl9saW1pdCAmJiBpdGVtcy5sZW5ndGggPiB0aGlzLl9saW1pdClcclxuICAgICAgICAgICAgaXRlbXMuc2hpZnQoKTtcclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgIH07XHJcbiAgICBRdWV1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zaXplKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5zcGxpY2UoMCwgMSlbMF07XHJcbiAgICB9O1xyXG4gICAgUXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5faXRlbXM7XHJcbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcclxuICAgICAgICByZXR1cm4gY3VycmVudDtcclxuICAgIH07XHJcbiAgICBRdWV1ZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIFF1ZXVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGl0ZW0pO1xyXG4gICAgICAgIHJldHVybiBpZHggPiAtMSAmJiB0aGlzLl9pdGVtcy5zcGxpY2UoaWR4LCAxKVswXTtcclxuICAgIH07XHJcbiAgICBRdWV1ZS5wcm90b3R5cGUucGVla1RhaWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdO1xyXG4gICAgfTtcclxuICAgIFF1ZXVlLnByb3RvdHlwZS5wZWVrSGVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zaXplKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1swXTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUXVldWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUXVldWUgPSBRdWV1ZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVldWUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3F1ZXVlLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQGNvcmVhcGlcclxuICogQG1vZHVsZSBwYXJhbXNcclxuICovXHJcbi8qKiAqL1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcclxuLyoqXHJcbiAqIEFuIGludGVybmFsIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0uXHJcbiAqXHJcbiAqIEEgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0gaXMgYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCB1c2VkIHRvIHJlZ2lzdGVyIGN1c3RvbSBwYXJhbWV0ZXIgdHlwZXMuXHJcbiAqIFdoZW4gYSBwYXJhbSB0eXBlIGRlZmluaXRpb24gaXMgcmVnaXN0ZXJlZCwgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBpcyBjcmVhdGVkIGludGVybmFsbHkuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgaGFzIG5haXZlIGltcGxlbWVudGF0aW9ucyBmb3IgYWxsIHRoZSBbW1BhcmFtVHlwZURlZmluaXRpb25dXSBtZXRob2RzLlxyXG4gKlxyXG4gKiBVc2VkIGJ5IFtbVXJsTWF0Y2hlcl1dIHdoZW4gbWF0Y2hpbmcgb3IgZm9ybWF0dGluZyBVUkxzLCBvciBjb21wYXJpbmcgYW5kIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHZhbHVlcy5cclxuICpcclxuICogIyMjIyBFeGFtcGxlOlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcGFyYW1UeXBlRGVmID0ge1xyXG4gKiAgIGRlY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiBwYXJzZUludCh2YWwsIDEwKTsgfSxcclxuICogICBlbmNvZGU6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gdmFsICYmIHZhbC50b1N0cmluZygpOyB9LFxyXG4gKiAgIGVxdWFsczogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gdGhpcy5pcyhhKSAmJiBhID09PSBiOyB9LFxyXG4gKiAgIGlzOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIGFuZ3VsYXIuaXNOdW1iZXIodmFsKSAmJiBpc0Zpbml0ZSh2YWwpICYmIHZhbCAlIDEgPT09IDA7IH0sXHJcbiAqICAgcGF0dGVybjogL1xcZCsvXHJcbiAqIH1cclxuICpcclxuICogdmFyIHBhcmFtVHlwZSA9IG5ldyBQYXJhbVR5cGUocGFyYW1UeXBlRGVmKTtcclxuICogYGBgXHJcbiAqIEBpbnRlcm5hbGFwaVxyXG4gKi9cclxudmFyIFBhcmFtVHlwZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBkZWYgIEEgY29uZmlndXJhdGlvbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGN1c3RvbSB0eXBlIGRlZmluaXRpb24uICBUaGUgb2JqZWN0J3NcclxuICAgICAqICAgICAgICBwcm9wZXJ0aWVzIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgbWV0aG9kcyBhbmQvb3IgcGF0dGVybiBpbiBgUGFyYW1UeXBlYCdzIHB1YmxpYyBpbnRlcmZhY2UuXHJcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBQYXJhbVR5cGUgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFBhcmFtVHlwZShkZWYpIHtcclxuICAgICAgICAvKiogQGluaGVyaXRkb2MgKi9cclxuICAgICAgICB0aGlzLnBhdHRlcm4gPSAvLiovO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgICAgIHRoaXMuaW5oZXJpdCA9IHRydWU7XHJcbiAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIGRlZik7XHJcbiAgICB9XHJcbiAgICAvLyBjb25zaWRlciB0aGVzZSBmb3VyIG1ldGhvZHMgdG8gYmUgXCJhYnN0cmFjdCBtZXRob2RzXCIgdGhhdCBzaG91bGQgYmUgb3ZlcnJpZGRlblxyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKHZhbCwga2V5KSB7IHJldHVybiB0cnVlOyB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh2YWwsIGtleSkgeyByZXR1cm4gdmFsOyB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh2YWwsIGtleSkgeyByZXR1cm4gdmFsOyB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhID09IGI7IH07XHJcbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLiRzdWJQYXR0ZXJuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdWIgPSB0aGlzLnBhdHRlcm4udG9TdHJpbmcoKTtcclxuICAgICAgICByZXR1cm4gc3ViLnN1YnN0cigxLCBzdWIubGVuZ3RoIC0gMik7XHJcbiAgICB9O1xyXG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJ7UGFyYW1UeXBlOlwiICsgdGhpcy5uYW1lICsgXCJ9XCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIEdpdmVuIGFuIGVuY29kZWQgc3RyaW5nLCBvciBhIGRlY29kZWQgb2JqZWN0LCByZXR1cm5zIGEgZGVjb2RlZCBvYmplY3QgKi9cclxuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuJG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pcyh2YWwpID8gdmFsIDogdGhpcy5kZWNvZGUodmFsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdyYXBzIGFuIGV4aXN0aW5nIGN1c3RvbSBQYXJhbVR5cGUgYXMgYW4gYXJyYXkgb2YgUGFyYW1UeXBlLCBkZXBlbmRpbmcgb24gJ21vZGUnLlxyXG4gICAgICogZS5nLjpcclxuICAgICAqIC0gdXJsbWF0Y2hlciBwYXR0ZXJuIFwiL3BhdGg/e3F1ZXJ5UGFyYW1bXTppbnR9XCJcclxuICAgICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSZxdWVyeVBhcmFtPTJcclxuICAgICAqIC0gJHN0YXRlUGFyYW1zLnF1ZXJ5UGFyYW0gd2lsbCBiZSBbMSwgMl1cclxuICAgICAqIGlmIGBtb2RlYCBpcyBcImF1dG9cIiwgdGhlblxyXG4gICAgICogLSB1cmw6IFwiL3BhdGg/cXVlcnlQYXJhbT0xIHdpbGwgY3JlYXRlICRzdGF0ZVBhcmFtcy5xdWVyeVBhcmFtOiAxXHJcbiAgICAgKiAtIHVybDogXCIvcGF0aD9xdWVyeVBhcmFtPTEmcXVlcnlQYXJhbT0yIHdpbGwgY3JlYXRlICRzdGF0ZVBhcmFtcy5xdWVyeVBhcmFtOiBbMSwgMl1cclxuICAgICAqL1xyXG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS4kYXNBcnJheSA9IGZ1bmN0aW9uIChtb2RlLCBpc1NlYXJjaCkge1xyXG4gICAgICAgIGlmICghbW9kZSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgaWYgKG1vZGUgPT09IFwiYXV0b1wiICYmICFpc1NlYXJjaClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2F1dG8nIGFycmF5IG1vZGUgaXMgZm9yIHF1ZXJ5IHBhcmFtZXRlcnMgb25seVwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IEFycmF5VHlwZSh0aGlzLCBtb2RlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUGFyYW1UeXBlO1xyXG59KCkpO1xyXG5leHBvcnRzLlBhcmFtVHlwZSA9IFBhcmFtVHlwZTtcclxuLyoqXHJcbiAqIFdyYXBzIHVwIGEgYFBhcmFtVHlwZWAgb2JqZWN0IHRvIGhhbmRsZSBhcnJheSB2YWx1ZXMuXHJcbiAqIEBpbnRlcm5hbGFwaVxyXG4gKi9cclxuZnVuY3Rpb24gQXJyYXlUeXBlKHR5cGUsIG1vZGUpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAvLyBXcmFwIG5vbi1hcnJheSB2YWx1ZSBhcyBhcnJheVxyXG4gICAgZnVuY3Rpb24gYXJyYXlXcmFwKHZhbCkge1xyXG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNBcnJheSh2YWwpID8gdmFsIDogKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsKSA/IFt2YWxdIDogW10pO1xyXG4gICAgfVxyXG4gICAgLy8gVW53cmFwIGFycmF5IHZhbHVlIGZvciBcImF1dG9cIiBtb2RlLiBSZXR1cm4gdW5kZWZpbmVkIGZvciBlbXB0eSBhcnJheS5cclxuICAgIGZ1bmN0aW9uIGFycmF5VW53cmFwKHZhbCkge1xyXG4gICAgICAgIHN3aXRjaCAodmFsLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG1vZGUgPT09IFwiYXV0b1wiID8gdmFsWzBdIDogdmFsO1xyXG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gdmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFdyYXBzIHR5cGUgKC5pcy8uZW5jb2RlLy5kZWNvZGUpIGZ1bmN0aW9ucyB0byBvcGVyYXRlIG9uIGVhY2ggdmFsdWUgb2YgYW4gYXJyYXlcclxuICAgIGZ1bmN0aW9uIGFycmF5SGFuZGxlcihjYWxsYmFjaywgYWxsVHJ1dGh5TW9kZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVBcnJheSh2YWwpIHtcclxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0FycmF5KHZhbCkgJiYgdmFsLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBhcnJheVdyYXAodmFsKTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbW1vbl8xLm1hcChhcnIsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIChhbGxUcnV0aHlNb2RlID09PSB0cnVlKSA/IGNvbW1vbl8xLmZpbHRlcihyZXN1bHQsIGZ1bmN0aW9uICh4KSB7IHJldHVybiAheDsgfSkubGVuZ3RoID09PSAwIDogYXJyYXlVbndyYXAocmVzdWx0KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gV3JhcHMgdHlwZSAoLmVxdWFscykgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gZWFjaCB2YWx1ZSBvZiBhbiBhcnJheVxyXG4gICAgZnVuY3Rpb24gYXJyYXlFcXVhbHNIYW5kbGVyKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbDEsIHZhbDIpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSBhcnJheVdyYXAodmFsMSksIHJpZ2h0ID0gYXJyYXlXcmFwKHZhbDIpO1xyXG4gICAgICAgICAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKGxlZnRbaV0sIHJpZ2h0W2ldKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFsnZW5jb2RlJywgJ2RlY29kZScsICdlcXVhbHMnLCAnJG5vcm1hbGl6ZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgcGFyYW1UeXBlRm4gPSB0eXBlW25hbWVdLmJpbmQodHlwZSk7XHJcbiAgICAgICAgdmFyIHdyYXBwZXJGbiA9IG5hbWUgPT09ICdlcXVhbHMnID8gYXJyYXlFcXVhbHNIYW5kbGVyIDogYXJyYXlIYW5kbGVyO1xyXG4gICAgICAgIF90aGlzW25hbWVdID0gd3JhcHBlckZuKHBhcmFtVHlwZUZuKTtcclxuICAgIH0pO1xyXG4gICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIHtcclxuICAgICAgICBkeW5hbWljOiB0eXBlLmR5bmFtaWMsXHJcbiAgICAgICAgbmFtZTogdHlwZS5uYW1lLFxyXG4gICAgICAgIHBhdHRlcm46IHR5cGUucGF0dGVybixcclxuICAgICAgICBpbmhlcml0OiB0eXBlLmluaGVyaXQsXHJcbiAgICAgICAgaXM6IGFycmF5SGFuZGxlcih0eXBlLmlzLmJpbmQodHlwZSksIHRydWUpLFxyXG4gICAgICAgICRhcnJheU1vZGU6IG1vZGVcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmFtVHlwZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvcGFyYW1UeXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKiogQG1vZHVsZSBwYXRoICovIC8qKiBmb3IgdHlwZWRvYyAqL1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XHJcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbGFwaVxyXG4gKlxyXG4gKiBBIG5vZGUgaW4gYSBbW1RyZWVDaGFuZ2VzXV0gcGF0aFxyXG4gKlxyXG4gKiBGb3IgYSBbW1RyZWVDaGFuZ2VzXV0gcGF0aCwgdGhpcyBjbGFzcyBob2xkcyB0aGUgc3RhdGVmdWwgaW5mb3JtYXRpb24gZm9yIGEgc2luZ2xlIG5vZGUgaW4gdGhlIHBhdGguXHJcbiAqIEVhY2ggUGF0aE5vZGUgY29ycmVzcG9uZHMgdG8gYSBzdGF0ZSBiZWluZyBlbnRlcmVkLCBleGl0ZWQsIG9yIHJldGFpbmVkLlxyXG4gKiBUaGUgc3RhdGVmdWwgaW5mb3JtYXRpb24gaW5jbHVkZXMgcGFyYW1ldGVyIHZhbHVlcyBhbmQgcmVzb2x2ZSBkYXRhLlxyXG4gKi9cclxudmFyIFBhdGhOb2RlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhdGhOb2RlKHN0YXRlT3JOb2RlKSB7XHJcbiAgICAgICAgaWYgKHN0YXRlT3JOb2RlIGluc3RhbmNlb2YgUGF0aE5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGF0ZU9yTm9kZTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5vZGUuc3RhdGU7XHJcbiAgICAgICAgICAgIHRoaXMucGFyYW1TY2hlbWEgPSBub2RlLnBhcmFtU2NoZW1hLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSBjb21tb25fMS5leHRlbmQoe30sIG5vZGUucGFyYW1WYWx1ZXMpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmFibGVzID0gbm9kZS5yZXNvbHZhYmxlcy5zbGljZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdzID0gbm9kZS52aWV3cyAmJiBub2RlLnZpZXdzLnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZU9yTm9kZTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmFtU2NoZW1hID0gc3RhdGUucGFyYW1ldGVycyh7IGluaGVyaXQ6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmFtVmFsdWVzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2YWJsZXMgPSBzdGF0ZS5yZXNvbHZhYmxlcy5tYXAoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLmNsb25lKCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBTZXRzIFtbcGFyYW1WYWx1ZXNdXSBmb3IgdGhlIG5vZGUsIGZyb20gdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QgaGFzaCAqL1xyXG4gICAgUGF0aE5vZGUucHJvdG90eXBlLmFwcGx5UmF3UGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gICAgICAgIHZhciBnZXRQYXJhbVZhbCA9IGZ1bmN0aW9uIChwYXJhbURlZikgeyByZXR1cm4gW3BhcmFtRGVmLmlkLCBwYXJhbURlZi52YWx1ZShwYXJhbXNbcGFyYW1EZWYuaWRdKV07IH07XHJcbiAgICAgICAgdGhpcy5wYXJhbVZhbHVlcyA9IHRoaXMucGFyYW1TY2hlbWEucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBwRGVmKSB7IHJldHVybiBjb21tb25fMS5hcHBseVBhaXJzKG1lbW8sIGdldFBhcmFtVmFsKHBEZWYpKTsgfSwge30pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKiBHZXRzIGEgc3BlY2lmaWMgW1tQYXJhbV1dIG1ldGFkYXRhIHRoYXQgYmVsb25ncyB0byB0aGUgbm9kZSAqL1xyXG4gICAgUGF0aE5vZGUucHJvdG90eXBlLnBhcmFtZXRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmZpbmQodGhpcy5wYXJhbVNjaGVtYSwgaG9mXzEucHJvcEVxKFwiaWRcIiwgbmFtZSkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RhdGUgYW5kIHBhcmFtZXRlciB2YWx1ZXMgZm9yIGFub3RoZXIgUGF0aE5vZGUgYXJlXHJcbiAgICAgKiBlcXVhbCB0byB0aGUgc3RhdGUgYW5kIHBhcmFtIHZhbHVlcyBmb3IgdGhpcyBQYXRoTm9kZVxyXG4gICAgICovXHJcbiAgICBQYXRoTm9kZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG5vZGUsIHBhcmFtc0ZuKSB7XHJcbiAgICAgICAgdmFyIGRpZmYgPSB0aGlzLmRpZmYobm9kZSwgcGFyYW1zRm4pO1xyXG4gICAgICAgIHJldHVybiBkaWZmICYmIGRpZmYubGVuZ3RoID09PSAwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgUGFyYW1zIHdpdGggZGlmZmVyZW50IHBhcmFtZXRlciB2YWx1ZXMgb24gYW5vdGhlciBQYXRoTm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBHaXZlbiBhbm90aGVyIG5vZGUgKG9mIHRoZSBzYW1lIHN0YXRlKSwgZmluZHMgdGhlIHBhcmFtZXRlciB2YWx1ZXMgd2hpY2ggZGlmZmVyLlxyXG4gICAgICogUmV0dXJucyB0aGUgW1tQYXJhbV1dIChzY2hlbWEgb2JqZWN0cykgd2hvc2UgcGFyYW1ldGVyIHZhbHVlcyBkaWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogR2l2ZW4gYW5vdGhlciBub2RlIGZvciBhIGRpZmZlcmVudCBzdGF0ZSwgcmV0dXJucyBgZmFsc2VgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gY29tcGFyZSB0b1xyXG4gICAgICogQHBhcmFtIHBhcmFtc0ZuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoaWNoIHBhcmFtZXRlcnMgc2hvdWxkIGJlIGNvbXBhcmVkLlxyXG4gICAgICogQHJldHVybnMgVGhlIFtbUGFyYW1dXXMgd2hpY2ggZGlmZmVyLCBvciBudWxsIGlmIHRoZSB0d28gbm9kZXMgYXJlIGZvciBkaWZmZXJlbnQgc3RhdGVzXHJcbiAgICAgKi9cclxuICAgIFBhdGhOb2RlLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG5vZGUsIHBhcmFtc0ZuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IG5vZGUuc3RhdGUpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgcGFyYW1zID0gcGFyYW1zRm4gPyBwYXJhbXNGbih0aGlzKSA6IHRoaXMucGFyYW1TY2hlbWE7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtXzEuUGFyYW0uY2hhbmdlZChwYXJhbXMsIHRoaXMucGFyYW1WYWx1ZXMsIG5vZGUucGFyYW1WYWx1ZXMpO1xyXG4gICAgfTtcclxuICAgIC8qKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFBhdGhOb2RlICovXHJcbiAgICBQYXRoTm9kZS5jbG9uZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoTm9kZShub2RlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUGF0aE5vZGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUGF0aE5vZGUgPSBQYXRoTm9kZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aE5vZGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcGF0aC9wYXRoTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XHJcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xyXG52YXIgZ2xvYl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9nbG9iXCIpO1xyXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xyXG4vKipcclxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBVSS1Sb3V0ZXIgc3RhdGUuXHJcbiAqXHJcbiAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBjcmVhdGVkIHdoZW4gYSBbW1N0YXRlRGVjbGFyYXRpb25dXSBpcyByZWdpc3RlcmVkIHdpdGggdGhlIFtbU3RhdGVSZWdpc3RyeV1dLlxyXG4gKlxyXG4gKiBBIHJlZ2lzdGVyZWQgW1tTdGF0ZURlY2xhcmF0aW9uXV0gaXMgYXVnbWVudGVkIHdpdGggYSBnZXR0ZXIgKFtbU3RhdGVEZWNsYXJhdGlvbi4kJHN0YXRlXV0pIHdoaWNoIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgW1tTdGF0ZU9iamVjdF1dIG9iamVjdC5cclxuICpcclxuICogVGhpcyBjbGFzcyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSB0aGUgY29ycmVzcG9uZGluZyBbW1N0YXRlRGVjbGFyYXRpb25dXS5cclxuICogRWFjaCBvZiBpdHMgb3duIHByb3BlcnRpZXMgKGkuZS4sIGBoYXNPd25Qcm9wZXJ0eWApIGFyZSBidWlsdCB1c2luZyBidWlsZGVycyBmcm9tIHRoZSBbW1N0YXRlQnVpbGRlcl1dLlxyXG4gKi9cclxudmFyIFN0YXRlT2JqZWN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgU3RhdGUuY3JlYXRlKCkgKi9cclxuICAgIGZ1bmN0aW9uIFN0YXRlT2JqZWN0KGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiBTdGF0ZU9iamVjdC5jcmVhdGUoY29uZmlnIHx8IHt9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgc3RhdGUgb2JqZWN0IHRvIHB1dCB0aGUgcHJpdmF0ZS9pbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9udG8uXHJcbiAgICAgKiBUaGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIGxvb2tzIGxpa2U6XHJcbiAgICAgKiAoSW50ZXJuYWwgU3RhdGUgT2JqZWN0KSAtPiAoQ29weSBvZiBTdGF0ZS5wcm90b3R5cGUpIC0+IChTdGF0ZSBEZWNsYXJhdGlvbiBvYmplY3QpIC0+IChTdGF0ZSBEZWNsYXJhdGlvbidzIHByb3RvdHlwZS4uLilcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGVEZWNsIHRoZSB1c2VyLXN1cHBsaWVkIFN0YXRlIERlY2xhcmF0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7U3RhdGVPYmplY3R9IGFuIGludGVybmFsIFN0YXRlIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBTdGF0ZU9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoc3RhdGVEZWNsKSB7XHJcbiAgICAgICAgc3RhdGVEZWNsID0gU3RhdGVPYmplY3QuaXNTdGF0ZUNsYXNzKHN0YXRlRGVjbCkgPyBuZXcgc3RhdGVEZWNsKCkgOiBzdGF0ZURlY2w7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gY29tbW9uXzEuaW5oZXJpdChjb21tb25fMS5pbmhlcml0KHN0YXRlRGVjbCwgU3RhdGVPYmplY3QucHJvdG90eXBlKSk7XHJcbiAgICAgICAgc3RhdGVEZWNsLiQkc3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZTsgfTtcclxuICAgICAgICBzdGF0ZS5zZWxmID0gc3RhdGVEZWNsO1xyXG4gICAgICAgIHN0YXRlLl9fc3RhdGVPYmplY3RDYWNoZSA9IHtcclxuICAgICAgICAgICAgbmFtZUdsb2I6IGdsb2JfMS5HbG9iLmZyb21TdHJpbmcoc3RhdGUubmFtZSkgLy8gbWlnaHQgcmV0dXJuIG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIHRoZSBzYW1lIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIENvbXBhcmVzIHRoZSBpZGVudGl0eSBvZiB0aGUgc3RhdGUgYWdhaW5zdCB0aGUgcGFzc2VkIHZhbHVlLCB3aGljaCBpcyBlaXRoZXIgYW4gb2JqZWN0XHJcbiAgICAgKiByZWZlcmVuY2UgdG8gdGhlIGFjdHVhbCBgU3RhdGVgIGluc3RhbmNlLCB0aGUgb3JpZ2luYWwgZGVmaW5pdGlvbiBvYmplY3QgcGFzc2VkIHRvXHJcbiAgICAgKiBgJHN0YXRlUHJvdmlkZXIuc3RhdGUoKWAsIG9yIHRoZSBmdWxseS1xdWFsaWZpZWQgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVmIENhbiBiZSBvbmUgb2YgKGEpIGEgYFN0YXRlYCBpbnN0YW5jZSwgKGIpIGFuIG9iamVjdCB0aGF0IHdhcyBwYXNzZWRcclxuICAgICAqICAgICAgICBpbnRvIGAkc3RhdGVQcm92aWRlci5zdGF0ZSgpYCwgKGMpIHRoZSBmdWxseS1xdWFsaWZpZWQgbmFtZSBvZiBhIHN0YXRlIGFzIGEgc3RyaW5nLlxyXG4gICAgICogQHJldHVybnMgUmV0dXJucyBgdHJ1ZWAgaWYgYHJlZmAgbWF0Y2hlcyB0aGUgY3VycmVudCBgU3RhdGVgIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBTdGF0ZU9iamVjdC5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAocmVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgPT09IHJlZiB8fCB0aGlzLnNlbGYgPT09IHJlZiB8fCB0aGlzLmZxbigpID09PSByZWY7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCB0aGlzIGRvZXMgbm90IHByb3Blcmx5IGhhbmRsZSBkb3Qgbm90YXRpb25cclxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYSBkb3Qtc2VwYXJhdGVkIG5hbWUgb2YgdGhlIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBTdGF0ZU9iamVjdC5wcm90b3R5cGUuZnFuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQgfHwgISh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xyXG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJlbnQuZnFuKCk7XHJcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBuYW1lICsgXCIuXCIgKyB0aGlzLm5hbWUgOiB0aGlzLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByb290IG5vZGUgb2YgdGhpcyBzdGF0ZSdzIHRyZWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHJvb3Qgb2YgdGhpcyBzdGF0ZSdzIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5yb290KCkgfHwgdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHN0YXRlJ3MgYFBhcmFtYCBvYmplY3RzXHJcbiAgICAgKlxyXG4gICAgICogR2V0cyB0aGUgbGlzdCBvZiBbW1BhcmFtXV0gb2JqZWN0cyBvd25lZCBieSB0aGUgc3RhdGUuXHJcbiAgICAgKiBJZiBgb3B0cy5pbmhlcml0YCBpcyB0cnVlLCBpdCBhbHNvIGluY2x1ZGVzIHRoZSBhbmNlc3RvciBzdGF0ZXMnIFtbUGFyYW1dXSBvYmplY3RzLlxyXG4gICAgICogSWYgYG9wdHMubWF0Y2hpbmdLZXlzYCBleGlzdHMsIHJldHVybnMgb25seSBgUGFyYW1gcyB3aG9zZSBgaWRgIGlzIGEga2V5IG9uIHRoZSBgbWF0Y2hpbmdLZXlzYCBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0cyBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICBvcHRzID0gY29tbW9uXzEuZGVmYXVsdHMob3B0cywgeyBpbmhlcml0OiB0cnVlLCBtYXRjaGluZ0tleXM6IG51bGwgfSk7XHJcbiAgICAgICAgdmFyIGluaGVyaXRlZCA9IG9wdHMuaW5oZXJpdCAmJiB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5wYXJhbWV0ZXJzKCkgfHwgW107XHJcbiAgICAgICAgcmV0dXJuIGluaGVyaXRlZC5jb25jYXQoY29tbW9uXzEudmFsdWVzKHRoaXMucGFyYW1zKSlcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFvcHRzLm1hdGNoaW5nS2V5cyB8fCBvcHRzLm1hdGNoaW5nS2V5cy5oYXNPd25Qcm9wZXJ0eShwYXJhbS5pZCk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBbW1BhcmFtXV0gdGhhdCBpcyBvd25lZCBieSB0aGUgc3RhdGVcclxuICAgICAqXHJcbiAgICAgKiBJZiBgb3B0cy5pbmhlcml0YCBpcyB0cnVlLCBpdCBhbHNvIHNlYXJjaGVzIHRoZSBhbmNlc3RvciBzdGF0ZXNgIFtbUGFyYW1dXXMuXHJcbiAgICAgKiBAcGFyYW0gaWQgdGhlIG5hbWUgb2YgdGhlIFtbUGFyYW1dXSB0byByZXR1cm5cclxuICAgICAqIEBwYXJhbSBvcHRzIG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgU3RhdGVPYmplY3QucHJvdG90eXBlLnBhcmFtZXRlciA9IGZ1bmN0aW9uIChpZCwgb3B0cykge1xyXG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnVybCAmJiB0aGlzLnVybC5wYXJhbWV0ZXIoaWQsIG9wdHMpIHx8XHJcbiAgICAgICAgICAgIGNvbW1vbl8xLmZpbmQoY29tbW9uXzEudmFsdWVzKHRoaXMucGFyYW1zKSwgaG9mXzEucHJvcEVxKCdpZCcsIGlkKSkgfHxcclxuICAgICAgICAgICAgb3B0cy5pbmhlcml0ICYmIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnBhcmFtZXRlcihpZCkpO1xyXG4gICAgfTtcclxuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mcW4oKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3RhdGVPYmplY3Q7XHJcbn0oKSk7XHJcbi8qKiBQcmVkaWNhdGUgd2hpY2ggcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gY2xhc3Mgd2l0aCBAU3RhdGUoKSBkZWNvcmF0b3IgKi9cclxuU3RhdGVPYmplY3QuaXNTdGF0ZUNsYXNzID0gZnVuY3Rpb24gKHN0YXRlRGVjbCkge1xyXG4gICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHN0YXRlRGVjbCkgJiYgc3RhdGVEZWNsWydfX3VpUm91dGVyU3RhdGUnXSA9PT0gdHJ1ZTtcclxufTtcclxuLyoqIFByZWRpY2F0ZSB3aGljaCByZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhbiBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0ICovXHJcblN0YXRlT2JqZWN0LmlzU3RhdGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzT2JqZWN0KG9ialsnX19zdGF0ZU9iamVjdENhY2hlJ10pO1xyXG59O1xyXG5leHBvcnRzLlN0YXRlT2JqZWN0ID0gU3RhdGVPYmplY3Q7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlT2JqZWN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQGNvcmVhcGlcclxuICogQG1vZHVsZSB0cmFuc2l0aW9uXHJcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cclxudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XHJcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XHJcbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTsgLy8gaGFzIG9yIGlzIHVzaW5nXHJcbnZhciBnbG9iXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2dsb2JcIik7XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBzdGF0ZSBtYXRjaGVzIHRoZSBtYXRjaENyaXRlcmlhXHJcbiAqXHJcbiAqIEBoaWRkZW5cclxuICpcclxuICogQHBhcmFtIHN0YXRlIGEgU3RhdGUgT2JqZWN0IHRvIHRlc3QgYWdhaW5zdFxyXG4gKiBAcGFyYW0gY3JpdGVyaW9uXHJcbiAqIC0gSWYgYSBzdHJpbmcsIG1hdGNoU3RhdGUgdXNlcyB0aGUgc3RyaW5nIGFzIGEgZ2xvYi1tYXRjaGVyIGFnYWluc3QgdGhlIHN0YXRlIG5hbWVcclxuICogLSBJZiBhbiBhcnJheSAob2Ygc3RyaW5ncyksIG1hdGNoU3RhdGUgdXNlcyBlYWNoIHN0cmluZyBpbiB0aGUgYXJyYXkgYXMgYSBnbG9iLW1hdGNoZXJzIGFnYWluc3QgdGhlIHN0YXRlIG5hbWVcclxuICogICBhbmQgcmV0dXJucyBhIHBvc2l0aXZlIG1hdGNoIGlmIGFueSBvZiB0aGUgZ2xvYnMgbWF0Y2guXHJcbiAqIC0gSWYgYSBmdW5jdGlvbiwgbWF0Y2hTdGF0ZSBjYWxscyB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgc3RhdGUgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgZnVuY3Rpb24ncyByZXN1bHQgaXMgdHJ1dGh5LlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIG1hdGNoU3RhdGUoc3RhdGUsIGNyaXRlcmlvbikge1xyXG4gICAgdmFyIHRvTWF0Y2ggPSBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoY3JpdGVyaW9uKSA/IFtjcml0ZXJpb25dIDogY3JpdGVyaW9uO1xyXG4gICAgZnVuY3Rpb24gbWF0Y2hHbG9icyhfc3RhdGUpIHtcclxuICAgICAgICB2YXIgZ2xvYlN0cmluZ3MgPSB0b01hdGNoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2xvYlN0cmluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGdsb2IgPSBuZXcgZ2xvYl8xLkdsb2IoZ2xvYlN0cmluZ3NbaV0pO1xyXG4gICAgICAgICAgICBpZiAoKGdsb2IgJiYgZ2xvYi5tYXRjaGVzKF9zdGF0ZS5uYW1lKSkgfHwgKCFnbG9iICYmIGdsb2JTdHJpbmdzW2ldID09PSBfc3RhdGUubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBtYXRjaEZuID0gKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHRvTWF0Y2gpID8gdG9NYXRjaCA6IG1hdGNoR2xvYnMpO1xyXG4gICAgcmV0dXJuICEhbWF0Y2hGbihzdGF0ZSk7XHJcbn1cclxuZXhwb3J0cy5tYXRjaFN0YXRlID0gbWF0Y2hTdGF0ZTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbGFwaVxyXG4gKiBUaGUgcmVnaXN0cmF0aW9uIGRhdGEgZm9yIGEgcmVnaXN0ZXJlZCB0cmFuc2l0aW9uIGhvb2tcclxuICovXHJcbnZhciBSZWdpc3RlcmVkSG9vayA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWdpc3RlcmVkSG9vayh0cmFuU3ZjLCBldmVudFR5cGUsIGNhbGxiYWNrLCBtYXRjaENyaXRlcmlhLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICB0aGlzLnRyYW5TdmMgPSB0cmFuU3ZjO1xyXG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICB0aGlzLm1hdGNoQ3JpdGVyaWEgPSBtYXRjaENyaXRlcmlhO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSBvcHRpb25zLnByaW9yaXR5IHx8IDA7XHJcbiAgICAgICAgdGhpcy5iaW5kID0gb3B0aW9ucy5iaW5kIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZGVyZWdpc3RlcmVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG1hdGNoaW5nIFtbUGF0aE5vZGVdXXNcclxuICAgICAqXHJcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBbW1BhdGhOb2RlXV1zLCBhbmQgYSBbW0hvb2tNYXRjaENyaXRlcmlvbl1dLCByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmdcclxuICAgICAqIHRoZSBbW1BhdGhOb2RlXV1zIHRoYXQgdGhlIGNyaXRlcmlhIG1hdGNoZXMsIG9yIGBudWxsYCBpZiB0aGVyZSB3ZXJlIG5vIG1hdGNoaW5nIG5vZGVzLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybmluZyBgbnVsbGAgaXMgc2lnbmlmaWNhbnQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgZGVmYXVsdFxyXG4gICAgICogXCJtYXRjaC1hbGwgY3JpdGVyaW9uIHZhbHVlXCIgb2YgYHRydWVgIGNvbXBhcmVkIHRvIGEgYCgpID0+IHRydWVgIGZ1bmN0aW9uLFxyXG4gICAgICogd2hlbiB0aGUgbm9kZXMgaXMgYW4gZW1wdHkgYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyB1c2VmdWwgdG8gYWxsb3cgYSB0cmFuc2l0aW9uIG1hdGNoIGNyaXRlcmlhIG9mIGBlbnRlcmluZzogdHJ1ZWBcclxuICAgICAqIHRvIHN0aWxsIG1hdGNoIGEgdHJhbnNpdGlvbiwgZXZlbiB3aGVuIGBlbnRlcmluZyA9PT0gW11gLiAgQ29udHJhc3QgdGhhdFxyXG4gICAgICogd2l0aCBgZW50ZXJpbmc6IChzdGF0ZSkgPT4gdHJ1ZWAgd2hpY2ggb25seSBtYXRjaGVzIHdoZW4gYSBzdGF0ZSBpcyBhY3R1YWxseVxyXG4gICAgICogYmVpbmcgZW50ZXJlZC5cclxuICAgICAqL1xyXG4gICAgUmVnaXN0ZXJlZEhvb2sucHJvdG90eXBlLl9tYXRjaGluZ05vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBjcml0ZXJpb24pIHtcclxuICAgICAgICBpZiAoY3JpdGVyaW9uID09PSB0cnVlKVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICAgICAgdmFyIG1hdGNoaW5nID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBtYXRjaFN0YXRlKG5vZGUuc3RhdGUsIGNyaXRlcmlvbik7IH0pO1xyXG4gICAgICAgIHJldHVybiBtYXRjaGluZy5sZW5ndGggPyBtYXRjaGluZyA6IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IG1hdGNoIGNyaXRlcmlhIChhbGwgYHRydWVgKVxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGhhcyBhbGwgdGhlIGNyaXRlcmlhIG1hdGNoIHBhdGhzIGFzIGtleXMgYW5kIGB0cnVlYCBhcyB2YWx1ZXMsIGkuZS46XHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIHtcclxuICAgICAqICAgdG86IHRydWUsXHJcbiAgICAgKiAgIGZyb206IHRydWUsXHJcbiAgICAgKiAgIGVudGVyaW5nOiB0cnVlLFxyXG4gICAgICogICBleGl0aW5nOiB0cnVlLFxyXG4gICAgICogICByZXRhaW5lZDogdHJ1ZSxcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgUmVnaXN0ZXJlZEhvb2sucHJvdG90eXBlLl9nZXREZWZhdWx0TWF0Y2hDcml0ZXJpYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwKHRoaXMudHJhblN2Yy5fcGx1Z2luYXBpLl9nZXRQYXRoVHlwZXMoKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG1hdGNoaW5nIG5vZGVzIGFzIFtbSU1hdGNoaW5nTm9kZXNdXVxyXG4gICAgICpcclxuICAgICAqIENyZWF0ZSBhIElNYXRjaGluZ05vZGVzIG9iamVjdCBmcm9tIHRoZSBUcmFuc2l0aW9uSG9va1R5cGVzIHRoYXQgaXMgcm91Z2hseSBlcXVpdmFsZW50IHRvOlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiBsZXQgbWF0Y2hlczogSU1hdGNoaW5nTm9kZXMgPSB7XHJcbiAgICAgKiAgIHRvOiAgICAgICBfbWF0Y2hpbmdOb2RlcyhbdGFpbCh0cmVlQ2hhbmdlcy50byldLCAgIG1jLnRvKSxcclxuICAgICAqICAgZnJvbTogICAgIF9tYXRjaGluZ05vZGVzKFt0YWlsKHRyZWVDaGFuZ2VzLmZyb20pXSwgbWMuZnJvbSksXHJcbiAgICAgKiAgIGV4aXRpbmc6ICBfbWF0Y2hpbmdOb2Rlcyh0cmVlQ2hhbmdlcy5leGl0aW5nLCAgICAgIG1jLmV4aXRpbmcpLFxyXG4gICAgICogICByZXRhaW5lZDogX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMucmV0YWluZWQsICAgICBtYy5yZXRhaW5lZCksXHJcbiAgICAgKiAgIGVudGVyaW5nOiBfbWF0Y2hpbmdOb2Rlcyh0cmVlQ2hhbmdlcy5lbnRlcmluZywgICAgIG1jLmVudGVyaW5nKSxcclxuICAgICAqIH07XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgUmVnaXN0ZXJlZEhvb2sucHJvdG90eXBlLl9nZXRNYXRjaGluZ05vZGVzID0gZnVuY3Rpb24gKHRyZWVDaGFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY3JpdGVyaWEgPSBjb21tb25fMS5leHRlbmQodGhpcy5fZ2V0RGVmYXVsdE1hdGNoQ3JpdGVyaWEoKSwgdGhpcy5tYXRjaENyaXRlcmlhKTtcclxuICAgICAgICB2YXIgcGF0aHMgPSBjb21tb25fMS52YWx1ZXModGhpcy50cmFuU3ZjLl9wbHVnaW5hcGkuX2dldFBhdGhUeXBlcygpKTtcclxuICAgICAgICByZXR1cm4gcGF0aHMucmVkdWNlKGZ1bmN0aW9uIChtbiwgcGF0aHR5cGUpIHtcclxuICAgICAgICAgICAgLy8gU1RBVEUgc2NvcGUgY3JpdGVyaWEgbWF0Y2hlcyBhZ2FpbnN0IGV2ZXJ5IG5vZGUgaW4gdGhlIHBhdGguXHJcbiAgICAgICAgICAgIC8vIFRSQU5TSVRJT04gc2NvcGUgY3JpdGVyaWEgbWF0Y2hlcyBhZ2FpbnN0IG9ubHkgdGhlIGxhc3Qgbm9kZSBpbiB0aGUgcGF0aFxyXG4gICAgICAgICAgICB2YXIgaXNTdGF0ZUhvb2sgPSBwYXRodHlwZS5zY29wZSA9PT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURTtcclxuICAgICAgICAgICAgdmFyIHBhdGggPSB0cmVlQ2hhbmdlc1twYXRodHlwZS5uYW1lXSB8fCBbXTtcclxuICAgICAgICAgICAgdmFyIG5vZGVzID0gaXNTdGF0ZUhvb2sgPyBwYXRoIDogW2NvbW1vbl8xLnRhaWwocGF0aCldO1xyXG4gICAgICAgICAgICBtbltwYXRodHlwZS5uYW1lXSA9IF90aGlzLl9tYXRjaGluZ05vZGVzKG5vZGVzLCBjcml0ZXJpYVtwYXRodHlwZS5uYW1lXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtbjtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgaG9vaydzIFtbbWF0Y2hDcml0ZXJpYV1dIG1hdGNoIHRoZSBnaXZlbiBbW1RyZWVDaGFuZ2VzXV1cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBhbiBJTWF0Y2hpbmdOb2RlcyBvYmplY3QsIG9yIG51bGwuIElmIGFuIElNYXRjaGluZ05vZGVzIG9iamVjdCBpcyByZXR1cm5lZCwgaXRzIHZhbHVlc1xyXG4gICAgICogYXJlIHRoZSBtYXRjaGluZyBbW1BhdGhOb2RlXV1zIGZvciBlYWNoIFtbSG9va01hdGNoQ3JpdGVyaW9uXV0gKHRvLCBmcm9tLCBleGl0aW5nLCByZXRhaW5lZCwgZW50ZXJpbmcpXHJcbiAgICAgKi9cclxuICAgIFJlZ2lzdGVyZWRIb29rLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKHRyZWVDaGFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXMgPSB0aGlzLl9nZXRNYXRjaGluZ05vZGVzKHRyZWVDaGFuZ2VzKTtcclxuICAgICAgICAvLyBDaGVjayBpZiBhbGwgdGhlIGNyaXRlcmlhIG1hdGNoZWQgdGhlIFRyZWVDaGFuZ2VzIG9iamVjdFxyXG4gICAgICAgIHZhciBhbGxNYXRjaGVkID0gY29tbW9uXzEudmFsdWVzKG1hdGNoZXMpLmV2ZXJ5KGNvbW1vbl8xLmlkZW50aXR5KTtcclxuICAgICAgICByZXR1cm4gYWxsTWF0Y2hlZCA/IG1hdGNoZXMgOiBudWxsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZWdpc3RlcmVkSG9vaztcclxufSgpKTtcclxuZXhwb3J0cy5SZWdpc3RlcmVkSG9vayA9IFJlZ2lzdGVyZWRIb29rO1xyXG4vKiogQGhpZGRlbiBSZXR1cm4gYSByZWdpc3RyYXRpb24gZnVuY3Rpb24gb2YgdGhlIHJlcXVlc3RlZCB0eXBlLiAqL1xyXG5mdW5jdGlvbiBtYWtlRXZlbnQocmVnaXN0cnksIHRyYW5zaXRpb25TZXJ2aWNlLCBldmVudFR5cGUpIHtcclxuICAgIC8vIENyZWF0ZSB0aGUgb2JqZWN0IHdoaWNoIGhvbGRzIHRoZSByZWdpc3RlcmVkIHRyYW5zaXRpb24gaG9va3MuXHJcbiAgICB2YXIgX3JlZ2lzdGVyZWRIb29rcyA9IHJlZ2lzdHJ5Ll9yZWdpc3RlcmVkSG9va3MgPSAocmVnaXN0cnkuX3JlZ2lzdGVyZWRIb29rcyB8fCB7fSk7XHJcbiAgICB2YXIgaG9va3MgPSBfcmVnaXN0ZXJlZEhvb2tzW2V2ZW50VHlwZS5uYW1lXSA9IFtdO1xyXG4gICAgLy8gQ3JlYXRlIGhvb2sgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIG9uIHRoZSBJSG9va1JlZ2lzdHJ5IGZvciB0aGUgZXZlbnRcclxuICAgIHJlZ2lzdHJ5W2V2ZW50VHlwZS5uYW1lXSA9IGhvb2tSZWdpc3RyYXRpb25GbjtcclxuICAgIGZ1bmN0aW9uIGhvb2tSZWdpc3RyYXRpb25GbihtYXRjaE9iamVjdCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIHZhciByZWdpc3RlcmVkSG9vayA9IG5ldyBSZWdpc3RlcmVkSG9vayh0cmFuc2l0aW9uU2VydmljZSwgZXZlbnRUeXBlLCBjYWxsYmFjaywgbWF0Y2hPYmplY3QsIG9wdGlvbnMpO1xyXG4gICAgICAgIGhvb2tzLnB1c2gocmVnaXN0ZXJlZEhvb2spO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBkZXJlZ2lzdGVyRXZlbnRIb29rKCkge1xyXG4gICAgICAgICAgICByZWdpc3RlcmVkSG9vay5fZGVyZWdpc3RlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbShob29rcykocmVnaXN0ZXJlZEhvb2spO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaG9va1JlZ2lzdHJhdGlvbkZuO1xyXG59XHJcbmV4cG9ydHMubWFrZUV2ZW50ID0gbWFrZUV2ZW50O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rUmVnaXN0cnkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9ob29rUmVnaXN0cnkuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBAY29yZWFwaVxyXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cclxuICovXHJcbi8qKiBmb3IgdHlwZWRvYyAqL1xyXG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7XHJcbnZhciB0cmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uXCIpO1xyXG52YXIgaG9va1JlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi9ob29rUmVnaXN0cnlcIik7XHJcbnZhciBjb3JlUmVzb2x2YWJsZXNfMSA9IHJlcXVpcmUoXCIuLi9ob29rcy9jb3JlUmVzb2x2YWJsZXNcIik7XHJcbnZhciByZWRpcmVjdFRvXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvcmVkaXJlY3RUb1wiKTtcclxudmFyIG9uRW50ZXJFeGl0UmV0YWluXzEgPSByZXF1aXJlKFwiLi4vaG9va3Mvb25FbnRlckV4aXRSZXRhaW5cIik7XHJcbnZhciByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvcmVzb2x2ZVwiKTtcclxudmFyIHZpZXdzXzEgPSByZXF1aXJlKFwiLi4vaG9va3Mvdmlld3NcIik7XHJcbnZhciB1cGRhdGVHbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvdXBkYXRlR2xvYmFsc1wiKTtcclxudmFyIHVybF8xID0gcmVxdWlyZShcIi4uL2hvb2tzL3VybFwiKTtcclxudmFyIGxhenlMb2FkXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvbGF6eUxvYWRcIik7XHJcbnZhciB0cmFuc2l0aW9uRXZlbnRUeXBlXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uRXZlbnRUeXBlXCIpO1xyXG52YXIgdHJhbnNpdGlvbkhvb2tfMSA9IHJlcXVpcmUoXCIuL3RyYW5zaXRpb25Ib29rXCIpO1xyXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XHJcbnZhciBpZ25vcmVkVHJhbnNpdGlvbl8xID0gcmVxdWlyZShcIi4uL2hvb2tzL2lnbm9yZWRUcmFuc2l0aW9uXCIpO1xyXG52YXIgaW52YWxpZFRyYW5zaXRpb25fMSA9IHJlcXVpcmUoXCIuLi9ob29rcy9pbnZhbGlkVHJhbnNpdGlvblwiKTtcclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IFtbVHJhbnNpdGlvbl1dIG9wdGlvbnMuXHJcbiAqXHJcbiAqIEluY2x1ZGUgdGhpcyBvYmplY3Qgd2hlbiBhcHBseWluZyBjdXN0b20gZGVmYXVsdHM6XHJcbiAqIGxldCByZWxvYWRPcHRzID0geyByZWxvYWQ6IHRydWUsIG5vdGlmeTogdHJ1ZSB9XHJcbiAqIGxldCBvcHRpb25zID0gZGVmYXVsdHModGhlaXJPcHRzLCBjdXN0b21EZWZhdWx0cywgZGVmYXVsdE9wdGlvbnMpO1xyXG4gKi9cclxuZXhwb3J0cy5kZWZhdWx0VHJhbnNPcHRzID0ge1xyXG4gICAgbG9jYXRpb246IHRydWUsXHJcbiAgICByZWxhdGl2ZTogbnVsbCxcclxuICAgIGluaGVyaXQ6IGZhbHNlLFxyXG4gICAgbm90aWZ5OiB0cnVlLFxyXG4gICAgcmVsb2FkOiBmYWxzZSxcclxuICAgIGN1c3RvbToge30sXHJcbiAgICBjdXJyZW50OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxyXG4gICAgc291cmNlOiBcInVua25vd25cIlxyXG59O1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIFRyYW5zaXRpb25zLlxyXG4gKlxyXG4gKiAtIE1vc3QgaW1wb3J0YW50bHksIGl0IGFsbG93cyBnbG9iYWwgVHJhbnNpdGlvbiBIb29rcyB0byBiZSByZWdpc3RlcmVkLlxyXG4gKiAtIEl0IGFsbG93cyB0aGUgZGVmYXVsdCB0cmFuc2l0aW9uIGVycm9yIGhhbmRsZXIgdG8gYmUgc2V0LlxyXG4gKiAtIEl0IGFsc28gaGFzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IFtbVHJhbnNpdGlvbl1dIG9iamVjdHMsICh1c2VkIGludGVybmFsbHkgYnkgdGhlIFtbU3RhdGVTZXJ2aWNlXV0pLlxyXG4gKlxyXG4gKiBBdCBib290c3RyYXAsIFtbVUlSb3V0ZXJdXSBjcmVhdGVzIGEgc2luZ2xlIGluc3RhbmNlIChzaW5nbGV0b24pIG9mIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG52YXIgVHJhbnNpdGlvblNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqIEBoaWRkZW4gKi9cclxuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25TZXJ2aWNlKF9yb3V0ZXIpIHtcclxuICAgICAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25Db3VudCA9IDA7XHJcbiAgICAgICAgLyoqIEBoaWRkZW4gVGhlIHRyYW5zaXRpb24gaG9vayB0eXBlcywgc3VjaCBhcyBgb25FbnRlcmAsIGBvblN0YXJ0YCwgZXRjICovXHJcbiAgICAgICAgdGhpcy5fZXZlbnRUeXBlcyA9IFtdO1xyXG4gICAgICAgIC8qKiBAaGlkZGVuIFRoZSByZWdpc3RlcmVkIHRyYW5zaXRpb24gaG9va3MgKi9cclxuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkSG9va3MgPSB7fTtcclxuICAgICAgICAvKiogQGhpZGRlbiBUaGUgIHBhdGhzIG9uIGEgY3JpdGVyaWEgb2JqZWN0ICovXHJcbiAgICAgICAgdGhpcy5fY3JpdGVyaWFQYXRocyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3JvdXRlciA9IF9yb3V0ZXI7XHJcbiAgICAgICAgdGhpcy4kdmlldyA9IF9yb3V0ZXIudmlld1NlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5fZGVyZWdpc3Rlckhvb2tGbnMgPSB7fTtcclxuICAgICAgICB0aGlzLl9wbHVnaW5hcGkgPSBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhob2ZfMS52YWwodGhpcyksIHt9LCBob2ZfMS52YWwodGhpcyksIFtcclxuICAgICAgICAgICAgJ19kZWZpbmVQYXRoVHlwZScsXHJcbiAgICAgICAgICAgICdfZGVmaW5lRXZlbnQnLFxyXG4gICAgICAgICAgICAnX2dldFBhdGhUeXBlcycsXHJcbiAgICAgICAgICAgICdfZ2V0RXZlbnRzJyxcclxuICAgICAgICAgICAgJ2dldEhvb2tzJyxcclxuICAgICAgICBdKTtcclxuICAgICAgICB0aGlzLl9kZWZpbmVDb3JlUGF0aHMoKTtcclxuICAgICAgICB0aGlzLl9kZWZpbmVDb3JlRXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb3JlVHJhbnNpdGlvbkhvb2tzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhIFtbVHJhbnNpdGlvbkhvb2tGbl1dLCBjYWxsZWQgKndoaWxlIGEgdHJhbnNpdGlvbiBpcyBiZWluZyBjb25zdHJ1Y3RlZCouXHJcbiAgICAgKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgdHJhbnNpdGlvbiBsaWZlY3ljbGUgaG9vaywgd2hpY2ggaXMgaW52b2tlZCBkdXJpbmcgdHJhbnNpdGlvbiBjb25zdHJ1Y3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBsb3cgbGV2ZWwgaG9vayBzaG91bGQgb25seSBiZSB1c2VkIGJ5IHBsdWdpbnMuXHJcbiAgICAgKiBUaGlzIGNhbiBiZSBhIHVzZWZ1bCB0aW1lIGZvciBwbHVnaW5zIHRvIGFkZCByZXNvbHZlcyBvciBtdXRhdGUgdGhlIHRyYW5zaXRpb24gYXMgbmVlZGVkLlxyXG4gICAgICogVGhlIFN0aWNreSBTdGF0ZXMgcGx1Z2luIHVzZXMgdGhpcyBob29rIHRvIG1vZGlmeSB0aGUgdHJlZWNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIExpZmVjeWNsZVxyXG4gICAgICpcclxuICAgICAqIGBvbkNyZWF0ZWAgaG9va3MgYXJlIGludm9rZWQgKndoaWxlIGEgdHJhbnNpdGlvbiBpcyBiZWluZyBjb25zdHJ1Y3RlZCouXHJcbiAgICAgKlxyXG4gICAgICogIyMjIFJldHVybiB2YWx1ZVxyXG4gICAgICpcclxuICAgICAqIFRoZSBob29rJ3MgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWRcclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxhcGlcclxuICAgICAqIEBwYXJhbSBjcml0ZXJpYSBkZWZpbmVzIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBIb29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgaG9vayBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGludm9rZWQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgcmVnaXN0cmF0aW9uIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGhvb2suXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vbkNyZWF0ZSA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25CZWZvcmUgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uRXhpdCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgY2FsbGJhY2ssIG9wdGlvbnMpIHsgcmV0dXJuOyB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25SZXRhaW4gPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uRW50ZXIgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uRmluaXNoID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XHJcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cclxuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcclxuICAgIC8qKlxyXG4gICAgICogZGlzcG9zZVxyXG4gICAgICogQGludGVybmFsYXBpXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikge1xyXG4gICAgICAgIGNvbW1vbl8xLnZhbHVlcyh0aGlzLl9yZWdpc3RlcmVkSG9va3MpLmZvckVhY2goZnVuY3Rpb24gKGhvb2tzQXJyYXkpIHsgcmV0dXJuIGhvb2tzQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xyXG4gICAgICAgICAgICBob29rLl9kZXJlZ2lzdGVyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKGhvb2tzQXJyYXksIGhvb2spO1xyXG4gICAgICAgIH0pOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgW1tUcmFuc2l0aW9uXV0gb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIG5ldyBUcmFuc2l0aW9uIG9iamVjdHMuXHJcbiAgICAgKiBJdCBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIFtbU3RhdGVTZXJ2aWNlXV0gYW5kIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIGNhbGxlZCBieSBhcHBsaWNhdGlvbiBjb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmcm9tUGF0aCB0aGUgcGF0aCB0byB0aGUgY3VycmVudCBzdGF0ZSAodGhlIGZyb20gc3RhdGUpXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgdGhlIHRhcmdldCBzdGF0ZSAoZGVzdGluYXRpb24pXHJcbiAgICAgKiBAcmV0dXJucyBhIFRyYW5zaXRpb25cclxuICAgICAqL1xyXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChmcm9tUGF0aCwgdGFyZ2V0U3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHRyYW5zaXRpb25fMS5UcmFuc2l0aW9uKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSwgdGhpcy5fcm91dGVyKTtcclxuICAgIH07XHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLl9kZWZpbmVDb3JlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBQaGFzZSA9IGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2U7XHJcbiAgICAgICAgdmFyIFRIID0gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vaztcclxuICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLl9jcml0ZXJpYVBhdGhzO1xyXG4gICAgICAgIHZhciBOT1JNQUxfU09SVCA9IGZhbHNlLCBSRVZFUlNFX1NPUlQgPSB0cnVlO1xyXG4gICAgICAgIHZhciBBU1lOQ0hST05PVVMgPSBmYWxzZSwgU1lOQ0hST05PVVMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25DcmVhdGVcIiwgUGhhc2UuQ1JFQVRFLCAwLCBwYXRocy50bywgTk9STUFMX1NPUlQsIFRILkxPR19SRUpFQ1RFRF9SRVNVTFQsIFRILlRIUk9XX0VSUk9SLCBTWU5DSFJPTk9VUyk7XHJcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvbkJlZm9yZVwiLCBQaGFzZS5CRUZPUkUsIDAsIHBhdGhzLnRvKTtcclxuICAgICAgICB0aGlzLl9kZWZpbmVFdmVudChcIm9uU3RhcnRcIiwgUGhhc2UuUlVOLCAwLCBwYXRocy50byk7XHJcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvbkV4aXRcIiwgUGhhc2UuUlVOLCAxMDAsIHBhdGhzLmV4aXRpbmcsIFJFVkVSU0VfU09SVCk7XHJcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoXCJvblJldGFpblwiLCBQaGFzZS5SVU4sIDIwMCwgcGF0aHMucmV0YWluZWQpO1xyXG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25FbnRlclwiLCBQaGFzZS5SVU4sIDMwMCwgcGF0aHMuZW50ZXJpbmcpO1xyXG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25GaW5pc2hcIiwgUGhhc2UuUlVOLCA0MDAsIHBhdGhzLnRvKTtcclxuICAgICAgICB0aGlzLl9kZWZpbmVFdmVudChcIm9uU3VjY2Vzc1wiLCBQaGFzZS5TVUNDRVNTLCAwLCBwYXRocy50bywgTk9STUFMX1NPUlQsIFRILkxPR19SRUpFQ1RFRF9SRVNVTFQsIFRILkxPR19FUlJPUiwgU1lOQ0hST05PVVMpO1xyXG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KFwib25FcnJvclwiLCBQaGFzZS5FUlJPUiwgMCwgcGF0aHMudG8sIE5PUk1BTF9TT1JULCBUSC5MT0dfUkVKRUNURURfUkVTVUxULCBUSC5MT0dfRVJST1IsIFNZTkNIUk9OT1VTKTtcclxuICAgIH07XHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLl9kZWZpbmVDb3JlUGF0aHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIFNUQVRFID0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURSwgVFJBTlNJVElPTiA9IGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rU2NvcGUuVFJBTlNJVElPTjtcclxuICAgICAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZShcInRvXCIsIFRSQU5TSVRJT04pO1xyXG4gICAgICAgIHRoaXMuX2RlZmluZVBhdGhUeXBlKFwiZnJvbVwiLCBUUkFOU0lUSU9OKTtcclxuICAgICAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZShcImV4aXRpbmdcIiwgU1RBVEUpO1xyXG4gICAgICAgIHRoaXMuX2RlZmluZVBhdGhUeXBlKFwicmV0YWluZWRcIiwgU1RBVEUpO1xyXG4gICAgICAgIHRoaXMuX2RlZmluZVBhdGhUeXBlKFwiZW50ZXJpbmdcIiwgU1RBVEUpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX2RlZmluZUV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGhvb2tQaGFzZSwgaG9va09yZGVyLCBjcml0ZXJpYU1hdGNoUGF0aCwgcmV2ZXJzZVNvcnQsIGdldFJlc3VsdEhhbmRsZXIsIGdldEVycm9ySGFuZGxlciwgc3luY2hyb25vdXMpIHtcclxuICAgICAgICBpZiAocmV2ZXJzZVNvcnQgPT09IHZvaWQgMCkgeyByZXZlcnNlU29ydCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGdldFJlc3VsdEhhbmRsZXIgPT09IHZvaWQgMCkgeyBnZXRSZXN1bHRIYW5kbGVyID0gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5IQU5ETEVfUkVTVUxUOyB9XHJcbiAgICAgICAgaWYgKGdldEVycm9ySGFuZGxlciA9PT0gdm9pZCAwKSB7IGdldEVycm9ySGFuZGxlciA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suUkVKRUNUX0VSUk9SOyB9XHJcbiAgICAgICAgaWYgKHN5bmNocm9ub3VzID09PSB2b2lkIDApIHsgc3luY2hyb25vdXMgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBldmVudFR5cGUgPSBuZXcgdHJhbnNpdGlvbkV2ZW50VHlwZV8xLlRyYW5zaXRpb25FdmVudFR5cGUobmFtZSwgaG9va1BoYXNlLCBob29rT3JkZXIsIGNyaXRlcmlhTWF0Y2hQYXRoLCByZXZlcnNlU29ydCwgZ2V0UmVzdWx0SGFuZGxlciwgZ2V0RXJyb3JIYW5kbGVyLCBzeW5jaHJvbm91cyk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRUeXBlcy5wdXNoKGV2ZW50VHlwZSk7XHJcbiAgICAgICAgaG9va1JlZ2lzdHJ5XzEubWFrZUV2ZW50KHRoaXMsIHRoaXMsIGV2ZW50VHlwZSk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqIEBoaWRkZW4gKi9cclxuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0RXZlbnRzID0gZnVuY3Rpb24gKHBoYXNlKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zaXRpb25Ib29rVHlwZXMgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHBoYXNlKSA/XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50VHlwZXMuZmlsdGVyKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLmhvb2tQaGFzZSA9PT0gcGhhc2U7IH0pIDpcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRUeXBlcy5zbGljZSgpO1xyXG4gICAgICAgIHJldHVybiB0cmFuc2l0aW9uSG9va1R5cGVzLnNvcnQoZnVuY3Rpb24gKGwsIHIpIHtcclxuICAgICAgICAgICAgdmFyIGNtcEJ5UGhhc2UgPSBsLmhvb2tQaGFzZSAtIHIuaG9va1BoYXNlO1xyXG4gICAgICAgICAgICByZXR1cm4gY21wQnlQaGFzZSA9PT0gMCA/IGwuaG9va09yZGVyIC0gci5ob29rT3JkZXIgOiBjbXBCeVBoYXNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIFBhdGggdG8gYmUgdXNlZCBhcyBhIGNyaXRlcmlvbiBhZ2FpbnN0IGEgVHJlZUNoYW5nZXMgcGF0aFxyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlOiB0aGUgYGV4aXRpbmdgIHBhdGggaW4gW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIGEgU1RBVEUgc2NvcGVkIHBhdGguXHJcbiAgICAgKiBJdCB3YXMgZGVmaW5lZCBieSBjYWxsaW5nIGBkZWZpbmVUcmVlQ2hhbmdlc0NyaXRlcmlvbignZXhpdGluZycsIFRyYW5zaXRpb25Ib29rU2NvcGUuU1RBVEUpYFxyXG4gICAgICogRWFjaCBzdGF0ZSBpbiB0aGUgZXhpdGluZyBwYXRoIGlzIGNoZWNrZWQgYWdhaW5zdCB0aGUgY3JpdGVyaWEgYW5kIHJldHVybmVkIGFzIHBhcnQgb2YgdGhlIG1hdGNoLlxyXG4gICAgICpcclxuICAgICAqIEFub3RoZXIgZXhhbXBsZTogdGhlIGB0b2AgcGF0aCBpbiBbW0hvb2tNYXRjaENyaXRlcmlhXV0gaXMgYSBUUkFOU0lUSU9OIHNjb3BlZCBwYXRoLlxyXG4gICAgICogSXQgd2FzIGRlZmluZWQgYnkgY2FsbGluZyBgZGVmaW5lVHJlZUNoYW5nZXNDcml0ZXJpb24oJ3RvJywgVHJhbnNpdGlvbkhvb2tTY29wZS5UUkFOU0lUSU9OKWBcclxuICAgICAqIE9ubHkgdGhlIHRhaWwgb2YgdGhlIGB0b2AgcGF0aCBpcyBjaGVja2VkIGFnYWluc3QgdGhlIGNyaXRlcmlhIGFuZCByZXR1cm5lZCBhcyBwYXJ0IG9mIHRoZSBtYXRjaC5cclxuICAgICAqXHJcbiAgICAgKiBAaGlkZGVuXHJcbiAgICAgKi9cclxuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZGVmaW5lUGF0aFR5cGUgPSBmdW5jdGlvbiAobmFtZSwgaG9va1Njb3BlKSB7XHJcbiAgICAgICAgdGhpcy5fY3JpdGVyaWFQYXRoc1tuYW1lXSA9IHsgbmFtZTogbmFtZSwgc2NvcGU6IGhvb2tTY29wZSB9O1xyXG4gICAgfTtcclxuICAgIC8qKiAqIEBoaWRkZW4gKi9cclxuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0UGF0aFR5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jcml0ZXJpYVBhdGhzO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0SG9va3MgPSBmdW5jdGlvbiAoaG9va05hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJlZEhvb2tzW2hvb2tOYW1lXTtcclxuICAgIH07XHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLl9yZWdpc3RlckNvcmVUcmFuc2l0aW9uSG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZucyA9IHRoaXMuX2RlcmVnaXN0ZXJIb29rRm5zO1xyXG4gICAgICAgIGZucy5hZGRDb3JlUmVzb2x2ZXMgPSBjb3JlUmVzb2x2YWJsZXNfMS5yZWdpc3RlckFkZENvcmVSZXNvbHZhYmxlcyh0aGlzKTtcclxuICAgICAgICBmbnMuaWdub3JlZCA9IGlnbm9yZWRUcmFuc2l0aW9uXzEucmVnaXN0ZXJJZ25vcmVkVHJhbnNpdGlvbkhvb2sodGhpcyk7XHJcbiAgICAgICAgZm5zLmludmFsaWQgPSBpbnZhbGlkVHJhbnNpdGlvbl8xLnJlZ2lzdGVySW52YWxpZFRyYW5zaXRpb25Ib29rKHRoaXMpO1xyXG4gICAgICAgIC8vIFdpcmUgdXAgcmVkaXJlY3RUbyBob29rXHJcbiAgICAgICAgZm5zLnJlZGlyZWN0VG8gPSByZWRpcmVjdFRvXzEucmVnaXN0ZXJSZWRpcmVjdFRvSG9vayh0aGlzKTtcclxuICAgICAgICAvLyBXaXJlIHVwIG9uRXhpdC9SZXRhaW4vRW50ZXIgc3RhdGUgaG9va3NcclxuICAgICAgICBmbnMub25FeGl0ID0gb25FbnRlckV4aXRSZXRhaW5fMS5yZWdpc3Rlck9uRXhpdEhvb2sodGhpcyk7XHJcbiAgICAgICAgZm5zLm9uUmV0YWluID0gb25FbnRlckV4aXRSZXRhaW5fMS5yZWdpc3Rlck9uUmV0YWluSG9vayh0aGlzKTtcclxuICAgICAgICBmbnMub25FbnRlciA9IG9uRW50ZXJFeGl0UmV0YWluXzEucmVnaXN0ZXJPbkVudGVySG9vayh0aGlzKTtcclxuICAgICAgICAvLyBXaXJlIHVwIFJlc29sdmUgaG9va3NcclxuICAgICAgICBmbnMuZWFnZXJSZXNvbHZlID0gcmVzb2x2ZV8xLnJlZ2lzdGVyRWFnZXJSZXNvbHZlUGF0aCh0aGlzKTtcclxuICAgICAgICBmbnMubGF6eVJlc29sdmUgPSByZXNvbHZlXzEucmVnaXN0ZXJMYXp5UmVzb2x2ZVN0YXRlKHRoaXMpO1xyXG4gICAgICAgIC8vIFdpcmUgdXAgdGhlIFZpZXcgbWFuYWdlbWVudCBob29rc1xyXG4gICAgICAgIGZucy5sb2FkVmlld3MgPSB2aWV3c18xLnJlZ2lzdGVyTG9hZEVudGVyaW5nVmlld3ModGhpcyk7XHJcbiAgICAgICAgZm5zLmFjdGl2YXRlVmlld3MgPSB2aWV3c18xLnJlZ2lzdGVyQWN0aXZhdGVWaWV3cyh0aGlzKTtcclxuICAgICAgICAvLyBVcGRhdGVzIGdsb2JhbCBzdGF0ZSBhZnRlciBhIHRyYW5zaXRpb25cclxuICAgICAgICBmbnMudXBkYXRlR2xvYmFscyA9IHVwZGF0ZUdsb2JhbHNfMS5yZWdpc3RlclVwZGF0ZUdsb2JhbFN0YXRlKHRoaXMpO1xyXG4gICAgICAgIC8vIEFmdGVyIGdsb2JhbHMuY3VycmVudCBpcyB1cGRhdGVkIGF0IHByaW9yaXR5OiAxMDAwMFxyXG4gICAgICAgIGZucy51cGRhdGVVcmwgPSB1cmxfMS5yZWdpc3RlclVwZGF0ZVVybCh0aGlzKTtcclxuICAgICAgICAvLyBMYXp5IGxvYWQgc3RhdGUgdHJlZXNcclxuICAgICAgICBmbnMubGF6eUxvYWQgPSBsYXp5TG9hZF8xLnJlZ2lzdGVyTGF6eUxvYWRIb29rKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUcmFuc2l0aW9uU2VydmljZTtcclxufSgpKTtcclxuZXhwb3J0cy5UcmFuc2l0aW9uU2VydmljZSA9IFRyYW5zaXRpb25TZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2l0aW9uU2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogIyBBbmd1bGFyIDEgdHlwZXNcclxuICpcclxuICogVUktUm91dGVyIGNvcmUgcHJvdmlkZXMgdmFyaW91cyBUeXBlc2NyaXB0IHR5cGVzIHdoaWNoIHlvdSBjYW4gdXNlIGZvciBjb2RlIGNvbXBsZXRpb24gYW5kIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHZhbHVlcywgZXRjLlxyXG4gKiBUaGUgY3VzdG9taXphdGlvbnMgdG8gdGhlIGNvcmUgdHlwZXMgZm9yIEFuZ3VsYXIgVUktUm91dGVyIGFyZSBkb2N1bWVudGVkIGhlcmUuXHJcbiAqXHJcbiAqIFRoZSBvcHRpb25hbCBbWyRyZXNvbHZlXV0gc2VydmljZSBpcyBhbHNvIGRvY3VtZW50ZWQgaGVyZS5cclxuICpcclxuICogQG1vZHVsZSBuZzFcclxuICogQHByZWZlcnJlZFxyXG4gKi9cclxuLyoqIGZvciB0eXBlZG9jICovXHJcbnZhciBhbmd1bGFyXzEgPSByZXF1aXJlKFwiLi9hbmd1bGFyXCIpO1xyXG52YXIgY29yZV8xID0gcmVxdWlyZShcIkB1aXJvdXRlci9jb3JlXCIpO1xyXG52YXIgdmlld3NfMSA9IHJlcXVpcmUoXCIuL3N0YXRlYnVpbGRlcnMvdmlld3NcIik7XHJcbnZhciB0ZW1wbGF0ZUZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL3RlbXBsYXRlRmFjdG9yeVwiKTtcclxudmFyIHN0YXRlUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRlUHJvdmlkZXJcIik7XHJcbnZhciBvbkVudGVyRXhpdFJldGFpbl8xID0gcmVxdWlyZShcIi4vc3RhdGVidWlsZGVycy9vbkVudGVyRXhpdFJldGFpblwiKTtcclxudmFyIGxvY2F0aW9uU2VydmljZXNfMSA9IHJlcXVpcmUoXCIuL2xvY2F0aW9uU2VydmljZXNcIik7XHJcbnZhciB1cmxSb3V0ZXJQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vdXJsUm91dGVyUHJvdmlkZXJcIik7XHJcbmFuZ3VsYXJfMS5uZy5tb2R1bGUoXCJ1aS5yb3V0ZXIuYW5ndWxhcjFcIiwgW10pO1xyXG52YXIgbW9kX2luaXQgPSBhbmd1bGFyXzEubmcubW9kdWxlKCd1aS5yb3V0ZXIuaW5pdCcsIFtdKTtcclxudmFyIG1vZF91dGlsID0gYW5ndWxhcl8xLm5nLm1vZHVsZSgndWkucm91dGVyLnV0aWwnLCBbJ25nJywgJ3VpLnJvdXRlci5pbml0J10pO1xyXG52YXIgbW9kX3J0ciA9IGFuZ3VsYXJfMS5uZy5tb2R1bGUoJ3VpLnJvdXRlci5yb3V0ZXInLCBbJ3VpLnJvdXRlci51dGlsJ10pO1xyXG52YXIgbW9kX3N0YXRlID0gYW5ndWxhcl8xLm5nLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJywgWyd1aS5yb3V0ZXIucm91dGVyJywgJ3VpLnJvdXRlci51dGlsJywgJ3VpLnJvdXRlci5hbmd1bGFyMSddKTtcclxudmFyIG1vZF9tYWluID0gYW5ndWxhcl8xLm5nLm1vZHVsZSgndWkucm91dGVyJywgWyd1aS5yb3V0ZXIuaW5pdCcsICd1aS5yb3V0ZXIuc3RhdGUnLCAndWkucm91dGVyLmFuZ3VsYXIxJ10pO1xyXG52YXIgbW9kX2NtcHQgPSBhbmd1bGFyXzEubmcubW9kdWxlKCd1aS5yb3V0ZXIuY29tcGF0JywgWyd1aS5yb3V0ZXInXSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmVcclxudmFyIHJvdXRlciA9IG51bGw7XHJcbiR1aVJvdXRlci4kaW5qZWN0ID0gWyckbG9jYXRpb25Qcm92aWRlciddO1xyXG4vKiogVGhpcyBhbmd1bGFyIDEgcHJvdmlkZXIgaW5zdGFudGlhdGVzIGEgUm91dGVyIGFuZCBleHBvc2VzIGl0cyBzZXJ2aWNlcyB2aWEgdGhlIGFuZ3VsYXIgaW5qZWN0b3IgKi9cclxuZnVuY3Rpb24gJHVpUm91dGVyKCRsb2NhdGlvblByb3ZpZGVyKSB7XHJcbiAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFJvdXRlciB3aGVuIHRoZSAkdWlSb3V0ZXJQcm92aWRlciBpcyBpbml0aWFsaXplZFxyXG4gICAgcm91dGVyID0gdGhpcy5yb3V0ZXIgPSBuZXcgY29yZV8xLlVJUm91dGVyKCk7XHJcbiAgICByb3V0ZXIuc3RhdGVQcm92aWRlciA9IG5ldyBzdGF0ZVByb3ZpZGVyXzEuU3RhdGVQcm92aWRlcihyb3V0ZXIuc3RhdGVSZWdpc3RyeSwgcm91dGVyLnN0YXRlU2VydmljZSk7XHJcbiAgICAvLyBBcHBseSBuZzEgc3BlY2lmaWMgU3RhdGVCdWlsZGVyIGNvZGUgZm9yIGB2aWV3c2AsIGByZXNvbHZlYCwgYW5kIGBvbkV4aXQvUmV0YWluL0VudGVyYCBwcm9wZXJ0aWVzXHJcbiAgICByb3V0ZXIuc3RhdGVSZWdpc3RyeS5kZWNvcmF0b3IoXCJ2aWV3c1wiLCB2aWV3c18xLm5nMVZpZXdzQnVpbGRlcik7XHJcbiAgICByb3V0ZXIuc3RhdGVSZWdpc3RyeS5kZWNvcmF0b3IoXCJvbkV4aXRcIiwgb25FbnRlckV4aXRSZXRhaW5fMS5nZXRTdGF0ZUhvb2tCdWlsZGVyKFwib25FeGl0XCIpKTtcclxuICAgIHJvdXRlci5zdGF0ZVJlZ2lzdHJ5LmRlY29yYXRvcihcIm9uUmV0YWluXCIsIG9uRW50ZXJFeGl0UmV0YWluXzEuZ2V0U3RhdGVIb29rQnVpbGRlcihcIm9uUmV0YWluXCIpKTtcclxuICAgIHJvdXRlci5zdGF0ZVJlZ2lzdHJ5LmRlY29yYXRvcihcIm9uRW50ZXJcIiwgb25FbnRlckV4aXRSZXRhaW5fMS5nZXRTdGF0ZUhvb2tCdWlsZGVyKFwib25FbnRlclwiKSk7XHJcbiAgICByb3V0ZXIudmlld1NlcnZpY2UuX3BsdWdpbmFwaS5fdmlld0NvbmZpZ0ZhY3RvcnkoJ25nMScsIHZpZXdzXzEuZ2V0TmcxVmlld0NvbmZpZ0ZhY3RvcnkoKSk7XHJcbiAgICB2YXIgbmcxTG9jYXRpb25TZXJ2aWNlID0gcm91dGVyLmxvY2F0aW9uU2VydmljZSA9IHJvdXRlci5sb2NhdGlvbkNvbmZpZyA9IG5ldyBsb2NhdGlvblNlcnZpY2VzXzEuTmcxTG9jYXRpb25TZXJ2aWNlcygkbG9jYXRpb25Qcm92aWRlcik7XHJcbiAgICBsb2NhdGlvblNlcnZpY2VzXzEuTmcxTG9jYXRpb25TZXJ2aWNlcy5tb25rZXlQYXRjaFBhdGhQYXJhbWV0ZXJUeXBlKHJvdXRlcik7XHJcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0OiBhbHNvIGV4cG9zZSByb3V0ZXIgaW5zdGFuY2UgYXMgJHVpUm91dGVyUHJvdmlkZXIucm91dGVyXHJcbiAgICByb3V0ZXJbJ3JvdXRlciddID0gcm91dGVyO1xyXG4gICAgcm91dGVyWyckZ2V0J10gPSAkZ2V0O1xyXG4gICAgJGdldC4kaW5qZWN0ID0gWyckbG9jYXRpb24nLCAnJGJyb3dzZXInLCAnJHNuaWZmZXInLCAnJHJvb3RTY29wZScsICckaHR0cCcsICckdGVtcGxhdGVDYWNoZSddO1xyXG4gICAgZnVuY3Rpb24gJGdldCgkbG9jYXRpb24sICRicm93c2VyLCAkc25pZmZlciwgJHJvb3RTY29wZSwgJGh0dHAsICR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgICAgbmcxTG9jYXRpb25TZXJ2aWNlLl9ydW50aW1lU2VydmljZXMoJHJvb3RTY29wZSwgJGxvY2F0aW9uLCAkc25pZmZlciwgJGJyb3dzZXIpO1xyXG4gICAgICAgIGRlbGV0ZSByb3V0ZXJbJ3JvdXRlciddO1xyXG4gICAgICAgIGRlbGV0ZSByb3V0ZXJbJyRnZXQnXTtcclxuICAgICAgICByZXR1cm4gcm91dGVyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJvdXRlcjtcclxufVxyXG52YXIgZ2V0UHJvdmlkZXJGb3IgPSBmdW5jdGlvbiAoc2VydmljZU5hbWUpIHsgcmV0dXJuIFsnJHVpUm91dGVyUHJvdmlkZXInLCBmdW5jdGlvbiAoJHVycCkge1xyXG4gICAgICAgIHZhciBzZXJ2aWNlID0gJHVycC5yb3V0ZXJbc2VydmljZU5hbWVdO1xyXG4gICAgICAgIHNlcnZpY2VbXCIkZ2V0XCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmljZTsgfTtcclxuICAgICAgICByZXR1cm4gc2VydmljZTtcclxuICAgIH1dOyB9O1xyXG4vLyBUaGlzIGVmZmVjdGl2ZWx5IGNhbGxzICRnZXQoKSBvbiBgJHVpUm91dGVyUHJvdmlkZXJgIHRvIHRyaWdnZXIgaW5pdCAod2hlbiBuZyBlbnRlcnMgcnVudGltZSlcclxucnVuQmxvY2suJGluamVjdCA9IFsnJGluamVjdG9yJywgJyRxJywgJyR1aVJvdXRlciddO1xyXG5mdW5jdGlvbiBydW5CbG9jaygkaW5qZWN0b3IsICRxLCAkdWlSb3V0ZXIpIHtcclxuICAgIGNvcmVfMS5zZXJ2aWNlcy4kaW5qZWN0b3IgPSAkaW5qZWN0b3I7XHJcbiAgICBjb3JlXzEuc2VydmljZXMuJHEgPSAkcTtcclxuICAgIC8vIFRoZSAkaW5qZWN0b3IgaXMgbm93IGF2YWlsYWJsZS5cclxuICAgIC8vIEZpbmQgYW55IHJlc29sdmFibGVzIHRoYXQgaGFkIGRlcGVuZGVuY3kgYW5ub3RhdGlvbiBkZWZlcnJlZFxyXG4gICAgJHVpUm91dGVyLnN0YXRlUmVnaXN0cnkuZ2V0KClcclxuICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LiQkc3RhdGUoKS5yZXNvbHZhYmxlczsgfSlcclxuICAgICAgICAucmVkdWNlKGNvcmVfMS51bm5lc3RSLCBbXSlcclxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmRlcHMgPT09IFwiZGVmZXJyZWRcIjsgfSlcclxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2YWJsZSkgeyByZXR1cm4gcmVzb2x2YWJsZS5kZXBzID0gJGluamVjdG9yLmFubm90YXRlKHJlc29sdmFibGUucmVzb2x2ZUZuKTsgfSk7XHJcbn1cclxuLy8gJHVybFJvdXRlciBzZXJ2aWNlIGFuZCAkdXJsUm91dGVyUHJvdmlkZXJcclxudmFyIGdldFVybFJvdXRlclByb3ZpZGVyID0gZnVuY3Rpb24gKHVpUm91dGVyKSB7XHJcbiAgICByZXR1cm4gdWlSb3V0ZXIudXJsUm91dGVyUHJvdmlkZXIgPSBuZXcgdXJsUm91dGVyUHJvdmlkZXJfMS5VcmxSb3V0ZXJQcm92aWRlcih1aVJvdXRlcik7XHJcbn07XHJcbi8vICRzdGF0ZSBzZXJ2aWNlIGFuZCAkc3RhdGVQcm92aWRlclxyXG4vLyAkdXJsUm91dGVyIHNlcnZpY2UgYW5kICR1cmxSb3V0ZXJQcm92aWRlclxyXG52YXIgZ2V0U3RhdGVQcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBjb3JlXzEuZXh0ZW5kKHJvdXRlci5zdGF0ZVByb3ZpZGVyLCB7ICRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5zdGF0ZVNlcnZpY2U7IH0gfSk7XHJcbn07XHJcbndhdGNoRGlnZXN0cy4kaW5qZWN0ID0gWyckcm9vdFNjb3BlJ107XHJcbmZ1bmN0aW9uIHdhdGNoRGlnZXN0cygkcm9vdFNjb3BlKSB7XHJcbiAgICAkcm9vdFNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IGNvcmVfMS50cmFjZS5hcHByb3hpbWF0ZURpZ2VzdHMrKzsgfSk7XHJcbn1cclxuZXhwb3J0cy53YXRjaERpZ2VzdHMgPSB3YXRjaERpZ2VzdHM7XHJcbm1vZF9pbml0LnByb3ZpZGVyKFwiJHVpUm91dGVyXCIsICR1aVJvdXRlcik7XHJcbm1vZF9ydHIucHJvdmlkZXIoJyR1cmxSb3V0ZXInLCBbJyR1aVJvdXRlclByb3ZpZGVyJywgZ2V0VXJsUm91dGVyUHJvdmlkZXJdKTtcclxubW9kX3V0aWwucHJvdmlkZXIoJyR1cmxTZXJ2aWNlJywgZ2V0UHJvdmlkZXJGb3IoJ3VybFNlcnZpY2UnKSk7XHJcbm1vZF91dGlsLnByb3ZpZGVyKCckdXJsTWF0Y2hlckZhY3RvcnknLCBbJyR1aVJvdXRlclByb3ZpZGVyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5OyB9XSk7XHJcbm1vZF91dGlsLnByb3ZpZGVyKCckdGVtcGxhdGVGYWN0b3J5JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IHRlbXBsYXRlRmFjdG9yeV8xLlRlbXBsYXRlRmFjdG9yeSgpOyB9KTtcclxubW9kX3N0YXRlLnByb3ZpZGVyKCckc3RhdGVSZWdpc3RyeScsIGdldFByb3ZpZGVyRm9yKCdzdGF0ZVJlZ2lzdHJ5JykpO1xyXG5tb2Rfc3RhdGUucHJvdmlkZXIoJyR1aVJvdXRlckdsb2JhbHMnLCBnZXRQcm92aWRlckZvcignZ2xvYmFscycpKTtcclxubW9kX3N0YXRlLnByb3ZpZGVyKCckdHJhbnNpdGlvbnMnLCBnZXRQcm92aWRlckZvcigndHJhbnNpdGlvblNlcnZpY2UnKSk7XHJcbm1vZF9zdGF0ZS5wcm92aWRlcignJHN0YXRlJywgWyckdWlSb3V0ZXJQcm92aWRlcicsIGdldFN0YXRlUHJvdmlkZXJdKTtcclxubW9kX3N0YXRlLmZhY3RvcnkoJyRzdGF0ZVBhcmFtcycsIFsnJHVpUm91dGVyJywgZnVuY3Rpb24gKCR1aVJvdXRlcikgeyByZXR1cm4gJHVpUm91dGVyLmdsb2JhbHMucGFyYW1zOyB9XSk7XHJcbm1vZF9tYWluLmZhY3RvcnkoJyR2aWV3JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnZpZXdTZXJ2aWNlOyB9KTtcclxubW9kX21haW4uc2VydmljZShcIiR0cmFjZVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlXzEudHJhY2U7IH0pO1xyXG5tb2RfbWFpbi5ydW4od2F0Y2hEaWdlc3RzKTtcclxubW9kX3V0aWwucnVuKFsnJHVybE1hdGNoZXJGYWN0b3J5JywgZnVuY3Rpb24gKCR1cmxNYXRjaGVyRmFjdG9yeSkgeyB9XSk7XHJcbm1vZF9zdGF0ZS5ydW4oWyckc3RhdGUnLCBmdW5jdGlvbiAoJHN0YXRlKSB7IH1dKTtcclxubW9kX3J0ci5ydW4oWyckdXJsUm91dGVyJywgZnVuY3Rpb24gKCR1cmxSb3V0ZXIpIHsgfV0pO1xyXG5tb2RfaW5pdC5ydW4ocnVuQmxvY2spO1xyXG4vKiogQGhpZGRlbiBUT0RPOiBmaW5kIGEgcGxhY2UgdG8gbW92ZSB0aGlzICovXHJcbmV4cG9ydHMuZ2V0TG9jYWxzID0gZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgdmFyIHRva2VucyA9IGN0eC5nZXRUb2tlbnMoKS5maWx0ZXIoY29yZV8xLmlzU3RyaW5nKTtcclxuICAgIHZhciB0dXBsZXMgPSB0b2tlbnMubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IGN0eC5nZXRSZXNvbHZhYmxlKGtleSk7XHJcbiAgICAgICAgdmFyIHdhaXRQb2xpY3kgPSBjdHguZ2V0UG9saWN5KHJlc29sdmFibGUpLmFzeW5jO1xyXG4gICAgICAgIHJldHVybiBba2V5LCB3YWl0UG9saWN5ID09PSAnTk9XQUlUJyA/IHJlc29sdmFibGUucHJvbWlzZSA6IHJlc29sdmFibGUuZGF0YV07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0dXBsZXMucmVkdWNlKGNvcmVfMS5hcHBseVBhaXJzLCB7fSk7XHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZpY2VzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL3NlcnZpY2VzLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgY29yZV8xID0gcmVxdWlyZShcIkB1aXJvdXRlci9jb3JlXCIpO1xyXG5mdW5jdGlvbiBnZXROZzFWaWV3Q29uZmlnRmFjdG9yeSgpIHtcclxuICAgIHZhciB0ZW1wbGF0ZUZhY3RvcnkgPSBudWxsO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoLCB2aWV3KSB7XHJcbiAgICAgICAgdGVtcGxhdGVGYWN0b3J5ID0gdGVtcGxhdGVGYWN0b3J5IHx8IGNvcmVfMS5zZXJ2aWNlcy4kaW5qZWN0b3IuZ2V0KFwiJHRlbXBsYXRlRmFjdG9yeVwiKTtcclxuICAgICAgICByZXR1cm4gW25ldyBOZzFWaWV3Q29uZmlnKHBhdGgsIHZpZXcsIHRlbXBsYXRlRmFjdG9yeSldO1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldE5nMVZpZXdDb25maWdGYWN0b3J5ID0gZ2V0TmcxVmlld0NvbmZpZ0ZhY3Rvcnk7XHJcbnZhciBoYXNBbnlLZXkgPSBmdW5jdGlvbiAoa2V5cywgb2JqKSB7XHJcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7IHJldHVybiBhY2MgfHwgY29yZV8xLmlzRGVmaW5lZChvYmpba2V5XSk7IH0sIGZhbHNlKTtcclxufTtcclxuLyoqXHJcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIGFuZ3VsYXIxIGB2aWV3c2AuXHJcbiAqXHJcbiAqIFdoZW4gdGhlIFtbU3RhdGVCdWlsZGVyXV0gYnVpbGRzIGEgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCBmcm9tIGEgcmF3IFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGlzIGJ1aWxkZXJcclxuICogaGFuZGxlcyB0aGUgYHZpZXdzYCBwcm9wZXJ0eSB3aXRoIGxvZ2ljIHNwZWNpZmljIHRvIEB1aXJvdXRlci9hbmd1bGFyanMgKG5nMSkuXHJcbiAqXHJcbiAqIElmIG5vIGB2aWV3czoge31gIHByb3BlcnR5IGV4aXN0cyBvbiB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoZW4gaXQgY3JlYXRlcyB0aGUgYHZpZXdzYCBvYmplY3RcclxuICogYW5kIGFwcGxpZXMgdGhlIHN0YXRlLWxldmVsIGNvbmZpZ3VyYXRpb24gdG8gYSB2aWV3IG5hbWVkIGAkZGVmYXVsdGAuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZzFWaWV3c0J1aWxkZXIoc3RhdGUpIHtcclxuICAgIC8vIERvIG5vdCBwcm9jZXNzIHJvb3Qgc3RhdGVcclxuICAgIGlmICghc3RhdGUucGFyZW50KVxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIHZhciB0cGxLZXlzID0gWyd0ZW1wbGF0ZVByb3ZpZGVyJywgJ3RlbXBsYXRlVXJsJywgJ3RlbXBsYXRlJywgJ25vdGlmeScsICdhc3luYyddLCBjdHJsS2V5cyA9IFsnY29udHJvbGxlcicsICdjb250cm9sbGVyUHJvdmlkZXInLCAnY29udHJvbGxlckFzJywgJ3Jlc29sdmVBcyddLCBjb21wS2V5cyA9IFsnY29tcG9uZW50JywgJ2JpbmRpbmdzJywgJ2NvbXBvbmVudFByb3ZpZGVyJ10sIG5vbkNvbXBLZXlzID0gdHBsS2V5cy5jb25jYXQoY3RybEtleXMpLCBhbGxWaWV3S2V5cyA9IGNvbXBLZXlzLmNvbmNhdChub25Db21wS2V5cyk7XHJcbiAgICAvLyBEbyBub3QgYWxsb3cgYSBzdGF0ZSB0byBoYXZlIGJvdGggc3RhdGUtbGV2ZWwgcHJvcHMgYW5kIGFsc28gYSBgdmlld3M6IHt9YCBwcm9wZXJ0eS5cclxuICAgIC8vIEEgc3RhdGUgd2l0aG91dCBhIGB2aWV3czoge31gIHByb3BlcnR5IGNhbiBkZWNsYXJlIHByb3BlcnRpZXMgZm9yIHRoZSBgJGRlZmF1bHRgIHZpZXcgYXMgcHJvcGVydGllcyBvZiB0aGUgc3RhdGUuXHJcbiAgICAvLyBIb3dldmVyLCB0aGUgYCRkZWZhdWx0YCBhcHByb2FjaCBzaG91bGQgbm90IGJlIG1peGVkIHdpdGggYSBzZXBhcmF0ZSBgdmlld3M6IGAgYmxvY2suXHJcbiAgICBpZiAoY29yZV8xLmlzRGVmaW5lZChzdGF0ZS52aWV3cykgJiYgaGFzQW55S2V5KGFsbFZpZXdLZXlzLCBzdGF0ZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSAnXCIgKyBzdGF0ZS5uYW1lICsgXCInIGhhcyBhICd2aWV3cycgb2JqZWN0LiBcIiArXHJcbiAgICAgICAgICAgIFwiSXQgY2Fubm90IGFsc28gaGF2ZSBcXFwidmlldyBwcm9wZXJ0aWVzXFxcIiBhdCB0aGUgc3RhdGUgbGV2ZWwuICBcIiArXHJcbiAgICAgICAgICAgIFwiTW92ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW50byBhIHZpZXcgKGluIHRoZSAndmlld3MnIG9iamVjdCk6IFwiICtcclxuICAgICAgICAgICAgKFwiIFwiICsgYWxsVmlld0tleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNvcmVfMS5pc0RlZmluZWQoc3RhdGVba2V5XSk7IH0pLmpvaW4oXCIsIFwiKSkpO1xyXG4gICAgfVxyXG4gICAgdmFyIHZpZXdzID0ge30sIHZpZXdzT2JqZWN0ID0gc3RhdGUudmlld3MgfHwgeyBcIiRkZWZhdWx0XCI6IGNvcmVfMS5waWNrKHN0YXRlLCBhbGxWaWV3S2V5cykgfTtcclxuICAgIGNvcmVfMS5mb3JFYWNoKHZpZXdzT2JqZWN0LCBmdW5jdGlvbiAoY29uZmlnLCBuYW1lKSB7XHJcbiAgICAgICAgLy8gQWNjb3VudCBmb3Igdmlld3M6IHsgXCJcIjogeyB0ZW1wbGF0ZS4uLiB9IH1cclxuICAgICAgICBuYW1lID0gbmFtZSB8fCBcIiRkZWZhdWx0XCI7XHJcbiAgICAgICAgLy8gQWNjb3VudCBmb3Igdmlld3M6IHsgaGVhZGVyOiBcImhlYWRlckNvbXBvbmVudFwiIH1cclxuICAgICAgICBpZiAoY29yZV8xLmlzU3RyaW5nKGNvbmZpZykpXHJcbiAgICAgICAgICAgIGNvbmZpZyA9IHsgY29tcG9uZW50OiBjb25maWcgfTtcclxuICAgICAgICAvLyBNYWtlIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBjb25maWcgb2JqZWN0XHJcbiAgICAgICAgY29uZmlnID0gY29yZV8xLmV4dGVuZCh7fSwgY29uZmlnKTtcclxuICAgICAgICAvLyBEbyBub3QgYWxsb3cgYSB2aWV3IHRvIG1peCBwcm9wcyBmb3IgY29tcG9uZW50LXN0eWxlIHZpZXcgd2l0aCBwcm9wcyBmb3IgdGVtcGxhdGUvY29udHJvbGxlci1zdHlsZSB2aWV3XHJcbiAgICAgICAgaWYgKGhhc0FueUtleShjb21wS2V5cywgY29uZmlnKSAmJiBoYXNBbnlLZXkobm9uQ29tcEtleXMsIGNvbmZpZykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmU6IFwiICsgY29tcEtleXMuam9pbihcInxcIikgKyBcIiB3aXRoOiBcIiArIG5vbkNvbXBLZXlzLmpvaW4oXCJ8XCIpICsgXCIgaW4gc3RhdGV2aWV3OiAnXCIgKyBuYW1lICsgXCJAXCIgKyBzdGF0ZS5uYW1lICsgXCInXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25maWcucmVzb2x2ZUFzID0gY29uZmlnLnJlc29sdmVBcyB8fCAnJHJlc29sdmUnO1xyXG4gICAgICAgIGNvbmZpZy4kdHlwZSA9IFwibmcxXCI7XHJcbiAgICAgICAgY29uZmlnLiRjb250ZXh0ID0gc3RhdGU7XHJcbiAgICAgICAgY29uZmlnLiRuYW1lID0gbmFtZTtcclxuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IGNvcmVfMS5WaWV3U2VydmljZS5ub3JtYWxpemVVSVZpZXdUYXJnZXQoY29uZmlnLiRjb250ZXh0LCBjb25maWcuJG5hbWUpO1xyXG4gICAgICAgIGNvbmZpZy4kdWlWaWV3TmFtZSA9IG5vcm1hbGl6ZWQudWlWaWV3TmFtZTtcclxuICAgICAgICBjb25maWcuJHVpVmlld0NvbnRleHRBbmNob3IgPSBub3JtYWxpemVkLnVpVmlld0NvbnRleHRBbmNob3I7XHJcbiAgICAgICAgdmlld3NbbmFtZV0gPSBjb25maWc7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB2aWV3cztcclxufVxyXG5leHBvcnRzLm5nMVZpZXdzQnVpbGRlciA9IG5nMVZpZXdzQnVpbGRlcjtcclxudmFyIGlkID0gMDtcclxudmFyIE5nMVZpZXdDb25maWcgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmcxVmlld0NvbmZpZyhwYXRoLCB2aWV3RGVjbCwgZmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLnZpZXdEZWNsID0gdmlld0RlY2w7XHJcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcclxuICAgICAgICB0aGlzLiRpZCA9IGlkKys7XHJcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmdldFRlbXBsYXRlID0gZnVuY3Rpb24gKHVpVmlldywgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY29tcG9uZW50ID8gX3RoaXMuZmFjdG9yeS5tYWtlQ29tcG9uZW50VGVtcGxhdGUodWlWaWV3LCBjb250ZXh0LCBfdGhpcy5jb21wb25lbnQsIF90aGlzLnZpZXdEZWNsLmJpbmRpbmdzKSA6IF90aGlzLnRlbXBsYXRlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBOZzFWaWV3Q29uZmlnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyICRxID0gY29yZV8xLnNlcnZpY2VzLiRxO1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3IGNvcmVfMS5SZXNvbHZlQ29udGV4dCh0aGlzLnBhdGgpO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhdGgucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5vZGUpIHsgcmV0dXJuIGNvcmVfMS5leHRlbmQoYWNjLCBub2RlLnBhcmFtVmFsdWVzKTsgfSwge30pO1xyXG4gICAgICAgIHZhciBwcm9taXNlcyA9IHtcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICRxLndoZW4odGhpcy5mYWN0b3J5LmZyb21Db25maWcodGhpcy52aWV3RGVjbCwgcGFyYW1zLCBjb250ZXh0KSksXHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6ICRxLndoZW4odGhpcy5nZXRDb250cm9sbGVyKGNvbnRleHQpKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xyXG4gICAgICAgICAgICBjb3JlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZUV2ZW50KFwiTG9hZGVkXCIsIF90aGlzKTtcclxuICAgICAgICAgICAgX3RoaXMuY29udHJvbGxlciA9IHJlc3VsdHMuY29udHJvbGxlcjtcclxuICAgICAgICAgICAgY29yZV8xLmV4dGVuZChfdGhpcywgcmVzdWx0cy50ZW1wbGF0ZSk7IC8vIEVpdGhlciB7IHRlbXBsYXRlOiBcInRwbFwiIH0gb3IgeyBjb21wb25lbnQ6IFwiY21wTmFtZVwiIH1cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY29udHJvbGxlciBmb3IgYSB2aWV3IGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufFByb21pc2UuPEZ1bmN0aW9uPn0gUmV0dXJucyBhIGNvbnRyb2xsZXIsIG9yIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgY29udHJvbGxlci5cclxuICAgICAqL1xyXG4gICAgTmcxVmlld0NvbmZpZy5wcm90b3R5cGUuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdGhpcy52aWV3RGVjbC5jb250cm9sbGVyUHJvdmlkZXI7XHJcbiAgICAgICAgaWYgKCFjb3JlXzEuaXNJbmplY3RhYmxlKHByb3ZpZGVyKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld0RlY2wuY29udHJvbGxlcjtcclxuICAgICAgICB2YXIgZGVwcyA9IGNvcmVfMS5zZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUocHJvdmlkZXIpO1xyXG4gICAgICAgIHZhciBwcm92aWRlckZuID0gY29yZV8xLmlzQXJyYXkocHJvdmlkZXIpID8gY29yZV8xLnRhaWwocHJvdmlkZXIpIDogcHJvdmlkZXI7XHJcbiAgICAgICAgdmFyIHJlc29sdmFibGUgPSBuZXcgY29yZV8xLlJlc29sdmFibGUoXCJcIiwgcHJvdmlkZXJGbiwgZGVwcyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0KGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBOZzFWaWV3Q29uZmlnO1xyXG59KCkpO1xyXG5leHBvcnRzLk5nMVZpZXdDb25maWcgPSBOZzFWaWV3Q29uZmlnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3cy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2FuZ3VsYXItdWktcm91dGVyL2xpYi9zdGF0ZWJ1aWxkZXJzL3ZpZXdzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQGNvcmVhcGlcclxuICogQG1vZHVsZSBjb3JlXHJcbiAqLyAvKiogKi9cclxudmFyIHN0YXRlUGFyYW1zXzEgPSByZXF1aXJlKFwiLi9wYXJhbXMvc3RhdGVQYXJhbXNcIik7XHJcbnZhciBxdWV1ZV8xID0gcmVxdWlyZShcIi4vY29tbW9uL3F1ZXVlXCIpO1xyXG4vKipcclxuICogR2xvYmFsIHJvdXRlciBzdGF0ZVxyXG4gKlxyXG4gKiBUaGlzIGlzIHdoZXJlIHdlIGhvbGQgdGhlIGdsb2JhbCBtdXRhYmxlIHN0YXRlIHN1Y2ggYXMgY3VycmVudCBzdGF0ZSwgY3VycmVudFxyXG4gKiBwYXJhbXMsIGN1cnJlbnQgdHJhbnNpdGlvbiwgZXRjLlxyXG4gKi9cclxudmFyIFVJUm91dGVyR2xvYmFscyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVSVJvdXRlckdsb2JhbHMoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCBwYXJhbWV0ZXIgdmFsdWVzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgcGFyYW1ldGVyIHZhbHVlcyBmcm9tIHRoZSBsYXRlc3Qgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBuZXcgc3RhdGVQYXJhbXNfMS5TdGF0ZVBhcmFtcygpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cclxuICAgICAgICB0aGlzLmxhc3RTdGFydGVkVHJhbnNpdGlvbklkID0gLTE7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkhpc3RvcnkgPSBuZXcgcXVldWVfMS5RdWV1ZShbXSwgMSk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xyXG4gICAgICAgIHRoaXMuc3VjY2Vzc2Z1bFRyYW5zaXRpb25zID0gbmV3IHF1ZXVlXzEuUXVldWUoW10sIDEpO1xyXG4gICAgfVxyXG4gICAgVUlSb3V0ZXJHbG9iYWxzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkhpc3RvcnkuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnN1Y2Nlc3NmdWxUcmFuc2l0aW9ucy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbiA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFVJUm91dGVyR2xvYmFscztcclxufSgpKTtcclxuZXhwb3J0cy5VSVJvdXRlckdsb2JhbHMgPSBVSVJvdXRlckdsb2JhbHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvZ2xvYmFscy5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XHJcbi8qKlxyXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHRoYXQgcGVyZm9ybXMgbGF6eSBsb2FkaW5nXHJcbiAqXHJcbiAqIFdoZW4gZW50ZXJpbmcgYSBzdGF0ZSBcImFiY1wiIHdoaWNoIGhhcyBhIGBsYXp5TG9hZGAgZnVuY3Rpb24gZGVmaW5lZDpcclxuICogLSBJbnZva2UgdGhlIGBsYXp5TG9hZGAgZnVuY3Rpb24gKHVubGVzcyBpdCBpcyBhbHJlYWR5IGluIHByb2Nlc3MpXHJcbiAqICAgLSBGbGFnIHRoZSBob29rIGZ1bmN0aW9uIGFzIFwiaW4gcHJvY2Vzc1wiXHJcbiAqICAgLSBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIHByb21pc2UgKHRoYXQgcmVzb2x2ZXMgd2hlbiBsYXp5IGxvYWRpbmcgaXMgY29tcGxldGUpXHJcbiAqIC0gV2FpdCBmb3IgdGhlIHByb21pc2UgdG8gc2V0dGxlXHJcbiAqICAgLSBJZiB0aGUgcHJvbWlzZSByZXNvbHZlcyB0byBhIFtbTGF6eUxvYWRSZXN1bHRdXSwgdGhlbiByZWdpc3RlciB0aG9zZSBzdGF0ZXNcclxuICogICAtIEZsYWcgdGhlIGhvb2sgZnVuY3Rpb24gYXMgXCJub3QgaW4gcHJvY2Vzc1wiXHJcbiAqIC0gSWYgdGhlIGhvb2sgd2FzIHN1Y2Nlc3NmdWxcclxuICogICAtIFJlbW92ZSB0aGUgYGxhenlMb2FkYCBmdW5jdGlvbiBmcm9tIHRoZSBzdGF0ZSBkZWNsYXJhdGlvblxyXG4gKiAtIElmIGFsbCB0aGUgaG9va3Mgd2VyZSBzdWNjZXNzZnVsXHJcbiAqICAgLSBSZXRyeSB0aGUgdHJhbnNpdGlvbiAoYnkgcmV0dXJuaW5nIGEgVGFyZ2V0U3RhdGUpXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiAuc3RhdGUoJ2FiYycsIHtcclxuICogICBjb21wb25lbnQ6ICdmb29Db21wb25lbnQnLFxyXG4gKiAgIGxhenlMb2FkOiAoKSA9PiBTeXN0ZW0uaW1wb3J0KCcuL2Zvb0NvbXBvbmVudCcpXHJcbiAqICAgfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLmxhenlMb2FkXV1cclxuICovXHJcbnZhciBsYXp5TG9hZEhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xyXG4gICAgdmFyIHJvdXRlciA9IHRyYW5zaXRpb24ucm91dGVyO1xyXG4gICAgZnVuY3Rpb24gcmV0cnlUcmFuc2l0aW9uKCkge1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uLm9yaWdpbmFsVHJhbnNpdGlvbigpLm9wdGlvbnMoKS5zb3VyY2UgIT09ICd1cmwnKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIHdhcyBub3QgdHJpZ2dlcmVkIHZpYSB1cmwgc3luY1xyXG4gICAgICAgICAgICAvLyBUaGUgbGF6eSBzdGF0ZSBzaG91bGQgYmUgbG9hZGVkIG5vdywgc28gcmUtdHJ5IHRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uXHJcbiAgICAgICAgICAgIHZhciBvcmlnID0gdHJhbnNpdGlvbi50YXJnZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLnN0YXRlU2VydmljZS50YXJnZXQob3JpZy5pZGVudGlmaWVyKCksIG9yaWcucGFyYW1zKCksIG9yaWcub3B0aW9ucygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gd2FzIHRyaWdnZXJlZCB2aWEgdXJsIHN5bmNcclxuICAgICAgICAvLyBSdW4gdGhlIFVSTCBydWxlcyBhbmQgZmluZCB0aGUgYmVzdCBtYXRjaFxyXG4gICAgICAgIHZhciAkdXJsID0gcm91dGVyLnVybFNlcnZpY2U7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICR1cmwubWF0Y2goJHVybC5wYXJ0cygpKTtcclxuICAgICAgICB2YXIgcnVsZSA9IHJlc3VsdCAmJiByZXN1bHQucnVsZTtcclxuICAgICAgICAvLyBJZiB0aGUgYmVzdCBtYXRjaCBpcyBhIHN0YXRlLCByZWRpcmVjdCB0aGUgdHJhbnNpdGlvbiAoaW5zdGVhZFxyXG4gICAgICAgIC8vIG9mIGNhbGxpbmcgc3luYygpIHdoaWNoIHN1cGVyc2VkZXMgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbilcclxuICAgICAgICBpZiAocnVsZSAmJiBydWxlLnR5cGUgPT09IFwiU1RBVEVcIikge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBydWxlLnN0YXRlO1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gcmVzdWx0Lm1hdGNoO1xyXG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLnN0YXRlU2VydmljZS50YXJnZXQoc3RhdGUsIHBhcmFtcywgdHJhbnNpdGlvbi5vcHRpb25zKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBObyBtYXRjaGluZyBzdGF0ZSBmb3VuZCwgc28gbGV0IC5zeW5jKCkgY2hvb3NlIHRoZSBiZXN0IG5vbi1zdGF0ZSBtYXRjaC9vdGhlcndpc2VcclxuICAgICAgICByb3V0ZXIudXJsU2VydmljZS5zeW5jKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgcHJvbWlzZXMgPSB0cmFuc2l0aW9uLmVudGVyaW5nKClcclxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gISFzdGF0ZS4kJHN0YXRlKCkubGF6eUxvYWQ7IH0pXHJcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGxhenlMb2FkU3RhdGUodHJhbnNpdGlvbiwgc3RhdGUpOyB9KTtcclxuICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5hbGwocHJvbWlzZXMpLnRoZW4ocmV0cnlUcmFuc2l0aW9uKTtcclxufTtcclxuZXhwb3J0cy5yZWdpc3RlckxhenlMb2FkSG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xyXG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uQmVmb3JlKHsgZW50ZXJpbmc6IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gISFzdGF0ZS5sYXp5TG9hZDsgfSB9LCBsYXp5TG9hZEhvb2spO1xyXG59O1xyXG4vKipcclxuICogSW52b2tlcyBhIHN0YXRlJ3MgbGF6eSBsb2FkIGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB0cmFuc2l0aW9uIGEgVHJhbnNpdGlvbiBjb250ZXh0XHJcbiAqIEBwYXJhbSBzdGF0ZSB0aGUgc3RhdGUgdG8gbGF6eSBsb2FkXHJcbiAqIEByZXR1cm5zIEEgcHJvbWlzZSBmb3IgdGhlIGxhenkgbG9hZCByZXN1bHRcclxuICovXHJcbmZ1bmN0aW9uIGxhenlMb2FkU3RhdGUodHJhbnNpdGlvbiwgc3RhdGUpIHtcclxuICAgIHZhciBsYXp5TG9hZEZuID0gc3RhdGUuJCRzdGF0ZSgpLmxhenlMb2FkO1xyXG4gICAgLy8gU3RvcmUvZ2V0IHRoZSBsYXp5IGxvYWQgcHJvbWlzZSBvbi9mcm9tIHRoZSBob29rZm4gc28gaXQgZG9lc24ndCBnZXQgcmUtaW52b2tlZFxyXG4gICAgdmFyIHByb21pc2UgPSBsYXp5TG9hZEZuWydfcHJvbWlzZSddO1xyXG4gICAgaWYgKCFwcm9taXNlKSB7XHJcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5sYXp5TG9hZDtcclxuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLiQkc3RhdGUoKS5sYXp5TG9hZDtcclxuICAgICAgICAgICAgZGVsZXRlIGxhenlMb2FkRm5bJ19wcm9taXNlJ107XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBsYXp5TG9hZEZuWydfcHJvbWlzZSddO1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEucmVqZWN0KGVycik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwcm9taXNlID0gbGF6eUxvYWRGblsnX3Byb21pc2UnXSA9XHJcbiAgICAgICAgICAgIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4obGF6eUxvYWRGbih0cmFuc2l0aW9uLCBzdGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAudGhlbih1cGRhdGVTdGF0ZVJlZ2lzdHJ5KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJlZ2lzdGVyIGFueSBsYXp5IGxvYWRlZCBzdGF0ZSBkZWZpbml0aW9ucyAqL1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlU3RhdGVSZWdpc3RyeShyZXN1bHQpIHtcclxuICAgICAgICBpZiAocmVzdWx0ICYmIEFycmF5LmlzQXJyYXkocmVzdWx0LnN0YXRlcykpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gdHJhbnNpdGlvbi5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5yZWdpc3RlcihzdGF0ZSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb21pc2U7XHJcbn1cclxuZXhwb3J0cy5sYXp5TG9hZFN0YXRlID0gbGF6eUxvYWRTdGF0ZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF6eUxvYWQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvbGF6eUxvYWQuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBAY29yZWFwaVxyXG4gKiBAbW9kdWxlIHBhcmFtc1xyXG4gKi9cclxuLyoqICovXHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xyXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xyXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcclxudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XHJcbnZhciBwYXJhbVR5cGVfMSA9IHJlcXVpcmUoXCIuL3BhcmFtVHlwZVwiKTtcclxuLyoqXHJcbiAqIEEgcmVnaXN0cnkgZm9yIHBhcmFtZXRlciB0eXBlcy5cclxuICpcclxuICogVGhpcyByZWdpc3RyeSBtYW5hZ2VzIHRoZSBidWlsdC1pbiAoYW5kIGN1c3RvbSkgcGFyYW1ldGVyIHR5cGVzLlxyXG4gKlxyXG4gKiBUaGUgYnVpbHQtaW4gcGFyYW1ldGVyIHR5cGVzIGFyZTpcclxuICpcclxuICogLSBbW3N0cmluZ11dXHJcbiAqIC0gW1twYXRoXV1cclxuICogLSBbW3F1ZXJ5XV1cclxuICogLSBbW2hhc2hdXVxyXG4gKiAtIFtbaW50XV1cclxuICogLSBbW2Jvb2xdXVxyXG4gKiAtIFtbZGF0ZV1dXHJcbiAqIC0gW1tqc29uXV1cclxuICogLSBbW2FueV1dXHJcbiAqL1xyXG52YXIgUGFyYW1UeXBlcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKiogQGludGVybmFsYXBpICovXHJcbiAgICBmdW5jdGlvbiBQYXJhbVR5cGVzKCkge1xyXG4gICAgICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlID0gdHJ1ZTtcclxuICAgICAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgICAgIHRoaXMudHlwZVF1ZXVlID0gW107XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFR5cGVzID0gY29tbW9uXzEucGljayhQYXJhbVR5cGVzLnByb3RvdHlwZSwgW1wiaGFzaFwiLCBcInN0cmluZ1wiLCBcInF1ZXJ5XCIsIFwicGF0aFwiLCBcImludFwiLCBcImJvb2xcIiwgXCJkYXRlXCIsIFwianNvblwiLCBcImFueVwiXSk7XHJcbiAgICAgICAgLy8gUmVnaXN0ZXIgZGVmYXVsdCB0eXBlcy4gU3RvcmUgdGhlbSBpbiB0aGUgcHJvdG90eXBlIG9mIHRoaXMudHlwZXMuXHJcbiAgICAgICAgdmFyIG1ha2VUeXBlID0gZnVuY3Rpb24gKGRlZmluaXRpb24sIG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXJhbVR5cGVfMS5QYXJhbVR5cGUoY29tbW9uXzEuZXh0ZW5kKHsgbmFtZTogbmFtZSB9LCBkZWZpbml0aW9uKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnR5cGVzID0gY29tbW9uXzEuaW5oZXJpdChjb21tb25fMS5tYXAodGhpcy5kZWZhdWx0VHlwZXMsIG1ha2VUeXBlKSwge30pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xyXG4gICAgUGFyYW1UeXBlcy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnR5cGVzID0ge307XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBwYXJhbWV0ZXIgdHlwZVxyXG4gICAgICpcclxuICAgICAqIEVuZCB1c2VycyBzaG91bGQgY2FsbCBbW1VybE1hdGNoZXJGYWN0b3J5LnR5cGVdXSwgd2hpY2ggZGVsZWdhdGVzIHRvIHRoaXMgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBQYXJhbVR5cGVzLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb25Gbikge1xyXG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzRGVmaW5lZChkZWZpbml0aW9uKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZXNbbmFtZV07XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgdHlwZSBuYW1lZCAnXCIgKyBuYW1lICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdGhpcy50eXBlc1tuYW1lXSA9IG5ldyBwYXJhbVR5cGVfMS5QYXJhbVR5cGUoY29tbW9uXzEuZXh0ZW5kKHsgbmFtZTogbmFtZSB9LCBkZWZpbml0aW9uKSk7XHJcbiAgICAgICAgaWYgKGRlZmluaXRpb25Gbikge1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVRdWV1ZS5wdXNoKHsgbmFtZTogbmFtZSwgZGVmOiBkZWZpbml0aW9uRm4gfSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5lbnF1ZXVlKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmx1c2hUeXBlUXVldWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xyXG4gICAgUGFyYW1UeXBlcy5wcm90b3R5cGUuX2ZsdXNoVHlwZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHdoaWxlICh0aGlzLnR5cGVRdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVRdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZiAodHlwZS5wYXR0ZXJuKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBvdmVycmlkZSBhIHR5cGUncyAucGF0dGVybiBhdCBydW50aW1lLlwiKTtcclxuICAgICAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMudHlwZXNbdHlwZS5uYW1lXSwgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLmludm9rZSh0eXBlLmRlZikpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gUGFyYW1UeXBlcztcclxufSgpKTtcclxuZXhwb3J0cy5QYXJhbVR5cGVzID0gUGFyYW1UeXBlcztcclxuLyoqIEBoaWRkZW4gKi9cclxuZnVuY3Rpb24gaW5pdERlZmF1bHRUeXBlcygpIHtcclxuICAgIHZhciBtYWtlRGVmYXVsdFR5cGUgPSBmdW5jdGlvbiAoZGVmKSB7XHJcbiAgICAgICAgdmFyIHZhbFRvU3RyaW5nID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsICE9IG51bGwgPyB2YWwudG9TdHJpbmcoKSA6IHZhbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBkZWZhdWx0VHlwZUJhc2UgPSB7XHJcbiAgICAgICAgICAgIGVuY29kZTogdmFsVG9TdHJpbmcsXHJcbiAgICAgICAgICAgIGRlY29kZTogdmFsVG9TdHJpbmcsXHJcbiAgICAgICAgICAgIGlzOiBob2ZfMS5pcyhTdHJpbmcpLFxyXG4gICAgICAgICAgICBwYXR0ZXJuOiAvLiovLFxyXG4gICAgICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhID09IGI7IH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHt9LCBkZWZhdWx0VHlwZUJhc2UsIGRlZik7XHJcbiAgICB9O1xyXG4gICAgLy8gRGVmYXVsdCBQYXJhbWV0ZXIgVHlwZSBEZWZpbml0aW9uc1xyXG4gICAgY29tbW9uXzEuZXh0ZW5kKFBhcmFtVHlwZXMucHJvdG90eXBlLCB7XHJcbiAgICAgICAgc3RyaW5nOiBtYWtlRGVmYXVsdFR5cGUoe30pLFxyXG4gICAgICAgIHBhdGg6IG1ha2VEZWZhdWx0VHlwZSh7XHJcbiAgICAgICAgICAgIHBhdHRlcm46IC9bXi9dKi8sXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgcXVlcnk6IG1ha2VEZWZhdWx0VHlwZSh7fSksXHJcbiAgICAgICAgaGFzaDogbWFrZURlZmF1bHRUeXBlKHtcclxuICAgICAgICAgICAgaW5oZXJpdDogZmFsc2UsXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgaW50OiBtYWtlRGVmYXVsdFR5cGUoe1xyXG4gICAgICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApOyB9LFxyXG4gICAgICAgICAgICBpczogZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGVzXzEuaXNOdWxsT3JVbmRlZmluZWQodmFsKSAmJiB0aGlzLmRlY29kZSh2YWwudG9TdHJpbmcoKSkgPT09IHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGF0dGVybjogLy0/XFxkKy8sXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgYm9vbDogbWFrZURlZmF1bHRUeXBlKHtcclxuICAgICAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgJiYgMSB8fCAwOyB9LFxyXG4gICAgICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApICE9PSAwOyB9LFxyXG4gICAgICAgICAgICBpczogaG9mXzEuaXMoQm9vbGVhbiksXHJcbiAgICAgICAgICAgIHBhdHRlcm46IC8wfDEvXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZGF0ZTogbWFrZURlZmF1bHRUeXBlKHtcclxuICAgICAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuaXModmFsKSA/IHVuZGVmaW5lZCA6IFtcclxuICAgICAgICAgICAgICAgICAgICB2YWwuZ2V0RnVsbFllYXIoKSxcclxuICAgICAgICAgICAgICAgICAgICAoJzAnICsgKHZhbC5nZXRNb250aCgpICsgMSkpLnNsaWNlKC0yKSxcclxuICAgICAgICAgICAgICAgICAgICAoJzAnICsgdmFsLmdldERhdGUoKSkuc2xpY2UoLTIpXHJcbiAgICAgICAgICAgICAgICBdLmpvaW4oXCItXCIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzKHZhbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHRoaXMuY2FwdHVyZS5leGVjKHZhbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2ggPyBuZXcgRGF0ZShtYXRjaFsxXSwgbWF0Y2hbMl0gLSAxLCBtYXRjaFszXSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWwudmFsdWVPZigpKTsgfSxcclxuICAgICAgICAgICAgZXF1YWxzOiBmdW5jdGlvbiAobCwgcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZ2V0RnVsbFllYXInLCAnZ2V0TW9udGgnLCAnZ2V0RGF0ZSddXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBmbikgeyByZXR1cm4gYWNjICYmIGxbZm5dKCkgPT09IHJbZm5dKCk7IH0sIHRydWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXR0ZXJuOiAvWzAtOV17NH0tKD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfFsxLTJdWzAtOV18M1swLTFdKS8sXHJcbiAgICAgICAgICAgIGNhcHR1cmU6IC8oWzAtOV17NH0pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxLTJdWzAtOV18M1swLTFdKS9cclxuICAgICAgICB9KSxcclxuICAgICAgICBqc29uOiBtYWtlRGVmYXVsdFR5cGUoe1xyXG4gICAgICAgICAgICBlbmNvZGU6IGNvbW1vbl8xLnRvSnNvbixcclxuICAgICAgICAgICAgZGVjb2RlOiBjb21tb25fMS5mcm9tSnNvbixcclxuICAgICAgICAgICAgaXM6IGhvZl8xLmlzKE9iamVjdCksXHJcbiAgICAgICAgICAgIGVxdWFsczogY29tbW9uXzEuZXF1YWxzLFxyXG4gICAgICAgICAgICBwYXR0ZXJuOiAvW14vXSovXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgLy8gZG9lcyBub3QgZW5jb2RlL2RlY29kZVxyXG4gICAgICAgIGFueTogbWFrZURlZmF1bHRUeXBlKHtcclxuICAgICAgICAgICAgZW5jb2RlOiBjb21tb25fMS5pZGVudGl0eSxcclxuICAgICAgICAgICAgZGVjb2RlOiBjb21tb25fMS5pZGVudGl0eSxcclxuICAgICAgICAgICAgaXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sXHJcbiAgICAgICAgICAgIGVxdWFsczogY29tbW9uXzEuZXF1YWxzLFxyXG4gICAgICAgIH0pLFxyXG4gICAgfSk7XHJcbn1cclxuaW5pdERlZmF1bHRUeXBlcygpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhbVR5cGVzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbVR5cGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQGNvcmVhcGlcclxuICogQG1vZHVsZSBwYXJhbXNcclxuICovXHJcbi8qKiAqL1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxuLyoqIEBpbnRlcm5hbGFwaSAqL1xyXG52YXIgU3RhdGVQYXJhbXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3RhdGVQYXJhbXMocGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XHJcbiAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIHBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlcyBhIHNldCBvZiBwYXJhbWV0ZXJzIHdpdGggYWxsIHBhcmFtZXRlcnMgaW5oZXJpdGVkIGJldHdlZW4gdGhlIGNvbW1vbiBwYXJlbnRzIG9mIHRoZVxyXG4gICAgICogY3VycmVudCBzdGF0ZSBhbmQgYSBnaXZlbiBkZXN0aW5hdGlvbiBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3UGFyYW1zIFRoZSBzZXQgb2YgcGFyYW1ldGVycyB3aGljaCB3aWxsIGJlIGNvbXBvc2l0ZWQgd2l0aCBpbmhlcml0ZWQgcGFyYW1zLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRjdXJyZW50IEludGVybmFsIGRlZmluaXRpb24gb2Ygb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkdG8gSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8uXHJcbiAgICAgKi9cclxuICAgIFN0YXRlUGFyYW1zLnByb3RvdHlwZS4kaW5oZXJpdCA9IGZ1bmN0aW9uIChuZXdQYXJhbXMsICRjdXJyZW50LCAkdG8pIHtcclxuICAgICAgICB2YXIgcGFyZW50cyA9IGNvbW1vbl8xLmFuY2VzdG9ycygkY3VycmVudCwgJHRvKSwgcGFyZW50UGFyYW1zLCBpbmhlcml0ZWQgPSB7fSwgaW5oZXJpdExpc3QgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpIGluIHBhcmVudHMpIHtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2ldIHx8ICFwYXJlbnRzW2ldLnBhcmFtcylcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBwYXJlbnRQYXJhbXMgPSBPYmplY3Qua2V5cyhwYXJlbnRzW2ldLnBhcmFtcyk7XHJcbiAgICAgICAgICAgIGlmICghcGFyZW50UGFyYW1zLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqIGluIHBhcmVudFBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluaGVyaXRMaXN0LmluZGV4T2YocGFyZW50UGFyYW1zW2pdKSA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgaW5oZXJpdExpc3QucHVzaChwYXJlbnRQYXJhbXNbal0pO1xyXG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkW3BhcmVudFBhcmFtc1tqXV0gPSB0aGlzW3BhcmVudFBhcmFtc1tqXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh7fSwgaW5oZXJpdGVkLCBuZXdQYXJhbXMpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBTdGF0ZVBhcmFtcztcclxufSgpKTtcclxuZXhwb3J0cy5TdGF0ZVBhcmFtcyA9IFN0YXRlUGFyYW1zO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZVBhcmFtcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvc3RhdGVQYXJhbXMuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKiBAaW50ZXJuYWxhcGkgKi9cclxuZXhwb3J0cy5yZXNvbHZlUG9saWNpZXMgPSB7XHJcbiAgICB3aGVuOiB7XHJcbiAgICAgICAgTEFaWTogXCJMQVpZXCIsXHJcbiAgICAgICAgRUFHRVI6IFwiRUFHRVJcIlxyXG4gICAgfSxcclxuICAgIGFzeW5jOiB7XHJcbiAgICAgICAgV0FJVDogXCJXQUlUXCIsXHJcbiAgICAgICAgTk9XQUlUOiBcIk5PV0FJVFwiLFxyXG4gICAgICAgIFJYV0FJVDogXCJSWFdBSVRcIlxyXG4gICAgfVxyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcmVzb2x2ZS9pbnRlcmZhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBAY29yZWFwaVxyXG4gKiBAbW9kdWxlIGNvcmVcclxuICovIC8qKiAqL1xyXG52YXIgdXJsTWF0Y2hlckZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL3VybC91cmxNYXRjaGVyRmFjdG9yeVwiKTtcclxudmFyIHVybFJvdXRlcl8xID0gcmVxdWlyZShcIi4vdXJsL3VybFJvdXRlclwiKTtcclxudmFyIHRyYW5zaXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uL3RyYW5zaXRpb25TZXJ2aWNlXCIpO1xyXG52YXIgdmlld18xID0gcmVxdWlyZShcIi4vdmlldy92aWV3XCIpO1xyXG52YXIgc3RhdGVSZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vc3RhdGUvc3RhdGVSZWdpc3RyeVwiKTtcclxudmFyIHN0YXRlU2VydmljZV8xID0gcmVxdWlyZShcIi4vc3RhdGUvc3RhdGVTZXJ2aWNlXCIpO1xyXG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcclxudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xyXG52YXIgdXJsU2VydmljZV8xID0gcmVxdWlyZShcIi4vdXJsL3VybFNlcnZpY2VcIik7XHJcbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4vY29tbW9uL3RyYWNlXCIpO1xyXG4vKiogQGhpZGRlbiAqL1xyXG52YXIgX3JvdXRlckluc3RhbmNlID0gMDtcclxuLyoqXHJcbiAqIFRoZSBtYXN0ZXIgY2xhc3MgdXNlZCB0byBpbnN0YW50aWF0ZSBhbiBpbnN0YW5jZSBvZiBVSS1Sb3V0ZXIuXHJcbiAqXHJcbiAqIFVJLVJvdXRlciAoZm9yIGVhY2ggc3BlY2lmaWMgZnJhbWV3b3JrKSB3aWxsIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGR1cmluZyBib290c3RyYXAuXHJcbiAqIFRoaXMgY2xhc3MgaW5zdGFudGlhdGVzIGFuZCB3aXJlcyB0aGUgVUktUm91dGVyIHNlcnZpY2VzIHRvZ2V0aGVyLlxyXG4gKlxyXG4gKiBBZnRlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgVUlSb3V0ZXIgY2xhc3MgaXMgY3JlYXRlZCwgaXQgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgZm9yIHlvdXIgYXBwLlxyXG4gKiBGb3IgaW5zdGFuY2UsIGFwcCBzdGF0ZXMgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgW1tVSVJvdXRlci5zdGF0ZVJlZ2lzdHJ5XV0uXHJcbiAqXHJcbiAqIC0tLVxyXG4gKlxyXG4gKiBOb3JtYWxseSB0aGUgZnJhbWV3b3JrIGNvZGUgd2lsbCBib290c3RyYXAgVUktUm91dGVyLlxyXG4gKiBJZiB5b3UgYXJlIGJvb3RzdHJhcHBpbmcgVUlSb3V0ZXIgbWFudWFsbHksIHRlbGwgaXQgdG8gbW9uaXRvciB0aGUgVVJMIGJ5IGNhbGxpbmdcclxuICogW1tVcmxTZXJ2aWNlLmxpc3Rlbl1dIHRoZW4gW1tVcmxTZXJ2aWNlLnN5bmNdXS5cclxuICovXHJcbnZhciBVSVJvdXRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFVJUm91dGVyYCBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9jYXRpb25TZXJ2aWNlIGEgW1tMb2NhdGlvblNlcnZpY2VzXV0gaW1wbGVtZW50YXRpb25cclxuICAgICAqIEBwYXJhbSBsb2NhdGlvbkNvbmZpZyBhIFtbTG9jYXRpb25Db25maWddXSBpbXBsZW1lbnRhdGlvblxyXG4gICAgICogQGludGVybmFsYXBpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFVJUm91dGVyKGxvY2F0aW9uU2VydmljZSwgbG9jYXRpb25Db25maWcpIHtcclxuICAgICAgICBpZiAobG9jYXRpb25TZXJ2aWNlID09PSB2b2lkIDApIHsgbG9jYXRpb25TZXJ2aWNlID0gdXJsU2VydmljZV8xLlVybFNlcnZpY2UubG9jYXRpb25TZXJ2aWNlU3R1YjsgfVxyXG4gICAgICAgIGlmIChsb2NhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGxvY2F0aW9uQ29uZmlnID0gdXJsU2VydmljZV8xLlVybFNlcnZpY2UubG9jYXRpb25Db25maWdTdHViOyB9XHJcbiAgICAgICAgdGhpcy5sb2NhdGlvblNlcnZpY2UgPSBsb2NhdGlvblNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5sb2NhdGlvbkNvbmZpZyA9IGxvY2F0aW9uQ29uZmlnO1xyXG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuJGlkID0gX3JvdXRlckluc3RhbmNlKys7XHJcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcclxuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9kaXNwb3NhYmxlcyA9IFtdO1xyXG4gICAgICAgIC8qKiBQcm92aWRlcyB0cmFjZSBpbmZvcm1hdGlvbiB0byB0aGUgY29uc29sZSAqL1xyXG4gICAgICAgIHRoaXMudHJhY2UgPSB0cmFjZV8xLnRyYWNlO1xyXG4gICAgICAgIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHVpLXZpZXcgc3luY2hyb25pemF0aW9uICovXHJcbiAgICAgICAgdGhpcy52aWV3U2VydmljZSA9IG5ldyB2aWV3XzEuVmlld1NlcnZpY2UoKTtcclxuICAgICAgICAvKiogUHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byBUcmFuc2l0aW9ucyAqL1xyXG4gICAgICAgIHRoaXMudHJhbnNpdGlvblNlcnZpY2UgPSBuZXcgdHJhbnNpdGlvblNlcnZpY2VfMS5UcmFuc2l0aW9uU2VydmljZSh0aGlzKTtcclxuICAgICAgICAvKiogR2xvYmFsIHJvdXRlciBzdGF0ZSAqL1xyXG4gICAgICAgIHRoaXMuZ2xvYmFscyA9IG5ldyBnbG9iYWxzXzEuVUlSb3V0ZXJHbG9iYWxzKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVwcmVjYXRlZCBmb3IgcHVibGljIHVzZS4gVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWQuXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVybE1hdGNoZXJGYWN0b3J5ID0gbmV3IHVybE1hdGNoZXJGYWN0b3J5XzEuVXJsTWF0Y2hlckZhY3RvcnkoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXByZWNhdGVkIGZvciBwdWJsaWMgdXNlLiBVc2UgW1t1cmxTZXJ2aWNlXV0gaW5zdGVhZC5cclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1t1cmxTZXJ2aWNlXV0gaW5zdGVhZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudXJsUm91dGVyID0gbmV3IHVybFJvdXRlcl8xLlVybFJvdXRlcih0aGlzKTtcclxuICAgICAgICAvKiogUHJvdmlkZXMgYSByZWdpc3RyeSBmb3Igc3RhdGVzLCBhbmQgcmVsYXRlZCByZWdpc3RyYXRpb24gc2VydmljZXMgKi9cclxuICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkgPSBuZXcgc3RhdGVSZWdpc3RyeV8xLlN0YXRlUmVnaXN0cnkodGhpcyk7XHJcbiAgICAgICAgLyoqIFByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gc3RhdGVzICovXHJcbiAgICAgICAgdGhpcy5zdGF0ZVNlcnZpY2UgPSBuZXcgc3RhdGVTZXJ2aWNlXzEuU3RhdGVTZXJ2aWNlKHRoaXMpO1xyXG4gICAgICAgIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHRoZSBVUkwgKi9cclxuICAgICAgICB0aGlzLnVybFNlcnZpY2UgPSBuZXcgdXJsU2VydmljZV8xLlVybFNlcnZpY2UodGhpcyk7XHJcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cclxuICAgICAgICB0aGlzLl9wbHVnaW5zID0ge307XHJcbiAgICAgICAgdGhpcy52aWV3U2VydmljZS5fcGx1Z2luYXBpLl9yb290Vmlld0NvbnRleHQodGhpcy5zdGF0ZVJlZ2lzdHJ5LnJvb3QoKSk7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxzLiRjdXJyZW50ID0gdGhpcy5zdGF0ZVJlZ2lzdHJ5LnJvb3QoKTtcclxuICAgICAgICB0aGlzLmdsb2JhbHMuY3VycmVudCA9IHRoaXMuZ2xvYmFscy4kY3VycmVudC5zZWxmO1xyXG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLmdsb2JhbHMpO1xyXG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLnN0YXRlU2VydmljZSk7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMuc3RhdGVSZWdpc3RyeSk7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMudHJhbnNpdGlvblNlcnZpY2UpO1xyXG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLnVybFJvdXRlcik7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKGxvY2F0aW9uU2VydmljZSk7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKGxvY2F0aW9uQ29uZmlnKTtcclxuICAgIH1cclxuICAgIC8qKiBSZWdpc3RlcnMgYW4gb2JqZWN0IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHJvdXRlciBpcyBkaXNwb3NlZCAqL1xyXG4gICAgVUlSb3V0ZXIucHJvdG90eXBlLmRpc3Bvc2FibGUgPSBmdW5jdGlvbiAoZGlzcG9zYWJsZSkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzLnB1c2goZGlzcG9zYWJsZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlcyB0aGlzIHJvdXRlciBpbnN0YW5jZVxyXG4gICAgICpcclxuICAgICAqIFdoZW4gY2FsbGVkLCBjbGVhcnMgcmVzb3VyY2VzIHJldGFpbmVkIGJ5IHRoZSByb3V0ZXIgYnkgY2FsbGluZyBgZGlzcG9zZSh0aGlzKWAgb24gYWxsXHJcbiAgICAgKiByZWdpc3RlcmVkIFtbZGlzcG9zYWJsZV1dIG9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogT3IsIGlmIGEgYGRpc3Bvc2FibGVgIG9iamVjdCBpcyBwcm92aWRlZCwgY2FsbHMgYGRpc3Bvc2UodGhpcylgIG9uIHRoYXQgb2JqZWN0IG9ubHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRpc3Bvc2FibGUgKG9wdGlvbmFsKSB0aGUgZGlzcG9zYWJsZSB0byBkaXNwb3NlXHJcbiAgICAgKi9cclxuICAgIFVJUm91dGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGRpc3Bvc2FibGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChkaXNwb3NhYmxlICYmIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKGRpc3Bvc2FibGUuZGlzcG9zZSkpIHtcclxuICAgICAgICAgICAgZGlzcG9zYWJsZS5kaXNwb3NlKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgZC5kaXNwb3NlID09PSAnZnVuY3Rpb24nICYmIGQuZGlzcG9zZShfdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKF90aGlzLl9kaXNwb3NhYmxlcywgZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHsgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHBsdWdpbiB0byBVSS1Sb3V0ZXJcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBhZGRzIGEgVUktUm91dGVyIFBsdWdpbi5cclxuICAgICAqIEEgcGx1Z2luIGNhbiBlbmhhbmNlIG9yIGNoYW5nZSBVSS1Sb3V0ZXIgYmVoYXZpb3IgdXNpbmcgYW55IHB1YmxpYyBBUEkuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIyBFeGFtcGxlOlxyXG4gICAgICogYGBganNcclxuICAgICAqIGltcG9ydCB7IE15Q29vbFBsdWdpbiB9IGZyb20gXCJ1aS1yb3V0ZXItY29vbC1wbHVnaW5cIjtcclxuICAgICAqXHJcbiAgICAgKiB2YXIgcGx1Z2luID0gcm91dGVyLmFkZFBsdWdpbihNeUNvb2xQbHVnaW4pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogIyMjIFBsdWdpbiBhdXRob3JpbmdcclxuICAgICAqXHJcbiAgICAgKiBBIHBsdWdpbiBpcyBzaW1wbHkgYSBjbGFzcyAob3IgY29uc3RydWN0b3IgZnVuY3Rpb24pIHdoaWNoIGFjY2VwdHMgYSBbW1VJUm91dGVyXV0gaW5zdGFuY2UgYW5kIChvcHRpb25hbGx5KSBhbiBvcHRpb25zIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcGx1Z2luIGNhbiBpbXBsZW1lbnQgaXRzIGZ1bmN0aW9uYWxpdHkgdXNpbmcgYW55IG9mIHRoZSBwdWJsaWMgQVBJcyBvZiBbW1VJUm91dGVyXV0uXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgaXQgbWF5IGNvbmZpZ3VyZSByb3V0ZXIgb3B0aW9ucyBvciBhZGQgYSBUcmFuc2l0aW9uIEhvb2suXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHBsdWdpbiBjYW4gdGhlbiBiZSBwdWJsaXNoZWQgYXMgYSBzZXBhcmF0ZSBtb2R1bGUuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIyBFeGFtcGxlOlxyXG4gICAgICogYGBganNcclxuICAgICAqIGV4cG9ydCBjbGFzcyBNeUF1dGhQbHVnaW4gaW1wbGVtZW50cyBVSVJvdXRlclBsdWdpbiB7XHJcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHJvdXRlcjogVUlSb3V0ZXIsIG9wdGlvbnM6IGFueSkge1xyXG4gICAgICogICAgIHRoaXMubmFtZSA9IFwiTXlBdXRoUGx1Z2luXCI7XHJcbiAgICAgKiAgICAgbGV0ICR0cmFuc2l0aW9ucyA9IHJvdXRlci50cmFuc2l0aW9uU2VydmljZTtcclxuICAgICAqICAgICBsZXQgJHN0YXRlID0gcm91dGVyLnN0YXRlU2VydmljZTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgbGV0IGF1dGhDcml0ZXJpYSA9IHtcclxuICAgICAqICAgICAgIHRvOiAoc3RhdGUpID0+IHN0YXRlLmRhdGEgJiYgc3RhdGUuZGF0YS5yZXF1aXJlc0F1dGhcclxuICAgICAqICAgICB9O1xyXG4gICAgICpcclxuICAgICAqICAgICBmdW5jdGlvbiBhdXRoSG9vayh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKSB7XHJcbiAgICAgKiAgICAgICBsZXQgYXV0aFNlcnZpY2UgPSB0cmFuc2l0aW9uLmluamVjdG9yKCkuZ2V0KCdBdXRoU2VydmljZScpO1xyXG4gICAgICogICAgICAgaWYgKCFhdXRoU2VydmljZS5pc0F1dGhlbnRpY2F0ZWQoKSkge1xyXG4gICAgICogICAgICAgICByZXR1cm4gJHN0YXRlLnRhcmdldCgnbG9naW4nKTtcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgICR0cmFuc2l0aW9ucy5vblN0YXJ0KGF1dGhDcml0ZXJpYSwgYXV0aEhvb2spO1xyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGx1Z2luIG9uZSBvZjpcclxuICAgICAqICAgICAgICAtIGEgcGx1Z2luIGNsYXNzIHdoaWNoIGltcGxlbWVudHMgW1tVSVJvdXRlclBsdWdpbl1dXHJcbiAgICAgKiAgICAgICAgLSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBhIFtbVUlSb3V0ZXJQbHVnaW5dXSB3aGljaCBhY2NlcHRzIGEgW1tVSVJvdXRlcl1dIGluc3RhbmNlXHJcbiAgICAgKiAgICAgICAgLSBhIGZhY3RvcnkgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyBhIFtbVUlSb3V0ZXJdXSBpbnN0YW5jZSBhbmQgcmV0dXJucyBhIFtbVUlSb3V0ZXJQbHVnaW5dXSBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBwbHVnaW4gY2xhc3MvZmFjdG9yeVxyXG4gICAgICogQHJldHVybnMgdGhlIHJlZ2lzdGVyZWQgcGx1Z2luIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIFVJUm91dGVyLnByb3RvdHlwZS5wbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICB2YXIgcGx1Z2luSW5zdGFuY2UgPSBuZXcgcGx1Z2luKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIGlmICghcGx1Z2luSW5zdGFuY2UubmFtZSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZWQgcHJvcGVydHkgYG5hbWVgIG1pc3Npbmcgb24gcGx1Z2luOiBcIiArIHBsdWdpbkluc3RhbmNlKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlcy5wdXNoKHBsdWdpbkluc3RhbmNlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGx1Z2luc1twbHVnaW5JbnN0YW5jZS5uYW1lXSA9IHBsdWdpbkluc3RhbmNlO1xyXG4gICAgfTtcclxuICAgIFVJUm91dGVyLnByb3RvdHlwZS5nZXRQbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBwbHVnaW5OYW1lID8gdGhpcy5fcGx1Z2luc1twbHVnaW5OYW1lXSA6IGNvbW1vbl8xLnZhbHVlcyh0aGlzLl9wbHVnaW5zKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVUlSb3V0ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVUlSb3V0ZXIgPSBVSVJvdXRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3JvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xyXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xyXG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xyXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcclxudmFyIHJlc29sdmFibGVfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmFibGVcIik7XHJcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xyXG52YXIgcGFyc2VVcmwgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc1N0cmluZyh1cmwpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZhciByb290ID0gdXJsLmNoYXJBdCgwKSA9PT0gJ14nO1xyXG4gICAgcmV0dXJuIHsgdmFsOiByb290ID8gdXJsLnN1YnN0cmluZygxKSA6IHVybCwgcm9vdDogcm9vdCB9O1xyXG59O1xyXG5mdW5jdGlvbiBuYW1lQnVpbGRlcihzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm5hbWU7XHJcbn1cclxuZnVuY3Rpb24gc2VsZkJ1aWxkZXIoc3RhdGUpIHtcclxuICAgIHN0YXRlLnNlbGYuJCRzdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlOyB9O1xyXG4gICAgcmV0dXJuIHN0YXRlLnNlbGY7XHJcbn1cclxuZnVuY3Rpb24gZGF0YUJ1aWxkZXIoc3RhdGUpIHtcclxuICAgIGlmIChzdGF0ZS5wYXJlbnQgJiYgc3RhdGUucGFyZW50LmRhdGEpIHtcclxuICAgICAgICBzdGF0ZS5kYXRhID0gc3RhdGUuc2VsZi5kYXRhID0gY29tbW9uXzEuaW5oZXJpdChzdGF0ZS5wYXJlbnQuZGF0YSwgc3RhdGUuZGF0YSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhdGUuZGF0YTtcclxufVxyXG52YXIgZ2V0VXJsQnVpbGRlciA9IGZ1bmN0aW9uICgkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlciwgcm9vdCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVybEJ1aWxkZXIoc3RhdGUpIHtcclxuICAgICAgICB2YXIgc3RhdGVEZWMgPSBzdGF0ZTtcclxuICAgICAgICAvLyBGb3IgZnV0dXJlIHN0YXRlcywgaS5lLiwgc3RhdGVzIHdob3NlIG5hbWUgZW5kcyB3aXRoIGAuKipgLFxyXG4gICAgICAgIC8vIG1hdGNoIGFueXRoaW5nIHRoYXQgc3RhcnRzIHdpdGggdGhlIHVybCBwcmVmaXhcclxuICAgICAgICBpZiAoc3RhdGVEZWMgJiYgc3RhdGVEZWMudXJsICYmIHN0YXRlRGVjLm5hbWUgJiYgc3RhdGVEZWMubmFtZS5tYXRjaCgvXFwuXFwqXFwqJC8pKSB7XHJcbiAgICAgICAgICAgIHN0YXRlRGVjLnVybCArPSBcIntyZW1haW5kZXI6YW55fVwiOyAvLyBtYXRjaCBhbnkgcGF0aCAoLiopXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVVybChzdGF0ZURlYy51cmwpLCBwYXJlbnQgPSBzdGF0ZS5wYXJlbnQ7XHJcbiAgICAgICAgdmFyIHVybCA9ICFwYXJzZWQgPyBzdGF0ZURlYy51cmwgOiAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlci5jb21waWxlKHBhcnNlZC52YWwsIHtcclxuICAgICAgICAgICAgcGFyYW1zOiBzdGF0ZS5wYXJhbXMgfHwge30sXHJcbiAgICAgICAgICAgIHBhcmFtTWFwOiBmdW5jdGlvbiAocGFyYW1Db25maWcsIGlzU2VhcmNoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVEZWMucmVsb2FkT25TZWFyY2ggPT09IGZhbHNlICYmIGlzU2VhcmNoKVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtQ29uZmlnID0gY29tbW9uXzEuZXh0ZW5kKHBhcmFtQ29uZmlnIHx8IHt9LCB7IGR5bmFtaWM6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1Db25maWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIXVybClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYgKCEkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlci5pc01hdGNoZXIodXJsKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB1cmwgJ1wiICsgdXJsICsgXCInIGluIHN0YXRlICdcIiArIHN0YXRlICsgXCInXCIpO1xyXG4gICAgICAgIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5yb290KSA/IHVybCA6ICgocGFyZW50ICYmIHBhcmVudC5uYXZpZ2FibGUpIHx8IHJvb3QoKSkudXJsLmFwcGVuZCh1cmwpO1xyXG4gICAgfTtcclxufTtcclxudmFyIGdldE5hdmlnYWJsZUJ1aWxkZXIgPSBmdW5jdGlvbiAoaXNSb290KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gbmF2aWdhYmxlQnVpbGRlcihzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiAhaXNSb290KHN0YXRlKSAmJiBzdGF0ZS51cmwgPyBzdGF0ZSA6IChzdGF0ZS5wYXJlbnQgPyBzdGF0ZS5wYXJlbnQubmF2aWdhYmxlIDogbnVsbCk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgZ2V0UGFyYW1zQnVpbGRlciA9IGZ1bmN0aW9uIChwYXJhbUZhY3RvcnkpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBwYXJhbXNCdWlsZGVyKHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG1ha2VDb25maWdQYXJhbSA9IGZ1bmN0aW9uIChjb25maWcsIGlkKSB7IHJldHVybiBwYXJhbUZhY3RvcnkuZnJvbUNvbmZpZyhpZCwgbnVsbCwgY29uZmlnKTsgfTtcclxuICAgICAgICB2YXIgdXJsUGFyYW1zID0gKHN0YXRlLnVybCAmJiBzdGF0ZS51cmwucGFyYW1ldGVycyh7IGluaGVyaXQ6IGZhbHNlIH0pKSB8fCBbXTtcclxuICAgICAgICB2YXIgbm9uVXJsUGFyYW1zID0gY29tbW9uXzEudmFsdWVzKGNvbW1vbl8xLm1hcE9iaihjb21tb25fMS5vbWl0KHN0YXRlLnBhcmFtcyB8fCB7fSwgdXJsUGFyYW1zLm1hcChob2ZfMS5wcm9wKCdpZCcpKSksIG1ha2VDb25maWdQYXJhbSkpO1xyXG4gICAgICAgIHJldHVybiB1cmxQYXJhbXMuY29uY2F0KG5vblVybFBhcmFtcykubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBbcC5pZCwgcF07IH0pLnJlZHVjZShjb21tb25fMS5hcHBseVBhaXJzLCB7fSk7XHJcbiAgICB9O1xyXG59O1xyXG5mdW5jdGlvbiBwYXRoQnVpbGRlcihzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLnBhcmVudCA/IHN0YXRlLnBhcmVudC5wYXRoLmNvbmNhdChzdGF0ZSkgOiBbc3RhdGVdO1xyXG59XHJcbmZ1bmN0aW9uIGluY2x1ZGVzQnVpbGRlcihzdGF0ZSkge1xyXG4gICAgdmFyIGluY2x1ZGVzID0gc3RhdGUucGFyZW50ID8gY29tbW9uXzEuZXh0ZW5kKHt9LCBzdGF0ZS5wYXJlbnQuaW5jbHVkZXMpIDoge307XHJcbiAgICBpbmNsdWRlc1tzdGF0ZS5uYW1lXSA9IHRydWU7XHJcbiAgICByZXR1cm4gaW5jbHVkZXM7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIHRoZSBgcmVzb2x2ZTpgIGJsb2NrIG9uIGEgW1tTdGF0ZURlY2xhcmF0aW9uXV0uXHJcbiAqXHJcbiAqIFdoZW4gdGhlIFtbU3RhdGVCdWlsZGVyXV0gYnVpbGRzIGEgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCBmcm9tIGEgcmF3IFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGlzIGJ1aWxkZXJcclxuICogdmFsaWRhdGVzIHRoZSBgcmVzb2x2ZWAgcHJvcGVydHkgYW5kIGNvbnZlcnRzIGl0IHRvIGEgW1tSZXNvbHZhYmxlXV0gYXJyYXkuXHJcbiAqXHJcbiAqIHJlc29sdmU6IGlucHV0IHZhbHVlIGNhbiBiZTpcclxuICpcclxuICoge1xyXG4gKiAgIC8vIGFuYWx5emVkIGJ1dCBub3QgaW5qZWN0ZWRcclxuICogICBteUZvb1Jlc29sdmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJteUZvb0RhdGFcIjsgfSxcclxuICpcclxuICogICAvLyBmdW5jdGlvbi50b1N0cmluZygpIHBhcnNlZCwgXCJEZXBlbmRlbmN5TmFtZVwiIGRlcCBhcyBzdHJpbmcgKG5vdCBtaW4tc2FmZSlcclxuICogICBteUJhclJlc29sdmU6IGZ1bmN0aW9uKERlcGVuZGVuY3lOYW1lKSB7IHJldHVybiBEZXBlbmRlbmN5TmFtZS5mZXRjaFNvbWV0aGluZ0FzUHJvbWlzZSgpIH0sXHJcbiAqXHJcbiAqICAgLy8gQXJyYXkgc3BsaXQ7IFwiRGVwZW5kZW5jeU5hbWVcIiBkZXAgYXMgc3RyaW5nXHJcbiAqICAgbXlCYXpSZXNvbHZlOiBbIFwiRGVwZW5kZW5jeU5hbWVcIiwgZnVuY3Rpb24oZGVwKSB7IHJldHVybiBkZXAuZmV0Y2hTb21ldGhpbmdBc1Byb21pc2UoKSB9LFxyXG4gKlxyXG4gKiAgIC8vIEFycmF5IHNwbGl0OyBEZXBlbmRlbmN5VHlwZSBkZXAgYXMgdG9rZW4gKGNvbXBhcmVkIHVzaW5nID09PSlcclxuICogICBteVF1eFJlc29sdmU6IFsgRGVwZW5kZW5jeVR5cGUsIGZ1bmN0aW9uKGRlcCkgeyByZXR1cm4gZGVwLmZldGNoU29tZXRpbmdBc1Byb21pc2UoKSB9LFxyXG4gKlxyXG4gKiAgIC8vIHZhbC4kaW5qZWN0IHVzZWQgYXMgZGVwc1xyXG4gKiAgIC8vIHdoZXJlOlxyXG4gKiAgIC8vICAgICBjb3JnZVJlc29sdmUuJGluamVjdCA9IFtcIkRlcGVuZGVuY3lOYW1lXCJdO1xyXG4gKiAgIC8vICAgICBmdW5jdGlvbiBjb3JnZVJlc29sdmUoZGVwKSB7IGRlcC5mZXRjaFNvbWV0aW5nQXNQcm9taXNlKCkgfVxyXG4gKiAgIC8vIHRoZW4gXCJEZXBlbmRlbmN5TmFtZVwiIGRlcCBhcyBzdHJpbmdcclxuICogICBteUNvcmdlUmVzb2x2ZTogY29yZ2VSZXNvbHZlLFxyXG4gKlxyXG4gKiAgLy8gaW5qZWN0IHNlcnZpY2UgYnkgbmFtZVxyXG4gKiAgLy8gV2hlbiBhIHN0cmluZyBpcyBmb3VuZCwgZGVzdWdhciBjcmVhdGluZyBhIHJlc29sdmUgdGhhdCBpbmplY3RzIHRoZSBuYW1lZCBzZXJ2aWNlXHJcbiAqICAgbXlHcmF1bHRSZXNvbHZlOiBcIlNvbWVTZXJ2aWNlXCJcclxuICogfVxyXG4gKlxyXG4gKiBvcjpcclxuICpcclxuICogW1xyXG4gKiAgIG5ldyBSZXNvbHZhYmxlKFwibXlGb29SZXNvbHZlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJteUZvb0RhdGFcIiB9KSxcclxuICogICBuZXcgUmVzb2x2YWJsZShcIm15QmFyUmVzb2x2ZVwiLCBmdW5jdGlvbihkZXApIHsgcmV0dXJuIGRlcC5mZXRjaFNvbWV0aGluZ0FzUHJvbWlzZSgpIH0sIFsgXCJEZXBlbmRlbmN5TmFtZVwiIF0pLFxyXG4gKiAgIHsgcHJvdmlkZTogXCJteUJhelJlc29sdmVcIiwgdXNlRmFjdG9yeTogZnVuY3Rpb24oZGVwKSB7IGRlcC5mZXRjaFNvbWV0aGluZ0FzUHJvbWlzZSgpIH0sIGRlcHM6IFsgXCJEZXBlbmRlbmN5TmFtZVwiIF0gfVxyXG4gKiBdXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZhYmxlc0J1aWxkZXIoc3RhdGUpIHtcclxuICAgIC8qKiBjb252ZXJ0IHJlc29sdmU6IHt9IGFuZCByZXNvbHZlUG9saWN5OiB7fSBvYmplY3RzIHRvIGFuIGFycmF5IG9mIHR1cGxlcyAqL1xyXG4gICAgdmFyIG9iamVjdHMyVHVwbGVzID0gZnVuY3Rpb24gKHJlc29sdmVPYmosIHJlc29sdmVQb2xpY2llcykge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXNvbHZlT2JqIHx8IHt9KS5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiAoeyB0b2tlbjogdG9rZW4sIHZhbDogcmVzb2x2ZU9ialt0b2tlbl0sIGRlcHM6IHVuZGVmaW5lZCwgcG9saWN5OiByZXNvbHZlUG9saWNpZXNbdG9rZW5dIH0pOyB9KTtcclxuICAgIH07XHJcbiAgICAvKiogZmV0Y2ggREkgYW5ub3RhdGlvbnMgZnJvbSBhIGZ1bmN0aW9uIG9yIG5nMS1zdHlsZSBhcnJheSAqL1xyXG4gICAgdmFyIGFubm90YXRlID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdmFyICRpbmplY3RvciA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3RvcjtcclxuICAgICAgICAvLyBuZzEgZG9lc24ndCBoYXZlIGFuICRpbmplY3RvciB1bnRpbCBydW50aW1lLlxyXG4gICAgICAgIC8vIElmIHRoZSAkaW5qZWN0b3IgZG9lc24ndCBleGlzdCwgdXNlIFwiZGVmZXJyZWRcIiBsaXRlcmFsIGFzIGFcclxuICAgICAgICAvLyBtYXJrZXIgaW5kaWNhdGluZyB0aGV5IHNob3VsZCBiZSBhbm5vdGF0ZWQgd2hlbiBydW50aW1lIHN0YXJ0c1xyXG4gICAgICAgIHJldHVybiBmblsnJGluamVjdCddIHx8ICgkaW5qZWN0b3IgJiYgJGluamVjdG9yLmFubm90YXRlKGZuLCAkaW5qZWN0b3Iuc3RyaWN0RGkpKSB8fCBcImRlZmVycmVkXCI7XHJcbiAgICB9O1xyXG4gICAgLyoqIHRydWUgaWYgdGhlIG9iamVjdCBoYXMgYm90aCBgdG9rZW5gIGFuZCBgcmVzb2x2ZUZuYCwgYW5kIGlzIHByb2JhYmx5IGEgW1tSZXNvbHZlTGl0ZXJhbF1dICovXHJcbiAgICB2YXIgaXNSZXNvbHZlTGl0ZXJhbCA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuICEhKG9iai50b2tlbiAmJiBvYmoucmVzb2x2ZUZuKTsgfTtcclxuICAgIC8qKiB0cnVlIGlmIHRoZSBvYmplY3QgbG9va3MgbGlrZSBhIHByb3ZpZGUgbGl0ZXJhbCwgb3IgYSBuZzIgUHJvdmlkZXIgKi9cclxuICAgIHZhciBpc0xpa2VOZzJQcm92aWRlciA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuICEhKChvYmoucHJvdmlkZSB8fCBvYmoudG9rZW4pICYmIChvYmoudXNlVmFsdWUgfHwgb2JqLnVzZUZhY3RvcnkgfHwgb2JqLnVzZUV4aXN0aW5nIHx8IG9iai51c2VDbGFzcykpOyB9O1xyXG4gICAgLyoqIHRydWUgaWYgdGhlIG9iamVjdCBsb29rcyBsaWtlIGEgdHVwbGUgZnJvbSBvYmoyVHVwbGVzICovXHJcbiAgICB2YXIgaXNUdXBsZUZyb21PYmogPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiAhIShvYmogJiYgb2JqLnZhbCAmJiAocHJlZGljYXRlc18xLmlzU3RyaW5nKG9iai52YWwpIHx8IHByZWRpY2F0ZXNfMS5pc0FycmF5KG9iai52YWwpIHx8IHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKG9iai52YWwpKSk7IH07XHJcbiAgICAvKiogZXh0cmFjdHMgdGhlIHRva2VuIGZyb20gYSBQcm92aWRlciBvciBwcm92aWRlIGxpdGVyYWwgKi9cclxuICAgIHZhciB0b2tlbiA9IGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnByb3ZpZGUgfHwgcC50b2tlbjsgfTtcclxuICAgIC8qKiBHaXZlbiBhIGxpdGVyYWwgcmVzb2x2ZSBvciBwcm92aWRlciBvYmplY3QsIHJldHVybnMgYSBSZXNvbHZhYmxlICovXHJcbiAgICB2YXIgbGl0ZXJhbDJSZXNvbHZhYmxlID0gaG9mXzEucGF0dGVybihbXHJcbiAgICAgICAgW2hvZl8xLnByb3AoJ3Jlc29sdmVGbicpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHRva2VuKHApLCBwLnJlc29sdmVGbiwgcC5kZXBzLCBwLnBvbGljeSk7IH1dLFxyXG4gICAgICAgIFtob2ZfMS5wcm9wKCd1c2VGYWN0b3J5JyksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodG9rZW4ocCksIHAudXNlRmFjdG9yeSwgKHAuZGVwcyB8fCBwLmRlcGVuZGVuY2llcyksIHAucG9saWN5KTsgfV0sXHJcbiAgICAgICAgW2hvZl8xLnByb3AoJ3VzZUNsYXNzJyksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodG9rZW4ocCksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBwLnVzZUNsYXNzKCk7IH0sIFtdLCBwLnBvbGljeSk7IH1dLFxyXG4gICAgICAgIFtob2ZfMS5wcm9wKCd1c2VWYWx1ZScpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHRva2VuKHApLCBmdW5jdGlvbiAoKSB7IHJldHVybiBwLnVzZVZhbHVlOyB9LCBbXSwgcC5wb2xpY3ksIHAudXNlVmFsdWUpOyB9XSxcclxuICAgICAgICBbaG9mXzEucHJvcCgndXNlRXhpc3RpbmcnKSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0b2tlbihwKSwgY29tbW9uXzEuaWRlbnRpdHksIFtwLnVzZUV4aXN0aW5nXSwgcC5wb2xpY3kpOyB9XSxcclxuICAgIF0pO1xyXG4gICAgdmFyIHR1cGxlMlJlc29sdmFibGUgPSBob2ZfMS5wYXR0ZXJuKFtcclxuICAgICAgICBbaG9mXzEucGlwZShob2ZfMS5wcm9wKFwidmFsXCIpLCBwcmVkaWNhdGVzXzEuaXNTdHJpbmcpLCBmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0dXBsZS50b2tlbiwgY29tbW9uXzEuaWRlbnRpdHksIFt0dXBsZS52YWxdLCB0dXBsZS5wb2xpY3kpOyB9XSxcclxuICAgICAgICBbaG9mXzEucGlwZShob2ZfMS5wcm9wKFwidmFsXCIpLCBwcmVkaWNhdGVzXzEuaXNBcnJheSksIGZ1bmN0aW9uICh0dXBsZSkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHR1cGxlLnRva2VuLCBjb21tb25fMS50YWlsKHR1cGxlLnZhbCksIHR1cGxlLnZhbC5zbGljZSgwLCAtMSksIHR1cGxlLnBvbGljeSk7IH1dLFxyXG4gICAgICAgIFtob2ZfMS5waXBlKGhvZl8xLnByb3AoXCJ2YWxcIiksIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKSwgZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodHVwbGUudG9rZW4sIHR1cGxlLnZhbCwgYW5ub3RhdGUodHVwbGUudmFsKSwgdHVwbGUucG9saWN5KTsgfV0sXHJcbiAgICBdKTtcclxuICAgIHZhciBpdGVtMlJlc29sdmFibGUgPSBob2ZfMS5wYXR0ZXJuKFtcclxuICAgICAgICBbaG9mXzEuaXMocmVzb2x2YWJsZV8xLlJlc29sdmFibGUpLCBmdW5jdGlvbiAocikgeyByZXR1cm4gcjsgfV0sXHJcbiAgICAgICAgW2lzUmVzb2x2ZUxpdGVyYWwsIGxpdGVyYWwyUmVzb2x2YWJsZV0sXHJcbiAgICAgICAgW2lzTGlrZU5nMlByb3ZpZGVyLCBsaXRlcmFsMlJlc29sdmFibGVdLFxyXG4gICAgICAgIFtpc1R1cGxlRnJvbU9iaiwgdHVwbGUyUmVzb2x2YWJsZV0sXHJcbiAgICAgICAgW2hvZl8xLnZhbCh0cnVlKSwgZnVuY3Rpb24gKG9iaikgeyB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc29sdmUgdmFsdWU6IFwiICsgc3RyaW5nc18xLnN0cmluZ2lmeShvYmopKTsgfV1cclxuICAgIF0pO1xyXG4gICAgLy8gSWYgcmVzb2x2ZUJsb2NrIGlzIGFscmVhZHkgYW4gYXJyYXksIHVzZSBpdCBhcy1pcy5cclxuICAgIC8vIE90aGVyd2lzZSwgYXNzdW1lIGl0J3MgYW4gb2JqZWN0IGFuZCBjb252ZXJ0IHRvIGFuIEFycmF5IG9mIHR1cGxlc1xyXG4gICAgdmFyIGRlY2wgPSBzdGF0ZS5yZXNvbHZlO1xyXG4gICAgdmFyIGl0ZW1zID0gcHJlZGljYXRlc18xLmlzQXJyYXkoZGVjbCkgPyBkZWNsIDogb2JqZWN0czJUdXBsZXMoZGVjbCwgc3RhdGUucmVzb2x2ZVBvbGljeSB8fCB7fSk7XHJcbiAgICByZXR1cm4gaXRlbXMubWFwKGl0ZW0yUmVzb2x2YWJsZSk7XHJcbn1cclxuZXhwb3J0cy5yZXNvbHZhYmxlc0J1aWxkZXIgPSByZXNvbHZhYmxlc0J1aWxkZXI7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxhcGkgQSBpbnRlcm5hbCBnbG9iYWwgc2VydmljZVxyXG4gKlxyXG4gKiBTdGF0ZUJ1aWxkZXIgaXMgYSBmYWN0b3J5IGZvciB0aGUgaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIG9iamVjdHMuXHJcbiAqXHJcbiAqIFdoZW4geW91IHJlZ2lzdGVyIGEgc3RhdGUgd2l0aCB0aGUgW1tTdGF0ZVJlZ2lzdHJ5XV0sIHlvdSByZWdpc3RlciBhIHBsYWluIG9sZCBqYXZhc2NyaXB0IG9iamVjdCB3aGljaFxyXG4gKiBjb25mb3JtcyB0byB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uXV0gaW50ZXJmYWNlLiAgVGhpcyBmYWN0b3J5IHRha2VzIHRoYXQgb2JqZWN0IGFuZCBidWlsZHMgdGhlIGNvcnJlc3BvbmRpbmdcclxuICogW1tTdGF0ZU9iamVjdF1dIG9iamVjdCwgd2hpY2ggaGFzIGFuIEFQSSBhbmQgaXMgdXNlZCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBDdXN0b20gcHJvcGVydGllcyBvciBBUEkgbWF5IGJlIGFkZGVkIHRvIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGJ5IHJlZ2lzdGVyaW5nIGEgZGVjb3JhdG9yIGZ1bmN0aW9uXHJcbiAqIHVzaW5nIHRoZSBbW2J1aWxkZXJdXSBtZXRob2QuXHJcbiAqL1xyXG52YXIgU3RhdGVCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0YXRlQnVpbGRlcihtYXRjaGVyLCB1cmxNYXRjaGVyRmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMubWF0Y2hlciA9IG1hdGNoZXI7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciByb290ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0Y2hlci5maW5kKFwiXCIpOyB9O1xyXG4gICAgICAgIHZhciBpc1Jvb3QgPSBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLm5hbWUgPT09IFwiXCI7IH07XHJcbiAgICAgICAgZnVuY3Rpb24gcGFyZW50QnVpbGRlcihzdGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNSb290KHN0YXRlKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlci5maW5kKHNlbGYucGFyZW50TmFtZShzdGF0ZSkpIHx8IHJvb3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5idWlsZGVycyA9IHtcclxuICAgICAgICAgICAgbmFtZTogW25hbWVCdWlsZGVyXSxcclxuICAgICAgICAgICAgc2VsZjogW3NlbGZCdWlsZGVyXSxcclxuICAgICAgICAgICAgcGFyZW50OiBbcGFyZW50QnVpbGRlcl0sXHJcbiAgICAgICAgICAgIGRhdGE6IFtkYXRhQnVpbGRlcl0sXHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgVVJMTWF0Y2hlciBpZiBuZWNlc3NhcnksIGVpdGhlciB2aWEgYSByZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkxcclxuICAgICAgICAgICAgdXJsOiBbZ2V0VXJsQnVpbGRlcih1cmxNYXRjaGVyRmFjdG9yeSwgcm9vdCldLFxyXG4gICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHN0YXRlIHRoYXQgaGFzIGEgVVJMIChpLmUuIGlzIG5hdmlnYWJsZSlcclxuICAgICAgICAgICAgbmF2aWdhYmxlOiBbZ2V0TmF2aWdhYmxlQnVpbGRlcihpc1Jvb3QpXSxcclxuICAgICAgICAgICAgcGFyYW1zOiBbZ2V0UGFyYW1zQnVpbGRlcih1cmxNYXRjaGVyRmFjdG9yeS5wYXJhbUZhY3RvcnkpXSxcclxuICAgICAgICAgICAgLy8gRWFjaCBmcmFtZXdvcmstc3BlY2lmaWMgdWktcm91dGVyIGltcGxlbWVudGF0aW9uIHNob3VsZCBkZWZpbmUgaXRzIG93biBgdmlld3NgIGJ1aWxkZXJcclxuICAgICAgICAgICAgLy8gZS5nLiwgc3JjL25nMS9zdGF0ZWJ1aWxkZXJzL3ZpZXdzLnRzXHJcbiAgICAgICAgICAgIHZpZXdzOiBbXSxcclxuICAgICAgICAgICAgLy8gS2VlcCBhIGZ1bGwgcGF0aCBmcm9tIHRoZSByb290IGRvd24gdG8gdGhpcyBzdGF0ZSBhcyB0aGlzIGlzIG5lZWRlZCBmb3Igc3RhdGUgYWN0aXZhdGlvbi5cclxuICAgICAgICAgICAgcGF0aDogW3BhdGhCdWlsZGVyXSxcclxuICAgICAgICAgICAgLy8gU3BlZWQgdXAgJHN0YXRlLmluY2x1ZGVzKCkgYXMgaXQncyB1c2VkIGEgbG90XHJcbiAgICAgICAgICAgIGluY2x1ZGVzOiBbaW5jbHVkZXNCdWlsZGVyXSxcclxuICAgICAgICAgICAgcmVzb2x2YWJsZXM6IFtyZXNvbHZhYmxlc0J1aWxkZXJdXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgW1tCdWlsZGVyRnVuY3Rpb25dXSBmb3IgYSBzcGVjaWZpYyBbW1N0YXRlT2JqZWN0XV0gcHJvcGVydHkgKGUuZy4sIGBwYXJlbnRgLCBgdXJsYCwgb3IgYHBhdGhgKS5cclxuICAgICAqIE1vcmUgdGhhbiBvbmUgQnVpbGRlckZ1bmN0aW9uIGNhbiBiZSByZWdpc3RlcmVkIGZvciBhIGdpdmVuIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBCdWlsZGVyRnVuY3Rpb24ocykgd2lsbCBiZSB1c2VkIHRvIGRlZmluZSB0aGUgcHJvcGVydHkgb24gYW55IHN1YnNlcXVlbnRseSBidWlsdCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgU3RhdGUgcHJvcGVydHkgYmVpbmcgcmVnaXN0ZXJlZCBmb3IuXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIEJ1aWxkZXJGdW5jdGlvbiB3aGljaCB3aWxsIGJlIHVzZWQgdG8gYnVpbGQgdGhlIFN0YXRlIHByb3BlcnR5XHJcbiAgICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRlcmVnaXN0ZXJzIHRoZSBCdWlsZGVyRnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5idWlsZGVyID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XHJcbiAgICAgICAgdmFyIGJ1aWxkZXJzID0gdGhpcy5idWlsZGVycztcclxuICAgICAgICB2YXIgYXJyYXkgPSBidWlsZGVyc1tuYW1lXSB8fCBbXTtcclxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0OiBpZiBvbmx5IG9uZSBidWlsZGVyIGV4aXN0cywgcmV0dXJuIGl0LCBlbHNlIHJldHVybiB3aG9sZSBhcmFyeS5cclxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKG5hbWUpICYmICFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGZuKSlcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5Lmxlbmd0aCA+IDEgPyBhcnJheSA6IGFycmF5WzBdO1xyXG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzU3RyaW5nKG5hbWUpIHx8ICFwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihmbikpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBidWlsZGVyc1tuYW1lXSA9IGFycmF5O1xyXG4gICAgICAgIGJ1aWxkZXJzW25hbWVdLnB1c2goZm4pO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWlsZGVyc1tuYW1lXS5zcGxpY2UoYnVpbGRlcnNbbmFtZV0uaW5kZXhPZihmbiwgMSkpICYmIG51bGw7IH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIG9uIGFuIGVzc2VudGlhbGx5IGJsYW5rIFN0YXRlIG9iamVjdCwgcmV0dXJuaW5nIGEgU3RhdGUgb2JqZWN0IHdoaWNoIGhhcyBhbGwgaXRzXHJcbiAgICAgKiBwcm9wZXJ0aWVzIGFuZCBBUEkgYnVpbHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIGFuIHVuaW5pdGlhbGl6ZWQgU3RhdGUgb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB0aGUgYnVpbHQgU3RhdGUgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIFN0YXRlQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBtYXRjaGVyID0gX2EubWF0Y2hlciwgYnVpbGRlcnMgPSBfYS5idWlsZGVycztcclxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROYW1lKHN0YXRlKTtcclxuICAgICAgICBpZiAocGFyZW50ICYmICFtYXRjaGVyLmZpbmQocGFyZW50LCB1bmRlZmluZWQsIGZhbHNlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGJ1aWxkZXJzKSB7XHJcbiAgICAgICAgICAgIGlmICghYnVpbGRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB2YXIgY2hhaW4gPSBidWlsZGVyc1trZXldLnJlZHVjZShmdW5jdGlvbiAocGFyZW50Rm4sIHN0ZXApIHsgcmV0dXJuIGZ1bmN0aW9uIChfc3RhdGUpIHsgcmV0dXJuIHN0ZXAoX3N0YXRlLCBwYXJlbnRGbik7IH07IH0sIGNvbW1vbl8xLm5vb3ApO1xyXG4gICAgICAgICAgICBzdGF0ZVtrZXldID0gY2hhaW4oc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9O1xyXG4gICAgU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5wYXJlbnROYW1lID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5uYW1lIHx8IFwiXCI7XHJcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gbmFtZS5zcGxpdCgnLicpO1xyXG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlcyB0aGF0IHNwZWNpZnkgdGhlICdwYXJlbnQ6JyBwcm9wZXJ0eSBzaG91bGQgbm90IGhhdmUgYSAnLicgaW4gdGhlaXIgbmFtZSAoXCIgKyBuYW1lICsgXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzLnBvcCgpO1xyXG4gICAgICAgICAgICBpZiAobGFzdFNlZ21lbnQgPT09ICcqKicpXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wb3AoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnRzLmpvaW4oXCIuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN0YXRlLnBhcmVudClcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzdGF0ZS5wYXJlbnQpID8gc3RhdGUucGFyZW50IDogc3RhdGUucGFyZW50Lm5hbWU7XHJcbiAgICB9O1xyXG4gICAgU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5uYW1lO1xyXG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTEgfHwgIXN0YXRlLnBhcmVudClcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgdmFyIHBhcmVudE5hbWUgPSBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGUucGFyZW50KSA/IHN0YXRlLnBhcmVudCA6IHN0YXRlLnBhcmVudC5uYW1lO1xyXG4gICAgICAgIHJldHVybiBwYXJlbnROYW1lID8gcGFyZW50TmFtZSArIFwiLlwiICsgbmFtZSA6IG5hbWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFN0YXRlQnVpbGRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5TdGF0ZUJ1aWxkZXIgPSBTdGF0ZUJ1aWxkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlQnVpbGRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZUJ1aWxkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKiBAbW9kdWxlIHN0YXRlICovIC8qKiBmb3IgdHlwZWRvYyAqL1xyXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIFN0YXRlTWF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdGF0ZU1hdGNoZXIoX3N0YXRlcykge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IF9zdGF0ZXM7XHJcbiAgICB9XHJcbiAgICBTdGF0ZU1hdGNoZXIucHJvdG90eXBlLmlzUmVsYXRpdmUgPSBmdW5jdGlvbiAoc3RhdGVOYW1lKSB7XHJcbiAgICAgICAgc3RhdGVOYW1lID0gc3RhdGVOYW1lIHx8IFwiXCI7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlTmFtZS5pbmRleE9mKFwiLlwiKSA9PT0gMCB8fCBzdGF0ZU5hbWUuaW5kZXhPZihcIl5cIikgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgU3RhdGVNYXRjaGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBiYXNlLCBtYXRjaEdsb2IpIHtcclxuICAgICAgICBpZiAobWF0Y2hHbG9iID09PSB2b2lkIDApIHsgbWF0Y2hHbG9iID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmICghc3RhdGVPck5hbWUgJiYgc3RhdGVPck5hbWUgIT09IFwiXCIpXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGlzU3RyID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKHN0YXRlT3JOYW1lKTtcclxuICAgICAgICB2YXIgbmFtZSA9IGlzU3RyID8gc3RhdGVPck5hbWUgOiBzdGF0ZU9yTmFtZS5uYW1lO1xyXG4gICAgICAgIGlmICh0aGlzLmlzUmVsYXRpdmUobmFtZSkpXHJcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLnJlc29sdmVQYXRoKG5hbWUsIGJhc2UpO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlc1tuYW1lXTtcclxuICAgICAgICBpZiAoc3RhdGUgJiYgKGlzU3RyIHx8ICghaXNTdHIgJiYgKHN0YXRlID09PSBzdGF0ZU9yTmFtZSB8fCBzdGF0ZS5zZWxmID09PSBzdGF0ZU9yTmFtZSkpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzU3RyICYmIG1hdGNoR2xvYikge1xyXG4gICAgICAgICAgICB2YXIgX3N0YXRlcyA9IGNvbW1vbl8xLnZhbHVlcyh0aGlzLl9zdGF0ZXMpO1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IF9zdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLl9fc3RhdGVPYmplY3RDYWNoZS5uYW1lR2xvYiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLl9fc3RhdGVPYmplY3RDYWNoZS5uYW1lR2xvYi5tYXRjaGVzKG5hbWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzdGF0ZU1hdGNoZXIuZmluZDogRm91bmQgbXVsdGlwbGUgbWF0Y2hlcyBmb3IgXCIgKyBuYW1lICsgXCIgdXNpbmcgZ2xvYjogXCIsIG1hdGNoZXMubWFwKGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gbWF0Y2gubmFtZTsgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIFN0YXRlTWF0Y2hlci5wcm90b3R5cGUucmVzb2x2ZVBhdGggPSBmdW5jdGlvbiAobmFtZSwgYmFzZSkge1xyXG4gICAgICAgIGlmICghYmFzZSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVmZXJlbmNlIHBvaW50IGdpdmVuIGZvciBwYXRoICdcIiArIG5hbWUgKyBcIidcIik7XHJcbiAgICAgICAgdmFyIGJhc2VTdGF0ZSA9IHRoaXMuZmluZChiYXNlKTtcclxuICAgICAgICB2YXIgc3BsaXROYW1lID0gbmFtZS5zcGxpdChcIi5cIiksIGkgPSAwLCBwYXRoTGVuZ3RoID0gc3BsaXROYW1lLmxlbmd0aCwgY3VycmVudCA9IGJhc2VTdGF0ZTtcclxuICAgICAgICBmb3IgKDsgaSA8IHBhdGhMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoc3BsaXROYW1lW2ldID09PSBcIlwiICYmIGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBiYXNlU3RhdGU7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3BsaXROYW1lW2ldID09PSBcIl5cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50LnBhcmVudClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoICdcIiArIG5hbWUgKyBcIicgbm90IHZhbGlkIGZvciBzdGF0ZSAnXCIgKyBiYXNlU3RhdGUubmFtZSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVsTmFtZSA9IHNwbGl0TmFtZS5zbGljZShpKS5qb2luKFwiLlwiKTtcclxuICAgICAgICByZXR1cm4gY3VycmVudC5uYW1lICsgKGN1cnJlbnQubmFtZSAmJiByZWxOYW1lID8gXCIuXCIgOiBcIlwiKSArIHJlbE5hbWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFN0YXRlTWF0Y2hlcjtcclxufSgpKTtcclxuZXhwb3J0cy5TdGF0ZU1hdGNoZXIgPSBTdGF0ZU1hdGNoZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlTWF0Y2hlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZU1hdGNoZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKiBAbW9kdWxlIHN0YXRlICovIC8qKiBmb3IgdHlwZWRvYyAqL1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcclxudmFyIHN0YXRlT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9zdGF0ZU9iamVjdFwiKTtcclxudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XHJcbi8qKiBAaW50ZXJuYWxhcGkgKi9cclxudmFyIFN0YXRlUXVldWVNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0YXRlUXVldWVNYW5hZ2VyKCRyZWdpc3RyeSwgJHVybFJvdXRlciwgc3RhdGVzLCBidWlsZGVyLCBsaXN0ZW5lcnMpIHtcclxuICAgICAgICB0aGlzLiRyZWdpc3RyeSA9ICRyZWdpc3RyeTtcclxuICAgICAgICB0aGlzLiR1cmxSb3V0ZXIgPSAkdXJsUm91dGVyO1xyXG4gICAgICAgIHRoaXMuc3RhdGVzID0gc3RhdGVzO1xyXG4gICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XHJcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xyXG4gICAgICAgIHRoaXMubWF0Y2hlciA9ICRyZWdpc3RyeS5tYXRjaGVyO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xyXG4gICAgU3RhdGVRdWV1ZU1hbmFnZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xyXG4gICAgfTtcclxuICAgIFN0YXRlUXVldWVNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChzdGF0ZURlY2wpIHtcclxuICAgICAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlT2JqZWN0XzEuU3RhdGVPYmplY3QuY3JlYXRlKHN0YXRlRGVjbCk7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5uYW1lO1xyXG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzU3RyaW5nKG5hbWUpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBtdXN0IGhhdmUgYSB2YWxpZCBuYW1lXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBjb21tb25fMS5pbkFycmF5KHF1ZXVlLm1hcChob2ZfMS5wcm9wKCduYW1lJykpLCBuYW1lKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgJ1wiICsgbmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlZmluZWRcIik7XHJcbiAgICAgICAgcXVldWUucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH07XHJcbiAgICBTdGF0ZVF1ZXVlTWFuYWdlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBxdWV1ZSA9IF9hLnF1ZXVlLCBzdGF0ZXMgPSBfYS5zdGF0ZXMsIGJ1aWxkZXIgPSBfYS5idWlsZGVyO1xyXG4gICAgICAgIHZhciByZWdpc3RlcmVkID0gW10sIC8vIHN0YXRlcyB0aGF0IGdvdCByZWdpc3RlcmVkXHJcbiAgICAgICAgb3JwaGFucyA9IFtdLCAvLyBzdGF0ZXMgdGhhdCBkb24ndCB5ZXQgaGF2ZSBhIHBhcmVudCByZWdpc3RlcmVkXHJcbiAgICAgICAgcHJldmlvdXNRdWV1ZUxlbmd0aCA9IHt9OyAvLyBrZWVwIHRyYWNrIG9mIGhvdyBsb25nIHRoZSBxdWV1ZSB3aGVuIGFuIG9ycGhhbiB3YXMgZmlyc3QgZW5jb3VudGVyZWRcclxuICAgICAgICB2YXIgZ2V0U3RhdGUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc3RhdGVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIF90aGlzLnN0YXRlc1tuYW1lXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHF1ZXVlLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBzdGF0ZS5uYW1lO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gYnVpbGRlci5idWlsZChzdGF0ZSk7XHJcbiAgICAgICAgICAgIHZhciBvcnBoYW5JZHggPSBvcnBoYW5zLmluZGV4T2Yoc3RhdGUpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdTdGF0ZSA9IGdldFN0YXRlKG5hbWVfMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdTdGF0ZSAmJiBleGlzdGluZ1N0YXRlLm5hbWUgPT09IG5hbWVfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlICdcIiArIG5hbWVfMSArIFwiJyBpcyBhbHJlYWR5IGRlZmluZWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdGdXR1cmVTdGF0ZSA9IGdldFN0YXRlKG5hbWVfMSArIFwiLioqXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRnV0dXJlU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnV0dXJlIHN0YXRlIG9mIHRoZSBzYW1lIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRyZWdpc3RyeS5kZXJlZ2lzdGVyKGV4aXN0aW5nRnV0dXJlU3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3RhdGVzW25hbWVfMV0gPSBzdGF0ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoUm91dGUoc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9ycGhhbklkeCA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIG9ycGhhbnMuc3BsaWNlKG9ycGhhbklkeCwgMSk7XHJcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkLnB1c2goc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHByZXYgPSBwcmV2aW91c1F1ZXVlTGVuZ3RoW25hbWVfMV07XHJcbiAgICAgICAgICAgIHByZXZpb3VzUXVldWVMZW5ndGhbbmFtZV8xXSA9IHF1ZXVlLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKG9ycGhhbklkeCA+PSAwICYmIHByZXYgPT09IHF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCB0d28gY29uc2VjdXRpdmUgaXRlcmF0aW9ucyB3aGVyZSBubyBhZGRpdGlvbmFsIHN0YXRlcyB3ZXJlIGRlcXVldWVkIHN1Y2Nlc3NmdWxseS5cclxuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlZ2lzdGVyIG9ycGhhbmVkIHN0YXRlICcke25hbWV9J2ApO1xyXG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9ycGhhbklkeCA8IDApIHtcclxuICAgICAgICAgICAgICAgIG9ycGhhbnMucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcXVldWUucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWdpc3RlcmVkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIoXCJyZWdpc3RlcmVkXCIsIHJlZ2lzdGVyZWQubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnNlbGY7IH0pKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGF0ZXM7XHJcbiAgICB9O1xyXG4gICAgU3RhdGVRdWV1ZU1hbmFnZXIucHJvdG90eXBlLmF0dGFjaFJvdXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgaWYgKHN0YXRlLmFic3RyYWN0IHx8ICFzdGF0ZS51cmwpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLiR1cmxSb3V0ZXIucnVsZSh0aGlzLiR1cmxSb3V0ZXIudXJsUnVsZUZhY3RvcnkuY3JlYXRlKHN0YXRlKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFN0YXRlUXVldWVNYW5hZ2VyO1xyXG59KCkpO1xyXG5leHBvcnRzLlN0YXRlUXVldWVNYW5hZ2VyID0gU3RhdGVRdWV1ZU1hbmFnZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlUXVldWVNYW5hZ2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlUXVldWVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuLyoqXHJcbiAqIEBjb3JlYXBpXHJcbiAqIEBtb2R1bGUgc3RhdGVcclxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBzdGF0ZU1hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRlTWF0Y2hlclwiKTtcclxudmFyIHN0YXRlQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vc3RhdGVCdWlsZGVyXCIpO1xyXG52YXIgc3RhdGVRdWV1ZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRlUXVldWVNYW5hZ2VyXCIpO1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XHJcbnZhciBTdGF0ZVJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cclxuICAgIGZ1bmN0aW9uIFN0YXRlUmVnaXN0cnkoX3JvdXRlcikge1xyXG4gICAgICAgIHRoaXMuX3JvdXRlciA9IF9yb3V0ZXI7XHJcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB7fTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMubWF0Y2hlciA9IG5ldyBzdGF0ZU1hdGNoZXJfMS5TdGF0ZU1hdGNoZXIodGhpcy5zdGF0ZXMpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRlciA9IG5ldyBzdGF0ZUJ1aWxkZXJfMS5TdGF0ZUJ1aWxkZXIodGhpcy5tYXRjaGVyLCBfcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5KTtcclxuICAgICAgICB0aGlzLnN0YXRlUXVldWUgPSBuZXcgc3RhdGVRdWV1ZU1hbmFnZXJfMS5TdGF0ZVF1ZXVlTWFuYWdlcih0aGlzLCBfcm91dGVyLnVybFJvdXRlciwgdGhpcy5zdGF0ZXMsIHRoaXMuYnVpbGRlciwgdGhpcy5saXN0ZW5lcnMpO1xyXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyUm9vdCgpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xyXG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUuX3JlZ2lzdGVyUm9vdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcm9vdFN0YXRlRGVmID0ge1xyXG4gICAgICAgICAgICBuYW1lOiAnJyxcclxuICAgICAgICAgICAgdXJsOiAnXicsXHJcbiAgICAgICAgICAgIHZpZXdzOiBudWxsLFxyXG4gICAgICAgICAgICBwYXJhbXM6IHtcclxuICAgICAgICAgICAgICAgICcjJzogeyB2YWx1ZTogbnVsbCwgdHlwZTogJ2hhc2gnLCBkeW5hbWljOiB0cnVlIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWJzdHJhY3Q6IHRydWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBfcm9vdCA9IHRoaXMuX3Jvb3QgPSB0aGlzLnN0YXRlUXVldWUucmVnaXN0ZXIocm9vdFN0YXRlRGVmKTtcclxuICAgICAgICBfcm9vdC5uYXZpZ2FibGUgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cclxuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnN0YXRlUXVldWUuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5nZXQoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gX3RoaXMuZ2V0KHN0YXRlKSAmJiBfdGhpcy5kZXJlZ2lzdGVyKHN0YXRlKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZW4gZm9yIGEgU3RhdGUgUmVnaXN0cnkgZXZlbnRzXHJcbiAgICAgKlxyXG4gICAgICogQWRkcyBhIGNhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuIHN0YXRlcyBhcmUgcmVnaXN0ZXJlZCBvciBkZXJlZ2lzdGVyZWQgd2l0aCB0aGUgU3RhdGVSZWdpc3RyeS5cclxuICAgICAqXHJcbiAgICAgKiAjIyMjIEV4YW1wbGU6XHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogbGV0IGFsbFN0YXRlcyA9IHJlZ2lzdHJ5LmdldCgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIExhdGVyLCBpbnZva2UgZGVyZWdpc3RlckZuKCkgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxyXG4gICAgICogbGV0IGRlcmVnaXN0ZXJGbiA9IHJlZ2lzdHJ5Lm9uU3RhdGVzQ2hhbmdlZCgoZXZlbnQsIHN0YXRlcykgPT4ge1xyXG4gICAgICogICBzd2l0Y2goZXZlbnQpIHtcclxuICAgICAqICAgICBjYXNlOiAncmVnaXN0ZXJlZCc6XHJcbiAgICAgKiAgICAgICBzdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiBhbGxTdGF0ZXMucHVzaChzdGF0ZSkpO1xyXG4gICAgICogICAgICAgYnJlYWs7XHJcbiAgICAgKiAgICAgY2FzZTogJ2RlcmVnaXN0ZXJlZCc6XHJcbiAgICAgKiAgICAgICBzdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgKiAgICAgICAgIGxldCBpZHggPSBhbGxTdGF0ZXMuaW5kZXhPZihzdGF0ZSk7XHJcbiAgICAgKiAgICAgICAgIGlmIChpZHggIT09IC0xKSBhbGxTdGF0ZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgKiAgICAgICB9KTtcclxuICAgICAqICAgICAgIGJyZWFrO1xyXG4gICAgICogICB9XHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBhIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgd2hlbiB0aGUgcmVnaXN0ZXJlZCBzdGF0ZXMgY2hhbmdlcy5cclxuICAgICAqICAgICAgICBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHBhcmFtZXRlcnMsIGBldmVudGAgYW5kIGBzdGF0ZWAuXHJcbiAgICAgKiAgICAgICAgU2VlIFtbU3RhdGVSZWdpc3RyeUxpc3RlbmVyXV1cclxuICAgICAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGRlcmVnaXN0ZXJzIHRoZSBsaXN0ZW5lclxyXG4gICAgICovXHJcbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5vblN0YXRlc0NoYW5nZWQgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZGVyZWdpc3Rlckxpc3RlbmVyKCkge1xyXG4gICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKHRoaXMubGlzdGVuZXJzKShsaXN0ZW5lcik7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaW1wbGljaXQgcm9vdCBzdGF0ZVxyXG4gICAgICpcclxuICAgICAqIEdldHMgdGhlIHJvb3Qgb2YgdGhlIHN0YXRlIHRyZWUuXHJcbiAgICAgKiBUaGUgcm9vdCBzdGF0ZSBpcyBpbXBsaWNpdGx5IGNyZWF0ZWQgYnkgVUktUm91dGVyLlxyXG4gICAgICogTm90ZTogdGhpcyByZXR1cm5zIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gcmVwcmVzZW50YXRpb24sIG5vdCBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB0aGUgcm9vdCBbW1N0YXRlT2JqZWN0XV1cclxuICAgICAqL1xyXG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUucm9vdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzdGF0ZSB0byB0aGUgcmVnaXN0cnlcclxuICAgICAqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBbW1N0YXRlRGVjbGFyYXRpb25dXSBvciBxdWV1ZXMgaXQgZm9yIHJlZ2lzdHJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhIHN0YXRlIHdpbGwgYmUgcXVldWVkIGlmIHRoZSBzdGF0ZSdzIHBhcmVudCBpc24ndCB5ZXQgcmVnaXN0ZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGVEZWZpbml0aW9uIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBzdGF0ZSB0byByZWdpc3Rlci5cclxuICAgICAqIEByZXR1cm5zIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0LlxyXG4gICAgICogICAgICAgICAgSWYgdGhlIHN0YXRlIHdhcyBzdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZCwgdGhlbiB0aGUgb2JqZWN0IGlzIGZ1bGx5IGJ1aWx0IChTZWU6IFtbU3RhdGVCdWlsZGVyXV0pLlxyXG4gICAgICogICAgICAgICAgSWYgdGhlIHN0YXRlIHdhcyBvbmx5IHF1ZXVlZCwgdGhlbiB0aGUgb2JqZWN0IGlzIG5vdCBmdWxseSBidWlsdC5cclxuICAgICAqL1xyXG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoc3RhdGVEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVRdWV1ZS5yZWdpc3RlcihzdGF0ZURlZmluaXRpb24pO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5fZGVyZWdpc3RlclRyZWUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBhbGwgPSB0aGlzLmdldCgpLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy4kJHN0YXRlKCk7IH0pO1xyXG4gICAgICAgIHZhciBnZXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChzdGF0ZXMpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gYWxsLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gc3RhdGVzLmluZGV4T2Yocy5wYXJlbnQpICE9PSAtMTsgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPT09IDAgPyBjaGlsZHJlbiA6IGNoaWxkcmVuLmNvbmNhdChnZXRDaGlsZHJlbihjaGlsZHJlbikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oW3N0YXRlXSk7XHJcbiAgICAgICAgdmFyIGRlcmVnaXN0ZXJlZCA9IFtzdGF0ZV0uY29uY2F0KGNoaWxkcmVuKS5yZXZlcnNlKCk7XHJcbiAgICAgICAgZGVyZWdpc3RlcmVkLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIHZhciAkdXIgPSBfdGhpcy5fcm91dGVyLnVybFJvdXRlcjtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIFVSTCBydWxlXHJcbiAgICAgICAgICAgICR1ci5ydWxlcygpLmZpbHRlcihob2ZfMS5wcm9wRXEoXCJzdGF0ZVwiLCBzdGF0ZSkpLmZvckVhY2goJHVyLnJlbW92ZVJ1bGUuYmluZCgkdXIpKTtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHN0YXRlIGZyb20gcmVnaXN0cnlcclxuICAgICAgICAgICAgZGVsZXRlIF90aGlzLnN0YXRlc1tzdGF0ZS5uYW1lXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGVyZWdpc3RlcmVkO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIHN0YXRlIGZyb20gdGhlIHJlZ2lzdHJ5XHJcbiAgICAgKlxyXG4gICAgICogVGhpcyByZW1vdmVzIGEgc3RhdGUgZnJvbSB0aGUgcmVnaXN0cnkuXHJcbiAgICAgKiBJZiB0aGUgc3RhdGUgaGFzIGNoaWxkcmVuLCB0aGV5IGFyZSBhcmUgYWxzbyByZW1vdmVkIGZyb20gdGhlIHJlZ2lzdHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSB0aGUgc3RhdGUncyBuYW1lIG9yIG9iamVjdCByZXByZXNlbnRhdGlvblxyXG4gICAgICogQHJldHVybnMge1N0YXRlT2JqZWN0W119IGEgbGlzdCBvZiByZW1vdmVkIHN0YXRlc1xyXG4gICAgICovXHJcbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5kZXJlZ2lzdGVyID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lKSB7XHJcbiAgICAgICAgdmFyIF9zdGF0ZSA9IHRoaXMuZ2V0KHN0YXRlT3JOYW1lKTtcclxuICAgICAgICBpZiAoIV9zdGF0ZSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZGVyZWdpc3RlciBzdGF0ZTsgbm90IGZvdW5kOiBcIiArIHN0YXRlT3JOYW1lKTtcclxuICAgICAgICB2YXIgZGVyZWdpc3RlcmVkU3RhdGVzID0gdGhpcy5fZGVyZWdpc3RlclRyZWUoX3N0YXRlLiQkc3RhdGUoKSk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKFwiZGVyZWdpc3RlcmVkXCIsIGRlcmVnaXN0ZXJlZFN0YXRlcy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuc2VsZjsgfSkpOyB9KTtcclxuICAgICAgICByZXR1cm4gZGVyZWdpc3RlcmVkU3RhdGVzO1xyXG4gICAgfTtcclxuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgYmFzZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0YXRlcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5zdGF0ZXNbbmFtZV0uc2VsZjsgfSk7XHJcbiAgICAgICAgdmFyIGZvdW5kID0gdGhpcy5tYXRjaGVyLmZpbmQoc3RhdGVPck5hbWUsIGJhc2UpO1xyXG4gICAgICAgIHJldHVybiBmb3VuZCAmJiBmb3VuZC5zZWxmIHx8IG51bGw7XHJcbiAgICB9O1xyXG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUuZGVjb3JhdG9yID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZGVyLmJ1aWxkZXIobmFtZSwgZnVuYyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFN0YXRlUmVnaXN0cnk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuU3RhdGVSZWdpc3RyeSA9IFN0YXRlUmVnaXN0cnk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlUmVnaXN0cnkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvc3RhdGVSZWdpc3RyeS5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEBjb3JlYXBpXHJcbiAqIEBtb2R1bGUgc3RhdGVcclxuICovXHJcbi8qKiAqL1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcclxudmFyIHF1ZXVlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3F1ZXVlXCIpO1xyXG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcclxudmFyIHBhdGhGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vcGF0aC9wYXRoRmFjdG9yeVwiKTtcclxudmFyIHBhdGhOb2RlXzEgPSByZXF1aXJlKFwiLi4vcGF0aC9wYXRoTm9kZVwiKTtcclxudmFyIHRyYW5zaXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uU2VydmljZVwiKTtcclxudmFyIHJlamVjdEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnlcIik7XHJcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4vdGFyZ2V0U3RhdGVcIik7XHJcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcclxudmFyIGdsb2JfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZ2xvYlwiKTtcclxudmFyIHJlc29sdmVDb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZlQ29udGV4dFwiKTtcclxudmFyIGxhenlMb2FkXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvbGF6eUxvYWRcIik7XHJcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xyXG4vKipcclxuICogUHJvdmlkZXMgc3RhdGUgcmVsYXRlZCBzZXJ2aWNlIGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gdWktcm91dGVyIHN0YXRlcy5cclxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBpcyBsb2NhdGVkIG9uIHRoZSBnbG9iYWwgW1tVSVJvdXRlcl1dIG9iamVjdC5cclxuICovXHJcbnZhciBTdGF0ZVNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xyXG4gICAgZnVuY3Rpb24gU3RhdGVTZXJ2aWNlKHJvdXRlcikge1xyXG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cclxuICAgICAgICB0aGlzLmludmFsaWRDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgICAgIHRoaXMuX2RlZmF1bHRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAkZGVmYXVsdEVycm9ySGFuZGxlcigkZXJyb3IkKSB7XHJcbiAgICAgICAgICAgIGlmICgkZXJyb3IkIGluc3RhbmNlb2YgRXJyb3IgJiYgJGVycm9yJC5zdGFjaykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJC5zdGFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJGVycm9yJCBpbnN0YW5jZW9mIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIGlmICgkZXJyb3IkLmRldGFpbCAmJiAkZXJyb3IkLmRldGFpbC5zdGFjaylcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQuZGV0YWlsLnN0YWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBnZXR0ZXJzID0gWydjdXJyZW50JywgJyRjdXJyZW50JywgJ3BhcmFtcycsICd0cmFuc2l0aW9uJ107XHJcbiAgICAgICAgdmFyIGJvdW5kRm5zID0gT2JqZWN0LmtleXMoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSkuZmlsdGVyKGhvZl8xLm5vdChjb21tb25fMS5pbkFycmF5KGdldHRlcnMpKSk7XHJcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnMoaG9mXzEudmFsKFN0YXRlU2VydmljZS5wcm90b3R5cGUpLCB0aGlzLCBob2ZfMS52YWwodGhpcyksIGJvdW5kRm5zKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZVNlcnZpY2UucHJvdG90eXBlLCBcInRyYW5zaXRpb25cIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBbW1RyYW5zaXRpb25dXSBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MgKG9yIG51bGwpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGlzIGEgcGFzc3Rocm91Z2ggdGhyb3VnaCB0byBbW1VJUm91dGVyR2xvYmFscy50cmFuc2l0aW9uXV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbjsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJwYXJhbXNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsYXRlc3Qgc3VjY2Vzc2Z1bCBzdGF0ZSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGlzIGEgcGFzc3Rocm91Z2ggdGhyb3VnaCB0byBbW1VJUm91dGVyR2xvYmFscy5wYXJhbXNdXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy5wYXJhbXM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlU2VydmljZS5wcm90b3R5cGUsIFwiY3VycmVudFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGN1cnJlbnQgW1tTdGF0ZURlY2xhcmF0aW9uXV1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0aHJvdWdoIHRvIFtbVUlSb3V0ZXJHbG9iYWxzLmN1cnJlbnRdXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yb3V0ZXIuZ2xvYmFscy5jdXJyZW50OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZVNlcnZpY2UucHJvdG90eXBlLCBcIiRjdXJyZW50XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY3VycmVudCBbW1N0YXRlT2JqZWN0XV1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0aHJvdWdoIHRvIFtbVUlSb3V0ZXJHbG9iYWxzLiRjdXJyZW50XV1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucm91dGVyLmdsb2JhbHMuJGN1cnJlbnQ7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xyXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdEVycm9ySGFuZGxlcihjb21tb25fMS5ub29wKTtcclxuICAgICAgICB0aGlzLmludmFsaWRDYWxsYmFja3MgPSBbXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yIHdoZW4gW1t0cmFuc2l0aW9uVG9dXSBpcyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEludm9rZXMgdGhlIFtbb25JbnZhbGlkXV0gY2FsbGJhY2tzLCBpbiBuYXR1cmFsIG9yZGVyLlxyXG4gICAgICogRWFjaCBjYWxsYmFjaydzIHJldHVybiB2YWx1ZSBpcyBjaGVja2VkIGluIHNlcXVlbmNlIHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgVGFyZ2V0U3RhdGUuXHJcbiAgICAgKiBUaGUgcmVzdWx0cyBvZiB0aGUgY2FsbGJhY2tzIGFyZSB3cmFwcGVkIGluICRxLndoZW4oKSwgc28gdGhlIGNhbGxiYWNrcyBtYXkgcmV0dXJuIHByb21pc2VzLlxyXG4gICAgICpcclxuICAgICAqIElmIGEgY2FsbGJhY2sgcmV0dXJucyBhbiBUYXJnZXRTdGF0ZSwgdGhlbiBpdCBpcyB1c2VkIGFzIGFyZ3VtZW50cyB0byAkc3RhdGUudHJhbnNpdGlvblRvKCkgYW5kIHRoZSByZXN1bHQgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsYXBpXHJcbiAgICAgKi9cclxuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuX2hhbmRsZUludmFsaWRUYXJnZXRTdGF0ZSA9IGZ1bmN0aW9uIChmcm9tUGF0aCwgdG9TdGF0ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGZyb21TdGF0ZSA9IHBhdGhGYWN0b3J5XzEuUGF0aFV0aWxzLm1ha2VUYXJnZXRTdGF0ZShmcm9tUGF0aCk7XHJcbiAgICAgICAgdmFyIGdsb2JhbHMgPSB0aGlzLnJvdXRlci5nbG9iYWxzO1xyXG4gICAgICAgIHZhciBsYXRlc3RUaGluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsb2JhbHMudHJhbnNpdGlvbkhpc3RvcnkucGVla1RhaWwoKTsgfTtcclxuICAgICAgICB2YXIgbGF0ZXN0ID0gbGF0ZXN0VGhpbmcoKTtcclxuICAgICAgICB2YXIgY2FsbGJhY2tRdWV1ZSA9IG5ldyBxdWV1ZV8xLlF1ZXVlKHRoaXMuaW52YWxpZENhbGxiYWNrcy5zbGljZSgpKTtcclxuICAgICAgICB2YXIgaW5qZWN0b3IgPSBuZXcgcmVzb2x2ZUNvbnRleHRfMS5SZXNvbHZlQ29udGV4dChmcm9tUGF0aCkuaW5qZWN0b3IoKTtcclxuICAgICAgICB2YXIgY2hlY2tGb3JSZWRpcmVjdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAvLyBSZWNyZWF0ZSB0aGUgVGFyZ2V0U3RhdGUsIGluIGNhc2UgdGhlIHN0YXRlIGlzIG5vdyBkZWZpbmVkLlxyXG4gICAgICAgICAgICB0YXJnZXQgPSBfdGhpcy50YXJnZXQodGFyZ2V0LmlkZW50aWZpZXIoKSwgdGFyZ2V0LnBhcmFtcygpLCB0YXJnZXQub3B0aW9ucygpKTtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQudmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uaW52YWxpZCh0YXJnZXQuZXJyb3IoKSkudG9Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxhdGVzdFRoaW5nKCkgIT09IGxhdGVzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uc3VwZXJzZWRlZCgpLnRvUHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2l0aW9uVG8odGFyZ2V0LmlkZW50aWZpZXIoKSwgdGFyZ2V0LnBhcmFtcygpLCB0YXJnZXQub3B0aW9ucygpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZ1bmN0aW9uIGludm9rZU5leHRDYWxsYmFjaygpIHtcclxuICAgICAgICAgICAgdmFyIG5leHRDYWxsYmFjayA9IGNhbGxiYWNrUXVldWUuZGVxdWV1ZSgpO1xyXG4gICAgICAgICAgICBpZiAobmV4dENhbGxiYWNrID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5pbnZhbGlkKHRvU3RhdGUuZXJyb3IoKSkudG9Qcm9taXNlKCk7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFja1Jlc3VsdCA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4obmV4dENhbGxiYWNrKHRvU3RhdGUsIGZyb21TdGF0ZSwgaW5qZWN0b3IpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrUmVzdWx0LnRoZW4oY2hlY2tGb3JSZWRpcmVjdCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQgfHwgaW52b2tlTmV4dENhbGxiYWNrKCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW52b2tlTmV4dENhbGxiYWNrKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYW4gSW52YWxpZCBTdGF0ZSBoYW5kbGVyXHJcbiAgICAgKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgW1tPbkludmFsaWRDYWxsYmFja11dIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiBbW1N0YXRlU2VydmljZS50cmFuc2l0aW9uVG9dXVxyXG4gICAgICogaGFzIGJlZW4gY2FsbGVkIHdpdGggYW4gaW52YWxpZCBzdGF0ZSByZWZlcmVuY2UgcGFyYW1ldGVyXHJcbiAgICAgKlxyXG4gICAgICogRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiBzdGF0ZVNlcnZpY2Uub25JbnZhbGlkKGZ1bmN0aW9uKHRvLCBmcm9tLCBpbmplY3Rvcikge1xyXG4gICAgICogICBpZiAodG8ubmFtZSgpID09PSAnZm9vJykge1xyXG4gICAgICogICAgIGxldCBsYXp5TG9hZGVyID0gaW5qZWN0b3IuZ2V0KCdMYXp5TG9hZFNlcnZpY2UnKTtcclxuICAgICAqICAgICByZXR1cm4gbGF6eUxvYWRlci5sb2FkKCdmb28nKVxyXG4gICAgICogICAgICAgICAudGhlbigoKSA9PiBzdGF0ZVNlcnZpY2UudGFyZ2V0KCdmb28nKSk7XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgaW52b2tlZCB3aGVuIHRoZSB0b1N0YXRlIGlzIGludmFsaWRcclxuICAgICAqICAgVGhpcyBmdW5jdGlvbiByZWNlaXZlcyB0aGUgKGludmFsaWQpIHRvU3RhdGUsIHRoZSBmcm9tU3RhdGUsIGFuZCBhbiBpbmplY3Rvci5cclxuICAgICAqICAgVGhlIGZ1bmN0aW9uIG1heSBvcHRpb25hbGx5IHJldHVybiBhIFtbVGFyZ2V0U3RhdGVdXSBvciBhIFByb21pc2UgZm9yIGEgVGFyZ2V0U3RhdGUuXHJcbiAgICAgKiAgIElmIG9uZSBpcyByZXR1cm5lZCwgaXQgaXMgdHJlYXRlZCBhcyBhIHJlZGlyZWN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUub25JbnZhbGlkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5pbnZhbGlkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBkZXJlZ2lzdGVyTGlzdGVuZXIoKSB7XHJcbiAgICAgICAgICAgIGNvbW1vbl8xLnJlbW92ZUZyb20odGhpcy5pbnZhbGlkQ2FsbGJhY2tzKShjYWxsYmFjayk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVsb2FkcyB0aGUgY3VycmVudCBzdGF0ZVxyXG4gICAgICpcclxuICAgICAqIEEgbWV0aG9kIHRoYXQgZm9yY2UgcmVsb2FkcyB0aGUgY3VycmVudCBzdGF0ZSwgb3IgYSBwYXJ0aWFsIHN0YXRlIGhpZXJhcmNoeS5cclxuICAgICAqIEFsbCByZXNvbHZlcyBhcmUgcmUtcmVzb2x2ZWQsIGFuZCBjb21wb25lbnRzIHJlaW5zdGFudGlhdGVkLlxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiBsZXQgYXBwIGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcclxuICAgICAqXHJcbiAgICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xyXG4gICAgICogICAkc2NvcGUucmVsb2FkID0gZnVuY3Rpb24oKXtcclxuICAgICAqICAgICAkc3RhdGUucmVsb2FkKCk7XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogYHJlbG9hZCgpYCBpcyBqdXN0IGFuIGFsaWFzIGZvcjpcclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogJHN0YXRlLnRyYW5zaXRpb25Ubygkc3RhdGUuY3VycmVudCwgJHN0YXRlLnBhcmFtcywge1xyXG4gICAgICogICByZWxvYWQ6IHRydWUsIGluaGVyaXQ6IGZhbHNlXHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxvYWRTdGF0ZSBBIHN0YXRlIG5hbWUgb3IgYSBzdGF0ZSBvYmplY3QuXHJcbiAgICAgKiAgICBJZiBwcmVzZW50LCB0aGlzIHN0YXRlIGFuZCBhbGwgaXRzIGNoaWxkcmVuIHdpbGwgYmUgcmVsb2FkZWQsIGJ1dCBhbmNlc3RvcnMgd2lsbCBub3QgcmVsb2FkLlxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAvL2Fzc3VtaW5nIGFwcCBhcHBsaWNhdGlvbiBjb25zaXN0cyBvZiAzIHN0YXRlczogJ2NvbnRhY3RzJywgJ2NvbnRhY3RzLmRldGFpbCcsICdjb250YWN0cy5kZXRhaWwuaXRlbSdcclxuICAgICAqIC8vYW5kIGN1cnJlbnQgc3RhdGUgaXMgJ2NvbnRhY3RzLmRldGFpbC5pdGVtJ1xyXG4gICAgICogbGV0IGFwcCBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XHJcbiAgICAgKlxyXG4gICAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcclxuICAgICAqICAgJHNjb3BlLnJlbG9hZCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgKiAgICAgLy93aWxsIHJlbG9hZCAnY29udGFjdC5kZXRhaWwnIGFuZCBuZXN0ZWQgJ2NvbnRhY3QuZGV0YWlsLml0ZW0nIHN0YXRlc1xyXG4gICAgICogICAgICRzdGF0ZS5yZWxvYWQoJ2NvbnRhY3QuZGV0YWlsJyk7XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIG5ldyB0cmFuc2l0aW9uLiBTZWUgW1tTdGF0ZVNlcnZpY2UuZ29dXVxyXG4gICAgICovXHJcbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLnJlbG9hZCA9IGZ1bmN0aW9uIChyZWxvYWRTdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0aGlzLmN1cnJlbnQsIHRoaXMucGFyYW1zLCB7XHJcbiAgICAgICAgICAgIHJlbG9hZDogcHJlZGljYXRlc18xLmlzRGVmaW5lZChyZWxvYWRTdGF0ZSkgPyByZWxvYWRTdGF0ZSA6IHRydWUsXHJcbiAgICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBub3RpZnk6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNpdGlvbiB0byBhIGRpZmZlcmVudCBzdGF0ZSBhbmQvb3IgcGFyYW1ldGVyc1xyXG4gICAgICpcclxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgdHJhbnNpdGlvbmluZyB0byBhIG5ldyBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBgJHN0YXRlLmdvYCBjYWxscyBgJHN0YXRlLnRyYW5zaXRpb25Ub2AgaW50ZXJuYWxseSBidXQgYXV0b21hdGljYWxseSBzZXRzIG9wdGlvbnMgdG9cclxuICAgICAqIGB7IGxvY2F0aW9uOiB0cnVlLCBpbmhlcml0OiB0cnVlLCByZWxhdGl2ZTogcm91dGVyLmdsb2JhbHMuJGN1cnJlbnQsIG5vdGlmeTogdHJ1ZSB9YC5cclxuICAgICAqIFRoaXMgYWxsb3dzIHlvdSB0byB1c2UgZWl0aGVyIGFuIGFic29sdXRlIG9yIHJlbGF0aXZlIGB0b2AgYXJndW1lbnQgKGJlY2F1c2Ugb2YgYHJlbGF0aXZlOiByb3V0ZXIuZ2xvYmFscy4kY3VycmVudGApLlxyXG4gICAgICogSXQgYWxzbyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgKiBvbmx5IHRoZSBwYXJhbWV0ZXJzIHlvdSdkIGxpa2UgdG8gdXBkYXRlLCB3aGlsZSBsZXR0aW5nIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnNcclxuICAgICAqIGluaGVyaXQgZnJvbSB0aGUgY3VycmVudCBwYXJhbWV0ZXIgdmFsdWVzIChiZWNhdXNlIG9mIGBpbmhlcml0OiB0cnVlYCkuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIyBFeGFtcGxlOlxyXG4gICAgICogYGBganNcclxuICAgICAqIGxldCBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XHJcbiAgICAgKlxyXG4gICAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcclxuICAgICAqICAgJHNjb3BlLmNoYW5nZVN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICogICAgICRzdGF0ZS5nbygnY29udGFjdC5kZXRhaWwnKTtcclxuICAgICAqICAgfTtcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRvIEFic29sdXRlIHN0YXRlIG5hbWUsIHN0YXRlIG9iamVjdCwgb3IgcmVsYXRpdmUgc3RhdGUgcGF0aCAocmVsYXRpdmUgdG8gY3VycmVudCBzdGF0ZSkuXHJcbiAgICAgKlxyXG4gICAgICogU29tZSBleGFtcGxlczpcclxuICAgICAqXHJcbiAgICAgKiAtIGAkc3RhdGUuZ28oJ2NvbnRhY3QuZGV0YWlsJylgIC0gd2lsbCBnbyB0byB0aGUgYGNvbnRhY3QuZGV0YWlsYCBzdGF0ZVxyXG4gICAgICogLSBgJHN0YXRlLmdvKCdeJylgIC0gd2lsbCBnbyB0byB0aGUgcGFyZW50IHN0YXRlXHJcbiAgICAgKiAtIGAkc3RhdGUuZ28oJ14uc2libGluZycpYCAtIGlmIGN1cnJlbnQgc3RhdGUgaXMgYGhvbWUuY2hpbGRgLCB3aWxsIGdvIHRvIHRoZSBgaG9tZS5zaWJsaW5nYCBzdGF0ZVxyXG4gICAgICogLSBgJHN0YXRlLmdvKCcuY2hpbGQuZ3JhbmRjaGlsZCcpYCAtIGlmIGN1cnJlbnQgc3RhdGUgaXMgaG9tZSwgd2lsbCBnbyB0byB0aGUgYGhvbWUuY2hpbGQuZ3JhbmRjaGlsZGAgc3RhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIEEgbWFwIG9mIHRoZSBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSBzZW50IHRvIHRoZSBzdGF0ZSwgd2lsbCBwb3B1bGF0ZSAkc3RhdGVQYXJhbXMuXHJcbiAgICAgKlxyXG4gICAgICogICAgQW55IHBhcmFtZXRlcnMgdGhhdCBhcmUgbm90IHNwZWNpZmllZCB3aWxsIGJlIGluaGVyaXRlZCBmcm9tIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlcyAoYmVjYXVzZSBvZiBgaW5oZXJpdDogdHJ1ZWApLlxyXG4gICAgICogICAgVGhpcyBhbGxvd3MsIGZvciBleGFtcGxlLCBnb2luZyB0byBhIHNpYmxpbmcgc3RhdGUgdGhhdCBzaGFyZXMgcGFyYW1ldGVycyBkZWZpbmVkIGJ5IGEgcGFyZW50IHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRyYW5zaXRpb24gb3B0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtwcm9taXNlfSBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAodG8sIHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBkZWZhdXRHb09wdHMgPSB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50LCBpbmhlcml0OiB0cnVlIH07XHJcbiAgICAgICAgdmFyIHRyYW5zT3B0cyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIGRlZmF1dEdvT3B0cywgdHJhbnNpdGlvblNlcnZpY2VfMS5kZWZhdWx0VHJhbnNPcHRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8odG8sIHBhcmFtcywgdHJhbnNPcHRzKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBbW1RhcmdldFN0YXRlXV1cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIGEgZmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgVGFyZ2V0U3RhdGVcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1heSBiZSByZXR1cm5lZCBmcm9tIGEgVHJhbnNpdGlvbiBIb29rIHRvIHJlZGlyZWN0IGEgdHJhbnNpdGlvbiwgZm9yIGV4YW1wbGUuXHJcbiAgICAgKi9cclxuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUudGFyZ2V0ID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgLy8gSWYgd2UncmUgcmVsb2FkaW5nLCBmaW5kIHRoZSBzdGF0ZSBvYmplY3QgdG8gcmVsb2FkIGZyb21cclxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzT2JqZWN0KG9wdGlvbnMucmVsb2FkKSAmJiAhb3B0aW9ucy5yZWxvYWQubmFtZSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlbG9hZCBzdGF0ZSBvYmplY3QnKTtcclxuICAgICAgICB2YXIgcmVnID0gdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeTtcclxuICAgICAgICBvcHRpb25zLnJlbG9hZFN0YXRlID0gb3B0aW9ucy5yZWxvYWQgPT09IHRydWUgPyByZWcucm9vdCgpIDogcmVnLm1hdGNoZXIuZmluZChvcHRpb25zLnJlbG9hZCwgb3B0aW9ucy5yZWxhdGl2ZSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmVsb2FkICYmICFvcHRpb25zLnJlbG9hZFN0YXRlKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIHJlbG9hZCBzdGF0ZSAnXCIgKyAocHJlZGljYXRlc18xLmlzU3RyaW5nKG9wdGlvbnMucmVsb2FkKSA/IG9wdGlvbnMucmVsb2FkIDogb3B0aW9ucy5yZWxvYWQubmFtZSkgKyBcIidcIik7XHJcbiAgICAgICAgdmFyIHN0YXRlRGVmaW5pdGlvbiA9IHJlZy5tYXRjaGVyLmZpbmQoaWRlbnRpZmllciwgb3B0aW9ucy5yZWxhdGl2ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKGlkZW50aWZpZXIsIHN0YXRlRGVmaW5pdGlvbiwgcGFyYW1zLCBvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmdldEN1cnJlbnRQYXRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGdsb2JhbHMgPSB0aGlzLnJvdXRlci5nbG9iYWxzO1xyXG4gICAgICAgIHZhciBsYXRlc3RTdWNjZXNzID0gZ2xvYmFscy5zdWNjZXNzZnVsVHJhbnNpdGlvbnMucGVla1RhaWwoKTtcclxuICAgICAgICB2YXIgcm9vdFBhdGggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbbmV3IHBhdGhOb2RlXzEuUGF0aE5vZGUoX3RoaXMucm91dGVyLnN0YXRlUmVnaXN0cnkucm9vdCgpKV07IH07XHJcbiAgICAgICAgcmV0dXJuIGxhdGVzdFN1Y2Nlc3MgPyBsYXRlc3RTdWNjZXNzLnRyZWVDaGFuZ2VzKCkudG8gOiByb290UGF0aCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTG93LWxldmVsIG1ldGhvZCBmb3IgdHJhbnNpdGlvbmluZyB0byBhIG5ldyBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgW1tnb11dIG1ldGhvZCAod2hpY2ggdXNlcyBgdHJhbnNpdGlvblRvYCBpbnRlcm5hbGx5KSBpcyByZWNvbW1lbmRlZCBpbiBtb3N0IHNpdHVhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIyBFeGFtcGxlOlxyXG4gICAgICogYGBganNcclxuICAgICAqIGxldCBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XHJcbiAgICAgKlxyXG4gICAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcclxuICAgICAqICAgJHNjb3BlLmNoYW5nZVN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICogICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oJ2NvbnRhY3QuZGV0YWlsJyk7XHJcbiAgICAgKiAgIH07XHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0byBTdGF0ZSBuYW1lIG9yIHN0YXRlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB0b1BhcmFtcyBBIG1hcCBvZiB0aGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgc3RhdGUsXHJcbiAgICAgKiAgICAgIHdpbGwgcG9wdWxhdGUgJHN0YXRlUGFyYW1zLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVHJhbnNpdGlvbiBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIG5ldyB0cmFuc2l0aW9uLiBTZWUgW1tnb11dXHJcbiAgICAgKi9cclxuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gKHRvLCB0b1BhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRvUGFyYW1zID09PSB2b2lkIDApIHsgdG9QYXJhbXMgPSB7fTsgfVxyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMucm91dGVyO1xyXG4gICAgICAgIHZhciBnbG9iYWxzID0gcm91dGVyLmdsb2JhbHM7XHJcbiAgICAgICAgb3B0aW9ucyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIHRyYW5zaXRpb25TZXJ2aWNlXzEuZGVmYXVsdFRyYW5zT3B0cyk7XHJcbiAgICAgICAgdmFyIGdldEN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxzLnRyYW5zaXRpb247XHJcbiAgICAgICAgfTtcclxuICAgICAgICBvcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKG9wdGlvbnMsIHsgY3VycmVudDogZ2V0Q3VycmVudCB9KTtcclxuICAgICAgICB2YXIgcmVmID0gdGhpcy50YXJnZXQodG8sIHRvUGFyYW1zLCBvcHRpb25zKTtcclxuICAgICAgICB2YXIgY3VycmVudFBhdGggPSB0aGlzLmdldEN1cnJlbnRQYXRoKCk7XHJcbiAgICAgICAgaWYgKCFyZWYuZXhpc3RzKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVJbnZhbGlkVGFyZ2V0U3RhdGUoY3VycmVudFBhdGgsIHJlZik7XHJcbiAgICAgICAgaWYgKCFyZWYudmFsaWQoKSlcclxuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnNpbGVudFJlamVjdGlvbihyZWYuZXJyb3IoKSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3BlY2lhbCBoYW5kbGluZyBmb3IgSWdub3JlZCwgQWJvcnRlZCwgYW5kIFJlZGlyZWN0ZWQgdHJhbnNpdGlvbnNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZSBzZW1hbnRpY3MgZm9yIHRoZSB0cmFuc2l0aW9uLnJ1bigpIHByb21pc2UgYW5kIHRoZSBTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvKClcclxuICAgICAgICAgKiBwcm9taXNlIGRpZmZlci4gRm9yIGluc3RhbmNlLCB0aGUgcnVuKCkgcHJvbWlzZSBtYXkgYmUgcmVqZWN0ZWQgYmVjYXVzZSBpdCB3YXNcclxuICAgICAgICAgKiBJR05PUkVELCBidXQgdGhlIHRyYW5zaXRpb25UbygpIHByb21pc2UgaXMgcmVzb2x2ZWQgYmVjYXVzZSBmcm9tIHRoZSB1c2VyIHBlcnNwZWN0aXZlXHJcbiAgICAgICAgICogbm8gZXJyb3Igb2NjdXJyZWQuICBMaWtld2lzZSwgdGhlIHRyYW5zaXRpb24ucnVuKCkgcHJvbWlzZSBtYXkgYmUgcmVqZWN0ZWQgYmVjYXVzZSBvZlxyXG4gICAgICAgICAqIGEgUmVkaXJlY3QsIGJ1dCB0aGUgdHJhbnNpdGlvblRvKCkgcHJvbWlzZSBpcyBjaGFpbmVkIHRvIHRoZSBuZXcgVHJhbnNpdGlvbidzIHByb21pc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIHJlamVjdGVkVHJhbnNpdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikgeyByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc0xhdGVzdCA9IHJvdXRlci5nbG9iYWxzLmxhc3RTdGFydGVkVHJhbnNpdGlvbklkID09PSB0cmFuc2l0aW9uLiRpZDtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5JR05PUkVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNMYXRlc3QgJiYgcm91dGVyLnVybFJvdXRlci51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBpZ25vcmVkIGBUcmFuc2l0aW9uLnJ1bigpYCBhcyBhIHN1Y2Nlc3NmdWwgYHRyYW5zaXRpb25Ub2BcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbihnbG9iYWxzLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGRldGFpbCA9IGVycm9yLmRldGFpbDtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5TVVBFUlNFREVEICYmIGVycm9yLnJlZGlyZWN0ZWQgJiYgZGV0YWlsIGluc3RhbmNlb2YgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGBUcmFuc2l0aW9uLnJ1bigpYCB3YXMgcmVkaXJlY3RlZCwgYWxsb3cgdGhlIGB0cmFuc2l0aW9uVG8oKWAgcHJvbWlzZSB0byByZXNvbHZlIHN1Y2Nlc3NmdWxseVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ5IHJldHVybmluZyB0aGUgcHJvbWlzZSBmb3IgdGhlIG5ldyAocmVkaXJlY3QpIGBUcmFuc2l0aW9uLnJ1bigpYC5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVkaXJlY3QgPSB0cmFuc2l0aW9uLnJlZGlyZWN0KGRldGFpbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZGlyZWN0LnJ1bigpLmNhdGNoKHJlamVjdGVkVHJhbnNpdGlvbkhhbmRsZXIocmVkaXJlY3QpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5BQk9SVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNMYXRlc3QgJiYgcm91dGVyLnVybFJvdXRlci51cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gX3RoaXMuZGVmYXVsdEVycm9ySGFuZGxlcigpO1xyXG4gICAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEucmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9OyB9O1xyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy5yb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UuY3JlYXRlKGN1cnJlbnRQYXRoLCByZWYpO1xyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uVG9Qcm9taXNlID0gdHJhbnNpdGlvbi5ydW4oKS5jYXRjaChyZWplY3RlZFRyYW5zaXRpb25IYW5kbGVyKHRyYW5zaXRpb24pKTtcclxuICAgICAgICBjb21tb25fMS5zaWxlbmNlVW5jYXVnaHRJblByb21pc2UodHJhbnNpdGlvblRvUHJvbWlzZSk7IC8vIGlzc3VlICMyNjc2XHJcbiAgICAgICAgLy8gUmV0dXJuIGEgcHJvbWlzZSBmb3IgdGhlIHRyYW5zaXRpb24sIHdoaWNoIGFsc28gaGFzIHRoZSB0cmFuc2l0aW9uIG9iamVjdCBvbiBpdC5cclxuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHRyYW5zaXRpb25Ub1Byb21pc2UsIHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiB9KTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzdGF0ZSAqaXMqIHRoZSBwcm92aWRlZCBzdGF0ZVxyXG4gICAgICpcclxuICAgICAqIFNpbWlsYXIgdG8gW1tpbmNsdWRlc11dIGJ1dCBvbmx5IGNoZWNrcyBmb3IgdGhlIGZ1bGwgc3RhdGUgbmFtZS5cclxuICAgICAqIElmIHBhcmFtcyBpcyBzdXBwbGllZCB0aGVuIGl0IHdpbGwgYmUgdGVzdGVkIGZvciBzdHJpY3QgZXF1YWxpdHkgYWdhaW5zdCB0aGUgY3VycmVudFxyXG4gICAgICogYWN0aXZlIHBhcmFtcyBvYmplY3QsIHNvIGFsbCBwYXJhbXMgbXVzdCBtYXRjaCB3aXRoIG5vbmUgbWlzc2luZyBhbmQgbm8gZXh0cmFzLlxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAkc3RhdGUuJGN1cnJlbnQubmFtZSA9ICdjb250YWN0cy5kZXRhaWxzLml0ZW0nO1xyXG4gICAgICpcclxuICAgICAqIC8vIGFic29sdXRlIG5hbWVcclxuICAgICAqICRzdGF0ZS5pcygnY29udGFjdC5kZXRhaWxzLml0ZW0nKTsgLy8gcmV0dXJucyB0cnVlXHJcbiAgICAgKiAkc3RhdGUuaXMoY29udGFjdERldGFpbEl0ZW1TdGF0ZU9iamVjdCk7IC8vIHJldHVybnMgdHJ1ZVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogLy8gcmVsYXRpdmUgbmFtZSAoLiBhbmQgXiksIHR5cGljYWxseSBmcm9tIGEgdGVtcGxhdGVcclxuICAgICAqIC8vIEUuZy4gZnJvbSB0aGUgJ2NvbnRhY3RzLmRldGFpbHMnIHRlbXBsYXRlXHJcbiAgICAgKiBgYGBodG1sXHJcbiAgICAgKiA8ZGl2IG5nLWNsYXNzPVwie2hpZ2hsaWdodGVkOiAkc3RhdGUuaXMoJy5pdGVtJyl9XCI+SXRlbTwvZGl2PlxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlT3JOYW1lIFRoZSBzdGF0ZSBuYW1lIChhYnNvbHV0ZSBvciByZWxhdGl2ZSkgb3Igc3RhdGUgb2JqZWN0IHlvdSdkIGxpa2UgdG8gY2hlY2suXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIEEgcGFyYW0gb2JqZWN0LCBlLmcuIGB7c2VjdGlvbklkOiBzZWN0aW9uLmlkfWAsIHRoYXQgeW91J2QgbGlrZVxyXG4gICAgICogdG8gdGVzdCBhZ2FpbnN0IHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XHJcbiAgICAgKiAgIC0gYHJlbGF0aXZlYDogSWYgYHN0YXRlT3JOYW1lYCBpcyBhIHJlbGF0aXZlIHN0YXRlIG5hbWUgYW5kIGBvcHRpb25zLnJlbGF0aXZlYCBpcyBzZXQsIC5pcyB3aWxsXHJcbiAgICAgKiAgICAgdGVzdCByZWxhdGl2ZSB0byBgb3B0aW9ucy5yZWxhdGl2ZWAgc3RhdGUgKG9yIG5hbWUpLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiBpdCBpcyB0aGUgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50IH0pO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKHN0YXRlT3JOYW1lLCBvcHRpb25zLnJlbGF0aXZlKTtcclxuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoc3RhdGUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICh0aGlzLiRjdXJyZW50ICE9PSBzdGF0ZSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICghcGFyYW1zKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUucGFyYW1ldGVycyh7IGluaGVyaXQ6IHRydWUsIG1hdGNoaW5nS2V5czogcGFyYW1zIH0pO1xyXG4gICAgICAgIHJldHVybiBwYXJhbV8xLlBhcmFtLmVxdWFscyhzY2hlbWEsIHBhcmFtXzEuUGFyYW0udmFsdWVzKHNjaGVtYSwgcGFyYW1zKSwgdGhpcy5wYXJhbXMpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHN0YXRlICppbmNsdWRlcyogdGhlIHByb3ZpZGVkIHN0YXRlXHJcbiAgICAgKlxyXG4gICAgICogQSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZSBpcyBlcXVhbCB0byBvciBpcyB0aGUgY2hpbGQgb2YgdGhlXHJcbiAgICAgKiBzdGF0ZSBzdGF0ZU5hbWUuIElmIGFueSBwYXJhbXMgYXJlIHBhc3NlZCB0aGVuIHRoZXkgd2lsbCBiZSB0ZXN0ZWQgZm9yIGEgbWF0Y2ggYXMgd2VsbC5cclxuICAgICAqIE5vdCBhbGwgdGhlIHBhcmFtZXRlcnMgbmVlZCB0byBiZSBwYXNzZWQsIGp1c3QgdGhlIG9uZXMgeW91J2QgbGlrZSB0byB0ZXN0IGZvciBlcXVhbGl0eS5cclxuICAgICAqXHJcbiAgICAgKiAjIyMjIEV4YW1wbGUgd2hlbiBgJHN0YXRlLiRjdXJyZW50Lm5hbWUgPT09ICdjb250YWN0cy5kZXRhaWxzLml0ZW0nYFxyXG4gICAgICogYGBganNcclxuICAgICAqIC8vIFVzaW5nIHBhcnRpYWwgbmFtZXNcclxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzXCIpOyAvLyByZXR1cm5zIHRydWVcclxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzLmRldGFpbHNcIik7IC8vIHJldHVybnMgdHJ1ZVxyXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMuZGV0YWlscy5pdGVtXCIpOyAvLyByZXR1cm5zIHRydWVcclxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzLmxpc3RcIik7IC8vIHJldHVybnMgZmFsc2VcclxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImFib3V0XCIpOyAvLyByZXR1cm5zIGZhbHNlXHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiAjIyMjIEdsb2IgRXhhbXBsZXMgd2hlbiBgKiAkc3RhdGUuJGN1cnJlbnQubmFtZSA9PT0gJ2NvbnRhY3RzLmRldGFpbHMuaXRlbS51cmwnYDpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKi4qXCIpOyAvLyByZXR1cm5zIHRydWVcclxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy4qKlwiKTsgLy8gcmV0dXJucyB0cnVlXHJcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqKi5pdGVtLioqXCIpOyAvLyByZXR1cm5zIHRydWVcclxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy5pdGVtLnVybFwiKTsgLy8gcmV0dXJucyB0cnVlXHJcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKi51cmxcIik7IC8vIHJldHVybnMgdHJ1ZVxyXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLipcIik7IC8vIHJldHVybnMgZmFsc2VcclxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIml0ZW0uKipcIik7IC8vIHJldHVybnMgZmFsc2VcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSBBIHBhcnRpYWwgbmFtZSwgcmVsYXRpdmUgbmFtZSwgZ2xvYiBwYXR0ZXJuLFxyXG4gICAgICogICBvciBzdGF0ZSBvYmplY3QgdG8gYmUgc2VhcmNoZWQgZm9yIHdpdGhpbiB0aGUgY3VycmVudCBzdGF0ZSBuYW1lLlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBBIHBhcmFtIG9iamVjdCwgZS5nLiBge3NlY3Rpb25JZDogc2VjdGlvbi5pZH1gLFxyXG4gICAgICogICB0aGF0IHlvdSdkIGxpa2UgdG8gdGVzdCBhZ2FpbnN0IHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XHJcbiAgICAgKiAgIC0gYHJlbGF0aXZlYDogSWYgYHN0YXRlT3JOYW1lYCBpcyBhIHJlbGF0aXZlIHN0YXRlIG5hbWUgYW5kIGBvcHRpb25zLnJlbGF0aXZlYCBpcyBzZXQsIC5pcyB3aWxsXHJcbiAgICAgKiAgICAgdGVzdCByZWxhdGl2ZSB0byBgb3B0aW9ucy5yZWxhdGl2ZWAgc3RhdGUgKG9yIG5hbWUpLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgaXQgZG9lcyBpbmNsdWRlIHRoZSBzdGF0ZVxyXG4gICAgICovXHJcbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gY29tbW9uXzEuZGVmYXVsdHMob3B0aW9ucywgeyByZWxhdGl2ZTogdGhpcy4kY3VycmVudCB9KTtcclxuICAgICAgICB2YXIgZ2xvYiA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzdGF0ZU9yTmFtZSkgJiYgZ2xvYl8xLkdsb2IuZnJvbVN0cmluZyhzdGF0ZU9yTmFtZSk7XHJcbiAgICAgICAgaWYgKGdsb2IpIHtcclxuICAgICAgICAgICAgaWYgKCFnbG9iLm1hdGNoZXModGhpcy4kY3VycmVudC5uYW1lKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgc3RhdGVPck5hbWUgPSB0aGlzLiRjdXJyZW50Lm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKHN0YXRlT3JOYW1lLCBvcHRpb25zLnJlbGF0aXZlKSwgaW5jbHVkZSA9IHRoaXMuJGN1cnJlbnQuaW5jbHVkZXM7XHJcbiAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHN0YXRlKSlcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoaW5jbHVkZVtzdGF0ZS5uYW1lXSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoIXBhcmFtcylcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgdmFyIHNjaGVtYSA9IHN0YXRlLnBhcmFtZXRlcnMoeyBpbmhlcml0OiB0cnVlLCBtYXRjaGluZ0tleXM6IHBhcmFtcyB9KTtcclxuICAgICAgICByZXR1cm4gcGFyYW1fMS5QYXJhbS5lcXVhbHMoc2NoZW1hLCBwYXJhbV8xLlBhcmFtLnZhbHVlcyhzY2hlbWEsIHBhcmFtcyksIHRoaXMucGFyYW1zKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIFVSTCBmb3IgYSBzdGF0ZSBhbmQgcGFyYW1ldGVyc1xyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgdGhlIHVybCBmb3IgdGhlIGdpdmVuIHN0YXRlIHBvcHVsYXRlZCB3aXRoIHRoZSBnaXZlbiBwYXJhbXMuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIyBFeGFtcGxlOlxyXG4gICAgICogYGBganNcclxuICAgICAqIGV4cGVjdCgkc3RhdGUuaHJlZihcImFib3V0LnBlcnNvblwiLCB7IHBlcnNvbjogXCJib2JcIiB9KSkudG9FcXVhbChcIi9hYm91dC9ib2JcIik7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgVGhlIHN0YXRlIG5hbWUgb3Igc3RhdGUgb2JqZWN0IHlvdSdkIGxpa2UgdG8gZ2VuZXJhdGUgYSB1cmwgZnJvbS5cclxuICAgICAqIEBwYXJhbSBwYXJhbXMgQW4gb2JqZWN0IG9mIHBhcmFtZXRlciB2YWx1ZXMgdG8gZmlsbCB0aGUgc3RhdGUncyByZXF1aXJlZCBwYXJhbWV0ZXJzLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjb21waWxlZCBzdGF0ZSB1cmxcclxuICAgICAqL1xyXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5ocmVmID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZGVmYXVsdEhyZWZPcHRzID0ge1xyXG4gICAgICAgICAgICBsb3NzeTogdHJ1ZSxcclxuICAgICAgICAgICAgaW5oZXJpdDogdHJ1ZSxcclxuICAgICAgICAgICAgYWJzb2x1dGU6IGZhbHNlLFxyXG4gICAgICAgICAgICByZWxhdGl2ZTogdGhpcy4kY3VycmVudCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCBkZWZhdWx0SHJlZk9wdHMpO1xyXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcclxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSk7XHJcbiAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHN0YXRlKSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5oZXJpdClcclxuICAgICAgICAgICAgcGFyYW1zID0gdGhpcy5wYXJhbXMuJGluaGVyaXQocGFyYW1zLCB0aGlzLiRjdXJyZW50LCBzdGF0ZSk7XHJcbiAgICAgICAgdmFyIG5hdiA9IChzdGF0ZSAmJiBvcHRpb25zLmxvc3N5KSA/IHN0YXRlLm5hdmlnYWJsZSA6IHN0YXRlO1xyXG4gICAgICAgIGlmICghbmF2IHx8IG5hdi51cmwgPT09IHVuZGVmaW5lZCB8fCBuYXYudXJsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIudXJsUm91dGVyLmhyZWYobmF2LnVybCwgcGFyYW1zLCB7XHJcbiAgICAgICAgICAgIGFic29sdXRlOiBvcHRpb25zLmFic29sdXRlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBkZWZhdWx0IFtbdHJhbnNpdGlvblRvXV0gZXJyb3IgaGFuZGxlci5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZXJyb3IgaGFuZGxlciBpcyBjYWxsZWQgd2hlbiBhIFtbVHJhbnNpdGlvbl1dIGlzIHJlamVjdGVkIG9yIHdoZW4gYW55IGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgVHJhbnNpdGlvbi5cclxuICAgICAqIFRoaXMgaW5jbHVkZXMgZXJyb3JzIGNhdXNlZCBieSByZXNvbHZlcyBhbmQgdHJhbnNpdGlvbiBob29rcy5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOlxyXG4gICAgICogVGhpcyBoYW5kbGVyIGRvZXMgbm90IHJlY2VpdmUgY2VydGFpbiBUcmFuc2l0aW9uIHJlamVjdGlvbnMuXHJcbiAgICAgKiBSZWRpcmVjdGVkIGFuZCBJZ25vcmVkIFRyYW5zaXRpb25zIGFyZSBub3QgY29uc2lkZXJlZCB0byBiZSBlcnJvcnMgYnkgW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvXV0uXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGJ1aWx0LWluIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBsb2dzIHRoZSBlcnJvciB0byB0aGUgY29uc29sZS5cclxuICAgICAqXHJcbiAgICAgKiBZb3UgY2FuIHByb3ZpZGUgeW91ciBvd24gY3VzdG9tIGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogIyMjIyBFeGFtcGxlOlxyXG4gICAgICogYGBganNcclxuICAgICAqIHN0YXRlU2VydmljZS5kZWZhdWx0RXJyb3JIYW5kbGVyKGZ1bmN0aW9uKCkge1xyXG4gICAgICogICAvLyBEbyBub3QgbG9nIHRyYW5zaXRpb25UbyBlcnJvcnNcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGhhbmRsZXIgYSBnbG9iYWwgZXJyb3IgaGFuZGxlciBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgZ2xvYmFsIGVycm9yIGhhbmRsZXJcclxuICAgICAqL1xyXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5kZWZhdWx0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEVycm9ySGFuZGxlciA9IGhhbmRsZXIgfHwgdGhpcy5fZGVmYXVsdEVycm9ySGFuZGxlcjtcclxuICAgIH07XHJcbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgYmFzZSkge1xyXG4gICAgICAgIHZhciByZWcgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5O1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gcmVnLmdldCgpO1xyXG4gICAgICAgIHJldHVybiByZWcuZ2V0KHN0YXRlT3JOYW1lLCBiYXNlIHx8IHRoaXMuJGN1cnJlbnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTGF6eSBsb2FkcyBhIHN0YXRlXHJcbiAgICAgKlxyXG4gICAgICogRXhwbGljaXRseSBydW5zIGEgc3RhdGUncyBbW1N0YXRlRGVjbGFyYXRpb24ubGF6eUxvYWRdXSBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgdGhlIHN0YXRlIHRoYXQgc2hvdWxkIGJlIGxhenkgbG9hZGVkXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNpdGlvbiB0aGUgb3B0aW9uYWwgVHJhbnNpdGlvbiBjb250ZXh0IHRvIHVzZSAoaWYgdGhlIGxhenlMb2FkIGZ1bmN0aW9uIHJlcXVpcmVzIGFuIGluamVjdG9yLCBldGMpXHJcbiAgICAgKiBOb3RlOiBJZiBubyB0cmFuc2l0aW9uIGlzIHByb3ZpZGVkLCBhIG5vb3AgdHJhbnNpdGlvbiBpcyBjcmVhdGVkIHVzaW5nIHRoZSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gICAgICogVGhpcyBub29wIHRyYW5zaXRpb24gaXMgbm90IGFjdHVhbGx5IHJ1bi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdG8gbGF6eSBsb2FkXHJcbiAgICAgKi9cclxuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUubGF6eUxvYWQgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIHRyYW5zaXRpb24pIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldChzdGF0ZU9yTmFtZSk7XHJcbiAgICAgICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUubGF6eUxvYWQpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgbGF6eSBsb2FkIFwiICsgc3RhdGVPck5hbWUpO1xyXG4gICAgICAgIHZhciBjdXJyZW50UGF0aCA9IHRoaXMuZ2V0Q3VycmVudFBhdGgoKTtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gcGF0aEZhY3RvcnlfMS5QYXRoVXRpbHMubWFrZVRhcmdldFN0YXRlKGN1cnJlbnRQYXRoKTtcclxuICAgICAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbiB8fCB0aGlzLnJvdXRlci50cmFuc2l0aW9uU2VydmljZS5jcmVhdGUoY3VycmVudFBhdGgsIHRhcmdldCk7XHJcbiAgICAgICAgcmV0dXJuIGxhenlMb2FkXzEubGF6eUxvYWRTdGF0ZSh0cmFuc2l0aW9uLCBzdGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFN0YXRlU2VydmljZTtcclxufSgpKTtcclxuZXhwb3J0cy5TdGF0ZVNlcnZpY2UgPSBTdGF0ZVNlcnZpY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlU2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZVNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogQGNvcmVhcGlcclxuICogQG1vZHVsZSB0cmFuc2l0aW9uXHJcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcclxudmFyIGludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpO1xyXG52YXIgdHJhbnNpdGlvbkhvb2tfMSA9IHJlcXVpcmUoXCIuL3RyYW5zaXRpb25Ib29rXCIpO1xyXG4vKipcclxuICogVGhpcyBjbGFzcyByZXR1cm5zIGFwcGxpY2FibGUgVHJhbnNpdGlvbkhvb2tzIGZvciBhIHNwZWNpZmljIFRyYW5zaXRpb24gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEhvb2tzIChbW1JlZ2lzdGVyZWRIb29rXV0pIG1heSBiZSByZWdpc3RlcmVkIGdsb2JhbGx5LCBlLmcuLCAkdHJhbnNpdGlvbnMub25FbnRlciguLi4pLCBvciBsb2NhbGx5LCBlLmcuXHJcbiAqIG15VHJhbnNpdGlvbi5vbkVudGVyKC4uLikuICBUaGUgSG9va0J1aWxkZXIgZmluZHMgbWF0Y2hpbmcgUmVnaXN0ZXJlZEhvb2tzICh3aGVyZSB0aGUgbWF0Y2ggY3JpdGVyaWEgaXNcclxuICogZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBvZiBob29rKVxyXG4gKlxyXG4gKiBUaGUgSG9va0J1aWxkZXIgYWxzbyBjb252ZXJ0cyBSZWdpc3RlcmVkSG9va3Mgb2JqZWN0cyB0byBUcmFuc2l0aW9uSG9vayBvYmplY3RzLCB3aGljaCBhcmUgdXNlZCB0byBydW4gYSBUcmFuc2l0aW9uLlxyXG4gKlxyXG4gKiBUaGUgSG9va0J1aWxkZXIgY29uc3RydWN0b3IgaXMgZ2l2ZW4gdGhlICR0cmFuc2l0aW9ucyBzZXJ2aWNlIGFuZCBhIFRyYW5zaXRpb24gaW5zdGFuY2UuICBUaHVzLCBhIEhvb2tCdWlsZGVyXHJcbiAqIGluc3RhbmNlIG1heSBvbmx5IGJlIHVzZWQgZm9yIG9uZSBzcGVjaWZpYyBUcmFuc2l0aW9uIG9iamVjdC4gKHNpZGUgbm90ZTogdGhlIF90cmVlQ2hhbmdlcyBhY2Nlc3NvciBpcyBwcml2YXRlXHJcbiAqIGluIHRoZSBUcmFuc2l0aW9uIGNsYXNzLCBzbyB3ZSBtdXN0IGFsc28gcHJvdmlkZSB0aGUgVHJhbnNpdGlvbidzIF90cmVlQ2hhbmdlcylcclxuICpcclxuICovXHJcbnZhciBIb29rQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIb29rQnVpbGRlcih0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcclxuICAgIH1cclxuICAgIEhvb2tCdWlsZGVyLnByb3RvdHlwZS5idWlsZEhvb2tzRm9yUGhhc2UgPSBmdW5jdGlvbiAocGhhc2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciAkdHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb24ucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlO1xyXG4gICAgICAgIHJldHVybiAkdHJhbnNpdGlvbnMuX3BsdWdpbmFwaS5fZ2V0RXZlbnRzKHBoYXNlKVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5idWlsZEhvb2tzKHR5cGUpOyB9KVxyXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGNvbW1vbl8xLmlkZW50aXR5KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbmV3bHkgYnVpbHQgVHJhbnNpdGlvbkhvb2sgb2JqZWN0cy5cclxuICAgICAqXHJcbiAgICAgKiAtIEZpbmRzIGFsbCBSZWdpc3RlcmVkSG9va3MgcmVnaXN0ZXJlZCBmb3IgdGhlIGdpdmVuIGBob29rVHlwZWAgd2hpY2ggbWF0Y2hlZCB0aGUgdHJhbnNpdGlvbidzIFtbVHJlZUNoYW5nZXNdXS5cclxuICAgICAqIC0gRmluZHMgW1tQYXRoTm9kZV1dIChvciBgUGF0aE5vZGVbXWApIHRvIHVzZSBhcyB0aGUgVHJhbnNpdGlvbkhvb2sgY29udGV4dChzKVxyXG4gICAgICogLSBGb3IgZWFjaCBvZiB0aGUgW1tQYXRoTm9kZV1dcywgY3JlYXRlcyBhIFRyYW5zaXRpb25Ib29rXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGhvb2tUeXBlIHRoZSB0eXBlIG9mIHRoZSBob29rIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiwgZS5nLiwgJ29uRW50ZXInLCAnb25GaW5pc2gnLlxyXG4gICAgICovXHJcbiAgICBIb29rQnVpbGRlci5wcm90b3R5cGUuYnVpbGRIb29rcyA9IGZ1bmN0aW9uIChob29rVHlwZSkge1xyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uO1xyXG4gICAgICAgIHZhciB0cmVlQ2hhbmdlcyA9IHRyYW5zaXRpb24udHJlZUNoYW5nZXMoKTtcclxuICAgICAgICAvLyBGaW5kIGFsbCB0aGUgbWF0Y2hpbmcgcmVnaXN0ZXJlZCBob29rcyBmb3IgYSBnaXZlbiBob29rIHR5cGVcclxuICAgICAgICB2YXIgbWF0Y2hpbmdIb29rcyA9IHRoaXMuZ2V0TWF0Y2hpbmdIb29rcyhob29rVHlwZSwgdHJlZUNoYW5nZXMpO1xyXG4gICAgICAgIGlmICghbWF0Y2hpbmdIb29rcylcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIHZhciBiYXNlSG9va09wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXHJcbiAgICAgICAgICAgIGN1cnJlbnQ6IHRyYW5zaXRpb24ub3B0aW9ucygpLmN1cnJlbnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBtYWtlVHJhbnNpdGlvbkhvb2tzID0gZnVuY3Rpb24gKGhvb2spIHtcclxuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIE5vZGVzIHRoYXQgY2F1c2VkIHRoaXMgaG9vayB0byBtYXRjaC5cclxuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBob29rLm1hdGNoZXModHJlZUNoYW5nZXMpO1xyXG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIFBhdGhOb2RlW10gdGhhdCB3aWxsIGJlIHVzZWQgYXMgVHJhbnNpdGlvbkhvb2sgY29udGV4dCBvYmplY3RzXHJcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ05vZGVzID0gbWF0Y2hlc1tob29rVHlwZS5jcml0ZXJpYU1hdGNoUGF0aC5uYW1lXTtcclxuICAgICAgICAgICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIEhvb2tUdXBsZXNcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nTm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX29wdGlvbnMgPSBjb21tb25fMS5leHRlbmQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmQ6IGhvb2suYmluZCxcclxuICAgICAgICAgICAgICAgICAgICB0cmFjZURhdGE6IHsgaG9va1R5cGU6IGhvb2tUeXBlLm5hbWUsIGNvbnRleHQ6IG5vZGUgfVxyXG4gICAgICAgICAgICAgICAgfSwgYmFzZUhvb2tPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGhvb2tUeXBlLmNyaXRlcmlhTWF0Y2hQYXRoLnNjb3BlID09PSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1Njb3BlLlNUQVRFID8gbm9kZS5zdGF0ZS5zZWxmIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uSG9vayA9IG5ldyB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rKHRyYW5zaXRpb24sIHN0YXRlLCBob29rLCBfb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBob29rOiBob29rLCBub2RlOiBub2RlLCB0cmFuc2l0aW9uSG9vazogdHJhbnNpdGlvbkhvb2sgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbWF0Y2hpbmdIb29rcy5tYXAobWFrZVRyYW5zaXRpb25Ib29rcylcclxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcclxuICAgICAgICAgICAgLnNvcnQodHVwbGVTb3J0KGhvb2tUeXBlLnJldmVyc2VTb3J0KSlcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIHR1cGxlLnRyYW5zaXRpb25Ib29rOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIGFsbCBSZWdpc3RlcmVkSG9va3MgZnJvbTpcclxuICAgICAqIC0gVGhlIFRyYW5zaXRpb24gb2JqZWN0IGluc3RhbmNlIGhvb2sgcmVnaXN0cnlcclxuICAgICAqIC0gVGhlIFRyYW5zaXRpb25TZXJ2aWNlICgkdHJhbnNpdGlvbnMpIGdsb2JhbCBob29rIHJlZ2lzdHJ5XHJcbiAgICAgKlxyXG4gICAgICogd2hpY2ggbWF0Y2hlZDpcclxuICAgICAqIC0gdGhlIGV2ZW50VHlwZVxyXG4gICAgICogLSB0aGUgbWF0Y2hDcml0ZXJpYSAodG8sIGZyb20sIGV4aXRpbmcsIHJldGFpbmVkLCBlbnRlcmluZylcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVkIFtbUmVnaXN0ZXJlZEhvb2tdXXNcclxuICAgICAqL1xyXG4gICAgSG9va0J1aWxkZXIucHJvdG90eXBlLmdldE1hdGNoaW5nSG9va3MgPSBmdW5jdGlvbiAoaG9va1R5cGUsIHRyZWVDaGFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIGlzQ3JlYXRlID0gaG9va1R5cGUuaG9va1BoYXNlID09PSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlLkNSRUFURTtcclxuICAgICAgICAvLyBJbnN0YW5jZSBhbmQgR2xvYmFsIGhvb2sgcmVnaXN0cmllc1xyXG4gICAgICAgIHZhciAkdHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb24ucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlO1xyXG4gICAgICAgIHZhciByZWdpc3RyaWVzID0gaXNDcmVhdGUgPyBbJHRyYW5zaXRpb25zXSA6IFt0aGlzLnRyYW5zaXRpb24sICR0cmFuc2l0aW9uc107XHJcbiAgICAgICAgcmV0dXJuIHJlZ2lzdHJpZXMubWFwKGZ1bmN0aW9uIChyZWcpIHsgcmV0dXJuIHJlZy5nZXRIb29rcyhob29rVHlwZS5uYW1lKTsgfSkgLy8gR2V0IG5hbWVkIGhvb2tzIGZyb20gcmVnaXN0cmllc1xyXG4gICAgICAgICAgICAuZmlsdGVyKGNvbW1vbl8xLmFzc2VydFByZWRpY2F0ZShwcmVkaWNhdGVzXzEuaXNBcnJheSwgXCJicm9rZW4gZXZlbnQgbmFtZWQ6IFwiICsgaG9va1R5cGUubmFtZSkpIC8vIFNhbml0eSBjaGVja1xyXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKSAvLyBVbi1uZXN0IFJlZ2lzdGVyZWRIb29rW11bXSB0byBSZWdpc3RlcmVkSG9va1tdIGFycmF5XHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGhvb2subWF0Y2hlcyh0cmVlQ2hhbmdlcyk7IH0pOyAvLyBPbmx5IHRob3NlIHNhdGlzZnlpbmcgbWF0Y2hDcml0ZXJpYVxyXG4gICAgfTtcclxuICAgIHJldHVybiBIb29rQnVpbGRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Ib29rQnVpbGRlciA9IEhvb2tCdWlsZGVyO1xyXG4vKipcclxuICogQSBmYWN0b3J5IGZvciBhIHNvcnQgZnVuY3Rpb24gZm9yIEhvb2tUdXBsZXMuXHJcbiAqXHJcbiAqIFRoZSBzb3J0IGZ1bmN0aW9uIGZpcnN0IGNvbXBhcmVzIHRoZSBQYXRoTm9kZSBkZXB0aCAoaG93IGRlZXAgaW4gdGhlIHN0YXRlIHRyZWUgYSBub2RlIGlzKSwgdGhlbiBjb21wYXJlc1xyXG4gKiB0aGUgRXZlbnRIb29rIHByaW9yaXR5LlxyXG4gKlxyXG4gKiBAcGFyYW0gcmV2ZXJzZURlcHRoU29ydCBhIGJvb2xlYW4sIHdoZW4gdHJ1ZSwgcmV2ZXJzZXMgdGhlIHNvcnQgb3JkZXIgZm9yIHRoZSBub2RlIGRlcHRoXHJcbiAqIEByZXR1cm5zIGEgdHVwbGUgc29ydCBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gdHVwbGVTb3J0KHJldmVyc2VEZXB0aFNvcnQpIHtcclxuICAgIGlmIChyZXZlcnNlRGVwdGhTb3J0ID09PSB2b2lkIDApIHsgcmV2ZXJzZURlcHRoU29ydCA9IGZhbHNlOyB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gbm9kZURlcHRoVGhlblByaW9yaXR5KGwsIHIpIHtcclxuICAgICAgICB2YXIgZmFjdG9yID0gcmV2ZXJzZURlcHRoU29ydCA/IC0xIDogMTtcclxuICAgICAgICB2YXIgZGVwdGhEZWx0YSA9IChsLm5vZGUuc3RhdGUucGF0aC5sZW5ndGggLSByLm5vZGUuc3RhdGUucGF0aC5sZW5ndGgpICogZmFjdG9yO1xyXG4gICAgICAgIHJldHVybiBkZXB0aERlbHRhICE9PSAwID8gZGVwdGhEZWx0YSA6IHIuaG9vay5wcmlvcml0eSAtIGwuaG9vay5wcmlvcml0eTtcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va0J1aWxkZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9ob29rQnVpbGRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRyYW5zaXRpb25Ib29rXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uSG9va1wiKTtcclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgZGVmaW5lcyBhIHR5cGUgb2YgaG9vaywgc3VjaCBhcyBgb25CZWZvcmVgIG9yIGBvbkVudGVyYC5cclxuICogUGx1Z2lucyBjYW4gZGVmaW5lIGN1c3RvbSBob29rIHR5cGVzLCBzdWNoIGFzIHN0aWNreSBzdGF0ZXMgZG9lcyBmb3IgYG9uSW5hY3RpdmVgLlxyXG4gKlxyXG4gKiBAaW50ZXJhbGFwaVxyXG4gKi9cclxudmFyIFRyYW5zaXRpb25FdmVudFR5cGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbkV2ZW50VHlwZShuYW1lLCBob29rUGhhc2UsIGhvb2tPcmRlciwgY3JpdGVyaWFNYXRjaFBhdGgsIHJldmVyc2VTb3J0LCBnZXRSZXN1bHRIYW5kbGVyLCBnZXRFcnJvckhhbmRsZXIsIHN5bmNocm9ub3VzKSB7XHJcbiAgICAgICAgaWYgKHJldmVyc2VTb3J0ID09PSB2b2lkIDApIHsgcmV2ZXJzZVNvcnQgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmIChnZXRSZXN1bHRIYW5kbGVyID09PSB2b2lkIDApIHsgZ2V0UmVzdWx0SGFuZGxlciA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suSEFORExFX1JFU1VMVDsgfVxyXG4gICAgICAgIGlmIChnZXRFcnJvckhhbmRsZXIgPT09IHZvaWQgMCkgeyBnZXRFcnJvckhhbmRsZXIgPSB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLlJFSkVDVF9FUlJPUjsgfVxyXG4gICAgICAgIGlmIChzeW5jaHJvbm91cyA9PT0gdm9pZCAwKSB7IHN5bmNocm9ub3VzID0gZmFsc2U7IH1cclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuaG9va1BoYXNlID0gaG9va1BoYXNlO1xyXG4gICAgICAgIHRoaXMuaG9va09yZGVyID0gaG9va09yZGVyO1xyXG4gICAgICAgIHRoaXMuY3JpdGVyaWFNYXRjaFBhdGggPSBjcml0ZXJpYU1hdGNoUGF0aDtcclxuICAgICAgICB0aGlzLnJldmVyc2VTb3J0ID0gcmV2ZXJzZVNvcnQ7XHJcbiAgICAgICAgdGhpcy5nZXRSZXN1bHRIYW5kbGVyID0gZ2V0UmVzdWx0SGFuZGxlcjtcclxuICAgICAgICB0aGlzLmdldEVycm9ySGFuZGxlciA9IGdldEVycm9ySGFuZGxlcjtcclxuICAgICAgICB0aGlzLnN5bmNocm9ub3VzID0gc3luY2hyb25vdXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVHJhbnNpdGlvbkV2ZW50VHlwZTtcclxufSgpKTtcclxuZXhwb3J0cy5UcmFuc2l0aW9uRXZlbnRUeXBlID0gVHJhbnNpdGlvbkV2ZW50VHlwZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNpdGlvbkV2ZW50VHlwZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3RyYW5zaXRpb25FdmVudFR5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxhcGlcclxuICogQG1vZHVsZSB1cmxcclxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcclxudmFyIHVybE1hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL3VybE1hdGNoZXJcIik7XHJcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcclxudmFyIHBhcmFtVHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9wYXJhbXMvcGFyYW1UeXBlc1wiKTtcclxuLyoqXHJcbiAqIEZhY3RvcnkgZm9yIFtbVXJsTWF0Y2hlcl1dIGluc3RhbmNlcy5cclxuICpcclxuICogVGhlIGZhY3RvcnkgaXMgYXZhaWxhYmxlIHRvIG5nMSBzZXJ2aWNlcyBhc1xyXG4gKiBgJHVybE1hdGNoZXJGYWN0b3JgIG9yIG5nMSBwcm92aWRlcnMgYXMgYCR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyYC5cclxuICovXHJcbnZhciBVcmxNYXRjaGVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVcmxNYXRjaGVyRmFjdG9yeSgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMucGFyYW1UeXBlcyA9IG5ldyBwYXJhbVR5cGVzXzEuUGFyYW1UeXBlcygpO1xyXG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX2lzQ2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5faXNTdHJpY3RNb2RlID0gdHJ1ZTtcclxuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9kZWZhdWx0U3F1YXNoUG9saWN5ID0gZmFsc2U7XHJcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cclxuICAgICAgICB0aGlzLl9nZXRDb25maWcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQoeyBzdHJpY3Q6IF90aGlzLl9pc1N0cmljdE1vZGUsIGNhc2VJbnNlbnNpdGl2ZTogX3RoaXMuX2lzQ2FzZUluc2Vuc2l0aXZlIH0sIGNvbmZpZyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKiogQGludGVybmFsYXBpIENyZWF0ZXMgYSBuZXcgW1tQYXJhbV1dIGZvciBhIGdpdmVuIGxvY2F0aW9uIChEZWZUeXBlKSAqL1xyXG4gICAgICAgIHRoaXMucGFyYW1GYWN0b3J5ID0ge1xyXG4gICAgICAgICAgICAvKiogQ3JlYXRlcyBhIG5ldyBbW1BhcmFtXV0gZnJvbSBhIENPTkZJRyBibG9jayAqL1xyXG4gICAgICAgICAgICBmcm9tQ29uZmlnOiBmdW5jdGlvbiAoaWQsIHR5cGUsIGNvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXJhbV8xLlBhcmFtKGlkLCB0eXBlLCBjb25maWcsIHBhcmFtXzEuRGVmVHlwZS5DT05GSUcsIF90aGlzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqIENyZWF0ZXMgYSBuZXcgW1tQYXJhbV1dIGZyb20gYSB1cmwgUEFUSCAqL1xyXG4gICAgICAgICAgICBmcm9tUGF0aDogZnVuY3Rpb24gKGlkLCB0eXBlLCBjb25maWcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFyYW1fMS5QYXJhbShpZCwgdHlwZSwgY29uZmlnLCBwYXJhbV8xLkRlZlR5cGUuUEFUSCwgX3RoaXMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKiogQ3JlYXRlcyBhIG5ldyBbW1BhcmFtXV0gZnJvbSBhIHVybCBTRUFSQ0ggKi9cclxuICAgICAgICAgICAgZnJvbVNlYXJjaDogZnVuY3Rpb24gKGlkLCB0eXBlLCBjb25maWcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFyYW1fMS5QYXJhbShpZCwgdHlwZSwgY29uZmlnLCBwYXJhbV8xLkRlZlR5cGUuU0VBUkNILCBfdGhpcyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb21tb25fMS5leHRlbmQodGhpcywgeyBVcmxNYXRjaGVyOiB1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlciwgUGFyYW06IHBhcmFtXzEuUGFyYW0gfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cclxuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5jYXNlSW5zZW5zaXRpdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNDYXNlSW5zZW5zaXRpdmUgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogdGhpcy5faXNDYXNlSW5zZW5zaXRpdmU7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuc3RyaWN0TW9kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1N0cmljdE1vZGUgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogdGhpcy5faXNTdHJpY3RNb2RlO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLmRlZmF1bHRTcXVhc2hQb2xpY3kgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09IGZhbHNlICYmICFwcmVkaWNhdGVzXzEuaXNTdHJpbmcodmFsdWUpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNxdWFzaCBwb2xpY3k6IFwiICsgdmFsdWUgKyBcIi4gVmFsaWQgcG9saWNpZXM6IGZhbHNlLCB0cnVlLCBhcmJpdHJhcnktc3RyaW5nXCIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0U3F1YXNoUG9saWN5ID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6IHRoaXMuX2RlZmF1bHRTcXVhc2hQb2xpY3k7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgW1tVcmxNYXRjaGVyXV0gZm9yIHRoZSBzcGVjaWZpZWQgcGF0dGVybi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0dGVybiAgVGhlIFVSTCBwYXR0ZXJuLlxyXG4gICAgICogQHBhcmFtIGNvbmZpZyAgVGhlIGNvbmZpZyBvYmplY3QgaGFzaC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBVcmxNYXRjaGVyLlxyXG4gICAgICovXHJcbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBjb25maWcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHVybE1hdGNoZXJfMS5VcmxNYXRjaGVyKHBhdHRlcm4sIHRoaXMucGFyYW1UeXBlcywgdGhpcy5wYXJhbUZhY3RvcnksIHRoaXMuX2dldENvbmZpZyhjb25maWcpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIFtbVXJsTWF0Y2hlcl1dLCBvciBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9iamVjdCAgVGhlIG9iamVjdCB0byBwZXJmb3JtIHRoZSB0eXBlIGNoZWNrIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBtYXRjaGVzIHRoZSBgVXJsTWF0Y2hlcmAgaW50ZXJmYWNlLCBieVxyXG4gICAgICogICAgICAgICAgaW1wbGVtZW50aW5nIGFsbCB0aGUgc2FtZSBtZXRob2RzLlxyXG4gICAgICovXHJcbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuaXNNYXRjaGVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xyXG4gICAgICAgIC8vIFRPRE86IHR5cGVvZj9cclxuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc09iamVjdChvYmplY3QpKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgY29tbW9uXzEuZm9yRWFjaCh1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlci5wcm90b3R5cGUsIGZ1bmN0aW9uICh2YWwsIG5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHZhbCkpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQob2JqZWN0W25hbWVdKSAmJiBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihvYmplY3RbbmFtZV0pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmVnaXN0ZXJzIGEgY3VzdG9tIFtbUGFyYW1UeXBlXV0gb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQSBbW1BhcmFtVHlwZV1dIGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIFVSTHMgd2l0aCB0eXBlZCBwYXJhbWV0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lICBUaGUgdHlwZSBuYW1lLlxyXG4gICAgICogQHBhcmFtIGRlZmluaXRpb24gVGhlIHR5cGUgZGVmaW5pdGlvbi4gU2VlIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dIGZvciBpbmZvcm1hdGlvbiBvbiB0aGUgdmFsdWVzIGFjY2VwdGVkLlxyXG4gICAgICogQHBhcmFtIGRlZmluaXRpb25GbiBBIGZ1bmN0aW9uIHRoYXQgaXMgaW5qZWN0ZWQgYmVmb3JlIHRoZSBhcHAgcnVudGltZSBzdGFydHMuXHJcbiAgICAgKiAgICAgICAgVGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBhIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dLlxyXG4gICAgICogICAgICAgIFRoZSByZXN1bHQgaXMgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIGBkZWZpbml0aW9uYC5cclxuICAgICAqICAgICAgICBTZWUgW1tQYXJhbVR5cGVdXSBmb3IgaW5mb3JtYXRpb24gb24gdGhlIHZhbHVlcyBhY2NlcHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIGlmIGEgdHlwZSB3YXMgcmVnaXN0ZXJlZDogdGhlIFtbVXJsTWF0Y2hlckZhY3RvcnldXVxyXG4gICAgICogICAtIGlmIG9ubHkgdGhlIGBuYW1lYCBwYXJhbWV0ZXIgd2FzIHNwZWNpZmllZDogdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIFtbUGFyYW1UeXBlXV0gb2JqZWN0LCBvciB1bmRlZmluZWRcclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBSZWdpc3RlciBjdXN0b20gdHlwZXMgKmJlZm9yZSB1c2luZyB0aGVtKiBpbiBhIHN0YXRlIGRlZmluaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogU2VlIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dIGZvciBleGFtcGxlc1xyXG4gICAgICovXHJcbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uLCBkZWZpbml0aW9uRm4pIHtcclxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMucGFyYW1UeXBlcy50eXBlKG5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb25Gbik7XHJcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGRlZmluaXRpb24pID8gdHlwZSA6IHRoaXM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqIEBoaWRkZW4gKi9cclxuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS4kZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucGFyYW1UeXBlcy5lbnF1ZXVlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wYXJhbVR5cGVzLl9mbHVzaFR5cGVRdWV1ZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cclxuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucGFyYW1UeXBlcy5kaXNwb3NlKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFVybE1hdGNoZXJGYWN0b3J5O1xyXG59KCkpO1xyXG5leHBvcnRzLlVybE1hdGNoZXJGYWN0b3J5ID0gVXJsTWF0Y2hlckZhY3Rvcnk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybE1hdGNoZXJGYWN0b3J5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxNYXRjaGVyRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbGFwaVxyXG4gKiBAbW9kdWxlIHVybFxyXG4gKi9cclxuLyoqIGZvciB0eXBlZG9jICovXHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xyXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xyXG52YXIgdXJsTWF0Y2hlcl8xID0gcmVxdWlyZShcIi4vdXJsTWF0Y2hlclwiKTtcclxudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XHJcbnZhciB1cmxSdWxlXzEgPSByZXF1aXJlKFwiLi91cmxSdWxlXCIpO1xyXG52YXIgdGFyZ2V0U3RhdGVfMSA9IHJlcXVpcmUoXCIuLi9zdGF0ZS90YXJnZXRTdGF0ZVwiKTtcclxuLyoqIEBoaWRkZW4gKi9cclxuZnVuY3Rpb24gYXBwZW5kQmFzZVBhdGgodXJsLCBpc0h0bWw1LCBhYnNvbHV0ZSwgYmFzZUhyZWYpIHtcclxuICAgIGlmIChiYXNlSHJlZiA9PT0gJy8nKVxyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICBpZiAoaXNIdG1sNSlcclxuICAgICAgICByZXR1cm4gYmFzZUhyZWYuc2xpY2UoMCwgLTEpICsgdXJsO1xyXG4gICAgaWYgKGFic29sdXRlKVxyXG4gICAgICAgIHJldHVybiBiYXNlSHJlZi5zbGljZSgxKSArIHVybDtcclxuICAgIHJldHVybiB1cmw7XHJcbn1cclxuLyoqIEBoaWRkZW4gKi9cclxudmFyIGdldE1hdGNoZXIgPSBob2ZfMS5wcm9wKFwidXJsTWF0Y2hlclwiKTtcclxuLyoqXHJcbiAqIERlZmF1bHQgcnVsZSBwcmlvcml0eSBzb3J0aW5nIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBTb3J0cyBydWxlcyBieTpcclxuICpcclxuICogLSBFeHBsaWNpdCBwcmlvcml0eSAoc2V0IHJ1bGUgcHJpb3JpdHkgdXNpbmcgW1tVcmxSdWxlc0FwaS53aGVuXV0pXHJcbiAqIC0gUnVsZSB0eXBlIChTVEFURTogNCwgVVJMTUFUQ0hFUjogNCwgUkVHRVhQOiAzLCBSQVc6IDIsIE9USEVSOiAxKVxyXG4gKiAtIGBVcmxNYXRjaGVyYCBzcGVjaWZpY2l0eSAoW1tVcmxNYXRjaGVyLmNvbXBhcmVdXSk6IHdvcmtzIGZvciBTVEFURSBhbmQgVVJMTUFUQ0hFUiB0eXBlcyB0byBwaWNrIHRoZSBtb3N0IHNwZWNpZmljIHJ1bGUuXHJcbiAqIC0gUmVnaXN0cmF0aW9uIG9yZGVyIChmb3IgcnVsZSB0eXBlcyBvdGhlciB0aGFuIFNUQVRFIGFuZCBVUkxNQVRDSEVSKVxyXG4gKlxyXG4gKiBAY29yZWFwaVxyXG4gKi9cclxudmFyIGRlZmF1bHRSdWxlU29ydEZuO1xyXG5kZWZhdWx0UnVsZVNvcnRGbiA9IGNvbW1vbl8xLmNvbXBvc2VTb3J0KGNvbW1vbl8xLnNvcnRCeShob2ZfMS5waXBlKGhvZl8xLnByb3AoXCJwcmlvcml0eVwiKSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIC14OyB9KSksIGNvbW1vbl8xLnNvcnRCeShob2ZfMS5waXBlKGhvZl8xLnByb3AoXCJ0eXBlXCIpLCBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gKHsgXCJTVEFURVwiOiA0LCBcIlVSTE1BVENIRVJcIjogNCwgXCJSRUdFWFBcIjogMywgXCJSQVdcIjogMiwgXCJPVEhFUlwiOiAxIH0pW3R5cGVdOyB9KSksIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoZ2V0TWF0Y2hlcihhKSAmJiBnZXRNYXRjaGVyKGIpKSA/IHVybE1hdGNoZXJfMS5VcmxNYXRjaGVyLmNvbXBhcmUoZ2V0TWF0Y2hlcihhKSwgZ2V0TWF0Y2hlcihiKSkgOiAwOyB9LCBjb21tb25fMS5zb3J0QnkoaG9mXzEucHJvcChcIiRpZFwiKSwgY29tbW9uXzEuaW5BcnJheShbXCJSRUdFWFBcIiwgXCJSQVdcIiwgXCJPVEhFUlwiXSkpKTtcclxuLyoqXHJcbiAqIFVwZGF0ZXMgVVJMIGFuZCByZXNwb25kcyB0byBVUkwgY2hhbmdlc1xyXG4gKlxyXG4gKiAjIyMgRGVwcmVjYXRpb24gd2FybmluZzpcclxuICogVGhpcyBjbGFzcyBpcyBub3cgY29uc2lkZXJlZCB0byBiZSBhbiBpbnRlcm5hbCBBUElcclxuICogVXNlIHRoZSBbW1VybFNlcnZpY2VdXSBpbnN0ZWFkLlxyXG4gKiBGb3IgY29uZmlndXJpbmcgVVJMIHJ1bGVzLCB1c2UgdGhlIFtbVXJsUnVsZXNBcGldXSB3aGljaCBjYW4gYmUgZm91bmQgYXMgW1tVcmxTZXJ2aWNlLnJ1bGVzXV0uXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgdXBkYXRlcyB0aGUgVVJMIHdoZW4gdGhlIHN0YXRlIGNoYW5nZXMuXHJcbiAqIEl0IGFsc28gcmVzcG9uZHMgdG8gY2hhbmdlcyBpbiB0aGUgVVJMLlxyXG4gKi9cclxudmFyIFVybFJvdXRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgZnVuY3Rpb24gVXJsUm91dGVyKHJvdXRlcikge1xyXG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX3NvcnRGbiA9IGRlZmF1bHRSdWxlU29ydEZuO1xyXG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX3J1bGVzID0gW107XHJcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5pbnRlcmNlcHREZWZlcnJlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX2lkID0gMDtcclxuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yb3V0ZXIgPSByb3V0ZXI7XHJcbiAgICAgICAgdGhpcy51cmxSdWxlRmFjdG9yeSA9IG5ldyB1cmxSdWxlXzEuVXJsUnVsZUZhY3Rvcnkocm91dGVyKTtcclxuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhob2ZfMS52YWwoVXJsUm91dGVyLnByb3RvdHlwZSksIHRoaXMsIGhvZl8xLnZhbCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsYXBpICovXHJcbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW4oZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuX3J1bGVzID0gW107XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX290aGVyd2lzZUZuO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGNvbXBhcmVGbikge1xyXG4gICAgICAgIHRoaXMuX3J1bGVzLnNvcnQodGhpcy5fc29ydEZuID0gY29tcGFyZUZuIHx8IHRoaXMuX3NvcnRGbik7XHJcbiAgICAgICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmVuc3VyZVNvcnRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9zb3J0ZWQgfHwgdGhpcy5zb3J0KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIFVSTCwgY2hlY2sgYWxsIHJ1bGVzIGFuZCByZXR1cm4gdGhlIGJlc3QgW1tNYXRjaFJlc3VsdF1dXHJcbiAgICAgKiBAcGFyYW0gdXJsXHJcbiAgICAgKiBAcmV0dXJucyB7TWF0Y2hSZXN1bHR9XHJcbiAgICAgKi9cclxuICAgIFVybFJvdXRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmVuc3VyZVNvcnRlZCgpO1xyXG4gICAgICAgIHVybCA9IGNvbW1vbl8xLmV4dGVuZCh7IHBhdGg6ICcnLCBzZWFyY2g6IHt9LCBoYXNoOiAnJyB9LCB1cmwpO1xyXG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMoKTtcclxuICAgICAgICBpZiAodGhpcy5fb3RoZXJ3aXNlRm4pXHJcbiAgICAgICAgICAgIHJ1bGVzLnB1c2godGhpcy5fb3RoZXJ3aXNlRm4pO1xyXG4gICAgICAgIC8vIENoZWNrcyBhIHNpbmdsZSBydWxlLiBSZXR1cm5zIHsgcnVsZTogcnVsZSwgbWF0Y2g6IG1hdGNoLCB3ZWlnaHQ6IHdlaWdodCB9IGlmIGl0IG1hdGNoZWQsIG9yIHVuZGVmaW5lZFxyXG4gICAgICAgIHZhciBjaGVja1J1bGUgPSBmdW5jdGlvbiAocnVsZSkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKHVybCwgX3RoaXMuX3JvdXRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiB7IG1hdGNoOiBtYXRjaCwgcnVsZTogcnVsZSwgd2VpZ2h0OiBydWxlLm1hdGNoUHJpb3JpdHkobWF0Y2gpIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBUaGUgcnVsZXMgYXJlIHByZS1zb3J0ZWQuXHJcbiAgICAgICAgLy8gLSBGaW5kIHRoZSBmaXJzdCBtYXRjaGluZyBydWxlLlxyXG4gICAgICAgIC8vIC0gRmluZCBhbnkgb3RoZXIgbWF0Y2hpbmcgcnVsZSB0aGF0IHNvcnRlZCAqZXhhY3RseSB0aGUgc2FtZSosIGFjY29yZGluZyB0byBgLnNvcnQoKWAuXHJcbiAgICAgICAgLy8gLSBDaG9vc2UgdGhlIHJ1bGUgd2l0aCB0aGUgaGlnaGVzdCBtYXRjaCB3ZWlnaHQuXHJcbiAgICAgICAgdmFyIGJlc3Q7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBTdG9wIHdoZW4gdGhlcmUgaXMgYSAnYmVzdCcgcnVsZSBhbmQgdGhlIG5leHQgcnVsZSBzb3J0cyBkaWZmZXJlbnRseSB0aGFuIGl0LlxyXG4gICAgICAgICAgICBpZiAoYmVzdCAmJiB0aGlzLl9zb3J0Rm4ocnVsZXNbaV0sIGJlc3QucnVsZSkgIT09IDApXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBjaGVja1J1bGUocnVsZXNbaV0pO1xyXG4gICAgICAgICAgICAvLyBQaWNrIHRoZSBiZXN0IE1hdGNoUmVzdWx0XHJcbiAgICAgICAgICAgIGJlc3QgPSAoIWJlc3QgfHwgY3VycmVudCAmJiBjdXJyZW50LndlaWdodCA+IGJlc3Qud2VpZ2h0KSA/IGN1cnJlbnQgOiBiZXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmVzdDtcclxuICAgIH07XHJcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cclxuICAgIFVybFJvdXRlci5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICBpZiAoZXZ0ICYmIGV2dC5kZWZhdWx0UHJldmVudGVkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMuX3JvdXRlciwgJHVybCA9IHJvdXRlci51cmxTZXJ2aWNlLCAkc3RhdGUgPSByb3V0ZXIuc3RhdGVTZXJ2aWNlO1xyXG4gICAgICAgIHZhciB1cmwgPSB7XHJcbiAgICAgICAgICAgIHBhdGg6ICR1cmwucGF0aCgpLCBzZWFyY2g6ICR1cmwuc2VhcmNoKCksIGhhc2g6ICR1cmwuaGFzaCgpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGJlc3QgPSB0aGlzLm1hdGNoKHVybCk7XHJcbiAgICAgICAgdmFyIGFwcGx5UmVzdWx0ID0gaG9mXzEucGF0dGVybihbXHJcbiAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNTdHJpbmcsIGZ1bmN0aW9uIChuZXd1cmwpIHsgcmV0dXJuICR1cmwudXJsKG5ld3VybCwgdHJ1ZSk7IH1dLFxyXG4gICAgICAgICAgICBbdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZS5pc0RlZiwgZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gJHN0YXRlLmdvKGRlZi5zdGF0ZSwgZGVmLnBhcmFtcywgZGVmLm9wdGlvbnMpOyB9XSxcclxuICAgICAgICAgICAgW2hvZl8xLmlzKHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUpLCBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiAkc3RhdGUuZ28odGFyZ2V0LnN0YXRlKCksIHRhcmdldC5wYXJhbXMoKSwgdGFyZ2V0Lm9wdGlvbnMoKSk7IH1dLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGFwcGx5UmVzdWx0KGJlc3QgJiYgYmVzdC5ydWxlLmhhbmRsZXIoYmVzdC5tYXRjaCwgdXJsLCByb3V0ZXIpKTtcclxuICAgIH07XHJcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cclxuICAgIFVybFJvdXRlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChlbmFibGVkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wRm4gJiYgdGhpcy5fc3RvcEZuKCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdG9wRm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcEZuID0gdGhpcy5fc3RvcEZuIHx8IHRoaXMuX3JvdXRlci51cmxTZXJ2aWNlLm9uQ2hhbmdlKGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuIF90aGlzLnN5bmMoZXZ0KTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgQVBJLlxyXG4gICAgICogQGludGVybmFsYXBpXHJcbiAgICAgKi9cclxuICAgIFVybFJvdXRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHJlYWQpIHtcclxuICAgICAgICB2YXIgJHVybCA9IHRoaXMuX3JvdXRlci5sb2NhdGlvblNlcnZpY2U7XHJcbiAgICAgICAgaWYgKHJlYWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9ICR1cmwucGF0aCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgkdXJsLnBhdGgoKSA9PT0gdGhpcy5sb2NhdGlvbilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICR1cmwudXJsKHRoaXMubG9jYXRpb24sIHRydWUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgQVBJLlxyXG4gICAgICpcclxuICAgICAqIFB1c2hlcyBhIG5ldyBsb2NhdGlvbiB0byB0aGUgYnJvd3NlciBoaXN0b3J5LlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbGFwaVxyXG4gICAgICogQHBhcmFtIHVybE1hdGNoZXJcclxuICAgICAqIEBwYXJhbSBwYXJhbXNcclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIFVybFJvdXRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh1cmxNYXRjaGVyLCBwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgcmVwbGFjZSA9IG9wdGlvbnMgJiYgISFvcHRpb25zLnJlcGxhY2U7XHJcbiAgICAgICAgdGhpcy5fcm91dGVyLnVybFNlcnZpY2UudXJsKHVybE1hdGNoZXIuZm9ybWF0KHBhcmFtcyB8fCB7fSksIHJlcGxhY2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIGFuZCByZXR1cm5zIGEgVVJMIHdpdGggaW50ZXJwb2xhdGVkIHBhcmFtZXRlcnNcclxuICAgICAqXHJcbiAgICAgKiAjIyMjIEV4YW1wbGU6XHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogbWF0Y2hlciA9ICR1bWYuY29tcGlsZShcIi9hYm91dC86cGVyc29uXCIpO1xyXG4gICAgICogcGFyYW1zID0geyBwZXJzb246IFwiYm9iXCIgfTtcclxuICAgICAqICRib2IgPSAkdXJsUm91dGVyLmhyZWYobWF0Y2hlciwgcGFyYW1zKTtcclxuICAgICAqIC8vICRib2IgPT0gXCIvYWJvdXQvYm9iXCI7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsTWF0Y2hlciBUaGUgW1tVcmxNYXRjaGVyXV0gb2JqZWN0IHdoaWNoIGlzIHVzZWQgYXMgdGhlIHRlbXBsYXRlIG9mIHRoZSBVUkwgdG8gZ2VuZXJhdGUuXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRvIGZpbGwgdGhlIG1hdGNoZXIncyByZXF1aXJlZCBwYXJhbWV0ZXJzLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcclxuICAgICAqXHJcbiAgICAgKiAtICoqYGFic29sdXRlYCoqIC0ge2Jvb2xlYW49ZmFsc2V9LCAgSWYgdHJ1ZSB3aWxsIGdlbmVyYXRlIGFuIGFic29sdXRlIHVybCwgZS5nLiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vZnVsbHVybFwiLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIGZ1bGx5IGNvbXBpbGVkIFVSTCwgb3IgYG51bGxgIGlmIGBwYXJhbXNgIGZhaWwgdmFsaWRhdGlvbiBhZ2FpbnN0IGB1cmxNYXRjaGVyYFxyXG4gICAgICovXHJcbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmhyZWYgPSBmdW5jdGlvbiAodXJsTWF0Y2hlciwgcGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHVybCA9IHVybE1hdGNoZXIuZm9ybWF0KHBhcmFtcyk7XHJcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGFic29sdXRlOiBmYWxzZSB9O1xyXG4gICAgICAgIHZhciBjZmcgPSB0aGlzLl9yb3V0ZXIudXJsU2VydmljZS5jb25maWc7XHJcbiAgICAgICAgdmFyIGlzSHRtbDUgPSBjZmcuaHRtbDVNb2RlKCk7XHJcbiAgICAgICAgaWYgKCFpc0h0bWw1ICYmIHVybCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB1cmwgPSBcIiNcIiArIGNmZy5oYXNoUHJlZml4KCkgKyB1cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVybCA9IGFwcGVuZEJhc2VQYXRoKHVybCwgaXNIdG1sNSwgb3B0aW9ucy5hYnNvbHV0ZSwgY2ZnLmJhc2VIcmVmKCkpO1xyXG4gICAgICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZSB8fCAhdXJsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzbGFzaCA9ICghaXNIdG1sNSAmJiB1cmwgPyAnLycgOiAnJyksIHBvcnQgPSBjZmcucG9ydCgpO1xyXG4gICAgICAgIHBvcnQgPSAocG9ydCA9PT0gODAgfHwgcG9ydCA9PT0gNDQzID8gJycgOiAnOicgKyBwb3J0KTtcclxuICAgICAgICByZXR1cm4gW2NmZy5wcm90b2NvbCgpLCAnOi8vJywgY2ZnLmhvc3QoKSwgcG9ydCwgc2xhc2gsIHVybF0uam9pbignJyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYW51YWxseSBhZGRzIGEgVVJMIFJ1bGUuXHJcbiAgICAgKlxyXG4gICAgICogVXN1YWxseSwgYSB1cmwgcnVsZSBpcyBhZGRlZCB1c2luZyBbW1N0YXRlRGVjbGFyYXRpb24udXJsXV0gb3IgW1t3aGVuXV0uXHJcbiAgICAgKiBUaGlzIGFwaSBjYW4gYmUgdXNlZCBkaXJlY3RseSBmb3IgbW9yZSBjb250cm9sICh0byByZWdpc3RlciBhIFtbQmFzZVVybFJ1bGVdXSwgZm9yIGV4YW1wbGUpLlxyXG4gICAgICogUnVsZXMgY2FuIGJlIGNyZWF0ZWQgdXNpbmcgW1tVcmxSb3V0ZXIudXJsUnVsZUZhY3RvcnldXSwgb3IgY3JlYXRlIG1hbnVhbGx5IGFzIHNpbXBsZSBvYmplY3RzLlxyXG4gICAgICpcclxuICAgICAqIEEgcnVsZSBzaG91bGQgaGF2ZSBhIGBtYXRjaGAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0cnV0aHkgaWYgdGhlIHJ1bGUgbWF0Y2hlZC5cclxuICAgICAqIEl0IHNob3VsZCBhbHNvIGhhdmUgYSBgaGFuZGxlcmAgZnVuY3Rpb24gd2hpY2ggaXMgaW52b2tlZCBpZiB0aGUgcnVsZSBpcyB0aGUgYmVzdCBtYXRjaC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBkZXJlZ2lzdGVycyB0aGUgcnVsZVxyXG4gICAgICovXHJcbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLnJ1bGUgPSBmdW5jdGlvbiAocnVsZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF1cmxSdWxlXzEuVXJsUnVsZUZhY3RvcnkuaXNVcmxSdWxlKHJ1bGUpKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJ1bGVcIik7XHJcbiAgICAgICAgcnVsZS4kaWQgPSB0aGlzLl9pZCsrO1xyXG4gICAgICAgIHJ1bGUucHJpb3JpdHkgPSBydWxlLnByaW9yaXR5IHx8IDA7XHJcbiAgICAgICAgdGhpcy5fcnVsZXMucHVzaChydWxlKTtcclxuICAgICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVtb3ZlUnVsZShydWxlKTsgfTtcclxuICAgIH07XHJcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cclxuICAgIFVybFJvdXRlci5wcm90b3R5cGUucmVtb3ZlUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh0aGlzLl9ydWxlcywgcnVsZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLnJ1bGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlU29ydGVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzLnNsaWNlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLm90aGVyd2lzZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZXJGbiA9IGdldEhhbmRsZXJGbihoYW5kbGVyKTtcclxuICAgICAgICB0aGlzLl9vdGhlcndpc2VGbiA9IHRoaXMudXJsUnVsZUZhY3RvcnkuY3JlYXRlKGhvZl8xLnZhbCh0cnVlKSwgaGFuZGxlckZuKTtcclxuICAgICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cclxuICAgIFVybFJvdXRlci5wcm90b3R5cGUuaW5pdGlhbCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZXJGbiA9IGdldEhhbmRsZXJGbihoYW5kbGVyKTtcclxuICAgICAgICB2YXIgbWF0Y2hGbiA9IGZ1bmN0aW9uICh1cmxQYXJ0cywgcm91dGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uSGlzdG9yeS5zaXplKCkgPT09IDAgJiYgISEvXlxcLz8kLy5leGVjKHVybFBhcnRzLnBhdGgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydWxlKHRoaXMudXJsUnVsZUZhY3RvcnkuY3JlYXRlKG1hdGNoRm4sIGhhbmRsZXJGbikpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24gKG1hdGNoZXIsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgcnVsZSA9IHRoaXMudXJsUnVsZUZhY3RvcnkuY3JlYXRlKG1hdGNoZXIsIGhhbmRsZXIpO1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKG9wdGlvbnMgJiYgb3B0aW9ucy5wcmlvcml0eSkpXHJcbiAgICAgICAgICAgIHJ1bGUucHJpb3JpdHkgPSBvcHRpb25zLnByaW9yaXR5O1xyXG4gICAgICAgIHRoaXMucnVsZShydWxlKTtcclxuICAgICAgICByZXR1cm4gcnVsZTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cclxuICAgIFVybFJvdXRlci5wcm90b3R5cGUuZGVmZXJJbnRlcmNlcHQgPSBmdW5jdGlvbiAoZGVmZXIpIHtcclxuICAgICAgICBpZiAoZGVmZXIgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgZGVmZXIgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaW50ZXJjZXB0RGVmZXJyZWQgPSBkZWZlcjtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gVXJsUm91dGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlVybFJvdXRlciA9IFVybFJvdXRlcjtcclxuZnVuY3Rpb24gZ2V0SGFuZGxlckZuKGhhbmRsZXIpIHtcclxuICAgIGlmICghcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oaGFuZGxlcikgJiYgIXByZWRpY2F0ZXNfMS5pc1N0cmluZyhoYW5kbGVyKSAmJiAhaG9mXzEuaXModGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSkoaGFuZGxlcikgJiYgIXRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUuaXNEZWYoaGFuZGxlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInaGFuZGxlcicgbXVzdCBiZSBhIHN0cmluZywgZnVuY3Rpb24sIFRhcmdldFN0YXRlLCBvciBoYXZlIGEgc3RhdGU6ICduZXd0YXJnZXQnIHByb3BlcnR5XCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKGhhbmRsZXIpID8gaGFuZGxlciA6IGhvZl8xLnZhbChoYW5kbGVyKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmxSb3V0ZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdXJsL3VybFJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEBjb3JlYXBpXHJcbiAqIEBtb2R1bGUgdXJsXHJcbiAqLyAvKiogKi9cclxudmFyIHVybE1hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL3VybE1hdGNoZXJcIik7XHJcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xyXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBbW1VybFJ1bGVdXVxyXG4gKlxyXG4gKiBDcmVhdGVzIGEgW1tVcmxSdWxlXV0gZnJvbSBhOlxyXG4gKlxyXG4gKiAtIGBzdHJpbmdgXHJcbiAqIC0gW1tVcmxNYXRjaGVyXV1cclxuICogLSBgUmVnRXhwYFxyXG4gKiAtIFtbU3RhdGVPYmplY3RdXVxyXG4gKiBAaW50ZXJuYWxhcGlcclxuICovXHJcbnZhciBVcmxSdWxlRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVcmxSdWxlRmFjdG9yeShyb3V0ZXIpIHtcclxuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcclxuICAgIH1cclxuICAgIFVybFJ1bGVGYWN0b3J5LnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdXRlci51cmxNYXRjaGVyRmFjdG9yeS5jb21waWxlKHN0cik7XHJcbiAgICB9O1xyXG4gICAgVXJsUnVsZUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICh3aGF0LCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgbWFrZVJ1bGUgPSBob2ZfMS5wYXR0ZXJuKFtcclxuICAgICAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc1N0cmluZywgZnVuY3Rpb24gKF93aGF0KSB7IHJldHVybiBtYWtlUnVsZShfdGhpcy5jb21waWxlKF93aGF0KSk7IH1dLFxyXG4gICAgICAgICAgICBbaG9mXzEuaXModXJsTWF0Y2hlcl8xLlVybE1hdGNoZXIpLCBmdW5jdGlvbiAoX3doYXQpIHsgcmV0dXJuIF90aGlzLmZyb21VcmxNYXRjaGVyKF93aGF0LCBoYW5kbGVyKTsgfV0sXHJcbiAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNTdGF0ZSwgZnVuY3Rpb24gKF93aGF0KSB7IHJldHVybiBfdGhpcy5mcm9tU3RhdGUoX3doYXQsIF90aGlzLnJvdXRlcik7IH1dLFxyXG4gICAgICAgICAgICBbaG9mXzEuaXMoUmVnRXhwKSwgZnVuY3Rpb24gKF93aGF0KSB7IHJldHVybiBfdGhpcy5mcm9tUmVnRXhwKF93aGF0LCBoYW5kbGVyKTsgfV0sXHJcbiAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbiwgZnVuY3Rpb24gKF93aGF0KSB7IHJldHVybiBuZXcgQmFzZVVybFJ1bGUoX3doYXQsIGhhbmRsZXIpOyB9XSxcclxuICAgICAgICBdKTtcclxuICAgICAgICB2YXIgcnVsZSA9IG1ha2VSdWxlKHdoYXQpO1xyXG4gICAgICAgIGlmICghcnVsZSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCAnd2hhdCcgaW4gd2hlbigpXCIpO1xyXG4gICAgICAgIHJldHVybiBydWxlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQSBVcmxSdWxlIHdoaWNoIG1hdGNoZXMgYmFzZWQgb24gYSBVcmxNYXRjaGVyXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGBoYW5kbGVyYCBtYXkgYmUgZWl0aGVyIGEgYHN0cmluZ2AsIGEgW1tVcmxSdWxlSGFuZGxlckZuXV0gb3IgYW5vdGhlciBbW1VybE1hdGNoZXJdXVxyXG4gICAgICpcclxuICAgICAqICMjIEhhbmRsZXIgYXMgYSBmdW5jdGlvblxyXG4gICAgICpcclxuICAgICAqIElmIGBoYW5kbGVyYCBpcyBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoOlxyXG4gICAgICpcclxuICAgICAqIC0gbWF0Y2hlZCBwYXJhbWV0ZXIgdmFsdWVzIChbW1Jhd1BhcmFtc11dIGZyb20gW1tVcmxNYXRjaGVyLmV4ZWNdXSlcclxuICAgICAqIC0gdXJsOiB0aGUgY3VycmVudCBVcmwgKFtbVXJsUGFydHNdXSlcclxuICAgICAqIC0gcm91dGVyOiB0aGUgcm91dGVyIG9iamVjdCAoW1tVSVJvdXRlcl1dKVxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiB2YXIgdXJsTWF0Y2hlciA9ICR1bWYuY29tcGlsZShcIi9mb28vOmZvb0lkLzpiYXJJZFwiKTtcclxuICAgICAqIHZhciBydWxlID0gZmFjdG9yeS5mcm9tVXJsTWF0Y2hlcih1cmxNYXRjaGVyLCBtYXRjaCA9PiBcIi9ob21lL1wiICsgbWF0Y2guZm9vSWQgKyBcIi9cIiArIG1hdGNoLmJhcklkKTtcclxuICAgICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vMTIzLzQ1NicpOyAvLyByZXN1bHRzIGluIHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxyXG4gICAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS8xMjMvNDU2J1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogIyMgSGFuZGxlciBhcyBVcmxNYXRjaGVyXHJcbiAgICAgKlxyXG4gICAgICogSWYgYGhhbmRsZXJgIGlzIGEgVXJsTWF0Y2hlciwgdGhlIGhhbmRsZXIgbWF0Y2hlciBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgbmV3IHVybC5cclxuICAgICAqIFRoZSBgaGFuZGxlcmAgVXJsTWF0Y2hlciBpcyBmb3JtYXR0ZWQgdXNpbmcgdGhlIG1hdGNoZWQgcGFyYW0gZnJvbSB0aGUgZmlyc3QgbWF0Y2hlci5cclxuICAgICAqIFRoZSB1cmwgaXMgcmVwbGFjZWQgd2l0aCB0aGUgcmVzdWx0LlxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiB2YXIgdXJsTWF0Y2hlciA9ICR1bWYuY29tcGlsZShcIi9mb28vOmZvb0lkLzpiYXJJZFwiKTtcclxuICAgICAqIHZhciBoYW5kbGVyID0gJHVtZi5jb21waWxlKFwiL2hvbWUvOmZvb0lkLzpiYXJJZFwiKTtcclxuICAgICAqIHZhciBydWxlID0gZmFjdG9yeS5mcm9tVXJsTWF0Y2hlcih1cmxNYXRjaGVyLCBoYW5kbGVyKTtcclxuICAgICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vMTIzLzQ1NicpOyAvLyByZXN1bHRzIGluIHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxyXG4gICAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS8xMjMvNDU2J1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIFVybFJ1bGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tVXJsTWF0Y2hlciA9IGZ1bmN0aW9uICh1cmxNYXRjaGVyLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIF9oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKGhhbmRsZXIpKVxyXG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5yb3V0ZXIudXJsTWF0Y2hlckZhY3RvcnkuY29tcGlsZShoYW5kbGVyKTtcclxuICAgICAgICBpZiAoaG9mXzEuaXModXJsTWF0Y2hlcl8xLlVybE1hdGNoZXIpKGhhbmRsZXIpKVxyXG4gICAgICAgICAgICBfaGFuZGxlciA9IGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gaGFuZGxlci5mb3JtYXQobWF0Y2gpOyB9O1xyXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoKHVybCkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB1cmxNYXRjaGVyLmV4ZWModXJsLnBhdGgsIHVybC5zZWFyY2gsIHVybC5oYXNoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVybE1hdGNoZXIudmFsaWRhdGVzKG1hdGNoKSAmJiBtYXRjaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJpb3JpdGl6ZSBVUkxzLCBsb3dlc3QgdG8gaGlnaGVzdDpcclxuICAgICAgICAvLyAtIFNvbWUgb3B0aW9uYWwgVVJMIHBhcmFtZXRlcnMsIGJ1dCBub25lIG1hdGNoZWRcclxuICAgICAgICAvLyAtIE5vIG9wdGlvbmFsIHBhcmFtZXRlcnMgaW4gVVJMXHJcbiAgICAgICAgLy8gLSBTb21lIG9wdGlvbmFsIHBhcmFtZXRlcnMsIHNvbWUgbWF0Y2hlZFxyXG4gICAgICAgIC8vIC0gU29tZSBvcHRpb25hbCBwYXJhbWV0ZXJzLCBhbGwgbWF0Y2hlZFxyXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoUHJpb3JpdHkocGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25hbCA9IHVybE1hdGNoZXIucGFyYW1ldGVycygpLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLmlzT3B0aW9uYWw7IH0pO1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbmFsLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiAwLjAwMDAwMTtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBvcHRpb25hbC5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbXNbcGFyYW0uaWRdOyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQubGVuZ3RoIC8gb3B0aW9uYWwubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGV0YWlscyA9IHsgdXJsTWF0Y2hlcjogdXJsTWF0Y2hlciwgbWF0Y2hQcmlvcml0eTogbWF0Y2hQcmlvcml0eSwgdHlwZTogXCJVUkxNQVRDSEVSXCIgfTtcclxuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKG5ldyBCYXNlVXJsUnVsZShtYXRjaCwgX2hhbmRsZXIpLCBkZXRhaWxzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEEgVXJsUnVsZSB3aGljaCBtYXRjaGVzIGEgc3RhdGUgYnkgaXRzIHVybFxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVN0YXRlKCRzdGF0ZS5nZXQoJ2ZvbycpLCByb3V0ZXIpO1xyXG4gICAgICogdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgnL2Zvby8xMjMvNDU2Jyk7IC8vIHJlc3VsdHMgaW4geyBmb29JZDogJzEyMycsIGJhcklkOiAnNDU2JyB9XHJcbiAgICAgKiB2YXIgcmVzdWx0ID0gcnVsZS5oYW5kbGVyKG1hdGNoKTtcclxuICAgICAqIC8vIFN0YXJ0cyBhIHRyYW5zaXRpb24gdG8gJ2Zvbycgd2l0aCBwYXJhbXM6IHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIFVybFJ1bGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHJvdXRlcikge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgbWF0Y2ggYnkgdHJhbnNpdGlvbmluZyB0byBtYXRjaGVkIHN0YXRlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBGaXJzdCBjaGVja3MgaWYgdGhlIHJvdXRlciBzaG91bGQgc3RhcnQgYSBuZXcgdHJhbnNpdGlvbi5cclxuICAgICAgICAgKiBBIG5ldyB0cmFuc2l0aW9uIGlzIG5vdCByZXF1aXJlZCBpZiB0aGUgY3VycmVudCBzdGF0ZSdzIFVSTFxyXG4gICAgICAgICAqIGFuZCB0aGUgbmV3IFVSTCBhcmUgYWxyZWFkeSBpZGVudGljYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICB2YXIgJHN0YXRlID0gcm91dGVyLnN0YXRlU2VydmljZTtcclxuICAgICAgICAgICAgdmFyIGdsb2JhbHMgPSByb3V0ZXIuZ2xvYmFscztcclxuICAgICAgICAgICAgaWYgKCRzdGF0ZS5ocmVmKHN0YXRlLCBtYXRjaCkgIT09ICRzdGF0ZS5ocmVmKGdsb2JhbHMuY3VycmVudCwgZ2xvYmFscy5wYXJhbXMpKSB7XHJcbiAgICAgICAgICAgICAgICAkc3RhdGUudHJhbnNpdGlvblRvKHN0YXRlLCBtYXRjaCwgeyBpbmhlcml0OiB0cnVlLCBzb3VyY2U6IFwidXJsXCIgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBkZXRhaWxzID0geyBzdGF0ZTogc3RhdGUsIHR5cGU6IFwiU1RBVEVcIiB9O1xyXG4gICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQodGhpcy5mcm9tVXJsTWF0Y2hlcihzdGF0ZS51cmwsIGhhbmRsZXIpLCBkZXRhaWxzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEEgVXJsUnVsZSB3aGljaCBtYXRjaGVzIGJhc2VkIG9uIGEgcmVndWxhciBleHByZXNzaW9uXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGBoYW5kbGVyYCBtYXkgYmUgZWl0aGVyIGEgW1tVcmxSdWxlSGFuZGxlckZuXV0gb3IgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogIyMgSGFuZGxlciBhcyBhIGZ1bmN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogSWYgYGhhbmRsZXJgIGlzIGEgZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGg6XHJcbiAgICAgKlxyXG4gICAgICogLSByZWdleHAgbWF0Y2ggYXJyYXkgKGZyb20gYHJlZ2V4cGApXHJcbiAgICAgKiAtIHVybDogdGhlIGN1cnJlbnQgVXJsIChbW1VybFBhcnRzXV0pXHJcbiAgICAgKiAtIHJvdXRlcjogdGhlIHJvdXRlciBvYmplY3QgKFtbVUlSb3V0ZXJdXSlcclxuICAgICAqXHJcbiAgICAgKiAjIyMjIEV4YW1wbGU6XHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogdmFyIHJ1bGUgPSBmYWN0b3J5LmZyb21SZWdFeHAoL15cXC9mb29cXC8oYmFyfGJheikkLywgbWF0Y2ggPT4gXCIvaG9tZS9cIiArIG1hdGNoWzFdKVxyXG4gICAgICogdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgnL2Zvby9iYXInKTsgLy8gcmVzdWx0cyBpbiBbICcvZm9vL2JhcicsICdiYXInIF1cclxuICAgICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpOyAvLyAnL2hvbWUvYmFyJ1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogIyMgSGFuZGxlciBhcyBzdHJpbmdcclxuICAgICAqXHJcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgYSBzdHJpbmcsIHRoZSB1cmwgaXMgKnJlcGxhY2VkIGJ5IHRoZSBzdHJpbmcqIHdoZW4gdGhlIFJ1bGUgaXMgaW52b2tlZC5cclxuICAgICAqIFRoZSBzdHJpbmcgaXMgZmlyc3QgaW50ZXJwb2xhdGVkIHVzaW5nIGBzdHJpbmcucmVwbGFjZSgpYCBzdHlsZSBwYXR0ZXJuLlxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVJlZ0V4cCgvXlxcL2Zvb1xcLyhiYXJ8YmF6KSQvLCBcIi9ob21lLyQxXCIpXHJcbiAgICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vL2JhcicpOyAvLyByZXN1bHRzIGluIFsgJy9mb28vYmFyJywgJ2JhcicgXVxyXG4gICAgICogdmFyIHJlc3VsdCA9IHJ1bGUuaGFuZGxlcihtYXRjaCk7IC8vICcvaG9tZS9iYXInXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgVXJsUnVsZUZhY3RvcnkucHJvdG90eXBlLmZyb21SZWdFeHAgPSBmdW5jdGlvbiAocmVnZXhwLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKHJlZ2V4cC5nbG9iYWwgfHwgcmVnZXhwLnN0aWNreSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVsZSBSZWdFeHAgbXVzdCBub3QgYmUgZ2xvYmFsIG9yIHN0aWNreVwiKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBoYW5kbGVyIGlzIGEgc3RyaW5nLCB0aGUgdXJsIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIHN0cmluZy5cclxuICAgICAgICAgKiBJZiB0aGUgc3RyaW5nIGhhcyBhbnkgU3RyaW5nLnJlcGxhY2UoKSBzdHlsZSB2YXJpYWJsZXMgaW4gaXQgKGxpa2UgYCQyYCksXHJcbiAgICAgICAgICogdGhleSB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBjYXB0dXJlcyBmcm9tIFtbbWF0Y2hdXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciByZWRpcmVjdFVybFRvID0gZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIC8vIEludGVycG9sYXRlcyBtYXRjaGVkIHZhbHVlcyBpbnRvICQxICQyLCBldGMgdXNpbmcgYSBTdHJpbmcucmVwbGFjZSgpLXN0eWxlIHBhdHRlcm5cclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIucmVwbGFjZSgvXFwkKFxcJHxcXGR7MSwyfSkvLCBmdW5jdGlvbiAobSwgd2hhdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoW3doYXQgPT09ICckJyA/IDAgOiBOdW1iZXIod2hhdCldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBfaGFuZGxlciA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhoYW5kbGVyKSA/IHJlZGlyZWN0VXJsVG8gOiBoYW5kbGVyO1xyXG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZ2V4cC5leGVjKHVybC5wYXRoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBkZXRhaWxzID0geyByZWdleHA6IHJlZ2V4cCwgdHlwZTogXCJSRUdFWFBcIiB9O1xyXG4gICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQobmV3IEJhc2VVcmxSdWxlKG1hdGNoLCBfaGFuZGxlciksIGRldGFpbHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBVcmxSdWxlRmFjdG9yeTtcclxufSgpKTtcclxuVXJsUnVsZUZhY3RvcnkuaXNVcmxSdWxlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiAmJiBbJ3R5cGUnLCAnbWF0Y2gnLCAnaGFuZGxlciddLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0RlZmluZWQob2JqW2tleV0pOyB9KTtcclxufTtcclxuZXhwb3J0cy5VcmxSdWxlRmFjdG9yeSA9IFVybFJ1bGVGYWN0b3J5O1xyXG4vKipcclxuICogQSBiYXNlIHJ1bGUgd2hpY2ggY2FsbHMgYG1hdGNoYFxyXG4gKlxyXG4gKiBUaGUgdmFsdWUgZnJvbSB0aGUgYG1hdGNoYCBmdW5jdGlvbiBpcyBwYXNzZWQgdGhyb3VnaCB0byB0aGUgYGhhbmRsZXJgLlxyXG4gKiBAaW50ZXJuYWxhcGlcclxuICovXHJcbnZhciBCYXNlVXJsUnVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCYXNlVXJsUnVsZShtYXRjaCwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiUkFXXCI7XHJcbiAgICAgICAgdGhpcy5tYXRjaFByaW9yaXR5ID0gZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiAwIC0gX3RoaXMuJGlkOyB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXIgfHwgY29tbW9uXzEuaWRlbnRpdHk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQmFzZVVybFJ1bGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQmFzZVVybFJ1bGUgPSBCYXNlVXJsUnVsZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsUnVsZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsUnVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBAY29yZWFwaVxyXG4gKiBAbW9kdWxlIHVybFxyXG4gKi8gLyoqICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xyXG4vKiogQGhpZGRlbiAqL1xyXG52YXIgbWFrZVN0dWIgPSBmdW5jdGlvbiAoa2V5cykge1xyXG4gICAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkgeyByZXR1cm4gKGFjY1trZXldID0gY29yZXNlcnZpY2VzXzEubm90SW1wbGVtZW50ZWQoa2V5KSwgYWNjKTsgfSwgeyBkaXNwb3NlOiBjb21tb25fMS5ub29wIH0pO1xyXG59O1xyXG4vKiogQGhpZGRlbiAqLyB2YXIgbG9jYXRpb25TZXJ2aWNlc0ZucyA9IFtcInVybFwiLCBcInBhdGhcIiwgXCJzZWFyY2hcIiwgXCJoYXNoXCIsIFwib25DaGFuZ2VcIl07XHJcbi8qKiBAaGlkZGVuICovIHZhciBsb2NhdGlvbkNvbmZpZ0ZucyA9IFtcInBvcnRcIiwgXCJwcm90b2NvbFwiLCBcImhvc3RcIiwgXCJiYXNlSHJlZlwiLCBcImh0bWw1TW9kZVwiLCBcImhhc2hQcmVmaXhcIl07XHJcbi8qKiBAaGlkZGVuICovIHZhciB1bWZGbnMgPSBbXCJ0eXBlXCIsIFwiY2FzZUluc2Vuc2l0aXZlXCIsIFwic3RyaWN0TW9kZVwiLCBcImRlZmF1bHRTcXVhc2hQb2xpY3lcIl07XHJcbi8qKiBAaGlkZGVuICovIHZhciBydWxlc0ZucyA9IFtcInNvcnRcIiwgXCJ3aGVuXCIsIFwiaW5pdGlhbFwiLCBcIm90aGVyd2lzZVwiLCBcInJ1bGVzXCIsIFwicnVsZVwiLCBcInJlbW92ZVJ1bGVcIl07XHJcbi8qKiBAaGlkZGVuICovIHZhciBzeW5jRm5zID0gW1wiZGVmZXJJbnRlcmNlcHRcIiwgXCJsaXN0ZW5cIiwgXCJzeW5jXCIsIFwibWF0Y2hcIl07XHJcbi8qKlxyXG4gKiBBUEkgZm9yIFVSTCBtYW5hZ2VtZW50XHJcbiAqL1xyXG52YXIgVXJsU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgZnVuY3Rpb24gVXJsU2VydmljZShyb3V0ZXIsIGxhdGVCaW5kKSB7XHJcbiAgICAgICAgaWYgKGxhdGVCaW5kID09PSB2b2lkIDApIHsgbGF0ZUJpbmQgPSB0cnVlOyB9XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XHJcbiAgICAgICAgdGhpcy5ydWxlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0ge307XHJcbiAgICAgICAgLy8gcHJveHkgZnVuY3Rpb24gY2FsbHMgZnJvbSBVcmxTZXJ2aWNlIHRvIHRoZSBMb2NhdGlvblNlcnZpY2UvTG9jYXRpb25Db25maWdcclxuICAgICAgICB2YXIgbG9jYXRpb25TZXJ2aWNlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5sb2NhdGlvblNlcnZpY2U7IH07XHJcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnMobG9jYXRpb25TZXJ2aWNlcywgdGhpcywgbG9jYXRpb25TZXJ2aWNlcywgbG9jYXRpb25TZXJ2aWNlc0ZucywgbGF0ZUJpbmQpO1xyXG4gICAgICAgIHZhciBsb2NhdGlvbkNvbmZpZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5sb2NhdGlvbkNvbmZpZzsgfTtcclxuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhsb2NhdGlvbkNvbmZpZywgdGhpcy5jb25maWcsIGxvY2F0aW9uQ29uZmlnLCBsb2NhdGlvbkNvbmZpZ0ZucywgbGF0ZUJpbmQpO1xyXG4gICAgICAgIHZhciB1bWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIudXJsTWF0Y2hlckZhY3Rvcnk7IH07XHJcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnModW1mLCB0aGlzLmNvbmZpZywgdW1mLCB1bWZGbnMpO1xyXG4gICAgICAgIHZhciB1cmxSb3V0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIudXJsUm91dGVyOyB9O1xyXG4gICAgICAgIGNvbW1vbl8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKHVybFJvdXRlciwgdGhpcy5ydWxlcywgdXJsUm91dGVyLCBydWxlc0Zucyk7XHJcbiAgICAgICAgY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnModXJsUm91dGVyLCB0aGlzLCB1cmxSb3V0ZXIsIHN5bmNGbnMpO1xyXG4gICAgfVxyXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24gKG5ld3VybCwgcmVwbGFjZSwgc3RhdGUpIHsgcmV0dXJuOyB9O1xyXG4gICAgO1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICA7XHJcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cclxuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xyXG4gICAgO1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XHJcbiAgICA7XHJcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cclxuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybjsgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGFydHNcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjdXJyZW50IFVSTCBjb21wb25lbnRzIGFzIGEgW1tVcmxQYXJ0c11dIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cmwgcGFydHNcclxuICAgICAqL1xyXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUucGFydHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogdGhpcy5wYXRoKCksIHNlYXJjaDogdGhpcy5zZWFyY2goKSwgaGFzaDogdGhpcy5oYXNoKCkgfTtcclxuICAgIH07XHJcbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKGV2dCkgeyByZXR1cm47IH07XHJcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cclxuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChlbmFibGVkKSB7IHJldHVybjsgfTtcclxuICAgIDtcclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUuZGVmZXJJbnRlcmNlcHQgPSBmdW5jdGlvbiAoZGVmZXIpIHsgcmV0dXJuOyB9O1xyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICh1cmxQYXJ0cykgeyByZXR1cm47IH07XHJcbiAgICByZXR1cm4gVXJsU2VydmljZTtcclxufSgpKTtcclxuLyoqIEBoaWRkZW4gKi9cclxuVXJsU2VydmljZS5sb2NhdGlvblNlcnZpY2VTdHViID0gbWFrZVN0dWIobG9jYXRpb25TZXJ2aWNlc0Zucyk7XHJcbi8qKiBAaGlkZGVuICovXHJcblVybFNlcnZpY2UubG9jYXRpb25Db25maWdTdHViID0gbWFrZVN0dWIobG9jYXRpb25Db25maWdGbnMpO1xyXG5leHBvcnRzLlVybFNlcnZpY2UgPSBVcmxTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmxTZXJ2aWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQGludGVybmFsYXBpXHJcbiAqIEBtb2R1bGUgdmFuaWxsYVxyXG4gKi9cclxuLyoqICovXHJcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XHJcbi8qKiBBIGBMb2NhdGlvbkNvbmZpZ2AgdGhhdCBkZWxlZ2F0ZXMgdG8gdGhlIGJyb3dzZXIncyBgbG9jYXRpb25gIG9iamVjdCAqL1xyXG52YXIgQnJvd3NlckxvY2F0aW9uQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJyb3dzZXJMb2NhdGlvbkNvbmZpZyhyb3V0ZXIsIF9pc0h0bWw1KSB7XHJcbiAgICAgICAgaWYgKF9pc0h0bWw1ID09PSB2b2lkIDApIHsgX2lzSHRtbDUgPSBmYWxzZTsgfVxyXG4gICAgICAgIHRoaXMuX2lzSHRtbDUgPSBfaXNIdG1sNTtcclxuICAgICAgICB0aGlzLl9iYXNlSHJlZiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9oYXNoUHJlZml4ID0gXCJcIjtcclxuICAgIH1cclxuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUucG9ydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobG9jYXRpb24ucG9ydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKGxvY2F0aW9uLnBvcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbCgpID09PSAnaHR0cHMnID8gNDQzIDogODA7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5wcm90b2NvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wucmVwbGFjZSgvOi9nLCAnJyk7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5ob3N0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5ob3N0O1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuaHRtbDVNb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0h0bWw1O1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuaGFzaFByZWZpeCA9IGZ1bmN0aW9uIChuZXdwcmVmaXgpIHtcclxuICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRGVmaW5lZChuZXdwcmVmaXgpID8gdGhpcy5faGFzaFByZWZpeCA9IG5ld3ByZWZpeCA6IHRoaXMuX2hhc2hQcmVmaXg7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5iYXNlSHJlZiA9IGZ1bmN0aW9uIChocmVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0RlZmluZWQoaHJlZikgPyB0aGlzLl9iYXNlSHJlZiA9IGhyZWYgOiB0aGlzLl9iYXNlSHJlZiB8fCB0aGlzLmFwcGx5RG9jdW1lbnRCYXNlSHJlZigpO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuYXBwbHlEb2N1bWVudEJhc2VIcmVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiYXNlVGFncyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYmFzZVwiKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYmFzZUhyZWYgPSBiYXNlVGFncy5sZW5ndGggPyBiYXNlVGFnc1swXS5ocmVmLnN1YnN0cihsb2NhdGlvbi5vcmlnaW4ubGVuZ3RoKSA6IFwiXCI7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgcmV0dXJuIEJyb3dzZXJMb2NhdGlvbkNvbmZpZztcclxufSgpKTtcclxuZXhwb3J0cy5Ccm93c2VyTG9jYXRpb25Db25maWcgPSBCcm93c2VyTG9jYXRpb25Db25maWc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXJMb2NhdGlvbkNvbmZpZy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2Jyb3dzZXJMb2NhdGlvbkNvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxhcGlcclxuICogQG1vZHVsZSB2YW5pbGxhXHJcbiAqL1xyXG4vKiogKi9cclxudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcclxudmFyIGJhc2VMb2NhdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2Jhc2VMb2NhdGlvblNlcnZpY2VcIik7XHJcbi8qKiBBIGBMb2NhdGlvblNlcnZpY2VzYCB0aGF0IHVzZXMgdGhlIGJyb3dzZXIgaGFzaCBcIiNcIiB0byBnZXQvc2V0IHRoZSBjdXJyZW50IGxvY2F0aW9uICovXHJcbnZhciBIYXNoTG9jYXRpb25TZXJ2aWNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhIYXNoTG9jYXRpb25TZXJ2aWNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSGFzaExvY2F0aW9uU2VydmljZShyb3V0ZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb3V0ZXIsIGZhbHNlKSB8fCB0aGlzO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgX3RoaXMuX2xpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgSGFzaExvY2F0aW9uU2VydmljZS5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdXRpbHNfMS50cmltSGFzaFZhbCh0aGlzLl9sb2NhdGlvbi5oYXNoKTtcclxuICAgIH07XHJcbiAgICBIYXNoTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsLCByZXBsYWNlKSB7XHJcbiAgICAgICAgdGhpcy5fbG9jYXRpb24uaGFzaCA9IHVybDtcclxuICAgIH07XHJcbiAgICBIYXNoTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMsIHJvdXRlcik7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9saXN0ZW5lcik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhhc2hMb2NhdGlvblNlcnZpY2U7XHJcbn0oYmFzZUxvY2F0aW9uU2VydmljZV8xLkJhc2VMb2NhdGlvblNlcnZpY2VzKSk7XHJcbmV4cG9ydHMuSGFzaExvY2F0aW9uU2VydmljZSA9IEhhc2hMb2NhdGlvblNlcnZpY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2hMb2NhdGlvblNlcnZpY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9oYXNoTG9jYXRpb25TZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQGludGVybmFsYXBpXHJcbiAqIEBtb2R1bGUgdmFuaWxsYVxyXG4gKi9cclxuLyoqICovXHJcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9pbmRleFwiKTtcclxuLy8gZ2xvYmFsbHkgYXZhaWxhYmxlIGluamVjdGFibGVzXHJcbnZhciBnbG9iYWxzID0ge307XHJcbnZhciBTVFJJUF9DT01NRU5UUyA9IC8oKFxcL1xcLy4qJCl8KFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pKS9tZztcclxudmFyIEFSR1VNRU5UX05BTUVTID0gLyhbXlxccyxdKykvZztcclxuLyoqXHJcbiAqIEEgYmFzaWMgYW5ndWxhcjEtbGlrZSBpbmplY3RvciBhcGlcclxuICpcclxuICogVGhpcyBvYmplY3QgaW1wbGVtZW50cyBmb3VyIG1ldGhvZHMgc2ltaWxhciB0byB0aGVcclxuICogW2FuZ3VsYXIgMSBkZXBlbmRlbmN5IGluamVjdG9yXShodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvYXV0by9zZXJ2aWNlLyRpbmplY3RvcilcclxuICpcclxuICogVUktUm91dGVyIGV2b2x2ZWQgZnJvbSBhbiBhbmd1bGFyIDEgbGlicmFyeSB0byBhIGZyYW1ld29yayBhZ25vc3RpYyBsaWJyYXJ5LlxyXG4gKiBIb3dldmVyLCBzb21lIG9mIHRoZSBgQHVpcm91dGVyL2NvcmVgIGNvZGUgdXNlcyB0aGVzZSBuZzEgc3R5bGUgQVBJcyB0byBzdXBwb3J0IG5nMSBzdHlsZSBkZXBlbmRlbmN5IGluamVjdGlvbi5cclxuICpcclxuICogVGhpcyBvYmplY3QgcHJvdmlkZXMgYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGdsb2JhbGx5IHNjb3BlZCBkZXBlbmRlbmN5IGluamVjdGlvbiBzeXN0ZW0uXHJcbiAqIEl0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgREkgYXBwcm9hY2hlczpcclxuICpcclxuICogIyMjIEZ1bmN0aW9uIHBhcmFtZXRlciBuYW1lc1xyXG4gKlxyXG4gKiBBIGZ1bmN0aW9uJ3MgYC50b1N0cmluZygpYCBpcyBjYWxsZWQsIGFuZCB0aGUgcGFyYW1ldGVyIG5hbWVzIGFyZSBwYXJzZWQuXHJcbiAqIFRoaXMgb25seSB3b3JrcyB3aGVuIHRoZSBwYXJhbWV0ZXIgbmFtZXMgYXJlbid0IFwibWFuZ2xlZFwiIGJ5IGEgbWluaWZpZXIgc3VjaCBhcyBVZ2xpZnlKUy5cclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gaW5qZWN0ZWRGdW5jdGlvbihGb29TZXJ2aWNlLCBCYXJTZXJ2aWNlKSB7XHJcbiAqICAgLy8gRm9vU2VydmljZSBhbmQgQmFyU2VydmljZSBhcmUgaW5qZWN0ZWRcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogIyMjIEZ1bmN0aW9uIGFubm90YXRpb25cclxuICpcclxuICogQSBmdW5jdGlvbiBtYXkgYmUgYW5ub3RhdGVkIHdpdGggYW4gYXJyYXkgb2YgZGVwZW5kZW5jeSBuYW1lcyBhcyB0aGUgYCRpbmplY3RgIHByb3BlcnR5LlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpbmplY3RlZEZ1bmN0aW9uLiRpbmplY3QgPSBbICdGb29TZXJ2aWNlJywgJ0JhclNlcnZpY2UnIF07XHJcbiAqIGZ1bmN0aW9uIGluamVjdGVkRnVuY3Rpb24oZnMsIGJzKSB7XHJcbiAqICAgLy8gRm9vU2VydmljZSBhbmQgQmFyU2VydmljZSBhcmUgaW5qZWN0ZWQgYXMgZnMgYW5kIGJzIHBhcmFtZXRlcnNcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogIyMjIEFycmF5IG5vdGF0aW9uXHJcbiAqXHJcbiAqIEFuIGFycmF5IHByb3ZpZGVzIHRoZSBuYW1lcyBvZiB0aGUgZGVwZW5kZW5jaWVzIHRvIGluamVjdCAoYXMgc3RyaW5ncykuXHJcbiAqIFRoZSBmdW5jdGlvbiBpcyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBhcnJheS5cclxuICpcclxuICogYGBganNcclxuICogWyAnRm9vU2VydmljZScsICdCYXJTZXJ2aWNlJywgZnVuY3Rpb24gKGZzLCBicykge1xyXG4gKiAgIC8vIEZvb1NlcnZpY2UgYW5kIEJhclNlcnZpY2UgYXJlIGluamVjdGVkIGFzIGZzIGFuZCBicyBwYXJhbWV0ZXJzXHJcbiAqIH1dXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAdHlwZSB7JEluamVjdG9yTGlrZX1cclxuICovXHJcbmV4cG9ydHMuJGluamVjdG9yID0ge1xyXG4gICAgLyoqIEdldHMgYW4gb2JqZWN0IGZyb20gREkgYmFzZWQgb24gYSBzdHJpbmcgdG9rZW4gKi9cclxuICAgIGdldDogZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGdsb2JhbHNbbmFtZV07IH0sXHJcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIGFuIG9iamVjdCBuYW1lZCBgbmFtZWAgZXhpc3RzIGluIGdsb2JhbCBESSAqL1xyXG4gICAgaGFzOiBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZXhwb3J0cy4kaW5qZWN0b3IuZ2V0KG5hbWUpICE9IG51bGw7IH0sXHJcbiAgICAvKipcclxuICAgICAqIEluamVjdHMgYSBmdW5jdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmbiB0aGUgZnVuY3Rpb24gdG8gaW5qZWN0XHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCB0aGUgZnVuY3Rpb24ncyBgdGhpc2AgYmluZGluZ1xyXG4gICAgICogQHBhcmFtIGxvY2FscyBBbiBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIERJIHRva2VucyBhbmQgdmFsdWVzLCBzdWNoIGFzIGB7IHNvbWVUb2tlbjogeyBmb286IDEgfSB9YFxyXG4gICAgICovXHJcbiAgICBpbnZva2U6IGZ1bmN0aW9uIChmbiwgY29udGV4dCwgbG9jYWxzKSB7XHJcbiAgICAgICAgdmFyIGFsbCA9IGluZGV4XzEuZXh0ZW5kKHt9LCBnbG9iYWxzLCBsb2NhbHMgfHwge30pO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBleHBvcnRzLiRpbmplY3Rvci5hbm5vdGF0ZShmbik7XHJcbiAgICAgICAgdmFyIGVuc3VyZUV4aXN0ID0gaW5kZXhfMS5hc3NlcnRQcmVkaWNhdGUoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYWxsLmhhc093blByb3BlcnR5KGtleSk7IH0sIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFwiREkgY2FuJ3QgZmluZCBpbmplY3RhYmxlOiAnXCIgKyBrZXkgKyBcIidcIjsgfSk7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBwYXJhbXMuZmlsdGVyKGVuc3VyZUV4aXN0KS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGFsbFt4XTsgfSk7XHJcbiAgICAgICAgaWYgKGluZGV4XzEuaXNGdW5jdGlvbihmbikpXHJcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmbi5zbGljZSgtMSlbMF0uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24ncyBkZXBlbmRlbmNpZXNcclxuICAgICAqXHJcbiAgICAgKiBBbmFseXplcyBhIGZ1bmN0aW9uIChvciBhcnJheSkgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgREkgdG9rZW5zIHRoYXQgdGhlIGZ1bmN0aW9uIHJlcXVpcmVzLlxyXG4gICAgICogQHJldHVybiBhbiBhcnJheSBvZiBgc3RyaW5nYHNcclxuICAgICAqL1xyXG4gICAgYW5ub3RhdGU6IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIGlmICghaW5kZXhfMS5pc0luamVjdGFibGUoZm4pKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYW4gaW5qZWN0YWJsZSBmdW5jdGlvbjogXCIgKyBmbik7XHJcbiAgICAgICAgaWYgKGZuICYmIGZuLiRpbmplY3QpXHJcbiAgICAgICAgICAgIHJldHVybiBmbi4kaW5qZWN0O1xyXG4gICAgICAgIGlmIChpbmRleF8xLmlzQXJyYXkoZm4pKVxyXG4gICAgICAgICAgICByZXR1cm4gZm4uc2xpY2UoMCwgLTEpO1xyXG4gICAgICAgIHZhciBmblN0ciA9IGZuLnRvU3RyaW5nKCkucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBmblN0ci5zbGljZShmblN0ci5pbmRleE9mKCcoJykgKyAxLCBmblN0ci5pbmRleE9mKCcpJykpLm1hdGNoKEFSR1VNRU5UX05BTUVTKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IFtdO1xyXG4gICAgfVxyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3Rvci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2luamVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xyXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcclxuLyoqIEEgYExvY2F0aW9uQ29uZmlnYCBtb2NrIHRoYXQgZ2V0cy9zZXRzIGFsbCBjb25maWcgZnJvbSBhbiBpbi1tZW1vcnkgb2JqZWN0ICovXHJcbnZhciBNZW1vcnlMb2NhdGlvbkNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZW1vcnlMb2NhdGlvbkNvbmZpZygpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2Jhc2VIcmVmID0gJyc7XHJcbiAgICAgICAgdGhpcy5fcG9ydCA9IDgwO1xyXG4gICAgICAgIHRoaXMuX3Byb3RvY29sID0gXCJodHRwXCI7XHJcbiAgICAgICAgdGhpcy5faG9zdCA9IFwibG9jYWxob3N0XCI7XHJcbiAgICAgICAgdGhpcy5faGFzaFByZWZpeCA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5wb3J0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3BvcnQ7IH07XHJcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9wcm90b2NvbDsgfTtcclxuICAgICAgICB0aGlzLmhvc3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faG9zdDsgfTtcclxuICAgICAgICB0aGlzLmJhc2VIcmVmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2Jhc2VIcmVmOyB9O1xyXG4gICAgICAgIHRoaXMuaHRtbDVNb2RlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XHJcbiAgICAgICAgdGhpcy5oYXNoUHJlZml4ID0gZnVuY3Rpb24gKG5ld3ZhbCkgeyByZXR1cm4gcHJlZGljYXRlc18xLmlzRGVmaW5lZChuZXd2YWwpID8gX3RoaXMuX2hhc2hQcmVmaXggPSBuZXd2YWwgOiBfdGhpcy5faGFzaFByZWZpeDsgfTtcclxuICAgICAgICB0aGlzLmRpc3Bvc2UgPSBjb21tb25fMS5ub29wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1lbW9yeUxvY2F0aW9uQ29uZmlnO1xyXG59KCkpO1xyXG5leHBvcnRzLk1lbW9yeUxvY2F0aW9uQ29uZmlnID0gTWVtb3J5TG9jYXRpb25Db25maWc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9yeUxvY2F0aW9uQ29uZmlnLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvbWVtb3J5TG9jYXRpb25Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQGludGVybmFsYXBpXHJcbiAqIEBtb2R1bGUgdmFuaWxsYVxyXG4gKi9cclxuLyoqICovXHJcbnZhciBiYXNlTG9jYXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9iYXNlTG9jYXRpb25TZXJ2aWNlXCIpO1xyXG4vKiogQSBgTG9jYXRpb25TZXJ2aWNlc2AgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gZnJvbSBhbiBpbi1tZW1vcnkgb2JqZWN0ICovXHJcbnZhciBNZW1vcnlMb2NhdGlvblNlcnZpY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1lbW9yeUxvY2F0aW9uU2VydmljZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1lbW9yeUxvY2F0aW9uU2VydmljZShyb3V0ZXIpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgcm91dGVyLCB0cnVlKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgTWVtb3J5TG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91cmw7XHJcbiAgICB9O1xyXG4gICAgTWVtb3J5TG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsLCByZXBsYWNlKSB7XHJcbiAgICAgICAgdGhpcy5fdXJsID0gdXJsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNZW1vcnlMb2NhdGlvblNlcnZpY2U7XHJcbn0oYmFzZUxvY2F0aW9uU2VydmljZV8xLkJhc2VMb2NhdGlvblNlcnZpY2VzKSk7XHJcbmV4cG9ydHMuTWVtb3J5TG9jYXRpb25TZXJ2aWNlID0gTWVtb3J5TG9jYXRpb25TZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW1vcnlMb2NhdGlvblNlcnZpY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9tZW1vcnlMb2NhdGlvblNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xyXG52YXIgYmFzZUxvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vYmFzZUxvY2F0aW9uU2VydmljZVwiKTtcclxuLyoqXHJcbiAqIEEgYExvY2F0aW9uU2VydmljZXNgIHRoYXQgZ2V0cy9zZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIHVzaW5nIHRoZSBicm93c2VyJ3MgYGxvY2F0aW9uYCBhbmQgYGhpc3RvcnlgIGFwaXNcclxuICpcclxuICogVXNlcyBgaGlzdG9yeS5wdXNoU3RhdGVgIGFuZCBgaGlzdG9yeS5yZXBsYWNlU3RhdGVgXHJcbiAqL1xyXG52YXIgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2Uocm91dGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcm91dGVyLCB0cnVlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9jb25maWcgPSByb3V0ZXIudXJsU2VydmljZS5jb25maWc7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBfdGhpcy5fbGlzdGVuZXIsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLl9nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fbG9jYXRpb24sIHBhdGhuYW1lID0gX2EucGF0aG5hbWUsIGhhc2ggPSBfYS5oYXNoLCBzZWFyY2ggPSBfYS5zZWFyY2g7XHJcbiAgICAgICAgc2VhcmNoID0gdXRpbHNfMS5zcGxpdFF1ZXJ5KHNlYXJjaClbMV07IC8vIHN0cmlwID8gaWYgZm91bmRcclxuICAgICAgICBoYXNoID0gdXRpbHNfMS5zcGxpdEhhc2goaGFzaClbMV07IC8vIHN0cmlwICMgaWYgZm91bmRcclxuICAgICAgICByZXR1cm4gcGF0aG5hbWUgKyAoc2VhcmNoID8gXCI/XCIgKyBzZWFyY2ggOiBcIlwiKSArIChoYXNoID8gXCIkXCIgKyBzZWFyY2ggOiBcIlwiKTtcclxuICAgIH07XHJcbiAgICBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwsIHJlcGxhY2UpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfY29uZmlnID0gX2EuX2NvbmZpZywgX2hpc3RvcnkgPSBfYS5faGlzdG9yeTtcclxuICAgICAgICB2YXIgZnVsbFVybCA9IF9jb25maWcuYmFzZUhyZWYoKSArIHVybDtcclxuICAgICAgICBpZiAocmVwbGFjZSkge1xyXG4gICAgICAgICAgICBfaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCBmdWxsVXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIGZ1bGxVcmwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAocm91dGVyKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcywgcm91dGVyKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMuX2xpc3RlbmVyKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlO1xyXG59KGJhc2VMb2NhdGlvblNlcnZpY2VfMS5CYXNlTG9jYXRpb25TZXJ2aWNlcykpO1xyXG5leHBvcnRzLlB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZSA9IFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvcHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQGludGVybmFsYXBpXHJcbiAqIEBtb2R1bGUgdmFuaWxsYVxyXG4gKi9cclxuLyoqICovXHJcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9pbmRleFwiKTtcclxuLyoqXHJcbiAqIEFuIGFuZ3VsYXIxLWxpa2UgcHJvbWlzZSBhcGlcclxuICpcclxuICogVGhpcyBvYmplY3QgaW1wbGVtZW50cyBmb3VyIG1ldGhvZHMgc2ltaWxhciB0byB0aGVcclxuICogW2FuZ3VsYXIgMSBwcm9taXNlIGFwaV0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nL3NlcnZpY2UvJHEpXHJcbiAqXHJcbiAqIFVJLVJvdXRlciBldm9sdmVkIGZyb20gYW4gYW5ndWxhciAxIGxpYnJhcnkgdG8gYSBmcmFtZXdvcmsgYWdub3N0aWMgbGlicmFyeS5cclxuICogSG93ZXZlciwgc29tZSBvZiB0aGUgYEB1aXJvdXRlci9jb3JlYCBjb2RlIHVzZXMgdGhlc2UgbmcxIHN0eWxlIEFQSXMgdG8gc3VwcG9ydCBuZzEgc3R5bGUgZGVwZW5kZW5jeSBpbmplY3Rpb24uXHJcbiAqXHJcbiAqIFRoaXMgQVBJIHByb3ZpZGVzIG5hdGl2ZSBFUzYgcHJvbWlzZSBzdXBwb3J0IHdyYXBwZWQgYXMgYSAkcS1saWtlIEFQSS5cclxuICogSW50ZXJuYWxseSwgVUktUm91dGVyIHVzZXMgdGhpcyAkcSBvYmplY3QgdG8gcGVyZm9ybSBwcm9taXNlIG9wZXJhdGlvbnMuXHJcbiAqIFRoZSBgYW5ndWxhci11aS1yb3V0ZXJgICh1aS1yb3V0ZXIgZm9yIGFuZ3VsYXIgMSkgdXNlcyB0aGUgJHEgQVBJIHByb3ZpZGVkIGJ5IGFuZ3VsYXIuXHJcbiAqXHJcbiAqICRxLWxpa2UgcHJvbWlzZSBhcGlcclxuICovXHJcbmV4cG9ydHMuJHEgPSB7XHJcbiAgICAvKiogTm9ybWFsaXplcyBhIHZhbHVlIGFzIGEgcHJvbWlzZSAqL1xyXG4gICAgd2hlbjogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyByZXR1cm4gcmVzb2x2ZSh2YWwpOyB9KTsgfSxcclxuICAgIC8qKiBOb3JtYWxpemVzIGEgdmFsdWUgYXMgYSBwcm9taXNlIHJlamVjdGlvbiAqL1xyXG4gICAgcmVqZWN0OiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHJlamVjdCh2YWwpOyB9KTsgfSxcclxuICAgIC8qKiBAcmV0dXJucyBhIGRlZmVycmVkIG9iamVjdCwgd2hpY2ggaGFzIGByZXNvbHZlYCBhbmQgYHJlamVjdGAgZnVuY3Rpb25zICovXHJcbiAgICBkZWZlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHt9O1xyXG4gICAgICAgIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xyXG4gICAgfSxcclxuICAgIC8qKiBMaWtlIFByb21pc2UuYWxsKCksIGJ1dCBhbHNvIHN1cHBvcnRzIG9iamVjdCBrZXkvcHJvbWlzZSBub3RhdGlvbiBsaWtlICRxICovXHJcbiAgICBhbGw6IGZ1bmN0aW9uIChwcm9taXNlcykge1xyXG4gICAgICAgIGlmIChpbmRleF8xLmlzQXJyYXkocHJvbWlzZXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmRleF8xLmlzT2JqZWN0KHByb21pc2VzKSkge1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHByb21pc2VzIG1hcCB0byBwcm9taXNlcyBhcnJheS5cclxuICAgICAgICAgICAgLy8gV2hlbiBlYWNoIHByb21pc2UgcmVzb2x2ZXMsIG1hcCBpdCB0byBhIHR1cGxlIHsga2V5OiBrZXksIHZhbDogdmFsIH1cclxuICAgICAgICAgICAgdmFyIGNoYWluID0gT2JqZWN0LmtleXMocHJvbWlzZXMpXHJcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHByb21pc2VzW2tleV0udGhlbihmdW5jdGlvbiAodmFsKSB7IHJldHVybiAoeyBrZXk6IGtleSwgdmFsOiB2YWwgfSk7IH0pOyB9KTtcclxuICAgICAgICAgICAgLy8gVGhlbiB3YWl0IGZvciBhbGwgcHJvbWlzZXMgdG8gcmVzb2x2ZSwgYW5kIGNvbnZlcnQgdGhlbSBiYWNrIHRvIGFuIG9iamVjdFxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy4kcS5hbGwoY2hhaW4pLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdHVwbGUpIHsgYWNjW3R1cGxlLmtleV0gPSB0dXBsZS52YWw7IHJldHVybiBhY2M7IH0sIHt9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1xLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvcS5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEBjb3JlYXBpXHJcbiAqIEBtb2R1bGUgdmlld1xyXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xyXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcclxudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcclxudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xyXG4vKipcclxuICogVGhlIFZpZXcgc2VydmljZVxyXG4gKlxyXG4gKiBUaGlzIHNlcnZpY2UgcGFpcnMgZXhpc3RpbmcgYHVpLXZpZXdgIGNvbXBvbmVudHMgKHdoaWNoIGxpdmUgaW4gdGhlIERPTSlcclxuICogd2l0aCB2aWV3IGNvbmZpZ3MgKGZyb20gdGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdHM6IFtbU3RhdGVEZWNsYXJhdGlvbi52aWV3c11dKS5cclxuICpcclxuICogLSBBZnRlciBhIHN1Y2Nlc3NmdWwgVHJhbnNpdGlvbiwgdGhlIHZpZXdzIGZyb20gdGhlIG5ld2x5IGVudGVyZWQgc3RhdGVzIGFyZSBhY3RpdmF0ZWQgdmlhIFtbYWN0aXZhdGVWaWV3Q29uZmlnXV0uXHJcbiAqICAgVGhlIHZpZXdzIGZyb20gZXhpdGVkIHN0YXRlcyBhcmUgZGVhY3RpdmF0ZWQgdmlhIFtbZGVhY3RpdmF0ZVZpZXdDb25maWddXS5cclxuICogICAoU2VlOiB0aGUgW1tyZWdpc3RlckFjdGl2YXRlVmlld3NdXSBUcmFuc2l0aW9uIEhvb2spXHJcbiAqXHJcbiAqIC0gQXMgYHVpLXZpZXdgIGNvbXBvbmVudHMgcG9wIGluIGFuZCBvdXQgb2YgZXhpc3RlbmNlLCB0aGV5IHJlZ2lzdGVyIHRoZW1zZWx2ZXMgdXNpbmcgW1tyZWdpc3RlclVJVmlld11dLlxyXG4gKlxyXG4gKiAtIFdoZW4gdGhlIFtbc3luY11dIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHJlZ2lzdGVyZWQgYHVpLXZpZXdgKHMpIChbW0FjdGl2ZVVJVmlld11dKVxyXG4gKiBhcmUgY29uZmlndXJlZCB3aXRoIHRoZSBtYXRjaGluZyBbW1ZpZXdDb25maWddXShzKVxyXG4gKlxyXG4gKi9cclxudmFyIFZpZXdTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZpZXdTZXJ2aWNlKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fdWlWaWV3cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdDb25maWdzID0gW107XHJcbiAgICAgICAgdGhpcy5fdmlld0NvbmZpZ0ZhY3RvcmllcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3BsdWdpbmFwaSA9IHtcclxuICAgICAgICAgICAgX3Jvb3RWaWV3Q29udGV4dDogdGhpcy5fcm9vdFZpZXdDb250ZXh0LmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIF92aWV3Q29uZmlnRmFjdG9yeTogdGhpcy5fdmlld0NvbmZpZ0ZhY3RvcnkuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgX3JlZ2lzdGVyZWRVSVZpZXdzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdWlWaWV3czsgfSxcclxuICAgICAgICAgICAgX2FjdGl2ZVZpZXdDb25maWdzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdmlld0NvbmZpZ3M7IH0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5fcm9vdFZpZXdDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdENvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuX3Jvb3RDb250ZXh0O1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5fdmlld0NvbmZpZ0ZhY3RvcnkgPSBmdW5jdGlvbiAodmlld1R5cGUsIGZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLl92aWV3Q29uZmlnRmFjdG9yaWVzW3ZpZXdUeXBlXSA9IGZhY3Rvcnk7XHJcbiAgICB9O1xyXG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLmNyZWF0ZVZpZXdDb25maWcgPSBmdW5jdGlvbiAocGF0aCwgZGVjbCkge1xyXG4gICAgICAgIHZhciBjZmdGYWN0b3J5ID0gdGhpcy5fdmlld0NvbmZpZ0ZhY3Rvcmllc1tkZWNsLiR0eXBlXTtcclxuICAgICAgICBpZiAoIWNmZ0ZhY3RvcnkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZpZXdTZXJ2aWNlOiBObyB2aWV3IGNvbmZpZyBmYWN0b3J5IHJlZ2lzdGVyZWQgZm9yIHR5cGUgXCIgKyBkZWNsLiR0eXBlKTtcclxuICAgICAgICB2YXIgY2ZncyA9IGNmZ0ZhY3RvcnkocGF0aCwgZGVjbCk7XHJcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0FycmF5KGNmZ3MpID8gY2ZncyA6IFtjZmdzXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlYWN0aXZhdGVzIGEgVmlld0NvbmZpZy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRlYWN0aXZhdGVzIGEgYFZpZXdDb25maWdgLlxyXG4gICAgICogQWZ0ZXIgY2FsbGluZyBbW3N5bmNdXSwgaXQgd2lsbCB1bi1wYWlyIGZyb20gYW55IGB1aS12aWV3YCB3aXRoIHdoaWNoIGl0IGlzIGN1cnJlbnRseSBwYWlyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZpZXdDb25maWcgVGhlIFZpZXdDb25maWcgdmlldyB0byBkZXJlZ2lzdGVyLlxyXG4gICAgICovXHJcbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuZGVhY3RpdmF0ZVZpZXdDb25maWcgPSBmdW5jdGlvbiAodmlld0NvbmZpZykge1xyXG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZUV2ZW50KFwiPC0gUmVtb3ZpbmdcIiwgdmlld0NvbmZpZyk7XHJcbiAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh0aGlzLl92aWV3Q29uZmlncywgdmlld0NvbmZpZyk7XHJcbiAgICB9O1xyXG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLmFjdGl2YXRlVmlld0NvbmZpZyA9IGZ1bmN0aW9uICh2aWV3Q29uZmlnKSB7XHJcbiAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVZpZXdTZXJ2aWNlRXZlbnQoXCItPiBSZWdpc3RlcmluZ1wiLCB2aWV3Q29uZmlnKTtcclxuICAgICAgICB0aGlzLl92aWV3Q29uZmlncy5wdXNoKHZpZXdDb25maWcpO1xyXG4gICAgfTtcclxuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHVpVmlld3NCeUZxbiA9IHRoaXMuX3VpVmlld3MubWFwKGZ1bmN0aW9uICh1aXYpIHsgcmV0dXJuIFt1aXYuZnFuLCB1aXZdOyB9KS5yZWR1Y2UoY29tbW9uXzEuYXBwbHlQYWlycywge30pO1xyXG4gICAgICAgIC8vIFJldHVybiBhIHdlaWdodGVkIGRlcHRoIHZhbHVlIGZvciBhIHVpVmlldy5cclxuICAgICAgICAvLyBUaGUgZGVwdGggaXMgdGhlIG5lc3RpbmcgZGVwdGggb2YgdWktdmlld3MgKGJhc2VkIG9uIEZRTjsgdGltZXMgMTAsMDAwKVxyXG4gICAgICAgIC8vIHBsdXMgdGhlIGRlcHRoIG9mIHRoZSBzdGF0ZSB0aGF0IGlzIHBvcHVsYXRpbmcgdGhlIHVpVmlld1xyXG4gICAgICAgIGZ1bmN0aW9uIHVpVmlld0RlcHRoKHVpVmlldykge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGVEZXB0aCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dCAmJiBjb250ZXh0LnBhcmVudCA/IHN0YXRlRGVwdGgoY29udGV4dC5wYXJlbnQpICsgMSA6IDE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiAodWlWaWV3LmZxbi5zcGxpdChcIi5cIikubGVuZ3RoICogMTAwMDApICsgc3RhdGVEZXB0aCh1aVZpZXcuY3JlYXRpb25Db250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBWaWV3Q29uZmlnJ3MgY29udGV4dCdzIGRlcHRoIGluIHRoZSBjb250ZXh0IHRyZWUuXHJcbiAgICAgICAgZnVuY3Rpb24gdmlld0NvbmZpZ0RlcHRoKGNvbmZpZykge1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbmZpZy52aWV3RGVjbC4kY29udGV4dCwgY291bnQgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAoKytjb3VudCAmJiBjb250ZXh0LnBhcmVudClcclxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcclxuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHaXZlbiBhIGRlcHRoIGZ1bmN0aW9uLCByZXR1cm5zIGEgY29tcGFyZSBmdW5jdGlvbiB3aGljaCBjYW4gcmV0dXJuIGVpdGhlciBhc2NlbmRpbmcgb3IgZGVzY2VuZGluZyBvcmRlclxyXG4gICAgICAgIHZhciBkZXB0aENvbXBhcmUgPSBob2ZfMS5jdXJyeShmdW5jdGlvbiAoZGVwdGhGbiwgcG9zTmVnLCBsZWZ0LCByaWdodCkgeyByZXR1cm4gcG9zTmVnICogKGRlcHRoRm4obGVmdCkgLSBkZXB0aEZuKHJpZ2h0KSk7IH0pO1xyXG4gICAgICAgIHZhciBtYXRjaGluZ0NvbmZpZ1BhaXIgPSBmdW5jdGlvbiAodWlWaWV3KSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ0NvbmZpZ3MgPSBfdGhpcy5fdmlld0NvbmZpZ3MuZmlsdGVyKFZpZXdTZXJ2aWNlLm1hdGNoZXModWlWaWV3c0J5RnFuLCB1aVZpZXcpKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nQ29uZmlncy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIE9LLiAgQ2hpbGQgc3RhdGVzIGNhbiB0YXJnZXQgYSB1aS12aWV3IHRoYXQgdGhlIHBhcmVudCBzdGF0ZSBhbHNvIHRhcmdldHMgKHRoZSBjaGlsZCB3aW5zKVxyXG4gICAgICAgICAgICAgICAgLy8gU29ydCBieSBkZXB0aCBhbmQgcmV0dXJuIHRoZSBtYXRjaCBmcm9tIHRoZSBkZWVwZXN0IGNoaWxkXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgTXVsdGlwbGUgbWF0Y2hpbmcgdmlldyBjb25maWdzIGZvciAke3VpVmlldy5mcW59YCwgbWF0Y2hpbmdDb25maWdzKTtcclxuICAgICAgICAgICAgICAgIG1hdGNoaW5nQ29uZmlncy5zb3J0KGRlcHRoQ29tcGFyZSh2aWV3Q29uZmlnRGVwdGgsIC0xKSk7IC8vIGRlc2NlbmRpbmdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW3VpVmlldywgbWF0Y2hpbmdDb25maWdzWzBdXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBjb25maWd1cmVVSVZpZXcgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIHVpVmlldyA9IF9hWzBdLCB2aWV3Q29uZmlnID0gX2FbMV07XHJcbiAgICAgICAgICAgIC8vIElmIGEgcGFyZW50IHVpLXZpZXcgaXMgcmVjb25maWd1cmVkLCBpdCBjb3VsZCBkZXN0cm95IGNoaWxkIHVpLXZpZXdzLlxyXG4gICAgICAgICAgICAvLyBCZWZvcmUgY29uZmlndXJpbmcgYSBjaGlsZCB1aS12aWV3LCBtYWtlIHN1cmUgaXQncyBzdGlsbCBpbiB0aGUgYWN0aXZlIHVpVmlld3MgYXJyYXkuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5fdWlWaWV3cy5pbmRleE9mKHVpVmlldykgIT09IC0xKVxyXG4gICAgICAgICAgICAgICAgdWlWaWV3LmNvbmZpZ1VwZGF0ZWQodmlld0NvbmZpZyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTb3J0IHZpZXdzIGJ5IEZRTiBhbmQgc3RhdGUgZGVwdGguIFByb2Nlc3MgdWl2aWV3cyBuZWFyZXN0IHRoZSByb290IGZpcnN0LlxyXG4gICAgICAgIHRoaXMuX3VpVmlld3Muc29ydChkZXB0aENvbXBhcmUodWlWaWV3RGVwdGgsIDEpKS5tYXAobWF0Y2hpbmdDb25maWdQYWlyKS5mb3JFYWNoKGNvbmZpZ3VyZVVJVmlldyk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBgdWktdmlld2AgY29tcG9uZW50XHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBhIGB1aS12aWV3YCBjb21wb25lbnQgaXMgY3JlYXRlZCwgaXQgdXNlcyB0aGlzIG1ldGhvZCB0byByZWdpc3RlciBpdHNlbGYuXHJcbiAgICAgKiBBZnRlciByZWdpc3RyYXRpb24gdGhlIFtbc3luY11dIG1ldGhvZCBpcyB1c2VkIHRvIGVuc3VyZSBhbGwgYHVpLXZpZXdgIGFyZSBjb25maWd1cmVkIHdpdGggdGhlIHByb3BlciBbW1ZpZXdDb25maWddXS5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiB0aGUgYHVpLXZpZXdgIGNvbXBvbmVudCB1c2VzIHRoZSBgVmlld0NvbmZpZ2AgdG8gZGV0ZXJtaW5lIHdoYXQgdmlldyBzaG91bGQgYmUgbG9hZGVkIGluc2lkZSB0aGUgYHVpLXZpZXdgLFxyXG4gICAgICogYW5kIHdoYXQgdGhlIHZpZXcncyBzdGF0ZSBjb250ZXh0IGlzLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IFRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgYGRlcmVnaXN0ZXJVSVZpZXdgLlxyXG4gICAgICogICAgICAgQSBgdWktdmlld2Agc2hvdWxkIGhhbmcgb24gdG8gdGhlIHJldHVybiB2YWx1ZSBvZiBgcmVnaXN0ZXJVSVZpZXdgIGFuZCBpbnZva2UgaXQgdG8gZGVyZWdpc3RlciBpdHNlbGYuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVpVmlldyBUaGUgbWV0YWRhdGEgZm9yIGEgVUlWaWV3XHJcbiAgICAgKiBAcmV0dXJuIGEgZGUtcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIHVzZWQgd2hlbiB0aGUgdmlldyBpcyBkZXN0cm95ZWQuXHJcbiAgICAgKi9cclxuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5yZWdpc3RlclVJVmlldyA9IGZ1bmN0aW9uICh1aVZpZXcpIHtcclxuICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudChcIi0+IFJlZ2lzdGVyaW5nXCIsIHVpVmlldyk7XHJcbiAgICAgICAgdmFyIHVpVmlld3MgPSB0aGlzLl91aVZpZXdzO1xyXG4gICAgICAgIHZhciBmcW5NYXRjaGVzID0gZnVuY3Rpb24gKHVpdikgeyByZXR1cm4gdWl2LmZxbiA9PT0gdWlWaWV3LmZxbjsgfTtcclxuICAgICAgICBpZiAodWlWaWV3cy5maWx0ZXIoZnFuTWF0Y2hlcykubGVuZ3RoKVxyXG4gICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudChcIiEhISEgZHVwbGljYXRlIHVpVmlldyBuYW1lZDpcIiwgdWlWaWV3KTtcclxuICAgICAgICB1aVZpZXdzLnB1c2godWlWaWV3KTtcclxuICAgICAgICB0aGlzLnN5bmMoKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gdWlWaWV3cy5pbmRleE9mKHVpVmlldyk7XHJcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudChcIlRyaWVkIHJlbW92aW5nIG5vbi1yZWdpc3RlcmVkIHVpVmlld1wiLCB1aVZpZXcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZVVJVmlld0V2ZW50KFwiPC0gRGVyZWdpc3RlcmluZ1wiLCB1aVZpZXcpO1xyXG4gICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKHVpVmlld3MpKHVpVmlldyk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygdmlld3MgY3VycmVudGx5IGF2YWlsYWJsZSBvbiB0aGUgcGFnZSwgYnkgZnVsbHktcXVhbGlmaWVkIG5hbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgZnVsbHktcXVhbGlmaWVkIHZpZXcgbmFtZXMuXHJcbiAgICAgKi9cclxuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5hdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpVmlld3MubWFwKGhvZl8xLnByb3AoXCJmcW5cIikpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiB2aWV3cyBvbiB0aGUgcGFnZSBjb250YWluaW5nIGxvYWRlZCBjb250ZW50LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGZ1bGx5LXF1YWxpZmllZCB2aWV3IG5hbWVzLlxyXG4gICAgICovXHJcbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuYWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91aVZpZXdzLmZpbHRlcihob2ZfMS5wcm9wKFwiJGNvbmZpZ1wiKSkubWFwKGhvZl8xLnByb3AoXCJuYW1lXCIpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgYSB2aWV3J3MgbmFtZSBmcm9tIGEgc3RhdGUudmlld3MgY29uZmlndXJhdGlvbiBibG9jay5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIGJ5IGEgZnJhbWV3b3JrIGltcGxlbWVudGF0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgdmFsdWVzIGZvclxyXG4gICAgICogW1tfVmlld0RlY2xhcmF0aW9uLiR1aVZpZXdOYW1lXV0gYW5kIFtbX1ZpZXdEZWNsYXJhdGlvbi4kdWlWaWV3Q29udGV4dEFuY2hvcl1dLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250ZXh0IHRoZSBjb250ZXh0IG9iamVjdCAoc3RhdGUgZGVjbGFyYXRpb24pIHRoYXQgdGhlIHZpZXcgYmVsb25ncyB0b1xyXG4gICAgICogQHBhcmFtIHJhd1ZpZXdOYW1lIHRoZSBuYW1lIG9mIHRoZSB2aWV3LCBhcyBkZWNsYXJlZCBpbiB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uLnZpZXdzXV1cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgbm9ybWFsaXplZCB1aVZpZXdOYW1lIGFuZCB1aVZpZXdDb250ZXh0QW5jaG9yIHRoYXQgdGhlIHZpZXcgdGFyZ2V0c1xyXG4gICAgICovXHJcbiAgICBWaWV3U2VydmljZS5ub3JtYWxpemVVSVZpZXdUYXJnZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgcmF3Vmlld05hbWUpIHtcclxuICAgICAgICBpZiAocmF3Vmlld05hbWUgPT09IHZvaWQgMCkgeyByYXdWaWV3TmFtZSA9IFwiXCI7IH1cclxuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSBpbmNvbWluZyB2aWV3IG5hbWUgd2l0aCBhIHJlZ2V4cCB0byBhbGxvdzpcclxuICAgICAgICAvLyBleDogXCJ2aWV3Lm5hbWVAZm9vLmJhclwiICwgXCJeLl4udmlldy5uYW1lXCIgLCBcInZpZXcubmFtZUBeLl5cIiAsIFwiXCIgLFxyXG4gICAgICAgIC8vIFwiQFwiICwgXCIkZGVmYXVsdEBeXCIgLCBcIiEkZGVmYXVsdC4kZGVmYXVsdFwiICwgXCIhZm9vLmJhclwiXHJcbiAgICAgICAgdmFyIHZpZXdBdENvbnRleHQgPSByYXdWaWV3TmFtZS5zcGxpdChcIkBcIik7XHJcbiAgICAgICAgdmFyIHVpVmlld05hbWUgPSB2aWV3QXRDb250ZXh0WzBdIHx8IFwiJGRlZmF1bHRcIjsgLy8gZGVmYXVsdCB0byB1bm5hbWVkIHZpZXdcclxuICAgICAgICB2YXIgdWlWaWV3Q29udGV4dEFuY2hvciA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyh2aWV3QXRDb250ZXh0WzFdKSA/IHZpZXdBdENvbnRleHRbMV0gOiBcIl5cIjsgLy8gZGVmYXVsdCB0byBwYXJlbnQgY29udGV4dFxyXG4gICAgICAgIC8vIEhhbmRsZSByZWxhdGl2ZSB2aWV3LW5hbWUgc3VnYXIgc3ludGF4LlxyXG4gICAgICAgIC8vIE1hdGNoZXMgcmF3Vmlld05hbWUgXCJeLl4uXi5mb28uYmFyXCIgaW50byBhcnJheTogW1wiXi5eLl4uZm9vLmJhclwiLCBcIl4uXi5eXCIsIFwiZm9vLmJhclwiXSxcclxuICAgICAgICB2YXIgcmVsYXRpdmVWaWV3TmFtZVN1Z2FyID0gL14oXFxeKD86XFwuXFxeKSopXFwuKC4qJCkvLmV4ZWModWlWaWV3TmFtZSk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlVmlld05hbWVTdWdhcikge1xyXG4gICAgICAgICAgICAvLyBDbG9iYmVycyBleGlzdGluZyBjb250ZXh0QW5jaG9yIChyYXdWaWV3TmFtZSB2YWxpZGF0aW9uIHdpbGwgZml4IHRoaXMpXHJcbiAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSByZWxhdGl2ZVZpZXdOYW1lU3VnYXJbMV07IC8vIHNldCBhbmNob3IgdG8gXCJeLl4uXlwiXHJcbiAgICAgICAgICAgIHVpVmlld05hbWUgPSByZWxhdGl2ZVZpZXdOYW1lU3VnYXJbMl07IC8vIHNldCB2aWV3LW5hbWUgdG8gXCJmb28uYmFyXCJcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVpVmlld05hbWUuY2hhckF0KDApID09PSAnIScpIHtcclxuICAgICAgICAgICAgdWlWaWV3TmFtZSA9IHVpVmlld05hbWUuc3Vic3RyKDEpO1xyXG4gICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yID0gXCJcIjsgLy8gdGFyZ2V0IGFic29sdXRlbHkgZnJvbSByb290XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGhhbmRsZSBwYXJlbnQgcmVsYXRpdmUgdGFyZ2V0aW5nIFwiXi5eLl5cIlxyXG4gICAgICAgIHZhciByZWxhdGl2ZU1hdGNoID0gL14oXFxeKD86XFwuXFxeKSopJC87XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlTWF0Y2guZXhlYyh1aVZpZXdDb250ZXh0QW5jaG9yKSkge1xyXG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gdWlWaWV3Q29udGV4dEFuY2hvci5zcGxpdChcIi5cIikucmVkdWNlKChmdW5jdGlvbiAoYW5jaG9yLCB4KSB7IHJldHVybiBhbmNob3IucGFyZW50OyB9KSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSBhbmNob3IubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodWlWaWV3Q29udGV4dEFuY2hvciA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSBjb250ZXh0Lm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHVpVmlld05hbWU6IHVpVmlld05hbWUsIHVpVmlld0NvbnRleHRBbmNob3I6IHVpVmlld0NvbnRleHRBbmNob3IgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmlld1NlcnZpY2U7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBHaXZlbiBhIHVpLXZpZXcgYW5kIGEgVmlld0NvbmZpZywgZGV0ZXJtaW5lcyBpZiB0aGV5IFwibWF0Y2hcIi5cclxuICpcclxuICogQSB1aS12aWV3IGhhcyBhIGZ1bGx5IHF1YWxpZmllZCBuYW1lIChmcW4pIGFuZCBhIGNvbnRleHQgb2JqZWN0LiAgVGhlIGZxbiBpcyBidWlsdCBmcm9tIGl0cyBvdmVyYWxsIGxvY2F0aW9uIGluXHJcbiAqIHRoZSBET00sIGRlc2NyaWJpbmcgaXRzIG5lc3RpbmcgcmVsYXRpb25zaGlwIHRvIGFueSBwYXJlbnQgdWktdmlldyB0YWdzIGl0IGlzIG5lc3RlZCBpbnNpZGUgb2YuXHJcbiAqXHJcbiAqIEEgVmlld0NvbmZpZyBoYXMgYSB0YXJnZXQgdWktdmlldyBuYW1lIGFuZCBhIGNvbnRleHQgYW5jaG9yLiAgVGhlIHVpLXZpZXcgbmFtZSBjYW4gYmUgYSBzaW1wbGUgbmFtZSwgb3JcclxuICogY2FuIGJlIGEgc2VnbWVudGVkIHVpLXZpZXcgcGF0aCwgZGVzY3JpYmluZyBhIHBvcnRpb24gb2YgYSB1aS12aWV3IGZxbi5cclxuICpcclxuICogSW4gb3JkZXIgZm9yIGEgdWktdmlldyB0byBtYXRjaCBWaWV3Q29uZmlnLCB1aS12aWV3J3MgJHR5cGUgbXVzdCBtYXRjaCB0aGUgVmlld0NvbmZpZydzICR0eXBlXHJcbiAqXHJcbiAqIElmIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IHVpLXZpZXcgbmFtZSBpcyBhIHNpbXBsZSBuYW1lIChubyBkb3RzKSwgdGhlbiBhIHVpLXZpZXcgbWF0Y2hlcyBpZjpcclxuICogLSB0aGUgdWktdmlldydzIG5hbWUgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXHJcbiAqIC0gdGhlIHVpLXZpZXcncyBjb250ZXh0IG1hdGNoZXMgdGhlIFZpZXdDb25maWcncyBhbmNob3JcclxuICpcclxuICogSWYgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgdWktdmlldyBuYW1lIGlzIGEgc2VnbWVudGVkIG5hbWUgKHdpdGggZG90cyksIHRoZW4gYSB1aS12aWV3IG1hdGNoZXMgaWY6XHJcbiAqIC0gVGhlcmUgZXhpc3RzIGEgcGFyZW50IHVpLXZpZXcgd2hlcmU6XHJcbiAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgbmFtZSBtYXRjaGVzIHRoZSBmaXJzdCBzZWdtZW50IChpbmRleCAwKSBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXHJcbiAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgY29udGV4dCBtYXRjaGVzIHRoZSBWaWV3Q29uZmlnJ3MgYW5jaG9yXHJcbiAqIC0gQW5kIHRoZSByZW1haW5pbmcgc2VnbWVudHMgKGluZGV4IDEuLm4pIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWUgbWF0Y2ggdGhlIHRhaWwgb2YgdGhlIHVpLXZpZXcncyBmcW5cclxuICpcclxuICogRXhhbXBsZTpcclxuICpcclxuICogRE9NOlxyXG4gKiA8dWktdmlldz4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIHJvb3QgY29udGV4dCAobmFtZTogXCJcIikgLS0+XHJcbiAqICAgPHVpLXZpZXcgbmFtZT1cImZvb1wiPiAgICAgICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIGNvbnRleHQgbmFtZWQ6IFwiQVwiICAgICAgLS0+XHJcbiAqICAgICA8dWktdmlldz4gICAgICAgICAgICAgICAgICAgIDwhLS0gY3JlYXRlZCBpbiB0aGUgY29udGV4dCBuYW1lZDogXCJBLkJcIiAgICAtLT5cclxuICogICAgICAgPHVpLXZpZXcgbmFtZT1cImJhclwiPiAgICAgICAgICAgIDwhLS0gY3JlYXRlZCBpbiB0aGUgY29udGV4dCBuYW1lZDogXCJBLkIuQ1wiICAtLT5cclxuICogICAgICAgPC91aS12aWV3PlxyXG4gKiAgICAgPC91aS12aWV3PlxyXG4gKiAgIDwvdWktdmlldz5cclxuICogPC91aS12aWV3PlxyXG4gKlxyXG4gKiB1aVZpZXdzOiBbXHJcbiAqICB7IGZxbjogXCIkZGVmYXVsdFwiLCAgICAgICAgICAgICAgICAgIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIlwiIH0gfSxcclxuICogIHsgZnFuOiBcIiRkZWZhdWx0LmZvb1wiLCAgICAgICAgICAgICAgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiQVwiIH0gfSxcclxuICogIHsgZnFuOiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdFwiLCAgICAgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiQS5CXCIgfSB9XHJcbiAqICB7IGZxbjogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCIsIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIkEuQi5DXCIgfSB9XHJcbiAqIF1cclxuICpcclxuICogVGhlc2UgZm91ciB2aWV3IGNvbmZpZ3MgYWxsIG1hdGNoIHRoZSB1aS12aWV3IHdpdGggdGhlIGZxbjogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCI6XHJcbiAqXHJcbiAqIC0gVmlld0NvbmZpZzE6IHsgdWlWaWV3TmFtZTogXCJiYXJcIiwgICAgICAgICAgICAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3I6IFwiQS5CLkNcIiB9XHJcbiAqIC0gVmlld0NvbmZpZzI6IHsgdWlWaWV3TmFtZTogXCIkZGVmYXVsdC5iYXJcIiwgICAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3I6IFwiQS5CXCIgfVxyXG4gKiAtIFZpZXdDb25maWczOiB7IHVpVmlld05hbWU6IFwiZm9vLiRkZWZhdWx0LmJhclwiLCAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yOiBcIkFcIiB9XHJcbiAqIC0gVmlld0NvbmZpZzQ6IHsgdWlWaWV3TmFtZTogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCIsIHVpVmlld0NvbnRleHRBbmNob3I6IFwiXCIgfVxyXG4gKlxyXG4gKiBVc2luZyBWaWV3Q29uZmlnMyBhcyBhbiBleGFtcGxlLCBpdCBtYXRjaGVzIHRoZSB1aS12aWV3IHdpdGggZnFuIFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0LmJhclwiIGJlY2F1c2U6XHJcbiAqIC0gVGhlIFZpZXdDb25maWcncyBzZWdtZW50ZWQgdGFyZ2V0IG5hbWUgaXM6IFsgXCJmb29cIiwgXCIkZGVmYXVsdFwiLCBcImJhclwiIF1cclxuICogLSBUaGVyZSBleGlzdHMgYSBwYXJlbnQgdWktdmlldyAod2hpY2ggaGFzIGZxbjogXCIkZGVmYXVsdC5mb29cIikgd2hlcmU6XHJcbiAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgbmFtZSBcImZvb1wiIG1hdGNoZXMgdGhlIGZpcnN0IHNlZ21lbnQgXCJmb29cIiBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXHJcbiAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgY29udGV4dCBcIkFcIiBtYXRjaGVzIHRoZSBWaWV3Q29uZmlnJ3MgYW5jaG9yIGNvbnRleHQgXCJBXCJcclxuICogLSBBbmQgdGhlIHJlbWFpbmluZyBzZWdtZW50cyBbIFwiJGRlZmF1bHRcIiwgXCJiYXJcIiBdLmpvaW4oXCIuXCJfIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWUgbWF0Y2hcclxuICogICB0aGUgdGFpbCBvZiB0aGUgdWktdmlldydzIGZxbiBcImRlZmF1bHQuYmFyXCJcclxuICpcclxuICogQGludGVybmFsYXBpXHJcbiAqL1xyXG5WaWV3U2VydmljZS5tYXRjaGVzID0gZnVuY3Rpb24gKHVpVmlld3NCeUZxbiwgdWlWaWV3KSB7IHJldHVybiBmdW5jdGlvbiAodmlld0NvbmZpZykge1xyXG4gICAgLy8gRG9uJ3Qgc3VwcGx5IGFuIG5nMSB1aS12aWV3IHdpdGggYW4gbmcyIFZpZXdDb25maWcsIGV0Y1xyXG4gICAgaWYgKHVpVmlldy4kdHlwZSAhPT0gdmlld0NvbmZpZy52aWV3RGVjbC4kdHlwZSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAvLyBTcGxpdCBuYW1lcyBhcGFydCBmcm9tIGJvdGggdmlld0NvbmZpZyBhbmQgdWlWaWV3IGludG8gc2VnbWVudHNcclxuICAgIHZhciB2YyA9IHZpZXdDb25maWcudmlld0RlY2w7XHJcbiAgICB2YXIgdmNTZWdtZW50cyA9IHZjLiR1aVZpZXdOYW1lLnNwbGl0KFwiLlwiKTtcclxuICAgIHZhciB1aXZTZWdtZW50cyA9IHVpVmlldy5mcW4uc3BsaXQoXCIuXCIpO1xyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRhaWxzIG9mIHRoZSBzZWdtZW50IGFycmF5cyBtYXRjaC4gZXgsIHRoZXNlIGFycmF5cycgdGFpbHMgbWF0Y2g6XHJcbiAgICAvLyB2YzogW1wiZm9vXCIsIFwiYmFyXCJdLCB1aXYgZnFuOiBbXCIkZGVmYXVsdFwiLCBcImZvb1wiLCBcImJhclwiXVxyXG4gICAgaWYgKCFjb21tb25fMS5lcXVhbHModmNTZWdtZW50cywgdWl2U2VnbWVudHMuc2xpY2UoMCAtIHZjU2VnbWVudHMubGVuZ3RoKSkpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgLy8gTm93IGNoZWNrIGlmIHRoZSBmcW4gZW5kaW5nIGF0IHRoZSBmaXJzdCBzZWdtZW50IG9mIHRoZSB2aWV3Q29uZmlnIG1hdGNoZXMgdGhlIGNvbnRleHQ6XHJcbiAgICAvLyBbXCIkZGVmYXVsdFwiLCBcImZvb1wiXS5qb2luKFwiLlwiKSA9PSBcIiRkZWZhdWx0LmZvb1wiLCBkb2VzIHRoZSB1aS12aWV3ICRkZWZhdWx0LmZvbyBjb250ZXh0IG1hdGNoP1xyXG4gICAgdmFyIG5lZ09mZnNldCA9ICgxIC0gdmNTZWdtZW50cy5sZW5ndGgpIHx8IHVuZGVmaW5lZDtcclxuICAgIHZhciBmcW5Ub0ZpcnN0U2VnbWVudCA9IHVpdlNlZ21lbnRzLnNsaWNlKDAsIG5lZ09mZnNldCkuam9pbihcIi5cIik7XHJcbiAgICB2YXIgdWlWaWV3Q29udGV4dCA9IHVpVmlld3NCeUZxbltmcW5Ub0ZpcnN0U2VnbWVudF0uY3JlYXRpb25Db250ZXh0O1xyXG4gICAgcmV0dXJuIHZjLiR1aVZpZXdDb250ZXh0QW5jaG9yID09PSAodWlWaWV3Q29udGV4dCAmJiB1aVZpZXdDb250ZXh0Lm5hbWUpO1xyXG59OyB9O1xyXG5leHBvcnRzLlZpZXdTZXJ2aWNlID0gVmlld1NlcnZpY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXcuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmlldy92aWV3LmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKiogQG1vZHVsZSBuZzEgKi8gLyoqIGZvciB0eXBlZG9jICovXHJcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIik7XHJcbi8qKlxyXG4gKiBUaGUgQW5ndWxhciAxIGBTdGF0ZVByb3ZpZGVyYFxyXG4gKlxyXG4gKiBUaGUgYCRzdGF0ZVByb3ZpZGVyYCB3b3JrcyBzaW1pbGFyIHRvIEFuZ3VsYXIncyB2MSByb3V0ZXIsIGJ1dCBpdCBmb2N1c2VzIHB1cmVseVxyXG4gKiBvbiBzdGF0ZS5cclxuICpcclxuICogQSBzdGF0ZSBjb3JyZXNwb25kcyB0byBhIFwicGxhY2VcIiBpbiB0aGUgYXBwbGljYXRpb24gaW4gdGVybXMgb2YgdGhlIG92ZXJhbGwgVUkgYW5kXHJcbiAqIG5hdmlnYXRpb24uIEEgc3RhdGUgZGVzY3JpYmVzICh2aWEgdGhlIGNvbnRyb2xsZXIgLyB0ZW1wbGF0ZSAvIHZpZXcgcHJvcGVydGllcykgd2hhdFxyXG4gKiB0aGUgVUkgbG9va3MgbGlrZSBhbmQgZG9lcyBhdCB0aGF0IHBsYWNlLlxyXG4gKlxyXG4gKiBTdGF0ZXMgb2Z0ZW4gaGF2ZSB0aGluZ3MgaW4gY29tbW9uLCBhbmQgdGhlIHByaW1hcnkgd2F5IG9mIGZhY3RvcmluZyBvdXQgdGhlc2VcclxuICogY29tbW9uYWxpdGllcyBpbiB0aGlzIG1vZGVsIGlzIHZpYSB0aGUgc3RhdGUgaGllcmFyY2h5LCBpLmUuIHBhcmVudC9jaGlsZCBzdGF0ZXMgYWthXHJcbiAqIG5lc3RlZCBzdGF0ZXMuXHJcbiAqXHJcbiAqIFRoZSBgJHN0YXRlUHJvdmlkZXJgIHByb3ZpZGVzIGludGVyZmFjZXMgdG8gZGVjbGFyZSB0aGVzZSBzdGF0ZXMgZm9yIHlvdXIgYXBwLlxyXG4gKi9cclxudmFyIFN0YXRlUHJvdmlkZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3RhdGVQcm92aWRlcihzdGF0ZVJlZ2lzdHJ5LCBzdGF0ZVNlcnZpY2UpIHtcclxuICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkgPSBzdGF0ZVJlZ2lzdHJ5O1xyXG4gICAgICAgIHRoaXMuc3RhdGVTZXJ2aWNlID0gc3RhdGVTZXJ2aWNlO1xyXG4gICAgICAgIGNvcmVfMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhjb3JlXzEudmFsKFN0YXRlUHJvdmlkZXIucHJvdG90eXBlKSwgdGhpcywgY29yZV8xLnZhbCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlY29yYXRlcyBzdGF0ZXMgd2hlbiB0aGV5IGFyZSByZWdpc3RlcmVkXHJcbiAgICAgKlxyXG4gICAgICogQWxsb3dzIHlvdSB0byBleHRlbmQgKGNhcmVmdWxseSkgb3Igb3ZlcnJpZGUgKGF0IHlvdXIgb3duIHBlcmlsKSB0aGVcclxuICAgICAqIGBzdGF0ZUJ1aWxkZXJgIG9iamVjdCB1c2VkIGludGVybmFsbHkgYnkgW1tTdGF0ZVJlZ2lzdHJ5XV0uXHJcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGFkZCBjdXN0b20gZnVuY3Rpb25hbGl0eSB0byB1aS1yb3V0ZXIsXHJcbiAgICAgKiBmb3IgZXhhbXBsZSBpbmZlcnJpbmcgdGVtcGxhdGVVcmwgYmFzZWQgb24gdGhlIHN0YXRlIG5hbWUuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBwYXNzaW5nIG9ubHkgYSBuYW1lLCBpdCByZXR1cm5zIHRoZSBjdXJyZW50IChvcmlnaW5hbCBvciBkZWNvcmF0ZWQpIGJ1aWxkZXJcclxuICAgICAqIGZ1bmN0aW9uIHRoYXQgbWF0Y2hlcyBgbmFtZWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGJ1aWxkZXIgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIGRlY29yYXRlZCBhcmUgbGlzdGVkIGJlbG93LiBUaG91Z2ggbm90IGFsbFxyXG4gICAgICogbmVjZXNzYXJpbHkgaGF2ZSBhIGdvb2QgdXNlIGNhc2UgZm9yIGRlY29yYXRpb24sIHRoYXQgaXMgdXAgdG8geW91IHRvIGRlY2lkZS5cclxuICAgICAqXHJcbiAgICAgKiBJbiBhZGRpdGlvbiwgdXNlcnMgY2FuIGF0dGFjaCBjdXN0b20gZGVjb3JhdG9ycywgd2hpY2ggd2lsbCBnZW5lcmF0ZSBuZXdcclxuICAgICAqIHByb3BlcnRpZXMgd2l0aGluIHRoZSBzdGF0ZSdzIGludGVybmFsIGRlZmluaXRpb24uIFRoZXJlIGlzIGN1cnJlbnRseSBubyBjbGVhclxyXG4gICAgICogdXNlLWNhc2UgZm9yIHRoaXMgYmV5b25kIGFjY2Vzc2luZyBpbnRlcm5hbCBzdGF0ZXMgKGkuZS4gJHN0YXRlLiRjdXJyZW50KSxcclxuICAgICAqIGhvd2V2ZXIsIGV4cGVjdCB0aGlzIHRvIGJlY29tZSBpbmNyZWFzaW5nbHkgcmVsZXZhbnQgYXMgd2UgaW50cm9kdWNlIGFkZGl0aW9uYWxcclxuICAgICAqIG1ldGEtcHJvZ3JhbW1pbmcgZmVhdHVyZXMuXHJcbiAgICAgKlxyXG4gICAgICogKipXYXJuaW5nKio6IERlY29yYXRvcnMgc2hvdWxkIG5vdCBiZSBpbnRlcmRlcGVuZGVudCBiZWNhdXNlIHRoZSBvcmRlciBvZlxyXG4gICAgICogZXhlY3V0aW9uIG9mIHRoZSBidWlsZGVyIGZ1bmN0aW9ucyBpbiBub24tZGV0ZXJtaW5pc3RpYy4gQnVpbGRlciBmdW5jdGlvbnNcclxuICAgICAqIHNob3VsZCBvbmx5IGJlIGRlcGVuZGVudCBvbiB0aGUgc3RhdGUgZGVmaW5pdGlvbiBvYmplY3QgYW5kIHN1cGVyIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBFeGlzdGluZyBidWlsZGVyIGZ1bmN0aW9ucyBhbmQgY3VycmVudCByZXR1cm4gdmFsdWVzOlxyXG4gICAgICpcclxuICAgICAqIC0gKipwYXJlbnQqKiBge29iamVjdH1gIC0gcmV0dXJucyB0aGUgcGFyZW50IHN0YXRlIG9iamVjdC5cclxuICAgICAqIC0gKipkYXRhKiogYHtvYmplY3R9YCAtIHJldHVybnMgc3RhdGUgZGF0YSwgaW5jbHVkaW5nIGFueSBpbmhlcml0ZWQgZGF0YSB0aGF0IGlzIG5vdFxyXG4gICAgICogICBvdmVycmlkZGVuIGJ5IG93biB2YWx1ZXMgKGlmIGFueSkuXHJcbiAgICAgKiAtICoqdXJsKiogYHtvYmplY3R9YCAtIHJldHVybnMgYSB7QGxpbmsgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyIFVybE1hdGNoZXJ9XHJcbiAgICAgKiAgIG9yIGBudWxsYC5cclxuICAgICAqIC0gKipuYXZpZ2FibGUqKiBge29iamVjdH1gIC0gcmV0dXJucyBjbG9zZXN0IGFuY2VzdG9yIHN0YXRlIHRoYXQgaGFzIGEgVVJMIChha2EgaXNcclxuICAgICAqICAgbmF2aWdhYmxlKS5cclxuICAgICAqIC0gKipwYXJhbXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZSBwYXJhbXMgdGhhdCBhcmUgZW5zdXJlZCB0b1xyXG4gICAgICogICBiZSBhIHN1cGVyLXNldCBvZiBwYXJlbnQncyBwYXJhbXMuXHJcbiAgICAgKiAtICoqdmlld3MqKiBge29iamVjdH1gIC0gcmV0dXJucyBhIHZpZXdzIG9iamVjdCB3aGVyZSBlYWNoIGtleSBpcyBhbiBhYnNvbHV0ZSB2aWV3XHJcbiAgICAgKiAgIG5hbWUgKGkuZS4gXCJ2aWV3TmFtZUBzdGF0ZU5hbWVcIikgYW5kIGVhY2ggdmFsdWUgaXMgdGhlIGNvbmZpZyBvYmplY3RcclxuICAgICAqICAgKHRlbXBsYXRlLCBjb250cm9sbGVyKSBmb3IgdGhlIHZpZXcuIEV2ZW4gd2hlbiB5b3UgZG9uJ3QgdXNlIHRoZSB2aWV3cyBvYmplY3RcclxuICAgICAqICAgZXhwbGljaXRseSBvbiBhIHN0YXRlIGNvbmZpZywgb25lIGlzIHN0aWxsIGNyZWF0ZWQgZm9yIHlvdSBpbnRlcm5hbGx5LlxyXG4gICAgICogICBTbyBieSBkZWNvcmF0aW5nIHRoaXMgYnVpbGRlciBmdW5jdGlvbiB5b3UgaGF2ZSBhY2Nlc3MgdG8gZGVjb3JhdGluZyB0ZW1wbGF0ZVxyXG4gICAgICogICBhbmQgY29udHJvbGxlciBwcm9wZXJ0aWVzLlxyXG4gICAgICogLSAqKm93blBhcmFtcyoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGFuIGFycmF5IG9mIHBhcmFtcyB0aGF0IGJlbG9uZyB0byB0aGUgc3RhdGUsXHJcbiAgICAgKiAgIG5vdCBpbmNsdWRpbmcgYW55IHBhcmFtcyBkZWZpbmVkIGJ5IGFuY2VzdG9yIHN0YXRlcy5cclxuICAgICAqIC0gKipwYXRoKiogYHtzdHJpbmd9YCAtIHJldHVybnMgdGhlIGZ1bGwgcGF0aCBmcm9tIHRoZSByb290IGRvd24gdG8gdGhpcyBzdGF0ZS5cclxuICAgICAqICAgTmVlZGVkIGZvciBzdGF0ZSBhY3RpdmF0aW9uLlxyXG4gICAgICogLSAqKmluY2x1ZGVzKiogYHtvYmplY3R9YCAtIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgaW5jbHVkZXMgZXZlcnkgc3RhdGUgdGhhdFxyXG4gICAgICogICB3b3VsZCBwYXNzIGEgYCRzdGF0ZS5pbmNsdWRlcygpYCB0ZXN0LlxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIE92ZXJyaWRlIHRoZSBpbnRlcm5hbCAndmlld3MnIGJ1aWxkZXIgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHN0YXRlXHJcbiAgICAgKiBkZWZpbml0aW9uLCBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGZ1bmN0aW9uIGJlaW5nIG92ZXJyaWRkZW46XHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogJHN0YXRlUHJvdmlkZXIuZGVjb3JhdG9yKCd2aWV3cycsIGZ1bmN0aW9uIChzdGF0ZSwgcGFyZW50KSB7XHJcbiAgICAgKiAgIGxldCByZXN1bHQgPSB7fSxcclxuICAgICAqICAgICAgIHZpZXdzID0gcGFyZW50KHN0YXRlKTtcclxuICAgICAqXHJcbiAgICAgKiAgIGFuZ3VsYXIuZm9yRWFjaCh2aWV3cywgZnVuY3Rpb24gKGNvbmZpZywgbmFtZSkge1xyXG4gICAgICogICAgIGxldCBhdXRvTmFtZSA9IChzdGF0ZS5uYW1lICsgJy4nICsgbmFtZSkucmVwbGFjZSgnLicsICcvJyk7XHJcbiAgICAgKiAgICAgY29uZmlnLnRlbXBsYXRlVXJsID0gY29uZmlnLnRlbXBsYXRlVXJsIHx8ICcvcGFydGlhbHMvJyArIGF1dG9OYW1lICsgJy5odG1sJztcclxuICAgICAqICAgICByZXN1bHRbbmFtZV0gPSBjb25maWc7XHJcbiAgICAgKiAgIH0pO1xyXG4gICAgICogICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoJ2hvbWUnLCB7XHJcbiAgICAgKiAgIHZpZXdzOiB7XHJcbiAgICAgKiAgICAgJ2NvbnRhY3QubGlzdCc6IHsgY29udHJvbGxlcjogJ0xpc3RDb250cm9sbGVyJyB9LFxyXG4gICAgICogICAgICdjb250YWN0Lml0ZW0nOiB7IGNvbnRyb2xsZXI6ICdJdGVtQ29udHJvbGxlcicgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogLy8gQXV0by1wb3B1bGF0ZXMgbGlzdCBhbmQgaXRlbSB2aWV3cyB3aXRoIC9wYXJ0aWFscy9ob21lL2NvbnRhY3QvbGlzdC5odG1sLFxyXG4gICAgICogLy8gYW5kIC9wYXJ0aWFscy9ob21lL2NvbnRhY3QvaXRlbS5odG1sLCByZXNwZWN0aXZlbHkuXHJcbiAgICAgKiAkc3RhdGUuZ28oJ2hvbWUnKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBidWlsZGVyIGZ1bmN0aW9uIHRvIGRlY29yYXRlLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZ1bmMgQSBmdW5jdGlvbiB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBkZWNvcmF0aW5nIHRoZSBvcmlnaW5hbFxyXG4gICAgICogYnVpbGRlciBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byBwYXJhbWV0ZXJzOlxyXG4gICAgICpcclxuICAgICAqICAgLSBge29iamVjdH1gIC0gc3RhdGUgLSBUaGUgc3RhdGUgY29uZmlnIG9iamVjdC5cclxuICAgICAqICAgLSBge29iamVjdH1gIC0gc3VwZXIgLSBUaGUgb3JpZ2luYWwgYnVpbGRlciBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICRzdGF0ZVByb3ZpZGVyIC0gJHN0YXRlUHJvdmlkZXIgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgU3RhdGVQcm92aWRlci5wcm90b3R5cGUuZGVjb3JhdG9yID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVJlZ2lzdHJ5LmRlY29yYXRvcihuYW1lLCBmdW5jKSB8fCB0aGlzO1xyXG4gICAgfTtcclxuICAgIFN0YXRlUHJvdmlkZXIucHJvdG90eXBlLnN0YXRlID0gZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcclxuICAgICAgICBpZiAoY29yZV8xLmlzT2JqZWN0KG5hbWUpKSB7XHJcbiAgICAgICAgICAgIGRlZmluaXRpb24gPSBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGF0ZVJlZ2lzdHJ5LnJlZ2lzdGVyKGRlZmluaXRpb24pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGFuIGludmFsaWQgc3RhdGUgaGFuZGxlclxyXG4gICAgICpcclxuICAgICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0byBbW1N0YXRlU2VydmljZS5vbkludmFsaWRdXSBmb3IgbmcxLlxyXG4gICAgICovXHJcbiAgICBTdGF0ZVByb3ZpZGVyLnByb3RvdHlwZS5vbkludmFsaWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVNlcnZpY2Uub25JbnZhbGlkKGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3RhdGVQcm92aWRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5TdGF0ZVByb3ZpZGVyID0gU3RhdGVQcm92aWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVQcm92aWRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2FuZ3VsYXItdWktcm91dGVyL2xpYi9zdGF0ZVByb3ZpZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKiogQG1vZHVsZSB1cmwgKi8gLyoqICovXHJcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIik7XHJcbnZhciBjb3JlXzIgPSByZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIik7XHJcbi8qKlxyXG4gKiBNYW5hZ2VzIHJ1bGVzIGZvciBjbGllbnQtc2lkZSBVUkxcclxuICpcclxuICogIyMjIERlcHJlY2F0aW9uIHdhcm5pbmc6XHJcbiAqIFRoaXMgY2xhc3MgaXMgbm93IGNvbnNpZGVyZWQgdG8gYmUgYW4gaW50ZXJuYWwgQVBJXHJcbiAqIFVzZSB0aGUgW1tVcmxTZXJ2aWNlXV0gaW5zdGVhZC5cclxuICogRm9yIGNvbmZpZ3VyaW5nIFVSTCBydWxlcywgdXNlIHRoZSBbW1VybFJ1bGVzQXBpXV0gd2hpY2ggY2FuIGJlIGZvdW5kIGFzIFtbVXJsU2VydmljZS5ydWxlc11dLlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIG1hbmFnZXMgdGhlIHJvdXRlciBydWxlcyBmb3Igd2hhdCB0byBkbyB3aGVuIHRoZSBVUkwgY2hhbmdlcy5cclxuICpcclxuICogVGhpcyBwcm92aWRlciByZW1haW5zIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cclxuICpcclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbnZhciBVcmxSb3V0ZXJQcm92aWRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgZnVuY3Rpb24gVXJsUm91dGVyUHJvdmlkZXIocm91dGVyKSB7XHJcbiAgICAgICAgdGhpcy5fcm91dGVyID0gcm91dGVyO1xyXG4gICAgICAgIHRoaXMuX3VybFJvdXRlciA9IHJvdXRlci51cmxSb3V0ZXI7XHJcbiAgICB9XHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgVXJsUm91dGVyUHJvdmlkZXIucHJvdG90eXBlLiRnZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHVybFJvdXRlciA9IHRoaXMuX3VybFJvdXRlcjtcclxuICAgICAgICB1cmxSb3V0ZXIudXBkYXRlKHRydWUpO1xyXG4gICAgICAgIGlmICghdXJsUm91dGVyLmludGVyY2VwdERlZmVycmVkKVxyXG4gICAgICAgICAgICB1cmxSb3V0ZXIubGlzdGVuKCk7XHJcbiAgICAgICAgcmV0dXJuIHVybFJvdXRlcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhIHVybCBoYW5kbGVyIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFJlZ2lzdGVycyBhIGxvdyBsZXZlbCB1cmwgaGFuZGxlciAoYSBgcnVsZWApLlxyXG4gICAgICogQSBydWxlIGRldGVjdHMgc3BlY2lmaWMgVVJMIHBhdHRlcm5zIGFuZCByZXR1cm5zIGEgcmVkaXJlY3QsIG9yIHBlcmZvcm1zIHNvbWUgYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIElmIGEgcnVsZSByZXR1cm5zIGEgc3RyaW5nLCB0aGUgVVJMIGlzIHJlcGxhY2VkIHdpdGggdGhlIHN0cmluZywgYW5kIGFsbCBydWxlcyBhcmUgZmlyZWQgYWdhaW4uXHJcbiAgICAgKlxyXG4gICAgICogIyMjIyBFeGFtcGxlOlxyXG4gICAgICogYGBganNcclxuICAgICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXIucm91dGVyJ10pO1xyXG4gICAgICpcclxuICAgICAqIGFwcC5jb25maWcoZnVuY3Rpb24gKCR1cmxSb3V0ZXJQcm92aWRlcikge1xyXG4gICAgICogICAvLyBIZXJlJ3MgYW4gZXhhbXBsZSBvZiBob3cgeW91IG1pZ2h0IGFsbG93IGNhc2UgaW5zZW5zaXRpdmUgdXJsc1xyXG4gICAgICogICAkdXJsUm91dGVyUHJvdmlkZXIucnVsZShmdW5jdGlvbiAoJGluamVjdG9yLCAkbG9jYXRpb24pIHtcclxuICAgICAqICAgICB2YXIgcGF0aCA9ICRsb2NhdGlvbi5wYXRoKCksXHJcbiAgICAgKiAgICAgICAgIG5vcm1hbGl6ZWQgPSBwYXRoLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgKlxyXG4gICAgICogICAgIGlmIChwYXRoICE9PSBub3JtYWxpemVkKSB7XHJcbiAgICAgKiAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH0pO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcnVsZUZuXHJcbiAgICAgKiBIYW5kbGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYCRpbmplY3RvcmAgYW5kIGAkbG9jYXRpb25gIHNlcnZpY2VzIGFzIGFyZ3VtZW50cy5cclxuICAgICAqIFlvdSBjYW4gdXNlIHRoZW0gdG8gZGV0ZWN0IGEgdXJsIGFuZCByZXR1cm4gYSBkaWZmZXJlbnQgdXJsIGFzIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gW1tVcmxSb3V0ZXJQcm92aWRlcl1dIChgdGhpc2ApXHJcbiAgICAgKi9cclxuICAgIFVybFJvdXRlclByb3ZpZGVyLnByb3RvdHlwZS5ydWxlID0gZnVuY3Rpb24gKHJ1bGVGbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFjb3JlXzIuaXNGdW5jdGlvbihydWxlRm4pKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIncnVsZScgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xyXG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVGbihjb3JlXzIuc2VydmljZXMuJGluamVjdG9yLCBfdGhpcy5fcm91dGVyLmxvY2F0aW9uU2VydmljZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcnVsZSA9IG5ldyBjb3JlXzEuQmFzZVVybFJ1bGUobWF0Y2gsIGNvcmVfMi5pZGVudGl0eSk7XHJcbiAgICAgICAgdGhpcy5fdXJsUm91dGVyLnJ1bGUocnVsZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIHRoZSBwYXRoIG9yIGJlaGF2aW9yIHRvIHVzZSB3aGVuIG5vIHVybCBjYW4gYmUgbWF0Y2hlZC5cclxuICAgICAqXHJcbiAgICAgKiAjIyMjIEV4YW1wbGU6XHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlci5yb3V0ZXInXSk7XHJcbiAgICAgKlxyXG4gICAgICogYXBwLmNvbmZpZyhmdW5jdGlvbiAoJHVybFJvdXRlclByb3ZpZGVyKSB7XHJcbiAgICAgKiAgIC8vIGlmIHRoZSBwYXRoIGRvZXNuJ3QgbWF0Y2ggYW55IG9mIHRoZSB1cmxzIHlvdSBjb25maWd1cmVkXHJcbiAgICAgKiAgIC8vIG90aGVyd2lzZSB3aWxsIHRha2UgY2FyZSBvZiByb3V0aW5nIHRoZSB1c2VyIHRvIHRoZVxyXG4gICAgICogICAvLyBzcGVjaWZpZWQgdXJsXHJcbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoJy9pbmRleCcpO1xyXG4gICAgICpcclxuICAgICAqICAgLy8gRXhhbXBsZSBvZiB1c2luZyBmdW5jdGlvbiBydWxlIGFzIHBhcmFtXHJcbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoZnVuY3Rpb24gKCRpbmplY3RvciwgJGxvY2F0aW9uKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuICcvYS92YWxpZC91cmwnO1xyXG4gICAgICogICB9KTtcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJ1bGVcclxuICAgICAqIFRoZSB1cmwgcGF0aCB5b3Ugd2FudCB0byByZWRpcmVjdCB0byBvciBhIGZ1bmN0aW9uIHJ1bGUgdGhhdCByZXR1cm5zIHRoZSB1cmwgcGF0aCBvciBwZXJmb3JtcyBhIGAkc3RhdGUuZ28oKWAuXHJcbiAgICAgKiBUaGUgZnVuY3Rpb24gdmVyc2lvbiBpcyBwYXNzZWQgdHdvIHBhcmFtczogYCRpbmplY3RvcmAgYW5kIGAkbG9jYXRpb25gIHNlcnZpY2VzLCBhbmQgc2hvdWxkIHJldHVybiBhIHVybCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBgJHVybFJvdXRlclByb3ZpZGVyYCAtIGAkdXJsUm91dGVyUHJvdmlkZXJgIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIFVybFJvdXRlclByb3ZpZGVyLnByb3RvdHlwZS5vdGhlcndpc2UgPSBmdW5jdGlvbiAocnVsZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHVybFJvdXRlciA9IHRoaXMuX3VybFJvdXRlcjtcclxuICAgICAgICBpZiAoY29yZV8yLmlzU3RyaW5nKHJ1bGUpKSB7XHJcbiAgICAgICAgICAgIHVybFJvdXRlci5vdGhlcndpc2UocnVsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvcmVfMi5pc0Z1bmN0aW9uKHJ1bGUpKSB7XHJcbiAgICAgICAgICAgIHVybFJvdXRlci5vdGhlcndpc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gcnVsZShjb3JlXzIuc2VydmljZXMuJGluamVjdG9yLCBfdGhpcy5fcm91dGVyLmxvY2F0aW9uU2VydmljZSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3J1bGUnIG11c3QgYmUgYSBzdHJpbmcgb3IgZnVuY3Rpb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgaGFuZGxlciBmb3IgYSBnaXZlbiB1cmwgbWF0Y2hpbmcuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIGhhbmRsZXIgaXMgYSBzdHJpbmcsIGl0IGlzXHJcbiAgICAgKiB0cmVhdGVkIGFzIGEgcmVkaXJlY3QsIGFuZCBpcyBpbnRlcnBvbGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzeW50YXggb2YgbWF0Y2hcclxuICAgICAqIChpLmUuIGxpa2UgYFN0cmluZy5yZXBsYWNlKClgIGZvciBgUmVnRXhwYCwgb3IgbGlrZSBhIGBVcmxNYXRjaGVyYCBwYXR0ZXJuIG90aGVyd2lzZSkuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIGhhbmRsZXIgaXMgYSBmdW5jdGlvbiwgaXQgaXMgaW5qZWN0YWJsZS5cclxuICAgICAqIEl0IGdldHMgaW52b2tlZCBpZiBgJGxvY2F0aW9uYCBtYXRjaGVzLlxyXG4gICAgICogWW91IGhhdmUgdGhlIG9wdGlvbiBvZiBpbmplY3QgdGhlIG1hdGNoIG9iamVjdCBhcyBgJG1hdGNoYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgaGFuZGxlciBjYW4gcmV0dXJuXHJcbiAgICAgKlxyXG4gICAgICogLSAqKmZhbHN5KiogdG8gaW5kaWNhdGUgdGhhdCB0aGUgcnVsZSBkaWRuJ3QgbWF0Y2ggYWZ0ZXIgYWxsLCB0aGVuIGAkdXJsUm91dGVyYFxyXG4gICAgICogICB3aWxsIGNvbnRpbnVlIHRyeWluZyB0byBmaW5kIGFub3RoZXIgb25lIHRoYXQgbWF0Y2hlcy5cclxuICAgICAqIC0gKipzdHJpbmcqKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcmVkaXJlY3QgYW5kIHBhc3NlZCB0byBgJGxvY2F0aW9uLnVybCgpYFxyXG4gICAgICogLSAqKnZvaWQqKiBvciBhbnkgKip0cnV0aHkqKiB2YWx1ZSB0ZWxscyBgJHVybFJvdXRlcmAgdGhhdCB0aGUgdXJsIHdhcyBoYW5kbGVkLlxyXG4gICAgICpcclxuICAgICAqICMjIyMgRXhhbXBsZTpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcclxuICAgICAqXHJcbiAgICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcclxuICAgICAqICAgJHVybFJvdXRlclByb3ZpZGVyLndoZW4oJHN0YXRlLnVybCwgZnVuY3Rpb24gKCRtYXRjaCwgJHN0YXRlUGFyYW1zKSB7XHJcbiAgICAgKiAgICAgaWYgKCRzdGF0ZS4kY3VycmVudC5uYXZpZ2FibGUgIT09IHN0YXRlIHx8XHJcbiAgICAgKiAgICAgICAgICFlcXVhbEZvcktleXMoJG1hdGNoLCAkc3RhdGVQYXJhbXMpIHtcclxuICAgICAqICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbyhzdGF0ZSwgJG1hdGNoLCBmYWxzZSk7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9KTtcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHdoYXQgQSBwYXR0ZXJuIHN0cmluZyB0byBtYXRjaCwgY29tcGlsZWQgYXMgYSBbW1VybE1hdGNoZXJdXS5cclxuICAgICAqIEBwYXJhbSBoYW5kbGVyIFRoZSBwYXRoIChvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwYXRoKSB0aGF0IHlvdSB3YW50IHRvIHJlZGlyZWN0IHlvdXIgdXNlciB0by5cclxuICAgICAqIEBwYXJhbSBydWxlQ2FsbGJhY2sgW29wdGlvbmFsXSBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGBydWxlYCByZWdpc3RlcmVkIHdpdGggW1tVcmxNYXRjaGVyLnJ1bGVdXVxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IHRoZSBoYW5kbGVyIG1heSBhbHNvIGludm9rZSBhcmJpdHJhcnkgY29kZSwgc3VjaCBhcyBgJHN0YXRlLmdvKClgXHJcbiAgICAgKi9cclxuICAgIFVybFJvdXRlclByb3ZpZGVyLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24gKHdoYXQsIGhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoY29yZV8yLmlzQXJyYXkoaGFuZGxlcikgfHwgY29yZV8yLmlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgaGFuZGxlciA9IFVybFJvdXRlclByb3ZpZGVyLmluamVjdGFibGVIYW5kbGVyKHRoaXMuX3JvdXRlciwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3VybFJvdXRlci53aGVuKHdoYXQsIGhhbmRsZXIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIFVybFJvdXRlclByb3ZpZGVyLmluamVjdGFibGVIYW5kbGVyID0gZnVuY3Rpb24gKHJvdXRlciwgaGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvcmVfMi5zZXJ2aWNlcy4kaW5qZWN0b3IuaW52b2tlKGhhbmRsZXIsIG51bGwsIHsgJG1hdGNoOiBtYXRjaCwgJHN0YXRlUGFyYW1zOiByb3V0ZXIuZ2xvYmFscy5wYXJhbXMgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGVzIG1vbml0b3Jpbmcgb2YgdGhlIFVSTC5cclxuICAgICAqXHJcbiAgICAgKiBDYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSBVSS1Sb3V0ZXIgaGFzIGJvb3RzdHJhcHBlZC5cclxuICAgICAqIEl0IHdpbGwgc3RvcCBVSS1Sb3V0ZXIgZnJvbSBwZXJmb3JtaW5nIHRoZSBpbml0aWFsIHVybCBzeW5jLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBwZXJmb3JtIHNvbWUgYXN5bmNocm9ub3VzIGluaXRpYWxpemF0aW9uIGJlZm9yZSB0aGUgcm91dGVyIHN0YXJ0cy5cclxuICAgICAqIE9uY2UgdGhlIGluaXRpYWxpemF0aW9uIGlzIGNvbXBsZXRlLCBjYWxsIFtbbGlzdGVuXV0gdG8gdGVsbCBVSS1Sb3V0ZXIgdG8gc3RhcnQgd2F0Y2hpbmcgYW5kIHN5bmNocm9uaXppbmcgdGhlIFVSTC5cclxuICAgICAqXHJcbiAgICAgKiAjIyMjIEV4YW1wbGU6XHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcclxuICAgICAqXHJcbiAgICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcclxuICAgICAqICAgLy8gUHJldmVudCAkdXJsUm91dGVyIGZyb20gYXV0b21hdGljYWxseSBpbnRlcmNlcHRpbmcgVVJMIGNoYW5nZXM7XHJcbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5kZWZlckludGVyY2VwdCgpO1xyXG4gICAgICogfSlcclxuICAgICAqXHJcbiAgICAgKiBhcHAucnVuKGZ1bmN0aW9uIChNeVNlcnZpY2UsICR1cmxSb3V0ZXIsICRodHRwKSB7XHJcbiAgICAgKiAgICRodHRwLmdldChcIi9zdHVmZlwiKS50aGVuKGZ1bmN0aW9uKHJlc3ApIHtcclxuICAgICAqICAgICBNeVNlcnZpY2UuZG9TdHVmZihyZXNwLmRhdGEpO1xyXG4gICAgICogICAgICR1cmxSb3V0ZXIubGlzdGVuKCk7XHJcbiAgICAgKiAgICAgJHVybFJvdXRlci5zeW5jKCk7XHJcbiAgICAgKiAgIH0pO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGVmZXIgSW5kaWNhdGVzIHdoZXRoZXIgdG8gZGVmZXIgbG9jYXRpb24gY2hhbmdlIGludGVyY2VwdGlvbi5cclxuICAgICAqICAgICAgICBQYXNzaW5nIG5vIHBhcmFtZXRlciBpcyBlcXVpdmFsZW50IHRvIGB0cnVlYC5cclxuICAgICAqL1xyXG4gICAgVXJsUm91dGVyUHJvdmlkZXIucHJvdG90eXBlLmRlZmVySW50ZXJjZXB0ID0gZnVuY3Rpb24gKGRlZmVyKSB7XHJcbiAgICAgICAgdGhpcy5fdXJsUm91dGVyLmRlZmVySW50ZXJjZXB0KGRlZmVyKTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICByZXR1cm4gVXJsUm91dGVyUHJvdmlkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVXJsUm91dGVyUHJvdmlkZXIgPSBVcmxSb3V0ZXJQcm92aWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsUm91dGVyUHJvdmlkZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9hbmd1bGFyLXVpLXJvdXRlci9saWIvdXJsUm91dGVyUHJvdmlkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhlYWRlckN0cmwodWliRGF0ZVBhcnNlcil7XHJcbiAgICAnbmdJbmplY3QnO1xyXG5cclxuICAgIHZhciAkY3RybCA9IHRoaXM7XHJcblxyXG4gICAgJGN0cmwudXBkYXRlVGl0bGUgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICRjdHJsLm5hbWUgPSAkY3RybC50aXRsZTtcclxuICAgIH1cclxuXHJcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGF5b3V0L2hlYWRlci9oZWFkZXIuY29udHJvbGxlci5qcyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFib3V0Q3RybCgkc3RhdGUpe1xyXG4gICAgJ25nSW5qZWN0JztcclxuXHJcbiAgICB2YXIgJGN0cmwgPSB0aGlzO1xyXG5cclxuICAgICRjdHJsLnRlc3QgPSAkc3RhdGU7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ2FiYm91dCB0ZXN0Jyk7XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9sYXlvdXQvbmF2aWdhdGlvbi9hYm91dC9hYm91dC5jb250cm9sbGVyLmpzIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGFjdEN0cmwoKXtcclxuICAgICduZ0luamVjdCc7XHJcblxyXG4gICAgdmFyICRjdHJsID0gdGhpcztcclxuXHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9sYXlvdXQvbmF2aWdhdGlvbi9jb250YWN0L2NvbnRhY3QuY29udHJvbGxlci5qcyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhvbWVDdHJsKCl7XHJcbiAgICAnbmdJbmplY3QnO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGF5b3V0L25hdmlnYXRpb24vaG9tZS9ob21lLmNvbnRyb2xsZXIuanMiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuYXZpZ2F0aW9uQ3RybCgkc3RhdGUsIHN0YXRlcywgJHJvb3RTY29wZSl7XHJcbiAgICAnbmdJbmplY3QnO1xyXG5cclxuICAgIHZhciAkY3RybCA9IHRoaXM7XHJcblxyXG4gICAgJGN0cmwubmFtZSA9IFwiTmF2IFNlY3Rpb25cIlxyXG5cclxuICAgICRjdHJsLnN0YXRlID0gJHN0YXRlO1xyXG4gICAgJGN0cmwubmF2SXRlbXMgPSBzdGF0ZXMubWFpbk5hdjtcclxuXHJcbiAgICAkcm9vdFNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0YXRlVGVtcCA9ICRzdGF0ZTtcclxuICAgICAgICB2YXIgc3RhdGV0ZXN0cGx6ID0gJ3Rlc3QnO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCd0ZXN0Jyk7XHJcbiAgICB9KVxyXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xheW91dC9uYXZpZ2F0aW9uL25hdmlnYXRpb24uY29udHJvbGxlci5qcyIsInJlcXVpcmUoJy4vZGlzdC91aS1ib290c3RyYXAtdHBscycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAndWkuYm9vdHN0cmFwJztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9hbmd1bGFyLXVpLWJvb3RzdHJhcC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBNYWluIGVudHJ5IHBvaW50IGZvciBhbmd1bGFyIDEueCBidWlsZFxyXG4gKiBAbW9kdWxlIG5nMVxyXG4gKi8gLyoqICovXHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBjb3JlID0gcmVxdWlyZShcIkB1aXJvdXRlci9jb3JlXCIpO1xyXG5leHBvcnRzLmNvcmUgPSBjb3JlO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiQHVpcm91dGVyL2NvcmVcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zZXJ2aWNlc1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlYnVpbGRlcnMvdmlld3NcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZVByb3ZpZGVyXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vdXJsUm91dGVyUHJvdmlkZXJcIikpO1xyXG5yZXF1aXJlKFwiLi9pbmplY3RhYmxlc1wiKTtcclxucmVxdWlyZShcIi4vZGlyZWN0aXZlcy9zdGF0ZURpcmVjdGl2ZXNcIik7XHJcbnJlcXVpcmUoXCIuL3N0YXRlRmlsdGVyc1wiKTtcclxucmVxdWlyZShcIi4vZGlyZWN0aXZlcy92aWV3RGlyZWN0aXZlXCIpO1xyXG5yZXF1aXJlKFwiLi92aWV3U2Nyb2xsXCIpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBcInVpLnJvdXRlclwiO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2FuZ3VsYXItdWktcm91dGVyL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGhlYWRlciBmcm9tICcuL2hlYWRlci9oZWFkZXIubW9kdWxlJztcclxuaW1wb3J0IG5hdmlnYXRpb24gZnJvbSAnLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24ubW9kdWxlJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFuZ3VsYXIubW9kdWxlKCdsYXlvdXQnLFtcclxuICAgIGhlYWRlcixcclxuICAgIG5hdmlnYXRpb25cclxuXSkubmFtZTtcclxuICAgIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xheW91dC9sYXlvdXQubW9kdWxlLmpzIiwiaW1wb3J0IHN0YXRlcyBmcm9tICcuL3N0YXRlcy9zdGF0ZXMubW9kdWxlJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFuZ3VsYXIubW9kdWxlKCd3aWRnZXQuY29uc3RhbnRzJywgW1xyXG4gICAgc3RhdGVzXHJcbl0pLm5hbWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vd2lkZ2V0L2NvbnN0YW50cy9jb25zdGFudHMubW9kdWxlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXHJcbnZhciB0cmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uXCIpO1xyXG52YXIgcm91dGVyXzEgPSByZXF1aXJlKFwiLi4vcm91dGVyXCIpO1xyXG5mdW5jdGlvbiBhZGRDb3JlUmVzb2x2YWJsZXModHJhbnMpIHtcclxuICAgIHRyYW5zLmFkZFJlc29sdmFibGUoeyB0b2tlbjogcm91dGVyXzEuVUlSb3V0ZXIsIGRlcHM6IFtdLCByZXNvbHZlRm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zLnJvdXRlcjsgfSwgZGF0YTogdHJhbnMucm91dGVyIH0sIFwiXCIpO1xyXG4gICAgdHJhbnMuYWRkUmVzb2x2YWJsZSh7IHRva2VuOiB0cmFuc2l0aW9uXzEuVHJhbnNpdGlvbiwgZGVwczogW10sIHJlc29sdmVGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnM7IH0sIGRhdGE6IHRyYW5zIH0sIFwiXCIpO1xyXG4gICAgdHJhbnMuYWRkUmVzb2x2YWJsZSh7IHRva2VuOiAnJHRyYW5zaXRpb24kJywgZGVwczogW10sIHJlc29sdmVGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnM7IH0sIGRhdGE6IHRyYW5zIH0sIFwiXCIpO1xyXG4gICAgdHJhbnMuYWRkUmVzb2x2YWJsZSh7IHRva2VuOiAnJHN0YXRlUGFyYW1zJywgZGVwczogW10sIHJlc29sdmVGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnMucGFyYW1zKCk7IH0sIGRhdGE6IHRyYW5zLnBhcmFtcygpIH0sIFwiXCIpO1xyXG4gICAgdHJhbnMuZW50ZXJpbmcoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgIHRyYW5zLmFkZFJlc29sdmFibGUoeyB0b2tlbjogJyRzdGF0ZSQnLCBkZXBzOiBbXSwgcmVzb2x2ZUZuOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZTsgfSwgZGF0YTogc3RhdGUgfSwgc3RhdGUpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5yZWdpc3RlckFkZENvcmVSZXNvbHZhYmxlcyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xyXG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uQ3JlYXRlKHt9LCBhZGRDb3JlUmVzb2x2YWJsZXMpO1xyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlUmVzb2x2YWJsZXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvY29yZVJlc29sdmFibGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xyXG52YXIgcmVqZWN0RmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeVwiKTtcclxuLyoqXHJcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCBza2lwcyBhIHRyYW5zaXRpb24gaWYgaXQgc2hvdWxkIGJlIGlnbm9yZWRcclxuICpcclxuICogVGhpcyBob29rIGlzIGludm9rZWQgYXQgdGhlIGVuZCBvZiB0aGUgb25CZWZvcmUgcGhhc2UuXHJcbiAqXHJcbiAqIElmIHRoZSB0cmFuc2l0aW9uIHNob3VsZCBiZSBpZ25vcmVkIChiZWNhdXNlIG5vIHBhcmFtZXRlciBvciBzdGF0ZXMgY2hhbmdlZClcclxuICogdGhlbiB0aGUgdHJhbnNpdGlvbiBpcyBpZ25vcmVkIGFuZCBub3QgcHJvY2Vzc2VkLlxyXG4gKi9cclxuZnVuY3Rpb24gaWdub3JlZEhvb2sodHJhbnMpIHtcclxuICAgIHZhciBpZ25vcmVkUmVhc29uID0gdHJhbnMuX2lnbm9yZWRSZWFzb24oKTtcclxuICAgIGlmICghaWdub3JlZFJlYXNvbilcclxuICAgICAgICByZXR1cm47XHJcbiAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVHJhbnNpdGlvbklnbm9yZWQodHJhbnMpO1xyXG4gICAgdmFyIHBlbmRpbmcgPSB0cmFucy5yb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uO1xyXG4gICAgLy8gVGhlIHVzZXIgY2xpY2tlZCBhIGxpbmsgZ29pbmcgYmFjayB0byB0aGUgKmN1cnJlbnQgc3RhdGUqICgnQScpXHJcbiAgICAvLyBIb3dldmVyLCB0aGVyZSBpcyBhbHNvIGEgcGVuZGluZyB0cmFuc2l0aW9uIGluIGZsaWdodCAodG8gJ0InKVxyXG4gICAgLy8gQWJvcnQgdGhlIHRyYW5zaXRpb24gdG8gJ0InIGJlY2F1c2UgdGhlIHVzZXIgbm93IHdhbnRzIHRvIGJlIGJhY2sgYXQgJ0EnLlxyXG4gICAgaWYgKGlnbm9yZWRSZWFzb24gPT09ICdTYW1lQXNDdXJyZW50JyAmJiBwZW5kaW5nKSB7XHJcbiAgICAgICAgcGVuZGluZy5hYm9ydCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uaWdub3JlZCgpLnRvUHJvbWlzZSgpO1xyXG59XHJcbmV4cG9ydHMucmVnaXN0ZXJJZ25vcmVkVHJhbnNpdGlvbkhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcclxuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgaWdub3JlZEhvb2ssIHsgcHJpb3JpdHk6IC05OTk5IH0pO1xyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZ25vcmVkVHJhbnNpdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9pZ25vcmVkVHJhbnNpdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKiBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHRoYXQgcmVqZWN0cyB0aGUgVHJhbnNpdGlvbiBpZiBpdCBpcyBpbnZhbGlkXHJcbiAqXHJcbiAqIFRoaXMgaG9vayBpcyBpbnZva2VkIGF0IHRoZSBlbmQgb2YgdGhlIG9uQmVmb3JlIHBoYXNlLlxyXG4gKiBJZiB0aGUgdHJhbnNpdGlvbiBpcyBpbnZhbGlkIChmb3IgZXhhbXBsZSwgcGFyYW0gdmFsdWVzIGRvIG5vdCB2YWxpZGF0ZSlcclxuICogdGhlbiB0aGUgdHJhbnNpdGlvbiBpcyByZWplY3RlZC5cclxuICovXHJcbmZ1bmN0aW9uIGludmFsaWRUcmFuc2l0aW9uSG9vayh0cmFucykge1xyXG4gICAgaWYgKCF0cmFucy52YWxpZCgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRyYW5zLmVycm9yKCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMucmVnaXN0ZXJJbnZhbGlkVHJhbnNpdGlvbkhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcclxuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgaW52YWxpZFRyYW5zaXRpb25Ib29rLCB7IHByaW9yaXR5OiAtMTAwMDAgfSk7XHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludmFsaWRUcmFuc2l0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL2ludmFsaWRUcmFuc2l0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQSBmYWN0b3J5IHdoaWNoIGNyZWF0ZXMgYW4gb25FbnRlciwgb25FeGl0IG9yIG9uUmV0YWluIHRyYW5zaXRpb24gaG9vayBmdW5jdGlvblxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gaW52b2tlcyB0aGUgKGZvciBpbnN0YW5jZSkgc3RhdGUub25FbnRlciBob29rIHdoZW4gdGhlXHJcbiAqIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQuXHJcbiAqXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VFbnRlckV4aXRSZXRhaW5Ib29rKGhvb2tOYW1lKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRyYW5zaXRpb24sIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIF9zdGF0ZSA9IHN0YXRlLiQkc3RhdGUoKTtcclxuICAgICAgICB2YXIgaG9va0ZuID0gX3N0YXRlW2hvb2tOYW1lXTtcclxuICAgICAgICByZXR1cm4gaG9va0ZuKHRyYW5zaXRpb24sIHN0YXRlKTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dIGZvciBvbkV4aXRcclxuICpcclxuICogV2hlbiB0aGUgc3RhdGUgaXMgYmVpbmcgZXhpdGVkLCB0aGUgc3RhdGUncyAub25FeGl0IGZ1bmN0aW9uIGlzIGludm9rZWQuXHJcbiAqXHJcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uRXhpdCh7IGV4aXRpbmc6IChzdGF0ZSkgPT4gISFzdGF0ZS5vbkV4aXQgfSwgb25FeGl0SG9vayk7YFxyXG4gKlxyXG4gKiBTZWU6IFtbSUhvb2tSZWdpc3RyeS5vbkV4aXRdXVxyXG4gKi9cclxudmFyIG9uRXhpdEhvb2sgPSBtYWtlRW50ZXJFeGl0UmV0YWluSG9vaygnb25FeGl0Jyk7XHJcbmV4cG9ydHMucmVnaXN0ZXJPbkV4aXRIb29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XHJcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25FeGl0KHsgZXhpdGluZzogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uRXhpdDsgfSB9LCBvbkV4aXRIb29rKTtcclxufTtcclxuLyoqXHJcbiAqIFRoZSBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dIGZvciBvblJldGFpblxyXG4gKlxyXG4gKiBXaGVuIHRoZSBzdGF0ZSB3YXMgYWxyZWFkeSBlbnRlcmVkLCBhbmQgaXMgbm90IGJlaW5nIGV4aXRlZCBvciByZS1lbnRlcmVkLCB0aGUgc3RhdGUncyAub25SZXRhaW4gZnVuY3Rpb24gaXMgaW52b2tlZC5cclxuICpcclxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25SZXRhaW4oeyByZXRhaW5lZDogKHN0YXRlKSA9PiAhIXN0YXRlLm9uUmV0YWluIH0sIG9uUmV0YWluSG9vayk7YFxyXG4gKlxyXG4gKiBTZWU6IFtbSUhvb2tSZWdpc3RyeS5vblJldGFpbl1dXHJcbiAqL1xyXG52YXIgb25SZXRhaW5Ib29rID0gbWFrZUVudGVyRXhpdFJldGFpbkhvb2soJ29uUmV0YWluJyk7XHJcbmV4cG9ydHMucmVnaXN0ZXJPblJldGFpbkhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcclxuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vblJldGFpbih7IHJldGFpbmVkOiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuICEhc3RhdGUub25SZXRhaW47IH0gfSwgb25SZXRhaW5Ib29rKTtcclxufTtcclxuLyoqXHJcbiAqIFRoZSBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dIGZvciBvbkVudGVyXHJcbiAqXHJcbiAqIFdoZW4gdGhlIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQsIHRoZSBzdGF0ZSdzIC5vbkVudGVyIGZ1bmN0aW9uIGlzIGludm9rZWQuXHJcbiAqXHJcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uRW50ZXIoeyBlbnRlcmluZzogKHN0YXRlKSA9PiAhIXN0YXRlLm9uRW50ZXIgfSwgb25FbnRlckhvb2spO2BcclxuICpcclxuICogU2VlOiBbW0lIb29rUmVnaXN0cnkub25FbnRlcl1dXHJcbiAqL1xyXG52YXIgb25FbnRlckhvb2sgPSBtYWtlRW50ZXJFeGl0UmV0YWluSG9vaygnb25FbnRlcicpO1xyXG5leHBvcnRzLnJlZ2lzdGVyT25FbnRlckhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcclxuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkVudGVyKHsgZW50ZXJpbmc6IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gISFzdGF0ZS5vbkVudGVyOyB9IH0sIG9uRW50ZXJIb29rKTtcclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25FbnRlckV4aXRSZXRhaW4uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3Mvb25FbnRlckV4aXRSZXRhaW4uanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKiBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xyXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xyXG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcclxudmFyIHRhcmdldFN0YXRlXzEgPSByZXF1aXJlKFwiLi4vc3RhdGUvdGFyZ2V0U3RhdGVcIik7XHJcbi8qKlxyXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHRoYXQgcmVkaXJlY3RzIHRvIGEgZGlmZmVyZW50IHN0YXRlIG9yIHBhcmFtc1xyXG4gKlxyXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHsgdG86IChzdGF0ZSkgPT4gISFzdGF0ZS5yZWRpcmVjdFRvIH0sIHJlZGlyZWN0SG9vayk7YFxyXG4gKlxyXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlZGlyZWN0VG9dXVxyXG4gKi9cclxudmFyIHJlZGlyZWN0VG9Ib29rID0gZnVuY3Rpb24gKHRyYW5zKSB7XHJcbiAgICB2YXIgcmVkaXJlY3QgPSB0cmFucy50bygpLnJlZGlyZWN0VG87XHJcbiAgICBpZiAoIXJlZGlyZWN0KVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciAkc3RhdGUgPSB0cmFucy5yb3V0ZXIuc3RhdGVTZXJ2aWNlO1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0KHJlc3VsdCkge1xyXG4gICAgICAgIGlmICghcmVzdWx0KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUpXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhyZXN1bHQpKVxyXG4gICAgICAgICAgICByZXR1cm4gJHN0YXRlLnRhcmdldChyZXN1bHQsIHRyYW5zLnBhcmFtcygpLCB0cmFucy5vcHRpb25zKCkpO1xyXG4gICAgICAgIGlmIChyZXN1bHRbJ3N0YXRlJ10gfHwgcmVzdWx0WydwYXJhbXMnXSlcclxuICAgICAgICAgICAgcmV0dXJuICRzdGF0ZS50YXJnZXQocmVzdWx0WydzdGF0ZSddIHx8IHRyYW5zLnRvKCksIHJlc3VsdFsncGFyYW1zJ10gfHwgdHJhbnMucGFyYW1zKCksIHRyYW5zLm9wdGlvbnMoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJlZGljYXRlc18xLmlzRnVuY3Rpb24ocmVkaXJlY3QpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4ocmVkaXJlY3QodHJhbnMpKS50aGVuKGhhbmRsZVJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KHJlZGlyZWN0KTtcclxufTtcclxuZXhwb3J0cy5yZWdpc3RlclJlZGlyZWN0VG9Ib29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XHJcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7IHRvOiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuICEhc3RhdGUucmVkaXJlY3RUbzsgfSB9LCByZWRpcmVjdFRvSG9vayk7XHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZGlyZWN0VG8uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvcmVkaXJlY3RUby5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqIEBtb2R1bGUgaG9va3MgKi9cclxuLyoqIGZvciB0eXBlZG9jICovXHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xyXG52YXIgcmVzb2x2ZUNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmVDb250ZXh0XCIpO1xyXG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcclxuLyoqXHJcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggcmVzb2x2ZXMgYWxsIEVBR0VSIFJlc29sdmFibGVzIGluIHRoZSBUbyBQYXRoXHJcbiAqXHJcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGVhZ2VyUmVzb2x2ZVBhdGgpO2BcclxuICpcclxuICogV2hlbiBhIFRyYW5zaXRpb24gc3RhcnRzLCB0aGlzIGhvb2sgcmVzb2x2ZXMgYWxsIHRoZSBFQUdFUiBSZXNvbHZhYmxlcywgd2hpY2ggdGhlIHRyYW5zaXRpb24gdGhlbiB3YWl0cyBmb3IuXHJcbiAqXHJcbiAqIFNlZSBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dXHJcbiAqL1xyXG52YXIgZWFnZXJSZXNvbHZlUGF0aCA9IGZ1bmN0aW9uICh0cmFucykge1xyXG4gICAgcmV0dXJuIG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KHRyYW5zLnRyZWVDaGFuZ2VzKCkudG8pXHJcbiAgICAgICAgLnJlc29sdmVQYXRoKFwiRUFHRVJcIiwgdHJhbnMpXHJcbiAgICAgICAgLnRoZW4oY29tbW9uXzEubm9vcCk7XHJcbn07XHJcbmV4cG9ydHMucmVnaXN0ZXJFYWdlclJlc29sdmVQYXRoID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XHJcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7fSwgZWFnZXJSZXNvbHZlUGF0aCwgeyBwcmlvcml0eTogMTAwMCB9KTtcclxufTtcclxuLyoqXHJcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggcmVzb2x2ZXMgYWxsIExBWlkgUmVzb2x2YWJsZXMgZm9yIHRoZSBzdGF0ZSAoYW5kIGFsbCBpdHMgYW5jZXN0b3JzKSBpbiB0aGUgVG8gUGF0aFxyXG4gKlxyXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vbkVudGVyKHsgZW50ZXJpbmc6ICgpID0+IHRydWUgfSwgbGF6eVJlc29sdmVTdGF0ZSk7YFxyXG4gKlxyXG4gKiBXaGVuIGEgU3RhdGUgaXMgYmVpbmcgZW50ZXJlZCwgdGhpcyBob29rIHJlc29sdmVzIGFsbCB0aGUgUmVzb2x2YWJsZXMgZm9yIHRoaXMgc3RhdGUsIHdoaWNoIHRoZSB0cmFuc2l0aW9uIHRoZW4gd2FpdHMgZm9yLlxyXG4gKlxyXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXVxyXG4gKi9cclxudmFyIGxhenlSZXNvbHZlU3RhdGUgPSBmdW5jdGlvbiAodHJhbnMsIHN0YXRlKSB7XHJcbiAgICByZXR1cm4gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQodHJhbnMudHJlZUNoYW5nZXMoKS50bylcclxuICAgICAgICAuc3ViQ29udGV4dChzdGF0ZS4kJHN0YXRlKCkpXHJcbiAgICAgICAgLnJlc29sdmVQYXRoKFwiTEFaWVwiLCB0cmFucylcclxuICAgICAgICAudGhlbihjb21tb25fMS5ub29wKTtcclxufTtcclxuZXhwb3J0cy5yZWdpc3RlckxhenlSZXNvbHZlU3RhdGUgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcclxuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkVudGVyKHsgZW50ZXJpbmc6IGhvZl8xLnZhbCh0cnVlKSB9LCBsYXp5UmVzb2x2ZVN0YXRlLCB7IHByaW9yaXR5OiAxMDAwIH0pO1xyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3Jlc29sdmUuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xyXG4vKipcclxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCB1cGRhdGVzIGdsb2JhbCBVSS1Sb3V0ZXIgc3RhdGVcclxuICpcclxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25CZWZvcmUoe30sIHVwZGF0ZUdsb2JhbFN0YXRlKTtgXHJcbiAqXHJcbiAqIEJlZm9yZSBhIFtbVHJhbnNpdGlvbl1dIHN0YXJ0cywgdXBkYXRlcyB0aGUgZ2xvYmFsIHZhbHVlIG9mIFwidGhlIGN1cnJlbnQgdHJhbnNpdGlvblwiIChbW0dsb2JhbHMudHJhbnNpdGlvbl1dKS5cclxuICogQWZ0ZXIgYSBzdWNjZXNzZnVsIFtbVHJhbnNpdGlvbl1dLCB1cGRhdGVzIHRoZSBnbG9iYWwgdmFsdWVzIG9mIFwidGhlIGN1cnJlbnQgc3RhdGVcIlxyXG4gKiAoW1tHbG9iYWxzLmN1cnJlbnRdXSBhbmQgW1tHbG9iYWxzLiRjdXJyZW50XV0pIGFuZCBcInRoZSBjdXJyZW50IHBhcmFtIHZhbHVlc1wiIChbW0dsb2JhbHMucGFyYW1zXV0pLlxyXG4gKlxyXG4gKiBTZWUgYWxzbyB0aGUgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzOlxyXG4gKiBbW1N0YXRlU2VydmljZS50cmFuc2l0aW9uXV0sIFtbU3RhdGVTZXJ2aWNlLmN1cnJlbnRdXSwgW1tTdGF0ZVNlcnZpY2UucGFyYW1zXV1cclxuICovXHJcbnZhciB1cGRhdGVHbG9iYWxTdGF0ZSA9IGZ1bmN0aW9uICh0cmFucykge1xyXG4gICAgdmFyIGdsb2JhbHMgPSB0cmFucy5yb3V0ZXIuZ2xvYmFscztcclxuICAgIHZhciB0cmFuc2l0aW9uU3VjY2Vzc2Z1bCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBnbG9iYWxzLnN1Y2Nlc3NmdWxUcmFuc2l0aW9ucy5lbnF1ZXVlKHRyYW5zKTtcclxuICAgICAgICBnbG9iYWxzLiRjdXJyZW50ID0gdHJhbnMuJHRvKCk7XHJcbiAgICAgICAgZ2xvYmFscy5jdXJyZW50ID0gZ2xvYmFscy4kY3VycmVudC5zZWxmO1xyXG4gICAgICAgIGNvbW1vbl8xLmNvcHkodHJhbnMucGFyYW1zKCksIGdsb2JhbHMucGFyYW1zKTtcclxuICAgIH07XHJcbiAgICB2YXIgY2xlYXJDdXJyZW50VHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3QgY2xlYXIgZ2xvYmFscy50cmFuc2l0aW9uIGlmIGEgZGlmZmVyZW50IHRyYW5zaXRpb24gaGFzIHN0YXJ0ZWQgaW4gdGhlIG1lYW50aW1lXHJcbiAgICAgICAgaWYgKGdsb2JhbHMudHJhbnNpdGlvbiA9PT0gdHJhbnMpXHJcbiAgICAgICAgICAgIGdsb2JhbHMudHJhbnNpdGlvbiA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgdHJhbnMub25TdWNjZXNzKHt9LCB0cmFuc2l0aW9uU3VjY2Vzc2Z1bCwgeyBwcmlvcml0eTogMTAwMDAgfSk7XHJcbiAgICB0cmFucy5wcm9taXNlLnRoZW4oY2xlYXJDdXJyZW50VHJhbnNpdGlvbiwgY2xlYXJDdXJyZW50VHJhbnNpdGlvbik7XHJcbn07XHJcbmV4cG9ydHMucmVnaXN0ZXJVcGRhdGVHbG9iYWxTdGF0ZSA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xyXG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uQ3JlYXRlKHt9LCB1cGRhdGVHbG9iYWxTdGF0ZSk7XHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwZGF0ZUdsb2JhbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvdXBkYXRlR2xvYmFscy5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gd2hpY2ggdXBkYXRlcyB0aGUgVVJMIGFmdGVyIGEgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uXHJcbiAqXHJcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlVXJsKTtgXHJcbiAqL1xyXG52YXIgdXBkYXRlVXJsID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcclxuICAgIHZhciBvcHRpb25zID0gdHJhbnNpdGlvbi5vcHRpb25zKCk7XHJcbiAgICB2YXIgJHN0YXRlID0gdHJhbnNpdGlvbi5yb3V0ZXIuc3RhdGVTZXJ2aWNlO1xyXG4gICAgdmFyICR1cmxSb3V0ZXIgPSB0cmFuc2l0aW9uLnJvdXRlci51cmxSb3V0ZXI7XHJcbiAgICAvLyBEb250IHVwZGF0ZSB0aGUgdXJsIGluIHRoZXNlIHNpdHVhdGlvbnM6XHJcbiAgICAvLyBUaGUgdHJhbnNpdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGEgVVJMIHN5bmMgKG9wdGlvbnMuc291cmNlID09PSAndXJsJylcclxuICAgIC8vIFRoZSB1c2VyIGRvZXNuJ3Qgd2FudCB0aGUgdXJsIHRvIHVwZGF0ZSAob3B0aW9ucy5sb2NhdGlvbiA9PT0gZmFsc2UpXHJcbiAgICAvLyBUaGUgZGVzdGluYXRpb24gc3RhdGUsIGFuZCBhbGwgcGFyZW50cyBoYXZlIG5vIG5hdmlnYWJsZSB1cmxcclxuICAgIGlmIChvcHRpb25zLnNvdXJjZSAhPT0gJ3VybCcgJiYgb3B0aW9ucy5sb2NhdGlvbiAmJiAkc3RhdGUuJGN1cnJlbnQubmF2aWdhYmxlKSB7XHJcbiAgICAgICAgdmFyIHVybE9wdGlvbnMgPSB7IHJlcGxhY2U6IG9wdGlvbnMubG9jYXRpb24gPT09ICdyZXBsYWNlJyB9O1xyXG4gICAgICAgICR1cmxSb3V0ZXIucHVzaCgkc3RhdGUuJGN1cnJlbnQubmF2aWdhYmxlLnVybCwgJHN0YXRlLnBhcmFtcywgdXJsT3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAkdXJsUm91dGVyLnVwZGF0ZSh0cnVlKTtcclxufTtcclxuZXhwb3J0cy5yZWdpc3RlclVwZGF0ZVVybCA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xyXG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlVXJsLCB7IHByaW9yaXR5OiA5OTk5IH0pO1xyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmwuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvdXJsLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKiogQG1vZHVsZSBob29rcyAqLyAvKiogZm9yIHR5cGVkb2MgKi9cclxudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XHJcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xyXG4vKipcclxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCB3YWl0cyBmb3IgdGhlIHZpZXdzIHRvIGxvYWRcclxuICpcclxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7fSwgbG9hZEVudGVyaW5nVmlld3MpO2BcclxuICpcclxuICogQWxsb3dzIHRoZSB2aWV3cyB0byBkbyBhc3luYyB3b3JrIGluIFtbVmlld0NvbmZpZy5sb2FkXV0gYmVmb3JlIHRoZSB0cmFuc2l0aW9uIGNvbnRpbnVlcy5cclxuICogSW4gYW5ndWxhciAxLCB0aGlzIGluY2x1ZGVzIGxvYWRpbmcgdGhlIHRlbXBsYXRlcy5cclxuICovXHJcbnZhciBsb2FkRW50ZXJpbmdWaWV3cyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XHJcbiAgICB2YXIgJHEgPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcTtcclxuICAgIHZhciBlbnRlcmluZ1ZpZXdzID0gdHJhbnNpdGlvbi52aWV3cyhcImVudGVyaW5nXCIpO1xyXG4gICAgaWYgKCFlbnRlcmluZ1ZpZXdzLmxlbmd0aClcclxuICAgICAgICByZXR1cm47XHJcbiAgICByZXR1cm4gJHEuYWxsKGVudGVyaW5nVmlld3MubWFwKGZ1bmN0aW9uICh2aWV3KSB7IHJldHVybiAkcS53aGVuKHZpZXcubG9hZCgpKTsgfSkpLnRoZW4oY29tbW9uXzEubm9vcCk7XHJcbn07XHJcbmV4cG9ydHMucmVnaXN0ZXJMb2FkRW50ZXJpbmdWaWV3cyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xyXG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uRmluaXNoKHt9LCBsb2FkRW50ZXJpbmdWaWV3cyk7XHJcbn07XHJcbi8qKlxyXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIGFjdGl2YXRlcyB0aGUgbmV3IHZpZXdzIHdoZW4gYSB0cmFuc2l0aW9uIGlzIHN1Y2Nlc3NmdWwuXHJcbiAqXHJcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgYWN0aXZhdGVWaWV3cyk7YFxyXG4gKlxyXG4gKiBBZnRlciBhIHRyYW5zaXRpb24gaXMgY29tcGxldGUsIHRoaXMgaG9vayBkZWFjdGl2YXRlcyB0aGUgb2xkIHZpZXdzIGZyb20gdGhlIHByZXZpb3VzIHN0YXRlLFxyXG4gKiBhbmQgYWN0aXZhdGVzIHRoZSBuZXcgdmlld3MgZnJvbSB0aGUgZGVzdGluYXRpb24gc3RhdGUuXHJcbiAqXHJcbiAqIFNlZSBbW1ZpZXdTZXJ2aWNlXV1cclxuICovXHJcbnZhciBhY3RpdmF0ZVZpZXdzID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcclxuICAgIHZhciBlbnRlcmluZ1ZpZXdzID0gdHJhbnNpdGlvbi52aWV3cyhcImVudGVyaW5nXCIpO1xyXG4gICAgdmFyIGV4aXRpbmdWaWV3cyA9IHRyYW5zaXRpb24udmlld3MoXCJleGl0aW5nXCIpO1xyXG4gICAgaWYgKCFlbnRlcmluZ1ZpZXdzLmxlbmd0aCAmJiAhZXhpdGluZ1ZpZXdzLmxlbmd0aClcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgJHZpZXcgPSB0cmFuc2l0aW9uLnJvdXRlci52aWV3U2VydmljZTtcclxuICAgIGV4aXRpbmdWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uICh2YykgeyByZXR1cm4gJHZpZXcuZGVhY3RpdmF0ZVZpZXdDb25maWcodmMpOyB9KTtcclxuICAgIGVudGVyaW5nVmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmMpIHsgcmV0dXJuICR2aWV3LmFjdGl2YXRlVmlld0NvbmZpZyh2Yyk7IH0pO1xyXG4gICAgJHZpZXcuc3luYygpO1xyXG59O1xyXG5leHBvcnRzLnJlZ2lzdGVyQWN0aXZhdGVWaWV3cyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xyXG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgYWN0aXZhdGVWaWV3cyk7XHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3ZpZXdzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuLyoqXHJcbiAqICMgQ29yZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzXHJcbiAqXHJcbiAqIFRoZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHRoYXQgYXJlIGNvcmUgdG8gdWktcm91dGVyIGFuZCBkbyBub3QgYmVsb25nXHJcbiAqIHRvIGEgbW9yZSBzcGVjaWZpYyBzdWJzeXN0ZW0gKHN1Y2ggYXMgcmVzb2x2ZSkuXHJcbiAqXHJcbiAqIEBjb3JlYXBpXHJcbiAqIEBwcmVmZXJyZWRcclxuICogQG1vZHVsZSBjb3JlXHJcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKiogQGludGVybmFsYXBpICovXHJcbnZhciBVSVJvdXRlclBsdWdpbkJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVUlSb3V0ZXJQbHVnaW5CYXNlKCkge1xyXG4gICAgfVxyXG4gICAgVUlSb3V0ZXJQbHVnaW5CYXNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikgeyB9O1xyXG4gICAgcmV0dXJuIFVJUm91dGVyUGx1Z2luQmFzZTtcclxufSgpKTtcclxuZXhwb3J0cy5VSVJvdXRlclBsdWdpbkJhc2UgPSBVSVJvdXRlclBsdWdpbkJhc2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9pbnRlcmZhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXJhbVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhcmFtVHlwZXNcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZVBhcmFtc1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhcmFtVHlwZVwiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKiBAbW9kdWxlIHBhdGggKi8gLyoqIGZvciB0eXBlZG9jICovXHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhdGhOb2RlXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vcGF0aEZhY3RvcnlcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqIEBtb2R1bGUgcmVzb2x2ZSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cclxuX19leHBvcnQocmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vcmVzb2x2YWJsZVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3Jlc29sdmVDb250ZXh0XCIpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvcmVzb2x2ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlQnVpbGRlclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlT2JqZWN0XCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVNYXRjaGVyXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVRdWV1ZU1hbmFnZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZVJlZ2lzdHJ5XCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVTZXJ2aWNlXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vdGFyZ2V0U3RhdGVcIikpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiAjIFRyYW5zaXRpb24gc3Vic3lzdGVtXHJcbiAqXHJcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIEFQSXMgcmVsYXRlZCB0byBhIFRyYW5zaXRpb24uXHJcbiAqXHJcbiAqIFNlZTpcclxuICogLSBbW1RyYW5zaXRpb25TZXJ2aWNlXV1cclxuICogLSBbW1RyYW5zaXRpb25dXVxyXG4gKiAtIFtbSG9va0ZuXV0sIFtbVHJhbnNpdGlvbkhvb2tGbl1dLCBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dLCBbW0hvb2tNYXRjaENyaXRlcmlhXV0sIFtbSG9va1Jlc3VsdF1dXHJcbiAqXHJcbiAqIEBjb3JlYXBpXHJcbiAqIEBwcmVmZXJyZWRcclxuICogQG1vZHVsZSB0cmFuc2l0aW9uXHJcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cclxuX19leHBvcnQocmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vaG9va0J1aWxkZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9ob29rUmVnaXN0cnlcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9yZWplY3RGYWN0b3J5XCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vdHJhbnNpdGlvblwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYW5zaXRpb25Ib29rXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vdHJhbnNpdGlvbkV2ZW50VHlwZVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYW5zaXRpb25TZXJ2aWNlXCIpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybE1hdGNoZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxNYXRjaGVyRmFjdG9yeVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybFJvdXRlclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybFJ1bGVcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxTZXJ2aWNlXCIpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdXJsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbGFwaVxyXG4gKiBAbW9kdWxlIHZhbmlsbGFcclxuICovXHJcbi8qKiAqL1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi92YW5pbGxhL2luZGV4XCIpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFuaWxsYS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vcVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2luamVjdG9yXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vYmFzZUxvY2F0aW9uU2VydmljZVwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hhc2hMb2NhdGlvblNlcnZpY2VcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9tZW1vcnlMb2NhdGlvblNlcnZpY2VcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wdXNoU3RhdGVMb2NhdGlvblNlcnZpY2VcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9tZW1vcnlMb2NhdGlvbkNvbmZpZ1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2Jyb3dzZXJMb2NhdGlvbkNvbmZpZ1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vcGx1Z2luc1wiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxhcGlcclxuICogQG1vZHVsZSB2YW5pbGxhXHJcbiAqL1xyXG4vKiogKi9cclxudmFyIGJyb3dzZXJMb2NhdGlvbkNvbmZpZ18xID0gcmVxdWlyZShcIi4vYnJvd3NlckxvY2F0aW9uQ29uZmlnXCIpO1xyXG52YXIgaGFzaExvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vaGFzaExvY2F0aW9uU2VydmljZVwiKTtcclxudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcclxudmFyIHB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vcHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlXCIpO1xyXG52YXIgbWVtb3J5TG9jYXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9tZW1vcnlMb2NhdGlvblNlcnZpY2VcIik7XHJcbnZhciBtZW1vcnlMb2NhdGlvbkNvbmZpZ18xID0gcmVxdWlyZShcIi4vbWVtb3J5TG9jYXRpb25Db25maWdcIik7XHJcbnZhciBpbmplY3Rvcl8xID0gcmVxdWlyZShcIi4vaW5qZWN0b3JcIik7XHJcbnZhciBxXzEgPSByZXF1aXJlKFwiLi9xXCIpO1xyXG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcclxuZnVuY3Rpb24gc2VydmljZXNQbHVnaW4ocm91dGVyKSB7XHJcbiAgICBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3IgPSBpbmplY3Rvcl8xLiRpbmplY3RvcjtcclxuICAgIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxID0gcV8xLiRxO1xyXG4gICAgcmV0dXJuIHsgbmFtZTogXCJ2YW5pbGxhLnNlcnZpY2VzXCIsICRxOiBxXzEuJHEsICRpbmplY3RvcjogaW5qZWN0b3JfMS4kaW5qZWN0b3IsIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0gfTtcclxufVxyXG5leHBvcnRzLnNlcnZpY2VzUGx1Z2luID0gc2VydmljZXNQbHVnaW47XHJcbi8qKiBBIGBVSVJvdXRlclBsdWdpbmAgdXNlcyB0aGUgYnJvd3NlciBoYXNoIHRvIGdldC9zZXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gKi9cclxuZXhwb3J0cy5oYXNoTG9jYXRpb25QbHVnaW4gPSB1dGlsc18xLmxvY2F0aW9uUGx1Z2luRmFjdG9yeSgndmFuaWxsYS5oYXNoQmFuZ0xvY2F0aW9uJywgZmFsc2UsIGhhc2hMb2NhdGlvblNlcnZpY2VfMS5IYXNoTG9jYXRpb25TZXJ2aWNlLCBicm93c2VyTG9jYXRpb25Db25maWdfMS5Ccm93c2VyTG9jYXRpb25Db25maWcpO1xyXG4vKiogQSBgVUlSb3V0ZXJQbHVnaW5gIHRoYXQgZ2V0cy9zZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIHVzaW5nIHRoZSBicm93c2VyJ3MgYGxvY2F0aW9uYCBhbmQgYGhpc3RvcnlgIGFwaXMgKi9cclxuZXhwb3J0cy5wdXNoU3RhdGVMb2NhdGlvblBsdWdpbiA9IHV0aWxzXzEubG9jYXRpb25QbHVnaW5GYWN0b3J5KFwidmFuaWxsYS5wdXNoU3RhdGVMb2NhdGlvblwiLCB0cnVlLCBwdXNoU3RhdGVMb2NhdGlvblNlcnZpY2VfMS5QdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UsIGJyb3dzZXJMb2NhdGlvbkNvbmZpZ18xLkJyb3dzZXJMb2NhdGlvbkNvbmZpZyk7XHJcbi8qKiBBIGBVSVJvdXRlclBsdWdpbmAgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gZnJvbSBhbiBpbi1tZW1vcnkgb2JqZWN0ICovXHJcbmV4cG9ydHMubWVtb3J5TG9jYXRpb25QbHVnaW4gPSB1dGlsc18xLmxvY2F0aW9uUGx1Z2luRmFjdG9yeShcInZhbmlsbGEubWVtb3J5TG9jYXRpb25cIiwgZmFsc2UsIG1lbW9yeUxvY2F0aW9uU2VydmljZV8xLk1lbW9yeUxvY2F0aW9uU2VydmljZSwgbWVtb3J5TG9jYXRpb25Db25maWdfMS5NZW1vcnlMb2NhdGlvbkNvbmZpZyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbnMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9wbHVnaW5zLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vdmlld1wiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQHVpcm91dGVyL2NvcmUvbGliL3ZpZXcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcbiAqIGFuZ3VsYXItdWktYm9vdHN0cmFwXHJcbiAqIGh0dHA6Ly9hbmd1bGFyLXVpLmdpdGh1Yi5pby9ib290c3RyYXAvXHJcblxyXG4gKiBWZXJzaW9uOiAyLjUuMCAtIDIwMTctMDEtMjhcclxuICogTGljZW5zZTogTUlUXHJcbiAqL2FuZ3VsYXIubW9kdWxlKFwidWkuYm9vdHN0cmFwXCIsIFtcInVpLmJvb3RzdHJhcC50cGxzXCIsIFwidWkuYm9vdHN0cmFwLmNvbGxhcHNlXCIsXCJ1aS5ib290c3RyYXAudGFiaW5kZXhcIixcInVpLmJvb3RzdHJhcC5hY2NvcmRpb25cIixcInVpLmJvb3RzdHJhcC5hbGVydFwiLFwidWkuYm9vdHN0cmFwLmJ1dHRvbnNcIixcInVpLmJvb3RzdHJhcC5jYXJvdXNlbFwiLFwidWkuYm9vdHN0cmFwLmRhdGVwYXJzZXJcIixcInVpLmJvb3RzdHJhcC5pc0NsYXNzXCIsXCJ1aS5ib290c3RyYXAuZGF0ZXBpY2tlclwiLFwidWkuYm9vdHN0cmFwLnBvc2l0aW9uXCIsXCJ1aS5ib290c3RyYXAuZGF0ZXBpY2tlclBvcHVwXCIsXCJ1aS5ib290c3RyYXAuZGVib3VuY2VcIixcInVpLmJvb3RzdHJhcC5tdWx0aU1hcFwiLFwidWkuYm9vdHN0cmFwLmRyb3Bkb3duXCIsXCJ1aS5ib290c3RyYXAuc3RhY2tlZE1hcFwiLFwidWkuYm9vdHN0cmFwLm1vZGFsXCIsXCJ1aS5ib290c3RyYXAucGFnaW5nXCIsXCJ1aS5ib290c3RyYXAucGFnZXJcIixcInVpLmJvb3RzdHJhcC5wYWdpbmF0aW9uXCIsXCJ1aS5ib290c3RyYXAudG9vbHRpcFwiLFwidWkuYm9vdHN0cmFwLnBvcG92ZXJcIixcInVpLmJvb3RzdHJhcC5wcm9ncmVzc2JhclwiLFwidWkuYm9vdHN0cmFwLnJhdGluZ1wiLFwidWkuYm9vdHN0cmFwLnRhYnNcIixcInVpLmJvb3RzdHJhcC50aW1lcGlja2VyXCIsXCJ1aS5ib290c3RyYXAudHlwZWFoZWFkXCJdKTtcclxuYW5ndWxhci5tb2R1bGUoXCJ1aS5ib290c3RyYXAudHBsc1wiLCBbXCJ1aWIvdGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi1ncm91cC5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbFwiLFwidWliL3RlbXBsYXRlL2Nhcm91c2VsL2Nhcm91c2VsLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RheS5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9tb250aC5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci95ZWFyLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyUG9wdXAvcG9wdXAuaHRtbFwiLFwidWliL3RlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvcGFnZXIvcGFnZXIuaHRtbFwiLFwidWliL3RlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtcG9wdXAuaHRtbFwiLFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXRlbXBsYXRlLXBvcHVwLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItaHRtbC5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLXRlbXBsYXRlLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXIuaHRtbFwiLFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFwiLFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9yYXRpbmcvcmF0aW5nLmh0bWxcIixcInVpYi90ZW1wbGF0ZS90YWJzL3RhYi5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFwiLFwidWliL3RlbXBsYXRlL3RpbWVwaWNrZXIvdGltZXBpY2tlci5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1tYXRjaC5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1wb3B1cC5odG1sXCJdKTtcclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5jb2xsYXBzZScsIFtdKVxyXG5cclxuICAuZGlyZWN0aXZlKCd1aWJDb2xsYXBzZScsIFsnJGFuaW1hdGUnLCAnJHEnLCAnJHBhcnNlJywgJyRpbmplY3RvcicsIGZ1bmN0aW9uKCRhbmltYXRlLCAkcSwgJHBhcnNlLCAkaW5qZWN0b3IpIHtcclxuICAgIHZhciAkYW5pbWF0ZUNzcyA9ICRpbmplY3Rvci5oYXMoJyRhbmltYXRlQ3NzJykgPyAkaW5qZWN0b3IuZ2V0KCckYW5pbWF0ZUNzcycpIDogbnVsbDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xyXG4gICAgICAgIHZhciBleHBhbmRpbmdFeHByID0gJHBhcnNlKGF0dHJzLmV4cGFuZGluZyksXHJcbiAgICAgICAgICBleHBhbmRlZEV4cHIgPSAkcGFyc2UoYXR0cnMuZXhwYW5kZWQpLFxyXG4gICAgICAgICAgY29sbGFwc2luZ0V4cHIgPSAkcGFyc2UoYXR0cnMuY29sbGFwc2luZyksXHJcbiAgICAgICAgICBjb2xsYXBzZWRFeHByID0gJHBhcnNlKGF0dHJzLmNvbGxhcHNlZCksXHJcbiAgICAgICAgICBob3Jpem9udGFsID0gZmFsc2UsXHJcbiAgICAgICAgICBjc3MgPSB7fSxcclxuICAgICAgICAgIGNzc1RvID0ge307XHJcblxyXG4gICAgICAgIGluaXQoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgICAgICAgIGhvcml6b250YWwgPSAhISgnaG9yaXpvbnRhbCcgaW4gYXR0cnMpO1xyXG4gICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgY3NzID0ge1xyXG4gICAgICAgICAgICAgIHdpZHRoOiAnJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjc3NUbyA9IHt3aWR0aDogJzAnfTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNzcyA9IHtcclxuICAgICAgICAgICAgICBoZWlnaHQ6ICcnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNzc1RvID0ge2hlaWdodDogJzAnfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghc2NvcGUuJGV2YWwoYXR0cnMudWliQ29sbGFwc2UpKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2luJylcclxuICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlJylcclxuICAgICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXHJcbiAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpXHJcbiAgICAgICAgICAgICAgLmNzcyhjc3MpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0U2Nyb2xsRnJvbUVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt3aWR0aDogZWxlbWVudC5zY3JvbGxXaWR0aCArICdweCd9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHtoZWlnaHQ6IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ICsgJ3B4J307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBleHBhbmQoKSB7XHJcbiAgICAgICAgICBpZiAoZWxlbWVudC5oYXNDbGFzcygnY29sbGFwc2UnKSAmJiBlbGVtZW50Lmhhc0NsYXNzKCdpbicpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAkcS5yZXNvbHZlKGV4cGFuZGluZ0V4cHIoc2NvcGUpKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdjb2xsYXBzZScpXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNpbmcnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcclxuICAgICAgICAgICAgICAgICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcclxuICAgICAgICAgICAgICAgICAgYWRkQ2xhc3M6ICdpbicsXHJcbiAgICAgICAgICAgICAgICAgIGVhc2luZzogJ2Vhc2UnLFxyXG4gICAgICAgICAgICAgICAgICBjc3M6IHtcclxuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgdG86IGdldFNjcm9sbEZyb21FbGVtZW50KGVsZW1lbnRbMF0pXHJcbiAgICAgICAgICAgICAgICB9KS5zdGFydCgpWydmaW5hbGx5J10oZXhwYW5kRG9uZSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICRhbmltYXRlLmFkZENsYXNzKGVsZW1lbnQsICdpbicsIHtcclxuICAgICAgICAgICAgICAgICAgY3NzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHRvOiBnZXRTY3JvbGxGcm9tRWxlbWVudChlbGVtZW50WzBdKVxyXG4gICAgICAgICAgICAgICAgfSkudGhlbihleHBhbmREb25lKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGFuZ3VsYXIubm9vcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBleHBhbmREb25lKCkge1xyXG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnY29sbGFwc2luZycpXHJcbiAgICAgICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2UnKVxyXG4gICAgICAgICAgICAuY3NzKGNzcyk7XHJcbiAgICAgICAgICBleHBhbmRlZEV4cHIoc2NvcGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY29sbGFwc2UoKSB7XHJcbiAgICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQ2xhc3MoJ2NvbGxhcHNlJykgJiYgIWVsZW1lbnQuaGFzQ2xhc3MoJ2luJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbGxhcHNlRG9uZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICRxLnJlc29sdmUoY29sbGFwc2luZ0V4cHIoc2NvcGUpKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBlbGVtZW50XHJcbiAgICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBUaGUgd2lkdGggbXVzdCBiZSBzZXQgYmVmb3JlIGFkZGluZyBcImNvbGxhcHNpbmdcIiBjbGFzcy5cclxuICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBicm93c2VyIGF0dGVtcHRzIHRvIGFuaW1hdGUgZnJvbSB3aWR0aCAwIChpblxyXG4gICAgICAgICAgICAgIC8vIGNvbGxhcHNpbmcgY2xhc3MpIHRvIHRoZSBnaXZlbiB3aWR0aCBoZXJlLlxyXG4gICAgICAgICAgICAgICAgLmNzcyhnZXRTY3JvbGxGcm9tRWxlbWVudChlbGVtZW50WzBdKSlcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxseSBhbGwgcGFuZWwgY29sbGFwc2UgaGF2ZSB0aGUgY29sbGFwc2UgY2xhc3MsIHRoaXMgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgLy8gcHJldmVudHMgdGhlIGFuaW1hdGlvbiBmcm9tIGp1bXBpbmcgdG8gY29sbGFwc2VkIHN0YXRlXHJcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlJylcclxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgIGlmICgkYW5pbWF0ZUNzcykge1xyXG4gICAgICAgICAgICAgICAgJGFuaW1hdGVDc3MoZWxlbWVudCwge1xyXG4gICAgICAgICAgICAgICAgICByZW1vdmVDbGFzczogJ2luJyxcclxuICAgICAgICAgICAgICAgICAgdG86IGNzc1RvXHJcbiAgICAgICAgICAgICAgICB9KS5zdGFydCgpWydmaW5hbGx5J10oY29sbGFwc2VEb25lKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJGFuaW1hdGUucmVtb3ZlQ2xhc3MoZWxlbWVudCwgJ2luJywge1xyXG4gICAgICAgICAgICAgICAgICB0bzogY3NzVG9cclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oY29sbGFwc2VEb25lKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGFuZ3VsYXIubm9vcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjb2xsYXBzZURvbmUoKSB7XHJcbiAgICAgICAgICBlbGVtZW50LmNzcyhjc3NUbyk7IC8vIFJlcXVpcmVkIHNvIHRoYXQgY29sbGFwc2Ugd29ya3Mgd2hlbiBhbmltYXRpb24gaXMgZGlzYWJsZWRcclxuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNpbmcnKVxyXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlJyk7XHJcbiAgICAgICAgICBjb2xsYXBzZWRFeHByKHNjb3BlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNjb3BlLiR3YXRjaChhdHRycy51aWJDb2xsYXBzZSwgZnVuY3Rpb24oc2hvdWxkQ29sbGFwc2UpIHtcclxuICAgICAgICAgIGlmIChzaG91bGRDb2xsYXBzZSkge1xyXG4gICAgICAgICAgICBjb2xsYXBzZSgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXhwYW5kKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50YWJpbmRleCcsIFtdKVxyXG5cclxuLmRpcmVjdGl2ZSgndWliVGFiaW5kZXhUb2dnbGUnLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtLCBhdHRycykge1xyXG4gICAgICBhdHRycy4kb2JzZXJ2ZSgnZGlzYWJsZWQnLCBmdW5jdGlvbihkaXNhYmxlZCkge1xyXG4gICAgICAgIGF0dHJzLiRzZXQoJ3RhYmluZGV4JywgZGlzYWJsZWQgPyAtMSA6IG51bGwpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59KTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYWNjb3JkaW9uJywgWyd1aS5ib290c3RyYXAuY29sbGFwc2UnLCAndWkuYm9vdHN0cmFwLnRhYmluZGV4J10pXHJcblxyXG4uY29uc3RhbnQoJ3VpYkFjY29yZGlvbkNvbmZpZycsIHtcclxuICBjbG9zZU90aGVyczogdHJ1ZVxyXG59KVxyXG5cclxuLmNvbnRyb2xsZXIoJ1VpYkFjY29yZGlvbkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAndWliQWNjb3JkaW9uQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsIGFjY29yZGlvbkNvbmZpZykge1xyXG4gIC8vIFRoaXMgYXJyYXkga2VlcHMgdHJhY2sgb2YgdGhlIGFjY29yZGlvbiBncm91cHNcclxuICB0aGlzLmdyb3VwcyA9IFtdO1xyXG5cclxuICAvLyBFbnN1cmUgdGhhdCBhbGwgdGhlIGdyb3VwcyBpbiB0aGlzIGFjY29yZGlvbiBhcmUgY2xvc2VkLCB1bmxlc3MgY2xvc2Utb3RoZXJzIGV4cGxpY2l0bHkgc2F5cyBub3QgdG9cclxuICB0aGlzLmNsb3NlT3RoZXJzID0gZnVuY3Rpb24ob3Blbkdyb3VwKSB7XHJcbiAgICB2YXIgY2xvc2VPdGhlcnMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuY2xvc2VPdGhlcnMpID9cclxuICAgICAgJHNjb3BlLiRldmFsKCRhdHRycy5jbG9zZU90aGVycykgOiBhY2NvcmRpb25Db25maWcuY2xvc2VPdGhlcnM7XHJcbiAgICBpZiAoY2xvc2VPdGhlcnMpIHtcclxuICAgICAgYW5ndWxhci5mb3JFYWNoKHRoaXMuZ3JvdXBzLCBmdW5jdGlvbihncm91cCkge1xyXG4gICAgICAgIGlmIChncm91cCAhPT0gb3Blbkdyb3VwKSB7XHJcbiAgICAgICAgICBncm91cC5pc09wZW4gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFRoaXMgaXMgY2FsbGVkIGZyb20gdGhlIGFjY29yZGlvbi1ncm91cCBkaXJlY3RpdmUgdG8gYWRkIGl0c2VsZiB0byB0aGUgYWNjb3JkaW9uXHJcbiAgdGhpcy5hZGRHcm91cCA9IGZ1bmN0aW9uKGdyb3VwU2NvcGUpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMuZ3JvdXBzLnB1c2goZ3JvdXBTY29wZSk7XHJcblxyXG4gICAgZ3JvdXBTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdGhhdC5yZW1vdmVHcm91cChncm91cFNjb3BlKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIFRoaXMgaXMgY2FsbGVkIGZyb20gdGhlIGFjY29yZGlvbi1ncm91cCBkaXJlY3RpdmUgd2hlbiB0byByZW1vdmUgaXRzZWxmXHJcbiAgdGhpcy5yZW1vdmVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLmdyb3Vwcy5pbmRleE9mKGdyb3VwKTtcclxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgdGhpcy5ncm91cHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxuICB9O1xyXG59XSlcclxuXHJcbi8vIFRoZSBhY2NvcmRpb24gZGlyZWN0aXZlIHNpbXBseSBzZXRzIHVwIHRoZSBkaXJlY3RpdmUgY29udHJvbGxlclxyXG4vLyBhbmQgYWRkcyBhbiBhY2NvcmRpb24gQ1NTIGNsYXNzIHRvIGl0c2VsZiBlbGVtZW50LlxyXG4uZGlyZWN0aXZlKCd1aWJBY2NvcmRpb24nLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgY29udHJvbGxlcjogJ1VpYkFjY29yZGlvbkNvbnRyb2xsZXInLFxyXG4gICAgY29udHJvbGxlckFzOiAnYWNjb3JkaW9uJyxcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcclxuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sJztcclxuICAgIH1cclxuICB9O1xyXG59KVxyXG5cclxuLy8gVGhlIGFjY29yZGlvbi1ncm91cCBkaXJlY3RpdmUgaW5kaWNhdGVzIGEgYmxvY2sgb2YgaHRtbCB0aGF0IHdpbGwgZXhwYW5kIGFuZCBjb2xsYXBzZSBpbiBhbiBhY2NvcmRpb25cclxuLmRpcmVjdGl2ZSgndWliQWNjb3JkaW9uR3JvdXAnLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVxdWlyZTogJ151aWJBY2NvcmRpb24nLCAgICAgICAgIC8vIFdlIG5lZWQgdGhpcyBkaXJlY3RpdmUgdG8gYmUgaW5zaWRlIGFuIGFjY29yZGlvblxyXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSwgICAgICAgICAgICAgIC8vIEl0IHRyYW5zY2x1ZGVzIHRoZSBjb250ZW50cyBvZiB0aGUgZGlyZWN0aXZlIGludG8gdGhlIHRlbXBsYXRlXHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbCc7XHJcbiAgICB9LFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgaGVhZGluZzogJ0AnLCAgICAgICAgICAgICAgIC8vIEludGVycG9sYXRlIHRoZSBoZWFkaW5nIGF0dHJpYnV0ZSBvbnRvIHRoaXMgc2NvcGVcclxuICAgICAgcGFuZWxDbGFzczogJ0A/JywgICAgICAgICAgIC8vIERpdHRvIHdpdGggcGFuZWxDbGFzc1xyXG4gICAgICBpc09wZW46ICc9PycsXHJcbiAgICAgIGlzRGlzYWJsZWQ6ICc9PydcclxuICAgIH0sXHJcbiAgICBjb250cm9sbGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5zZXRIZWFkaW5nID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuaGVhZGluZyA9IGVsZW1lbnQ7XHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBhY2NvcmRpb25DdHJsKSB7XHJcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ3BhbmVsJyk7XHJcbiAgICAgIGFjY29yZGlvbkN0cmwuYWRkR3JvdXAoc2NvcGUpO1xyXG5cclxuICAgICAgc2NvcGUub3BlbkNsYXNzID0gYXR0cnMub3BlbkNsYXNzIHx8ICdwYW5lbC1vcGVuJztcclxuICAgICAgc2NvcGUucGFuZWxDbGFzcyA9IGF0dHJzLnBhbmVsQ2xhc3MgfHwgJ3BhbmVsLWRlZmF1bHQnO1xyXG4gICAgICBzY29wZS4kd2F0Y2goJ2lzT3BlbicsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgZWxlbWVudC50b2dnbGVDbGFzcyhzY29wZS5vcGVuQ2xhc3MsICEhdmFsdWUpO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgYWNjb3JkaW9uQ3RybC5jbG9zZU90aGVycyhzY29wZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNjb3BlLnRvZ2dsZU9wZW4gPSBmdW5jdGlvbigkZXZlbnQpIHtcclxuICAgICAgICBpZiAoIXNjb3BlLmlzRGlzYWJsZWQpIHtcclxuICAgICAgICAgIGlmICghJGV2ZW50IHx8ICRldmVudC53aGljaCA9PT0gMzIpIHtcclxuICAgICAgICAgICAgc2NvcGUuaXNPcGVuID0gIXNjb3BlLmlzT3BlbjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgaWQgPSAnYWNjb3JkaW9uZ3JvdXAtJyArIHNjb3BlLiRpZCArICctJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcclxuICAgICAgc2NvcGUuaGVhZGluZ0lkID0gaWQgKyAnLXRhYic7XHJcbiAgICAgIHNjb3BlLnBhbmVsSWQgPSBpZCArICctcGFuZWwnO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pXHJcblxyXG4vLyBVc2UgYWNjb3JkaW9uLWhlYWRpbmcgYmVsb3cgYW4gYWNjb3JkaW9uLWdyb3VwIHRvIHByb3ZpZGUgYSBoZWFkaW5nIGNvbnRhaW5pbmcgSFRNTFxyXG4uZGlyZWN0aXZlKCd1aWJBY2NvcmRpb25IZWFkaW5nJywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsICAgLy8gR3JhYiB0aGUgY29udGVudHMgdG8gYmUgdXNlZCBhcyB0aGUgaGVhZGluZ1xyXG4gICAgdGVtcGxhdGU6ICcnLCAgICAgICAvLyBJbiBlZmZlY3QgcmVtb3ZlIHRoaXMgZWxlbWVudCFcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICByZXF1aXJlOiAnXnVpYkFjY29yZGlvbkdyb3VwJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgYWNjb3JkaW9uR3JvdXBDdHJsLCB0cmFuc2NsdWRlKSB7XHJcbiAgICAgIC8vIFBhc3MgdGhlIGhlYWRpbmcgdG8gdGhlIGFjY29yZGlvbi1ncm91cCBjb250cm9sbGVyXHJcbiAgICAgIC8vIHNvIHRoYXQgaXQgY2FuIGJlIHRyYW5zY2x1ZGVkIGludG8gdGhlIHJpZ2h0IHBsYWNlIGluIHRoZSB0ZW1wbGF0ZVxyXG4gICAgICAvLyBbVGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gdHJhbnNjbHVkZSBjYXVzZXMgdGhlIGVsZW1lbnRzIHRvIGJlIGNsb25lZCBzbyB0aGF0IHRoZXkgd29yayBpbiBuZy1yZXBlYXRdXHJcbiAgICAgIGFjY29yZGlvbkdyb3VwQ3RybC5zZXRIZWFkaW5nKHRyYW5zY2x1ZGUoc2NvcGUsIGFuZ3VsYXIubm9vcCkpO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pXHJcblxyXG4vLyBVc2UgaW4gdGhlIGFjY29yZGlvbi1ncm91cCB0ZW1wbGF0ZSB0byBpbmRpY2F0ZSB3aGVyZSB5b3Ugd2FudCB0aGUgaGVhZGluZyB0byBiZSB0cmFuc2NsdWRlZFxyXG4vLyBZb3UgbXVzdCBwcm92aWRlIHRoZSBwcm9wZXJ0eSBvbiB0aGUgYWNjb3JkaW9uLWdyb3VwIGNvbnRyb2xsZXIgdGhhdCB3aWxsIGhvbGQgdGhlIHRyYW5zY2x1ZGVkIGVsZW1lbnRcclxuLmRpcmVjdGl2ZSgndWliQWNjb3JkaW9uVHJhbnNjbHVkZScsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXF1aXJlOiAnXnVpYkFjY29yZGlvbkdyb3VwJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlcikge1xyXG4gICAgICBzY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7IHJldHVybiBjb250cm9sbGVyW2F0dHJzLnVpYkFjY29yZGlvblRyYW5zY2x1ZGVdOyB9LCBmdW5jdGlvbihoZWFkaW5nKSB7XHJcbiAgICAgICAgaWYgKGhlYWRpbmcpIHtcclxuICAgICAgICAgIHZhciBlbGVtID0gYW5ndWxhci5lbGVtZW50KGVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvcihnZXRIZWFkZXJTZWxlY3RvcnMoKSkpO1xyXG4gICAgICAgICAgZWxlbS5odG1sKCcnKTtcclxuICAgICAgICAgIGVsZW0uYXBwZW5kKGhlYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0SGVhZGVyU2VsZWN0b3JzKCkge1xyXG4gICAgICByZXR1cm4gJ3VpYi1hY2NvcmRpb24taGVhZGVyLCcgK1xyXG4gICAgICAgICAgJ2RhdGEtdWliLWFjY29yZGlvbi1oZWFkZXIsJyArXHJcbiAgICAgICAgICAneC11aWItYWNjb3JkaW9uLWhlYWRlciwnICtcclxuICAgICAgICAgICd1aWJcXFxcOmFjY29yZGlvbi1oZWFkZXIsJyArXHJcbiAgICAgICAgICAnW3VpYi1hY2NvcmRpb24taGVhZGVyXSwnICtcclxuICAgICAgICAgICdbZGF0YS11aWItYWNjb3JkaW9uLWhlYWRlcl0sJyArXHJcbiAgICAgICAgICAnW3gtdWliLWFjY29yZGlvbi1oZWFkZXJdJztcclxuICB9XHJcbn0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5hbGVydCcsIFtdKVxyXG5cclxuLmNvbnRyb2xsZXIoJ1VpYkFsZXJ0Q29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsICckaW50ZXJwb2xhdGUnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMsICRpbnRlcnBvbGF0ZSwgJHRpbWVvdXQpIHtcclxuICAkc2NvcGUuY2xvc2VhYmxlID0gISEkYXR0cnMuY2xvc2U7XHJcbiAgJGVsZW1lbnQuYWRkQ2xhc3MoJ2FsZXJ0Jyk7XHJcbiAgJGF0dHJzLiRzZXQoJ3JvbGUnLCAnYWxlcnQnKTtcclxuICBpZiAoJHNjb3BlLmNsb3NlYWJsZSkge1xyXG4gICAgJGVsZW1lbnQuYWRkQ2xhc3MoJ2FsZXJ0LWRpc21pc3NpYmxlJyk7XHJcbiAgfVxyXG5cclxuICB2YXIgZGlzbWlzc09uVGltZW91dCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5kaXNtaXNzT25UaW1lb3V0KSA/XHJcbiAgICAkaW50ZXJwb2xhdGUoJGF0dHJzLmRpc21pc3NPblRpbWVvdXQpKCRzY29wZS4kcGFyZW50KSA6IG51bGw7XHJcblxyXG4gIGlmIChkaXNtaXNzT25UaW1lb3V0KSB7XHJcbiAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgJHNjb3BlLmNsb3NlKCk7XHJcbiAgICB9LCBwYXJzZUludChkaXNtaXNzT25UaW1lb3V0LCAxMCkpO1xyXG4gIH1cclxufV0pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJBbGVydCcsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBjb250cm9sbGVyOiAnVWliQWxlcnRDb250cm9sbGVyJyxcclxuICAgIGNvbnRyb2xsZXJBczogJ2FsZXJ0JyxcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcclxuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbCc7XHJcbiAgICB9LFxyXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgIHNjb3BlOiB7XHJcbiAgICAgIGNsb3NlOiAnJidcclxuICAgIH1cclxuICB9O1xyXG59KTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYnV0dG9ucycsIFtdKVxyXG5cclxuLmNvbnN0YW50KCd1aWJCdXR0b25Db25maWcnLCB7XHJcbiAgYWN0aXZlQ2xhc3M6ICdhY3RpdmUnLFxyXG4gIHRvZ2dsZUV2ZW50OiAnY2xpY2snXHJcbn0pXHJcblxyXG4uY29udHJvbGxlcignVWliQnV0dG9uc0NvbnRyb2xsZXInLCBbJ3VpYkJ1dHRvbkNvbmZpZycsIGZ1bmN0aW9uKGJ1dHRvbkNvbmZpZykge1xyXG4gIHRoaXMuYWN0aXZlQ2xhc3MgPSBidXR0b25Db25maWcuYWN0aXZlQ2xhc3MgfHwgJ2FjdGl2ZSc7XHJcbiAgdGhpcy50b2dnbGVFdmVudCA9IGJ1dHRvbkNvbmZpZy50b2dnbGVFdmVudCB8fCAnY2xpY2snO1xyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYkJ0blJhZGlvJywgWyckcGFyc2UnLCBmdW5jdGlvbigkcGFyc2UpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVxdWlyZTogWyd1aWJCdG5SYWRpbycsICduZ01vZGVsJ10sXHJcbiAgICBjb250cm9sbGVyOiAnVWliQnV0dG9uc0NvbnRyb2xsZXInLFxyXG4gICAgY29udHJvbGxlckFzOiAnYnV0dG9ucycsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XHJcbiAgICAgIHZhciBidXR0b25zQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xyXG4gICAgICB2YXIgdW5jaGVja2FibGVFeHByID0gJHBhcnNlKGF0dHJzLnVpYlVuY2hlY2thYmxlKTtcclxuXHJcbiAgICAgIGVsZW1lbnQuZmluZCgnaW5wdXQnKS5jc3Moe2Rpc3BsYXk6ICdub25lJ30pO1xyXG5cclxuICAgICAgLy9tb2RlbCAtPiBVSVxyXG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZWxlbWVudC50b2dnbGVDbGFzcyhidXR0b25zQ3RybC5hY3RpdmVDbGFzcywgYW5ndWxhci5lcXVhbHMobmdNb2RlbEN0cmwuJG1vZGVsVmFsdWUsIHNjb3BlLiRldmFsKGF0dHJzLnVpYkJ0blJhZGlvKSkpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy91aS0+bW9kZWxcclxuICAgICAgZWxlbWVudC5vbihidXR0b25zQ3RybC50b2dnbGVFdmVudCwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGF0dHJzLmRpc2FibGVkKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaXNBY3RpdmUgPSBlbGVtZW50Lmhhc0NsYXNzKGJ1dHRvbnNDdHJsLmFjdGl2ZUNsYXNzKTtcclxuXHJcbiAgICAgICAgaWYgKCFpc0FjdGl2ZSB8fCBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy51bmNoZWNrYWJsZSkpIHtcclxuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShpc0FjdGl2ZSA/IG51bGwgOiBzY29wZS4kZXZhbChhdHRycy51aWJCdG5SYWRpbykpO1xyXG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKGF0dHJzLnVpYlVuY2hlY2thYmxlKSB7XHJcbiAgICAgICAgc2NvcGUuJHdhdGNoKHVuY2hlY2thYmxlRXhwciwgZnVuY3Rpb24odW5jaGVja2FibGUpIHtcclxuICAgICAgICAgIGF0dHJzLiRzZXQoJ3VuY2hlY2thYmxlJywgdW5jaGVja2FibGUgPyAnJyA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYkJ0bkNoZWNrYm94JywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlcXVpcmU6IFsndWliQnRuQ2hlY2tib3gnLCAnbmdNb2RlbCddLFxyXG4gICAgY29udHJvbGxlcjogJ1VpYkJ1dHRvbnNDb250cm9sbGVyJyxcclxuICAgIGNvbnRyb2xsZXJBczogJ2J1dHRvbicsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XHJcbiAgICAgIHZhciBidXR0b25zQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xyXG5cclxuICAgICAgZWxlbWVudC5maW5kKCdpbnB1dCcpLmNzcyh7ZGlzcGxheTogJ25vbmUnfSk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBnZXRUcnVlVmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldENoZWNrYm94VmFsdWUoYXR0cnMuYnRuQ2hlY2tib3hUcnVlLCB0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gZ2V0RmFsc2VWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShhdHRycy5idG5DaGVja2JveEZhbHNlLCBmYWxzZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoYXR0cmlidXRlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gYW5ndWxhci5pc0RlZmluZWQoYXR0cmlidXRlKSA/IHNjb3BlLiRldmFsKGF0dHJpYnV0ZSkgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vbW9kZWwgLT4gVUlcclxuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MsIGFuZ3VsYXIuZXF1YWxzKG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlLCBnZXRUcnVlVmFsdWUoKSkpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy91aS0+bW9kZWxcclxuICAgICAgZWxlbWVudC5vbihidXR0b25zQ3RybC50b2dnbGVFdmVudCwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGF0dHJzLmRpc2FibGVkKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGVsZW1lbnQuaGFzQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MpID8gZ2V0RmFsc2VWYWx1ZSgpIDogZ2V0VHJ1ZVZhbHVlKCkpO1xyXG4gICAgICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59KTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuY2Fyb3VzZWwnLCBbXSlcclxuXHJcbi5jb250cm9sbGVyKCdVaWJDYXJvdXNlbENvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckaW50ZXJ2YWwnLCAnJHRpbWVvdXQnLCAnJGFuaW1hdGUnLCBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkaW50ZXJ2YWwsICR0aW1lb3V0LCAkYW5pbWF0ZSkge1xyXG4gIHZhciBzZWxmID0gdGhpcyxcclxuICAgIHNsaWRlcyA9IHNlbGYuc2xpZGVzID0gJHNjb3BlLnNsaWRlcyA9IFtdLFxyXG4gICAgU0xJREVfRElSRUNUSU9OID0gJ3VpYi1zbGlkZURpcmVjdGlvbicsXHJcbiAgICBjdXJyZW50SW5kZXggPSAkc2NvcGUuYWN0aXZlLFxyXG4gICAgY3VycmVudEludGVydmFsLCBpc1BsYXlpbmc7XHJcblxyXG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcclxuICAkZWxlbWVudC5hZGRDbGFzcygnY2Fyb3VzZWwnKTtcclxuXHJcbiAgc2VsZi5hZGRTbGlkZSA9IGZ1bmN0aW9uKHNsaWRlLCBlbGVtZW50KSB7XHJcbiAgICBzbGlkZXMucHVzaCh7XHJcbiAgICAgIHNsaWRlOiBzbGlkZSxcclxuICAgICAgZWxlbWVudDogZWxlbWVudFxyXG4gICAgfSk7XHJcbiAgICBzbGlkZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgIHJldHVybiArYS5zbGlkZS5pbmRleCAtICtiLnNsaWRlLmluZGV4O1xyXG4gICAgfSk7XHJcbiAgICAvL2lmIHRoaXMgaXMgdGhlIGZpcnN0IHNsaWRlIG9yIHRoZSBzbGlkZSBpcyBzZXQgdG8gYWN0aXZlLCBzZWxlY3QgaXRcclxuICAgIGlmIChzbGlkZS5pbmRleCA9PT0gJHNjb3BlLmFjdGl2ZSB8fCBzbGlkZXMubGVuZ3RoID09PSAxICYmICFhbmd1bGFyLmlzTnVtYmVyKCRzY29wZS5hY3RpdmUpKSB7XHJcbiAgICAgIGlmICgkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN1cnJlbnRJbmRleCA9IHNsaWRlLmluZGV4O1xyXG4gICAgICAkc2NvcGUuYWN0aXZlID0gc2xpZGUuaW5kZXg7XHJcbiAgICAgIHNldEFjdGl2ZShjdXJyZW50SW5kZXgpO1xyXG4gICAgICBzZWxmLnNlbGVjdChzbGlkZXNbZmluZFNsaWRlSW5kZXgoc2xpZGUpXSk7XHJcbiAgICAgIGlmIChzbGlkZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgJHNjb3BlLnBsYXkoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHNlbGYuZ2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoc2xpZGVzW2ldLnNsaWRlLmluZGV4ID09PSBjdXJyZW50SW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gaTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHNlbGYubmV4dCA9ICRzY29wZS5uZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbmV3SW5kZXggPSAoc2VsZi5nZXRDdXJyZW50SW5kZXgoKSArIDEpICUgc2xpZGVzLmxlbmd0aDtcclxuXHJcbiAgICBpZiAobmV3SW5kZXggPT09IDAgJiYgJHNjb3BlLm5vV3JhcCgpKSB7XHJcbiAgICAgICRzY29wZS5wYXVzZSgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNlbGYuc2VsZWN0KHNsaWRlc1tuZXdJbmRleF0sICduZXh0Jyk7XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5wcmV2ID0gJHNjb3BlLnByZXYgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBuZXdJbmRleCA9IHNlbGYuZ2V0Q3VycmVudEluZGV4KCkgLSAxIDwgMCA/IHNsaWRlcy5sZW5ndGggLSAxIDogc2VsZi5nZXRDdXJyZW50SW5kZXgoKSAtIDE7XHJcblxyXG4gICAgaWYgKCRzY29wZS5ub1dyYXAoKSAmJiBuZXdJbmRleCA9PT0gc2xpZGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgJHNjb3BlLnBhdXNlKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2VsZi5zZWxlY3Qoc2xpZGVzW25ld0luZGV4XSwgJ3ByZXYnKTtcclxuICB9O1xyXG5cclxuICBzZWxmLnJlbW92ZVNsaWRlID0gZnVuY3Rpb24oc2xpZGUpIHtcclxuICAgIHZhciBpbmRleCA9IGZpbmRTbGlkZUluZGV4KHNsaWRlKTtcclxuXHJcbiAgICAvL2dldCB0aGUgaW5kZXggb2YgdGhlIHNsaWRlIGluc2lkZSB0aGUgY2Fyb3VzZWxcclxuICAgIHNsaWRlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgaWYgKHNsaWRlcy5sZW5ndGggPiAwICYmIGN1cnJlbnRJbmRleCA9PT0gaW5kZXgpIHtcclxuICAgICAgaWYgKGluZGV4ID49IHNsaWRlcy5sZW5ndGgpIHtcclxuICAgICAgICBjdXJyZW50SW5kZXggPSBzbGlkZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAkc2NvcGUuYWN0aXZlID0gY3VycmVudEluZGV4O1xyXG4gICAgICAgIHNldEFjdGl2ZShjdXJyZW50SW5kZXgpO1xyXG4gICAgICAgIHNlbGYuc2VsZWN0KHNsaWRlc1tzbGlkZXMubGVuZ3RoIC0gMV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICRzY29wZS5hY3RpdmUgPSBjdXJyZW50SW5kZXg7XHJcbiAgICAgICAgc2V0QWN0aXZlKGN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgc2VsZi5zZWxlY3Qoc2xpZGVzW2luZGV4XSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoY3VycmVudEluZGV4ID4gaW5kZXgpIHtcclxuICAgICAgY3VycmVudEluZGV4LS07XHJcbiAgICAgICRzY29wZS5hY3RpdmUgPSBjdXJyZW50SW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgLy9jbGVhbiB0aGUgYWN0aXZlIHZhbHVlIHdoZW4gbm8gbW9yZSBzbGlkZVxyXG4gICAgaWYgKHNsaWRlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY3VycmVudEluZGV4ID0gbnVsbDtcclxuICAgICAgJHNjb3BlLmFjdGl2ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyogZGlyZWN0aW9uOiBcInByZXZcIiBvciBcIm5leHRcIiAqL1xyXG4gIHNlbGYuc2VsZWN0ID0gJHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKG5leHRTbGlkZSwgZGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgbmV4dEluZGV4ID0gZmluZFNsaWRlSW5kZXgobmV4dFNsaWRlLnNsaWRlKTtcclxuICAgIC8vRGVjaWRlIGRpcmVjdGlvbiBpZiBpdCdzIG5vdCBnaXZlblxyXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGRpcmVjdGlvbiA9IG5leHRJbmRleCA+IHNlbGYuZ2V0Q3VycmVudEluZGV4KCkgPyAnbmV4dCcgOiAncHJldic7XHJcbiAgICB9XHJcbiAgICAvL1ByZXZlbnQgdGhpcyB1c2VyLXRyaWdnZXJlZCB0cmFuc2l0aW9uIGZyb20gb2NjdXJyaW5nIGlmIHRoZXJlIGlzIGFscmVhZHkgb25lIGluIHByb2dyZXNzXHJcbiAgICBpZiAobmV4dFNsaWRlLnNsaWRlLmluZGV4ICE9PSBjdXJyZW50SW5kZXggJiZcclxuICAgICAgISRzY29wZS4kY3VycmVudFRyYW5zaXRpb24pIHtcclxuICAgICAgZ29OZXh0KG5leHRTbGlkZS5zbGlkZSwgbmV4dEluZGV4LCBkaXJlY3Rpb24pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qIEFsbG93IG91dHNpZGUgcGVvcGxlIHRvIGNhbGwgaW5kZXhPZiBvbiBzbGlkZXMgYXJyYXkgKi9cclxuICAkc2NvcGUuaW5kZXhPZlNsaWRlID0gZnVuY3Rpb24oc2xpZGUpIHtcclxuICAgIHJldHVybiArc2xpZGUuc2xpZGUuaW5kZXg7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLmlzQWN0aXZlID0gZnVuY3Rpb24oc2xpZGUpIHtcclxuICAgIHJldHVybiAkc2NvcGUuYWN0aXZlID09PSBzbGlkZS5zbGlkZS5pbmRleDtcclxuICB9O1xyXG5cclxuICAkc2NvcGUuaXNQcmV2RGlzYWJsZWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAkc2NvcGUuYWN0aXZlID09PSAwICYmICRzY29wZS5ub1dyYXAoKTtcclxuICB9O1xyXG5cclxuICAkc2NvcGUuaXNOZXh0RGlzYWJsZWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAkc2NvcGUuYWN0aXZlID09PSBzbGlkZXMubGVuZ3RoIC0gMSAmJiAkc2NvcGUubm9XcmFwKCk7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoISRzY29wZS5ub1BhdXNlKSB7XHJcbiAgICAgIGlzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICByZXNldFRpbWVyKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLnBsYXkgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICghaXNQbGF5aW5nKSB7XHJcbiAgICAgIGlzUGxheWluZyA9IHRydWU7XHJcbiAgICAgIHJlc3RhcnRUaW1lcigpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gICRlbGVtZW50Lm9uKCdtb3VzZWVudGVyJywgJHNjb3BlLnBhdXNlKTtcclxuICAkZWxlbWVudC5vbignbW91c2VsZWF2ZScsICRzY29wZS5wbGF5KTtcclxuXHJcbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgIGRlc3Ryb3llZCA9IHRydWU7XHJcbiAgICByZXNldFRpbWVyKCk7XHJcbiAgfSk7XHJcblxyXG4gICRzY29wZS4kd2F0Y2goJ25vVHJhbnNpdGlvbicsIGZ1bmN0aW9uKG5vVHJhbnNpdGlvbikge1xyXG4gICAgJGFuaW1hdGUuZW5hYmxlZCgkZWxlbWVudCwgIW5vVHJhbnNpdGlvbik7XHJcbiAgfSk7XHJcblxyXG4gICRzY29wZS4kd2F0Y2goJ2ludGVydmFsJywgcmVzdGFydFRpbWVyKTtcclxuXHJcbiAgJHNjb3BlLiR3YXRjaENvbGxlY3Rpb24oJ3NsaWRlcycsIHJlc2V0VHJhbnNpdGlvbik7XHJcblxyXG4gICRzY29wZS4kd2F0Y2goJ2FjdGl2ZScsIGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICBpZiAoYW5ndWxhci5pc051bWJlcihpbmRleCkgJiYgY3VycmVudEluZGV4ICE9PSBpbmRleCkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChzbGlkZXNbaV0uc2xpZGUuaW5kZXggPT09IGluZGV4KSB7XHJcbiAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzbGlkZSA9IHNsaWRlc1tpbmRleF07XHJcbiAgICAgIGlmIChzbGlkZSkge1xyXG4gICAgICAgIHNldEFjdGl2ZShpbmRleCk7XHJcbiAgICAgICAgc2VsZi5zZWxlY3Qoc2xpZGVzW2luZGV4XSk7XHJcbiAgICAgICAgY3VycmVudEluZGV4ID0gaW5kZXg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0U2xpZGVCeUluZGV4KGluZGV4KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNsaWRlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgaWYgKHNsaWRlc1tpXS5pbmRleCA9PT0gaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gc2xpZGVzW2ldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXRBY3RpdmUoaW5kZXgpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHNsaWRlc1tpXS5zbGlkZS5hY3RpdmUgPSBpID09PSBpbmRleDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdvTmV4dChzbGlkZSwgaW5kZXgsIGRpcmVjdGlvbikge1xyXG4gICAgaWYgKGRlc3Ryb3llZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgYW5ndWxhci5leHRlbmQoc2xpZGUsIHtkaXJlY3Rpb246IGRpcmVjdGlvbn0pO1xyXG4gICAgYW5ndWxhci5leHRlbmQoc2xpZGVzW2N1cnJlbnRJbmRleF0uc2xpZGUgfHwge30sIHtkaXJlY3Rpb246IGRpcmVjdGlvbn0pO1xyXG4gICAgaWYgKCRhbmltYXRlLmVuYWJsZWQoJGVsZW1lbnQpICYmICEkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uICYmXHJcbiAgICAgIHNsaWRlc1tpbmRleF0uZWxlbWVudCAmJiBzZWxmLnNsaWRlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHNsaWRlc1tpbmRleF0uZWxlbWVudC5kYXRhKFNMSURFX0RJUkVDVElPTiwgc2xpZGUuZGlyZWN0aW9uKTtcclxuICAgICAgdmFyIGN1cnJlbnRJZHggPSBzZWxmLmdldEN1cnJlbnRJbmRleCgpO1xyXG5cclxuICAgICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIoY3VycmVudElkeCkgJiYgc2xpZGVzW2N1cnJlbnRJZHhdLmVsZW1lbnQpIHtcclxuICAgICAgICBzbGlkZXNbY3VycmVudElkeF0uZWxlbWVudC5kYXRhKFNMSURFX0RJUkVDVElPTiwgc2xpZGUuZGlyZWN0aW9uKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9IHRydWU7XHJcbiAgICAgICRhbmltYXRlLm9uKCdhZGRDbGFzcycsIHNsaWRlc1tpbmRleF0uZWxlbWVudCwgZnVuY3Rpb24oZWxlbWVudCwgcGhhc2UpIHtcclxuICAgICAgICBpZiAocGhhc2UgPT09ICdjbG9zZScpIHtcclxuICAgICAgICAgICRzY29wZS4kY3VycmVudFRyYW5zaXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgJGFuaW1hdGUub2ZmKCdhZGRDbGFzcycsIGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgJHNjb3BlLmFjdGl2ZSA9IHNsaWRlLmluZGV4O1xyXG4gICAgY3VycmVudEluZGV4ID0gc2xpZGUuaW5kZXg7XHJcbiAgICBzZXRBY3RpdmUoaW5kZXgpO1xyXG5cclxuICAgIC8vZXZlcnkgdGltZSB5b3UgY2hhbmdlIHNsaWRlcywgcmVzZXQgdGhlIHRpbWVyXHJcbiAgICByZXN0YXJ0VGltZXIoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZpbmRTbGlkZUluZGV4KHNsaWRlKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoc2xpZGVzW2ldLnNsaWRlID09PSBzbGlkZSkge1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZXNldFRpbWVyKCkge1xyXG4gICAgaWYgKGN1cnJlbnRJbnRlcnZhbCkge1xyXG4gICAgICAkaW50ZXJ2YWwuY2FuY2VsKGN1cnJlbnRJbnRlcnZhbCk7XHJcbiAgICAgIGN1cnJlbnRJbnRlcnZhbCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZXNldFRyYW5zaXRpb24oc2xpZGVzKSB7XHJcbiAgICBpZiAoIXNsaWRlcy5sZW5ndGgpIHtcclxuICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZXN0YXJ0VGltZXIoKSB7XHJcbiAgICByZXNldFRpbWVyKCk7XHJcbiAgICB2YXIgaW50ZXJ2YWwgPSArJHNjb3BlLmludGVydmFsO1xyXG4gICAgaWYgKCFpc05hTihpbnRlcnZhbCkgJiYgaW50ZXJ2YWwgPiAwKSB7XHJcbiAgICAgIGN1cnJlbnRJbnRlcnZhbCA9ICRpbnRlcnZhbCh0aW1lckZuLCBpbnRlcnZhbCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0aW1lckZuKCkge1xyXG4gICAgdmFyIGludGVydmFsID0gKyRzY29wZS5pbnRlcnZhbDtcclxuICAgIGlmIChpc1BsYXlpbmcgJiYgIWlzTmFOKGludGVydmFsKSAmJiBpbnRlcnZhbCA+IDAgJiYgc2xpZGVzLmxlbmd0aCkge1xyXG4gICAgICAkc2NvcGUubmV4dCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgJHNjb3BlLnBhdXNlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYkNhcm91c2VsJywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICBjb250cm9sbGVyOiAnVWliQ2Fyb3VzZWxDb250cm9sbGVyJyxcclxuICAgIGNvbnRyb2xsZXJBczogJ2Nhcm91c2VsJyxcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcclxuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbCc7XHJcbiAgICB9LFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgYWN0aXZlOiAnPScsXHJcbiAgICAgIGludGVydmFsOiAnPScsXHJcbiAgICAgIG5vVHJhbnNpdGlvbjogJz0nLFxyXG4gICAgICBub1BhdXNlOiAnPScsXHJcbiAgICAgIG5vV3JhcDogJyYnXHJcbiAgICB9XHJcbiAgfTtcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYlNsaWRlJywgWyckYW5pbWF0ZScsIGZ1bmN0aW9uKCRhbmltYXRlKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlcXVpcmU6ICdedWliQ2Fyb3VzZWwnLFxyXG4gICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcclxuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbCc7XHJcbiAgICB9LFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgYWN0dWFsOiAnPT8nLFxyXG4gICAgICBpbmRleDogJz0/J1xyXG4gICAgfSxcclxuICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNhcm91c2VsQ3RybCkge1xyXG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdpdGVtJyk7XHJcbiAgICAgIGNhcm91c2VsQ3RybC5hZGRTbGlkZShzY29wZSwgZWxlbWVudCk7XHJcbiAgICAgIC8vd2hlbiB0aGUgc2NvcGUgaXMgZGVzdHJveWVkIHRoZW4gcmVtb3ZlIHRoZSBzbGlkZSBmcm9tIHRoZSBjdXJyZW50IHNsaWRlcyBhcnJheVxyXG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2Fyb3VzZWxDdHJsLnJlbW92ZVNsaWRlKHNjb3BlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzY29wZS4kd2F0Y2goJ2FjdGl2ZScsIGZ1bmN0aW9uKGFjdGl2ZSkge1xyXG4gICAgICAgICRhbmltYXRlW2FjdGl2ZSA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShlbGVtZW50LCAnYWN0aXZlJyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKVxyXG5cclxuLmFuaW1hdGlvbignLml0ZW0nLCBbJyRhbmltYXRlQ3NzJyxcclxuZnVuY3Rpb24oJGFuaW1hdGVDc3MpIHtcclxuICB2YXIgU0xJREVfRElSRUNUSU9OID0gJ3VpYi1zbGlkZURpcmVjdGlvbic7XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgY2FsbGJhY2spIHtcclxuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcclxuICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICBjYWxsYmFjaygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGJlZm9yZUFkZENsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUsIGRvbmUpIHtcclxuICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gJ2FjdGl2ZScpIHtcclxuICAgICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBlbGVtZW50LmRhdGEoU0xJREVfRElSRUNUSU9OKTtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uQ2xhc3MgPSBkaXJlY3Rpb24gPT09ICduZXh0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XHJcbiAgICAgICAgdmFyIHJlbW92ZUNsYXNzRm4gPSByZW1vdmVDbGFzcy5iaW5kKHRoaXMsIGVsZW1lbnQsXHJcbiAgICAgICAgICBkaXJlY3Rpb25DbGFzcyArICcgJyArIGRpcmVjdGlvbiwgZG9uZSk7XHJcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhkaXJlY3Rpb24pO1xyXG5cclxuICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7YWRkQ2xhc3M6IGRpcmVjdGlvbkNsYXNzfSlcclxuICAgICAgICAgIC5zdGFydCgpXHJcbiAgICAgICAgICAuZG9uZShyZW1vdmVDbGFzc0ZuKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBkb25lKCk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlUmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUsIGRvbmUpIHtcclxuICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gJ2FjdGl2ZScpIHtcclxuICAgICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBlbGVtZW50LmRhdGEoU0xJREVfRElSRUNUSU9OKTtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uQ2xhc3MgPSBkaXJlY3Rpb24gPT09ICduZXh0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XHJcbiAgICAgICAgdmFyIHJlbW92ZUNsYXNzRm4gPSByZW1vdmVDbGFzcy5iaW5kKHRoaXMsIGVsZW1lbnQsIGRpcmVjdGlvbkNsYXNzLCBkb25lKTtcclxuXHJcbiAgICAgICAgJGFuaW1hdGVDc3MoZWxlbWVudCwge2FkZENsYXNzOiBkaXJlY3Rpb25DbGFzc30pXHJcbiAgICAgICAgICAuc3RhcnQoKVxyXG4gICAgICAgICAgLmRvbmUocmVtb3ZlQ2xhc3NGbik7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgZG9uZSgpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZGF0ZXBhcnNlcicsIFtdKVxyXG5cclxuLnNlcnZpY2UoJ3VpYkRhdGVQYXJzZXInLCBbJyRsb2cnLCAnJGxvY2FsZScsICdkYXRlRmlsdGVyJywgJ29yZGVyQnlGaWx0ZXInLCAnZmlsdGVyRmlsdGVyJywgZnVuY3Rpb24oJGxvZywgJGxvY2FsZSwgZGF0ZUZpbHRlciwgb3JkZXJCeUZpbHRlciwgZmlsdGVyRmlsdGVyKSB7XHJcbiAgLy8gUHVsbGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL2QzL2Jsb2IvbWFzdGVyL3NyYy9mb3JtYXQvcmVxdW90ZS5qc1xyXG4gIHZhciBTUEVDSUFMX0NIQVJBQ1RFUlNfUkVHRVhQID0gL1tcXFxcXFxeXFwkXFwqXFwrXFw/XFx8XFxbXFxdXFwoXFwpXFwuXFx7XFx9XS9nO1xyXG5cclxuICB2YXIgbG9jYWxlSWQ7XHJcbiAgdmFyIGZvcm1hdENvZGVUb1JlZ2V4O1xyXG5cclxuICB0aGlzLmluaXQgPSBmdW5jdGlvbigpIHtcclxuICAgIGxvY2FsZUlkID0gJGxvY2FsZS5pZDtcclxuXHJcbiAgICB0aGlzLnBhcnNlcnMgPSB7fTtcclxuICAgIHRoaXMuZm9ybWF0dGVycyA9IHt9O1xyXG5cclxuICAgIGZvcm1hdENvZGVUb1JlZ2V4ID0gW1xyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAneXl5eScsXHJcbiAgICAgICAgcmVnZXg6ICdcXFxcZHs0fScsXHJcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMueWVhciA9ICt2YWx1ZTsgfSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHtcclxuICAgICAgICAgIHZhciBfZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICBfZGF0ZS5zZXRGdWxsWWVhcihNYXRoLmFicyhkYXRlLmdldEZ1bGxZZWFyKCkpKTtcclxuICAgICAgICAgIHJldHVybiBkYXRlRmlsdGVyKF9kYXRlLCAneXl5eScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGtleTogJ3l5JyxcclxuICAgICAgICByZWdleDogJ1xcXFxkezJ9JyxcclxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdmFsdWUgPSArdmFsdWU7IHRoaXMueWVhciA9IHZhbHVlIDwgNjkgPyB2YWx1ZSArIDIwMDAgOiB2YWx1ZSArIDE5MDA7IH0sXHJcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7XHJcbiAgICAgICAgICB2YXIgX2RhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgX2RhdGUuc2V0RnVsbFllYXIoTWF0aC5hYnMoZGF0ZS5nZXRGdWxsWWVhcigpKSk7XHJcbiAgICAgICAgICByZXR1cm4gZGF0ZUZpbHRlcihfZGF0ZSwgJ3l5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAneScsXHJcbiAgICAgICAgcmVnZXg6ICdcXFxcZHsxLDR9JyxcclxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy55ZWFyID0gK3ZhbHVlOyB9LFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkge1xyXG4gICAgICAgICAgdmFyIF9kYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgIF9kYXRlLnNldEZ1bGxZZWFyKE1hdGguYWJzKGRhdGUuZ2V0RnVsbFllYXIoKSkpO1xyXG4gICAgICAgICAgcmV0dXJuIGRhdGVGaWx0ZXIoX2RhdGUsICd5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnTSEnLFxyXG4gICAgICAgIHJlZ2V4OiAnMD9bMS05XXwxWzAtMl0nLFxyXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1vbnRoID0gdmFsdWUgLSAxOyB9LFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkge1xyXG4gICAgICAgICAgdmFyIHZhbHVlID0gZGF0ZS5nZXRNb250aCgpO1xyXG4gICAgICAgICAgaWYgKC9eWzAtOV0kLy50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnTU0nKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnTScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGtleTogJ01NTU0nLFxyXG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuTU9OVEguam9pbignfCcpLFxyXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1vbnRoID0gJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLk1PTlRILmluZGV4T2YodmFsdWUpOyB9LFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnTU1NTScpOyB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBrZXk6ICdNTU0nLFxyXG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuU0hPUlRNT05USC5qb2luKCd8JyksXHJcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubW9udGggPSAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuU0hPUlRNT05USC5pbmRleE9mKHZhbHVlKTsgfSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ01NTScpOyB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBrZXk6ICdNTScsXHJcbiAgICAgICAgcmVnZXg6ICcwWzEtOV18MVswLTJdJyxcclxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5tb250aCA9IHZhbHVlIC0gMTsgfSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ01NJyk7IH1cclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGtleTogJ00nLFxyXG4gICAgICAgIHJlZ2V4OiAnWzEtOV18MVswLTJdJyxcclxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5tb250aCA9IHZhbHVlIC0gMTsgfSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ00nKTsgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnZCEnLFxyXG4gICAgICAgIHJlZ2V4OiAnWzAtMl0/WzAtOV17MX18M1swLTFdezF9JyxcclxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5kYXRlID0gK3ZhbHVlOyB9LFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkge1xyXG4gICAgICAgICAgdmFyIHZhbHVlID0gZGF0ZS5nZXREYXRlKCk7XHJcbiAgICAgICAgICBpZiAoL15bMS05XSQvLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdkZCcpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnZGQnLFxyXG4gICAgICAgIHJlZ2V4OiAnWzAtMl1bMC05XXsxfXwzWzAtMV17MX0nLFxyXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmRhdGUgPSArdmFsdWU7IH0sXHJcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdkZCcpOyB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBrZXk6ICdkJyxcclxuICAgICAgICByZWdleDogJ1sxLTJdP1swLTldezF9fDNbMC0xXXsxfScsXHJcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuZGF0ZSA9ICt2YWx1ZTsgfSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ2QnKTsgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnRUVFRScsXHJcbiAgICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5EQVkuam9pbignfCcpLFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnRUVFRScpOyB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBrZXk6ICdFRUUnLFxyXG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuU0hPUlREQVkuam9pbignfCcpLFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnRUVFJyk7IH1cclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGtleTogJ0hIJyxcclxuICAgICAgICByZWdleDogJyg/OjB8MSlbMC05XXwyWzAtM10nLFxyXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmhvdXJzID0gK3ZhbHVlOyB9LFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnSEgnKTsgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnaGgnLFxyXG4gICAgICAgIHJlZ2V4OiAnMFswLTldfDFbMC0yXScsXHJcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuaG91cnMgPSArdmFsdWU7IH0sXHJcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdoaCcpOyB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBrZXk6ICdIJyxcclxuICAgICAgICByZWdleDogJzE/WzAtOV18MlswLTNdJyxcclxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5ob3VycyA9ICt2YWx1ZTsgfSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ0gnKTsgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnaCcsXHJcbiAgICAgICAgcmVnZXg6ICdbMC05XXwxWzAtMl0nLFxyXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmhvdXJzID0gK3ZhbHVlOyB9LFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnaCcpOyB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBrZXk6ICdtbScsXHJcbiAgICAgICAgcmVnZXg6ICdbMC01XVswLTldJyxcclxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5taW51dGVzID0gK3ZhbHVlOyB9LFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnbW0nKTsgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnbScsXHJcbiAgICAgICAgcmVnZXg6ICdbMC05XXxbMS01XVswLTldJyxcclxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5taW51dGVzID0gK3ZhbHVlOyB9LFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnbScpOyB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBrZXk6ICdzc3MnLFxyXG4gICAgICAgIHJlZ2V4OiAnWzAtOV1bMC05XVswLTldJyxcclxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5taWxsaXNlY29uZHMgPSArdmFsdWU7IH0sXHJcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdzc3MnKTsgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnc3MnLFxyXG4gICAgICAgIHJlZ2V4OiAnWzAtNV1bMC05XScsXHJcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuc2Vjb25kcyA9ICt2YWx1ZTsgfSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ3NzJyk7IH1cclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGtleTogJ3MnLFxyXG4gICAgICAgIHJlZ2V4OiAnWzAtOV18WzEtNV1bMC05XScsXHJcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuc2Vjb25kcyA9ICt2YWx1ZTsgfSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ3MnKTsgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnYScsXHJcbiAgICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5BTVBNUy5qb2luKCd8JyksXHJcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5ob3VycyA9PT0gMTIpIHtcclxuICAgICAgICAgICAgdGhpcy5ob3VycyA9IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnUE0nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaG91cnMgKz0gMTI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ2EnKTsgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnWicsXHJcbiAgICAgICAgcmVnZXg6ICdbKy1dXFxcXGR7NH0nLFxyXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSB2YWx1ZS5tYXRjaCgvKFsrLV0pKFxcZHsyfSkoXFxkezJ9KS8pLFxyXG4gICAgICAgICAgICBzaWduID0gbWF0Y2hlc1sxXSxcclxuICAgICAgICAgICAgaG91cnMgPSBtYXRjaGVzWzJdLFxyXG4gICAgICAgICAgICBtaW51dGVzID0gbWF0Y2hlc1szXTtcclxuICAgICAgICAgIHRoaXMuaG91cnMgKz0gdG9JbnQoc2lnbiArIGhvdXJzKTtcclxuICAgICAgICAgIHRoaXMubWludXRlcyArPSB0b0ludChzaWduICsgbWludXRlcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHtcclxuICAgICAgICAgIHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdaJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnd3cnLFxyXG4gICAgICAgIHJlZ2V4OiAnWzAtNF1bMC05XXw1WzAtM10nLFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnd3cnKTsgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAndycsXHJcbiAgICAgICAgcmVnZXg6ICdbMC05XXxbMS00XVswLTldfDVbMC0zXScsXHJcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICd3Jyk7IH1cclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGtleTogJ0dHR0cnLFxyXG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuRVJBTkFNRVMuam9pbignfCcpLnJlcGxhY2UoL1xccy9nLCAnXFxcXHMnKSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ0dHR0cnKTsgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnR0dHJyxcclxuICAgICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLkVSQVMuam9pbignfCcpLFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnR0dHJyk7IH1cclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGtleTogJ0dHJyxcclxuICAgICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLkVSQVMuam9pbignfCcpLFxyXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnR0cnKTsgfVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiAnRycsXHJcbiAgICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5FUkFTLmpvaW4oJ3wnKSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ0cnKTsgfVxyXG4gICAgICB9XHJcbiAgICBdO1xyXG5cclxuICAgIGlmIChhbmd1bGFyLnZlcnNpb24ubWFqb3IgPj0gMSAmJiBhbmd1bGFyLnZlcnNpb24ubWlub3IgPiA0KSB7XHJcbiAgICAgIGZvcm1hdENvZGVUb1JlZ2V4LnB1c2goe1xyXG4gICAgICAgIGtleTogJ0xMTEwnLFxyXG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuU1RBTkRBTE9ORU1PTlRILmpvaW4oJ3wnKSxcclxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5tb250aCA9ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5TVEFOREFMT05FTU9OVEguaW5kZXhPZih2YWx1ZSk7IH0sXHJcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdMTExMJyk7IH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5pbml0KCk7XHJcblxyXG4gIGZ1bmN0aW9uIGdldEZvcm1hdENvZGVUb1JlZ2V4KGtleSkge1xyXG4gICAgcmV0dXJuIGZpbHRlckZpbHRlcihmb3JtYXRDb2RlVG9SZWdleCwge2tleToga2V5fSwgdHJ1ZSlbMF07XHJcbiAgfVxyXG5cclxuICB0aGlzLmdldFBhcnNlciA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHZhciBmID0gZ2V0Rm9ybWF0Q29kZVRvUmVnZXgoa2V5KTtcclxuICAgIHJldHVybiBmICYmIGYuYXBwbHkgfHwgbnVsbDtcclxuICB9O1xyXG5cclxuICB0aGlzLm92ZXJyaWRlUGFyc2VyID0gZnVuY3Rpb24gKGtleSwgcGFyc2VyKSB7XHJcbiAgICB2YXIgZiA9IGdldEZvcm1hdENvZGVUb1JlZ2V4KGtleSk7XHJcbiAgICBpZiAoZiAmJiBhbmd1bGFyLmlzRnVuY3Rpb24ocGFyc2VyKSkge1xyXG4gICAgICB0aGlzLnBhcnNlcnMgPSB7fTtcclxuICAgICAgZi5hcHBseSA9IHBhcnNlcjtcclxuICAgIH1cclxuICB9LmJpbmQodGhpcyk7XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhcnNlcihmb3JtYXQpIHtcclxuICAgIHZhciBtYXAgPSBbXSwgcmVnZXggPSBmb3JtYXQuc3BsaXQoJycpO1xyXG5cclxuICAgIC8vIGNoZWNrIGZvciBsaXRlcmFsIHZhbHVlc1xyXG4gICAgdmFyIHF1b3RlSW5kZXggPSBmb3JtYXQuaW5kZXhPZignXFwnJyk7XHJcbiAgICBpZiAocXVvdGVJbmRleCA+IC0xKSB7XHJcbiAgICAgIHZhciBpbkxpdGVyYWwgPSBmYWxzZTtcclxuICAgICAgZm9ybWF0ID0gZm9ybWF0LnNwbGl0KCcnKTtcclxuICAgICAgZm9yICh2YXIgaSA9IHF1b3RlSW5kZXg7IGkgPCBmb3JtYXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoaW5MaXRlcmFsKSB7XHJcbiAgICAgICAgICBpZiAoZm9ybWF0W2ldID09PSAnXFwnJykge1xyXG4gICAgICAgICAgICBpZiAoaSArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdFtpKzFdID09PSAnXFwnJykgeyAvLyBlc2NhcGVkIHNpbmdsZSBxdW90ZVxyXG4gICAgICAgICAgICAgIGZvcm1hdFtpKzFdID0gJyQnO1xyXG4gICAgICAgICAgICAgIHJlZ2V4W2krMV0gPSAnJztcclxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gZW5kIG9mIGxpdGVyYWxcclxuICAgICAgICAgICAgICByZWdleFtpXSA9ICcnO1xyXG4gICAgICAgICAgICAgIGluTGl0ZXJhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmb3JtYXRbaV0gPSAnJCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChmb3JtYXRbaV0gPT09ICdcXCcnKSB7IC8vIHN0YXJ0IG9mIGxpdGVyYWxcclxuICAgICAgICAgICAgZm9ybWF0W2ldID0gJyQnO1xyXG4gICAgICAgICAgICByZWdleFtpXSA9ICcnO1xyXG4gICAgICAgICAgICBpbkxpdGVyYWwgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9ybWF0ID0gZm9ybWF0LmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuICAgIGFuZ3VsYXIuZm9yRWFjaChmb3JtYXRDb2RlVG9SZWdleCwgZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICB2YXIgaW5kZXggPSBmb3JtYXQuaW5kZXhPZihkYXRhLmtleSk7XHJcblxyXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5zcGxpdCgnJyk7XHJcblxyXG4gICAgICAgIHJlZ2V4W2luZGV4XSA9ICcoJyArIGRhdGEucmVnZXggKyAnKSc7XHJcbiAgICAgICAgZm9ybWF0W2luZGV4XSA9ICckJzsgLy8gQ3VzdG9tIHN5bWJvbCB0byBkZWZpbmUgY29uc3VtZWQgcGFydCBvZiBmb3JtYXRcclxuICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggKyAxLCBuID0gaW5kZXggKyBkYXRhLmtleS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgIHJlZ2V4W2ldID0gJyc7XHJcbiAgICAgICAgICBmb3JtYXRbaV0gPSAnJCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5qb2luKCcnKTtcclxuXHJcbiAgICAgICAgbWFwLnB1c2goe1xyXG4gICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAga2V5OiBkYXRhLmtleSxcclxuICAgICAgICAgIGFwcGx5OiBkYXRhLmFwcGx5LFxyXG4gICAgICAgICAgbWF0Y2hlcjogZGF0YS5yZWdleFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZWdleDogbmV3IFJlZ0V4cCgnXicgKyByZWdleC5qb2luKCcnKSArICckJyksXHJcbiAgICAgIG1hcDogb3JkZXJCeUZpbHRlcihtYXAsICdpbmRleCcpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlRm9ybWF0dGVyKGZvcm1hdCkge1xyXG4gICAgdmFyIGZvcm1hdHRlcnMgPSBbXTtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBmb3JtYXR0ZXIsIGxpdGVyYWxJZHg7XHJcbiAgICB3aGlsZSAoaSA8IGZvcm1hdC5sZW5ndGgpIHtcclxuICAgICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIobGl0ZXJhbElkeCkpIHtcclxuICAgICAgICBpZiAoZm9ybWF0LmNoYXJBdChpKSA9PT0gJ1xcJycpIHtcclxuICAgICAgICAgIGlmIChpICsgMSA+PSBmb3JtYXQubGVuZ3RoIHx8IGZvcm1hdC5jaGFyQXQoaSArIDEpICE9PSAnXFwnJykge1xyXG4gICAgICAgICAgICBmb3JtYXR0ZXJzLnB1c2goY29uc3RydWN0TGl0ZXJhbEZvcm1hdHRlcihmb3JtYXQsIGxpdGVyYWxJZHgsIGkpKTtcclxuICAgICAgICAgICAgbGl0ZXJhbElkeCA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSBmb3JtYXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICB3aGlsZSAobGl0ZXJhbElkeCA8IGZvcm1hdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZm9ybWF0dGVyID0gY29uc3RydWN0Rm9ybWF0dGVyRnJvbUlkeChmb3JtYXQsIGxpdGVyYWxJZHgpO1xyXG4gICAgICAgICAgICBmb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcclxuICAgICAgICAgICAgbGl0ZXJhbElkeCA9IGZvcm1hdHRlci5lbmRJZHg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpKys7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChmb3JtYXQuY2hhckF0KGkpID09PSAnXFwnJykge1xyXG4gICAgICAgIGxpdGVyYWxJZHggPSBpO1xyXG4gICAgICAgIGkrKztcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9ybWF0dGVyID0gY29uc3RydWN0Rm9ybWF0dGVyRnJvbUlkeChmb3JtYXQsIGkpO1xyXG5cclxuICAgICAgZm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlci5wYXJzZXIpO1xyXG4gICAgICBpID0gZm9ybWF0dGVyLmVuZElkeDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZm9ybWF0dGVycztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdExpdGVyYWxGb3JtYXR0ZXIoZm9ybWF0LCBsaXRlcmFsSWR4LCBlbmRJZHgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGZvcm1hdC5zdWJzdHIobGl0ZXJhbElkeCArIDEsIGVuZElkeCAtIGxpdGVyYWxJZHggLSAxKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb25zdHJ1Y3RGb3JtYXR0ZXJGcm9tSWR4KGZvcm1hdCwgaSkge1xyXG4gICAgdmFyIGN1cnJlbnRQb3NTdHIgPSBmb3JtYXQuc3Vic3RyKGkpO1xyXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBmb3JtYXRDb2RlVG9SZWdleC5sZW5ndGg7IGorKykge1xyXG4gICAgICBpZiAobmV3IFJlZ0V4cCgnXicgKyBmb3JtYXRDb2RlVG9SZWdleFtqXS5rZXkpLnRlc3QoY3VycmVudFBvc1N0cikpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IGZvcm1hdENvZGVUb1JlZ2V4W2pdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBlbmRJZHg6IGkgKyBkYXRhLmtleS5sZW5ndGgsXHJcbiAgICAgICAgICBwYXJzZXI6IGRhdGEuZm9ybWF0dGVyXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGVuZElkeDogaSArIDEsXHJcbiAgICAgIHBhcnNlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQb3NTdHIuY2hhckF0KDApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgdGhpcy5maWx0ZXIgPSBmdW5jdGlvbihkYXRlLCBmb3JtYXQpIHtcclxuICAgIGlmICghYW5ndWxhci5pc0RhdGUoZGF0ZSkgfHwgaXNOYU4oZGF0ZSkgfHwgIWZvcm1hdCkge1xyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0ID0gJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTW2Zvcm1hdF0gfHwgZm9ybWF0O1xyXG5cclxuICAgIGlmICgkbG9jYWxlLmlkICE9PSBsb2NhbGVJZCkge1xyXG4gICAgICB0aGlzLmluaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuZm9ybWF0dGVyc1tmb3JtYXRdKSB7XHJcbiAgICAgIHRoaXMuZm9ybWF0dGVyc1tmb3JtYXRdID0gY3JlYXRlRm9ybWF0dGVyKGZvcm1hdCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZvcm1hdHRlcnMgPSB0aGlzLmZvcm1hdHRlcnNbZm9ybWF0XTtcclxuXHJcbiAgICByZXR1cm4gZm9ybWF0dGVycy5yZWR1Y2UoZnVuY3Rpb24oc3RyLCBmb3JtYXR0ZXIpIHtcclxuICAgICAgcmV0dXJuIHN0ciArIGZvcm1hdHRlcihkYXRlKTtcclxuICAgIH0sICcnKTtcclxuICB9O1xyXG5cclxuICB0aGlzLnBhcnNlID0gZnVuY3Rpb24oaW5wdXQsIGZvcm1hdCwgYmFzZURhdGUpIHtcclxuICAgIGlmICghYW5ndWxhci5pc1N0cmluZyhpbnB1dCkgfHwgIWZvcm1hdCkge1xyXG4gICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0ID0gJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTW2Zvcm1hdF0gfHwgZm9ybWF0O1xyXG4gICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoU1BFQ0lBTF9DSEFSQUNURVJTX1JFR0VYUCwgJ1xcXFwkJicpO1xyXG5cclxuICAgIGlmICgkbG9jYWxlLmlkICE9PSBsb2NhbGVJZCkge1xyXG4gICAgICB0aGlzLmluaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMucGFyc2Vyc1tmb3JtYXRdKSB7XHJcbiAgICAgIHRoaXMucGFyc2Vyc1tmb3JtYXRdID0gY3JlYXRlUGFyc2VyKGZvcm1hdCwgJ2FwcGx5Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBhcnNlciA9IHRoaXMucGFyc2Vyc1tmb3JtYXRdLFxyXG4gICAgICAgIHJlZ2V4ID0gcGFyc2VyLnJlZ2V4LFxyXG4gICAgICAgIG1hcCA9IHBhcnNlci5tYXAsXHJcbiAgICAgICAgcmVzdWx0cyA9IGlucHV0Lm1hdGNoKHJlZ2V4KSxcclxuICAgICAgICB0ek9mZnNldCA9IGZhbHNlO1xyXG4gICAgaWYgKHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGgpIHtcclxuICAgICAgdmFyIGZpZWxkcywgZHQ7XHJcbiAgICAgIGlmIChhbmd1bGFyLmlzRGF0ZShiYXNlRGF0ZSkgJiYgIWlzTmFOKGJhc2VEYXRlLmdldFRpbWUoKSkpIHtcclxuICAgICAgICBmaWVsZHMgPSB7XHJcbiAgICAgICAgICB5ZWFyOiBiYXNlRGF0ZS5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgICAgbW9udGg6IGJhc2VEYXRlLmdldE1vbnRoKCksXHJcbiAgICAgICAgICBkYXRlOiBiYXNlRGF0ZS5nZXREYXRlKCksXHJcbiAgICAgICAgICBob3VyczogYmFzZURhdGUuZ2V0SG91cnMoKSxcclxuICAgICAgICAgIG1pbnV0ZXM6IGJhc2VEYXRlLmdldE1pbnV0ZXMoKSxcclxuICAgICAgICAgIHNlY29uZHM6IGJhc2VEYXRlLmdldFNlY29uZHMoKSxcclxuICAgICAgICAgIG1pbGxpc2Vjb25kczogYmFzZURhdGUuZ2V0TWlsbGlzZWNvbmRzKClcclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChiYXNlRGF0ZSkge1xyXG4gICAgICAgICAgJGxvZy53YXJuKCdkYXRlcGFyc2VyOicsICdiYXNlRGF0ZSBpcyBub3QgYSB2YWxpZCBkYXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpZWxkcyA9IHsgeWVhcjogMTkwMCwgbW9udGg6IDAsIGRhdGU6IDEsIGhvdXJzOiAwLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwLCBtaWxsaXNlY29uZHM6IDAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDEsIG4gPSByZXN1bHRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHZhciBtYXBwZXIgPSBtYXBbaSAtIDFdO1xyXG4gICAgICAgIGlmIChtYXBwZXIubWF0Y2hlciA9PT0gJ1onKSB7XHJcbiAgICAgICAgICB0ek9mZnNldCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobWFwcGVyLmFwcGx5KSB7XHJcbiAgICAgICAgICBtYXBwZXIuYXBwbHkuY2FsbChmaWVsZHMsIHJlc3VsdHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGRhdGVzZXR0ZXIgPSB0ek9mZnNldCA/IERhdGUucHJvdG90eXBlLnNldFVUQ0Z1bGxZZWFyIDpcclxuICAgICAgICBEYXRlLnByb3RvdHlwZS5zZXRGdWxsWWVhcjtcclxuICAgICAgdmFyIHRpbWVzZXR0ZXIgPSB0ek9mZnNldCA/IERhdGUucHJvdG90eXBlLnNldFVUQ0hvdXJzIDpcclxuICAgICAgICBEYXRlLnByb3RvdHlwZS5zZXRIb3VycztcclxuXHJcbiAgICAgIGlmIChpc1ZhbGlkKGZpZWxkcy55ZWFyLCBmaWVsZHMubW9udGgsIGZpZWxkcy5kYXRlKSkge1xyXG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGF0ZShiYXNlRGF0ZSkgJiYgIWlzTmFOKGJhc2VEYXRlLmdldFRpbWUoKSkgJiYgIXR6T2Zmc2V0KSB7XHJcbiAgICAgICAgICBkdCA9IG5ldyBEYXRlKGJhc2VEYXRlKTtcclxuICAgICAgICAgIGRhdGVzZXR0ZXIuY2FsbChkdCwgZmllbGRzLnllYXIsIGZpZWxkcy5tb250aCwgZmllbGRzLmRhdGUpO1xyXG4gICAgICAgICAgdGltZXNldHRlci5jYWxsKGR0LCBmaWVsZHMuaG91cnMsIGZpZWxkcy5taW51dGVzLFxyXG4gICAgICAgICAgICBmaWVsZHMuc2Vjb25kcywgZmllbGRzLm1pbGxpc2Vjb25kcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGR0ID0gbmV3IERhdGUoMCk7XHJcbiAgICAgICAgICBkYXRlc2V0dGVyLmNhbGwoZHQsIGZpZWxkcy55ZWFyLCBmaWVsZHMubW9udGgsIGZpZWxkcy5kYXRlKTtcclxuICAgICAgICAgIHRpbWVzZXR0ZXIuY2FsbChkdCwgZmllbGRzLmhvdXJzIHx8IDAsIGZpZWxkcy5taW51dGVzIHx8IDAsXHJcbiAgICAgICAgICAgIGZpZWxkcy5zZWNvbmRzIHx8IDAsIGZpZWxkcy5taWxsaXNlY29uZHMgfHwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZHQ7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gQ2hlY2sgaWYgZGF0ZSBpcyB2YWxpZCBmb3Igc3BlY2lmaWMgbW9udGggKGFuZCB5ZWFyIGZvciBGZWJydWFyeSkuXHJcbiAgLy8gTW9udGg6IDAgPSBKYW4sIDEgPSBGZWIsIGV0Y1xyXG4gIGZ1bmN0aW9uIGlzVmFsaWQoeWVhciwgbW9udGgsIGRhdGUpIHtcclxuICAgIGlmIChkYXRlIDwgMSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1vbnRoID09PSAxICYmIGRhdGUgPiAyOCkge1xyXG4gICAgICByZXR1cm4gZGF0ZSA9PT0gMjkgJiYgKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1vbnRoID09PSAzIHx8IG1vbnRoID09PSA1IHx8IG1vbnRoID09PSA4IHx8IG1vbnRoID09PSAxMCkge1xyXG4gICAgICByZXR1cm4gZGF0ZSA8IDMxO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdG9JbnQoc3RyKSB7XHJcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxMCk7XHJcbiAgfVxyXG5cclxuICB0aGlzLnRvVGltZXpvbmUgPSB0b1RpbWV6b25lO1xyXG4gIHRoaXMuZnJvbVRpbWV6b25lID0gZnJvbVRpbWV6b25lO1xyXG4gIHRoaXMudGltZXpvbmVUb09mZnNldCA9IHRpbWV6b25lVG9PZmZzZXQ7XHJcbiAgdGhpcy5hZGREYXRlTWludXRlcyA9IGFkZERhdGVNaW51dGVzO1xyXG4gIHRoaXMuY29udmVydFRpbWV6b25lVG9Mb2NhbCA9IGNvbnZlcnRUaW1lem9uZVRvTG9jYWw7XHJcblxyXG4gIGZ1bmN0aW9uIHRvVGltZXpvbmUoZGF0ZSwgdGltZXpvbmUpIHtcclxuICAgIHJldHVybiBkYXRlICYmIHRpbWV6b25lID8gY29udmVydFRpbWV6b25lVG9Mb2NhbChkYXRlLCB0aW1lem9uZSkgOiBkYXRlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZnJvbVRpbWV6b25lKGRhdGUsIHRpbWV6b25lKSB7XHJcbiAgICByZXR1cm4gZGF0ZSAmJiB0aW1lem9uZSA/IGNvbnZlcnRUaW1lem9uZVRvTG9jYWwoZGF0ZSwgdGltZXpvbmUsIHRydWUpIDogZGF0ZTtcclxuICB9XHJcblxyXG4gIC8vaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9ibG9iLzYyMmM0MjE2OTY5OWVjMDdmYzZkYWFhMTlmZTZkMjI0ZTVkMmY3MGUvc3JjL0FuZ3VsYXIuanMjTDEyMDdcclxuICBmdW5jdGlvbiB0aW1lem9uZVRvT2Zmc2V0KHRpbWV6b25lLCBmYWxsYmFjaykge1xyXG4gICAgdGltZXpvbmUgPSB0aW1lem9uZS5yZXBsYWNlKC86L2csICcnKTtcclxuICAgIHZhciByZXF1ZXN0ZWRUaW1lem9uZU9mZnNldCA9IERhdGUucGFyc2UoJ0phbiAwMSwgMTk3MCAwMDowMDowMCAnICsgdGltZXpvbmUpIC8gNjAwMDA7XHJcbiAgICByZXR1cm4gaXNOYU4ocmVxdWVzdGVkVGltZXpvbmVPZmZzZXQpID8gZmFsbGJhY2sgOiByZXF1ZXN0ZWRUaW1lem9uZU9mZnNldDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFkZERhdGVNaW51dGVzKGRhdGUsIG1pbnV0ZXMpIHtcclxuICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XHJcbiAgICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgKyBtaW51dGVzKTtcclxuICAgIHJldHVybiBkYXRlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29udmVydFRpbWV6b25lVG9Mb2NhbChkYXRlLCB0aW1lem9uZSwgcmV2ZXJzZSkge1xyXG4gICAgcmV2ZXJzZSA9IHJldmVyc2UgPyAtMSA6IDE7XHJcbiAgICB2YXIgZGF0ZVRpbWV6b25lT2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xyXG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gdGltZXpvbmVUb09mZnNldCh0aW1lem9uZSwgZGF0ZVRpbWV6b25lT2Zmc2V0KTtcclxuICAgIHJldHVybiBhZGREYXRlTWludXRlcyhkYXRlLCByZXZlcnNlICogKHRpbWV6b25lT2Zmc2V0IC0gZGF0ZVRpbWV6b25lT2Zmc2V0KSk7XHJcbiAgfVxyXG59XSk7XHJcblxyXG4vLyBBdm9pZGluZyB1c2Ugb2YgbmctY2xhc3MgYXMgaXQgY3JlYXRlcyBhIGxvdCBvZiB3YXRjaGVycyB3aGVuIGEgY2xhc3MgaXMgdG8gYmUgYXBwbGllZCB0b1xyXG4vLyBhdCBtb3N0IG9uZSBlbGVtZW50LlxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmlzQ2xhc3MnLCBbXSlcclxuLmRpcmVjdGl2ZSgndWliSXNDbGFzcycsIFtcclxuICAgICAgICAgJyRhbmltYXRlJyxcclxuZnVuY3Rpb24gKCRhbmltYXRlKSB7XHJcbiAgLy8gICAgICAgICAgICAgICAgICAgIDExMTExMTExICAgICAgICAgIDIyMjIyMjIyXHJcbiAgdmFyIE9OX1JFR0VYUCA9IC9eXFxzKihbXFxzXFxTXSs/KVxccytvblxccysoW1xcc1xcU10rPylcXHMqJC87XHJcbiAgLy8gICAgICAgICAgICAgICAgICAgIDExMTExMTExICAgICAgICAgICAyMjIyMjIyMlxyXG4gIHZhciBJU19SRUdFWFAgPSAvXlxccyooW1xcc1xcU10rPylcXHMrZm9yXFxzKyhbXFxzXFxTXSs/KVxccyokLztcclxuXHJcbiAgdmFyIGRhdGFQZXJUcmFja2VkID0ge307XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgY29tcGlsZTogZnVuY3Rpb24odEVsZW1lbnQsIHRBdHRycykge1xyXG4gICAgICB2YXIgbGlua2VkU2NvcGVzID0gW107XHJcbiAgICAgIHZhciBpbnN0YW5jZXMgPSBbXTtcclxuICAgICAgdmFyIGV4cFRvRGF0YSA9IHt9O1xyXG4gICAgICB2YXIgbGFzdEFjdGl2YXRlZCA9IG51bGw7XHJcbiAgICAgIHZhciBvbkV4cE1hdGNoZXMgPSB0QXR0cnMudWliSXNDbGFzcy5tYXRjaChPTl9SRUdFWFApO1xyXG4gICAgICB2YXIgb25FeHAgPSBvbkV4cE1hdGNoZXNbMl07XHJcbiAgICAgIHZhciBleHBzU3RyID0gb25FeHBNYXRjaGVzWzFdO1xyXG4gICAgICB2YXIgZXhwcyA9IGV4cHNTdHIuc3BsaXQoJywnKTtcclxuXHJcbiAgICAgIHJldHVybiBsaW5rRm47XHJcblxyXG4gICAgICBmdW5jdGlvbiBsaW5rRm4oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgICAgbGlua2VkU2NvcGVzLnB1c2goc2NvcGUpO1xyXG4gICAgICAgIGluc3RhbmNlcy5wdXNoKHtcclxuICAgICAgICAgIHNjb3BlOiBzY29wZSxcclxuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZXhwcy5mb3JFYWNoKGZ1bmN0aW9uKGV4cCwgaykge1xyXG4gICAgICAgICAgYWRkRm9yRXhwKGV4cCwgc2NvcGUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgcmVtb3ZlU2NvcGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBhZGRGb3JFeHAoZXhwLCBzY29wZSkge1xyXG4gICAgICAgIHZhciBtYXRjaGVzID0gZXhwLm1hdGNoKElTX1JFR0VYUCk7XHJcbiAgICAgICAgdmFyIGNsYXp6ID0gc2NvcGUuJGV2YWwobWF0Y2hlc1sxXSk7XHJcbiAgICAgICAgdmFyIGNvbXBhcmVXaXRoRXhwID0gbWF0Y2hlc1syXTtcclxuICAgICAgICB2YXIgZGF0YSA9IGV4cFRvRGF0YVtleHBdO1xyXG4gICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgdmFyIHdhdGNoRm4gPSBmdW5jdGlvbihjb21wYXJlV2l0aFZhbCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3QWN0aXZhdGVkID0gbnVsbDtcclxuICAgICAgICAgICAgaW5zdGFuY2VzLnNvbWUoZnVuY3Rpb24oaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICB2YXIgdGhpc1ZhbCA9IGluc3RhbmNlLnNjb3BlLiRldmFsKG9uRXhwKTtcclxuICAgICAgICAgICAgICBpZiAodGhpc1ZhbCA9PT0gY29tcGFyZVdpdGhWYWwpIHtcclxuICAgICAgICAgICAgICAgIG5ld0FjdGl2YXRlZCA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGRhdGEubGFzdEFjdGl2YXRlZCAhPT0gbmV3QWN0aXZhdGVkKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGRhdGEubGFzdEFjdGl2YXRlZCkge1xyXG4gICAgICAgICAgICAgICAgJGFuaW1hdGUucmVtb3ZlQ2xhc3MoZGF0YS5sYXN0QWN0aXZhdGVkLmVsZW1lbnQsIGNsYXp6KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKG5ld0FjdGl2YXRlZCkge1xyXG4gICAgICAgICAgICAgICAgJGFuaW1hdGUuYWRkQ2xhc3MobmV3QWN0aXZhdGVkLmVsZW1lbnQsIGNsYXp6KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZGF0YS5sYXN0QWN0aXZhdGVkID0gbmV3QWN0aXZhdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgZXhwVG9EYXRhW2V4cF0gPSBkYXRhID0ge1xyXG4gICAgICAgICAgICBsYXN0QWN0aXZhdGVkOiBudWxsLFxyXG4gICAgICAgICAgICBzY29wZTogc2NvcGUsXHJcbiAgICAgICAgICAgIHdhdGNoRm46IHdhdGNoRm4sXHJcbiAgICAgICAgICAgIGNvbXBhcmVXaXRoRXhwOiBjb21wYXJlV2l0aEV4cCxcclxuICAgICAgICAgICAgd2F0Y2hlcjogc2NvcGUuJHdhdGNoKGNvbXBhcmVXaXRoRXhwLCB3YXRjaEZuKVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YS53YXRjaEZuKHNjb3BlLiRldmFsKGNvbXBhcmVXaXRoRXhwKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHJlbW92ZVNjb3BlKGUpIHtcclxuICAgICAgICB2YXIgcmVtb3ZlZFNjb3BlID0gZS50YXJnZXRTY29wZTtcclxuICAgICAgICB2YXIgaW5kZXggPSBsaW5rZWRTY29wZXMuaW5kZXhPZihyZW1vdmVkU2NvcGUpO1xyXG4gICAgICAgIGxpbmtlZFNjb3Blcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIGluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIGlmIChsaW5rZWRTY29wZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB2YXIgbmV3V2F0Y2hTY29wZSA9IGxpbmtlZFNjb3Blc1swXTtcclxuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChleHBUb0RhdGEsIGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuc2NvcGUgPT09IHJlbW92ZWRTY29wZSkge1xyXG4gICAgICAgICAgICAgIGRhdGEud2F0Y2hlciA9IG5ld1dhdGNoU2NvcGUuJHdhdGNoKGRhdGEuY29tcGFyZVdpdGhFeHAsIGRhdGEud2F0Y2hGbik7XHJcbiAgICAgICAgICAgICAgZGF0YS5zY29wZSA9IG5ld1dhdGNoU2NvcGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBleHBUb0RhdGEgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59XSk7XHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZGF0ZXBpY2tlcicsIFsndWkuYm9vdHN0cmFwLmRhdGVwYXJzZXInLCAndWkuYm9vdHN0cmFwLmlzQ2xhc3MnXSlcclxuXHJcbi52YWx1ZSgnJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yJywgZmFsc2UpXHJcblxyXG4udmFsdWUoJyRkYXRlcGlja2VyTGl0ZXJhbFdhcm5pbmcnLCB0cnVlKVxyXG5cclxuLmNvbnN0YW50KCd1aWJEYXRlcGlja2VyQ29uZmlnJywge1xyXG4gIGRhdGVwaWNrZXJNb2RlOiAnZGF5JyxcclxuICBmb3JtYXREYXk6ICdkZCcsXHJcbiAgZm9ybWF0TW9udGg6ICdNTU1NJyxcclxuICBmb3JtYXRZZWFyOiAneXl5eScsXHJcbiAgZm9ybWF0RGF5SGVhZGVyOiAnRUVFJyxcclxuICBmb3JtYXREYXlUaXRsZTogJ01NTU0geXl5eScsXHJcbiAgZm9ybWF0TW9udGhUaXRsZTogJ3l5eXknLFxyXG4gIG1heERhdGU6IG51bGwsXHJcbiAgbWF4TW9kZTogJ3llYXInLFxyXG4gIG1pbkRhdGU6IG51bGwsXHJcbiAgbWluTW9kZTogJ2RheScsXHJcbiAgbW9udGhDb2x1bW5zOiAzLFxyXG4gIG5nTW9kZWxPcHRpb25zOiB7fSxcclxuICBzaG9ydGN1dFByb3BhZ2F0aW9uOiBmYWxzZSxcclxuICBzaG93V2Vla3M6IHRydWUsXHJcbiAgeWVhckNvbHVtbnM6IDUsXHJcbiAgeWVhclJvd3M6IDRcclxufSlcclxuXHJcbi5jb250cm9sbGVyKCdVaWJEYXRlcGlja2VyQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsICckcGFyc2UnLCAnJGludGVycG9sYXRlJywgJyRsb2NhbGUnLCAnJGxvZycsICdkYXRlRmlsdGVyJywgJ3VpYkRhdGVwaWNrZXJDb25maWcnLCAnJGRhdGVwaWNrZXJMaXRlcmFsV2FybmluZycsICckZGF0ZXBpY2tlclN1cHByZXNzRXJyb3InLCAndWliRGF0ZVBhcnNlcicsXHJcbiAgZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzLCAkcGFyc2UsICRpbnRlcnBvbGF0ZSwgJGxvY2FsZSwgJGxvZywgZGF0ZUZpbHRlciwgZGF0ZXBpY2tlckNvbmZpZywgJGRhdGVwaWNrZXJMaXRlcmFsV2FybmluZywgJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yLCBkYXRlUGFyc2VyKSB7XHJcbiAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICBuZ01vZGVsQ3RybCA9IHsgJHNldFZpZXdWYWx1ZTogYW5ndWxhci5ub29wIH0sIC8vIG51bGxNb2RlbEN0cmw7XHJcbiAgICAgIG5nTW9kZWxPcHRpb25zID0ge30sXHJcbiAgICAgIHdhdGNoTGlzdGVuZXJzID0gW107XHJcblxyXG4gICRlbGVtZW50LmFkZENsYXNzKCd1aWItZGF0ZXBpY2tlcicpO1xyXG4gICRhdHRycy4kc2V0KCdyb2xlJywgJ2FwcGxpY2F0aW9uJyk7XHJcblxyXG4gIGlmICghJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zKSB7XHJcbiAgICAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMgPSB7fTtcclxuICB9XHJcblxyXG4gIC8vIE1vZGVzIGNoYWluXHJcbiAgdGhpcy5tb2RlcyA9IFsnZGF5JywgJ21vbnRoJywgJ3llYXInXTtcclxuXHJcbiAgW1xyXG4gICAgJ2N1c3RvbUNsYXNzJyxcclxuICAgICdkYXRlRGlzYWJsZWQnLFxyXG4gICAgJ2RhdGVwaWNrZXJNb2RlJyxcclxuICAgICdmb3JtYXREYXknLFxyXG4gICAgJ2Zvcm1hdERheUhlYWRlcicsXHJcbiAgICAnZm9ybWF0RGF5VGl0bGUnLFxyXG4gICAgJ2Zvcm1hdE1vbnRoJyxcclxuICAgICdmb3JtYXRNb250aFRpdGxlJyxcclxuICAgICdmb3JtYXRZZWFyJyxcclxuICAgICdtYXhEYXRlJyxcclxuICAgICdtYXhNb2RlJyxcclxuICAgICdtaW5EYXRlJyxcclxuICAgICdtaW5Nb2RlJyxcclxuICAgICdtb250aENvbHVtbnMnLFxyXG4gICAgJ3Nob3dXZWVrcycsXHJcbiAgICAnc2hvcnRjdXRQcm9wYWdhdGlvbicsXHJcbiAgICAnc3RhcnRpbmdEYXknLFxyXG4gICAgJ3llYXJDb2x1bW5zJyxcclxuICAgICd5ZWFyUm93cydcclxuICBdLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICBjYXNlICdjdXN0b21DbGFzcyc6XHJcbiAgICAgIGNhc2UgJ2RhdGVEaXNhYmxlZCc6XHJcbiAgICAgICAgJHNjb3BlW2tleV0gPSAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XSB8fCBhbmd1bGFyLm5vb3A7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2RhdGVwaWNrZXJNb2RlJzpcclxuICAgICAgICAkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPSBhbmd1bGFyLmlzRGVmaW5lZCgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMuZGF0ZXBpY2tlck1vZGUpID9cclxuICAgICAgICAgICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5kYXRlcGlja2VyTW9kZSA6IGRhdGVwaWNrZXJDb25maWcuZGF0ZXBpY2tlck1vZGU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2Zvcm1hdERheSc6XHJcbiAgICAgIGNhc2UgJ2Zvcm1hdERheUhlYWRlcic6XHJcbiAgICAgIGNhc2UgJ2Zvcm1hdERheVRpdGxlJzpcclxuICAgICAgY2FzZSAnZm9ybWF0TW9udGgnOlxyXG4gICAgICBjYXNlICdmb3JtYXRNb250aFRpdGxlJzpcclxuICAgICAgY2FzZSAnZm9ybWF0WWVhcic6XHJcbiAgICAgICAgc2VsZltrZXldID0gYW5ndWxhci5pc0RlZmluZWQoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zW2tleV0pID9cclxuICAgICAgICAgICRpbnRlcnBvbGF0ZSgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XSkoJHNjb3BlLiRwYXJlbnQpIDpcclxuICAgICAgICAgIGRhdGVwaWNrZXJDb25maWdba2V5XTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnbW9udGhDb2x1bW5zJzpcclxuICAgICAgY2FzZSAnc2hvd1dlZWtzJzpcclxuICAgICAgY2FzZSAnc2hvcnRjdXRQcm9wYWdhdGlvbic6XHJcbiAgICAgIGNhc2UgJ3llYXJDb2x1bW5zJzpcclxuICAgICAgY2FzZSAneWVhclJvd3MnOlxyXG4gICAgICAgIHNlbGZba2V5XSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRzY29wZS5kYXRlcGlja2VyT3B0aW9uc1trZXldKSA/XHJcbiAgICAgICAgICAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XSA6IGRhdGVwaWNrZXJDb25maWdba2V5XTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnc3RhcnRpbmdEYXknOlxyXG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMuc3RhcnRpbmdEYXkpKSB7XHJcbiAgICAgICAgICBzZWxmLnN0YXJ0aW5nRGF5ID0gJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLnN0YXJ0aW5nRGF5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc051bWJlcihkYXRlcGlja2VyQ29uZmlnLnN0YXJ0aW5nRGF5KSkge1xyXG4gICAgICAgICAgc2VsZi5zdGFydGluZ0RheSA9IGRhdGVwaWNrZXJDb25maWcuc3RhcnRpbmdEYXk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNlbGYuc3RhcnRpbmdEYXkgPSAoJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLkZJUlNUREFZT0ZXRUVLICsgOCkgJSA3O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ21heERhdGUnOlxyXG4gICAgICBjYXNlICdtaW5EYXRlJzpcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKCdkYXRlcGlja2VyT3B0aW9ucy4nICsga2V5LCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGF0ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICBzZWxmW2tleV0gPSBkYXRlUGFyc2VyLmZyb21UaW1lem9uZShuZXcgRGF0ZSh2YWx1ZSksIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKCRkYXRlcGlja2VyTGl0ZXJhbFdhcm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICRsb2cud2FybignTGl0ZXJhbCBkYXRlIHN1cHBvcnQgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHN3aXRjaCB0byBkYXRlIG9iamVjdCB1c2FnZScpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgc2VsZltrZXldID0gbmV3IERhdGUoZGF0ZUZpbHRlcih2YWx1ZSwgJ21lZGl1bScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZltrZXldID0gZGF0ZXBpY2tlckNvbmZpZ1trZXldID9cclxuICAgICAgICAgICAgICBkYXRlUGFyc2VyLmZyb21UaW1lem9uZShuZXcgRGF0ZShkYXRlcGlja2VyQ29uZmlnW2tleV0pLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpIDpcclxuICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHNlbGYucmVmcmVzaFZpZXcoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ21heE1vZGUnOlxyXG4gICAgICBjYXNlICdtaW5Nb2RlJzpcclxuICAgICAgICBpZiAoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zW2tleV0pIHtcclxuICAgICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7IHJldHVybiAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XTsgfSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgc2VsZltrZXldID0gJHNjb3BlW2tleV0gPSBhbmd1bGFyLmlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6ICRzY29wZS5kYXRlcGlja2VyT3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnbWluTW9kZScgJiYgc2VsZi5tb2Rlcy5pbmRleE9mKCRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5kYXRlcGlja2VyTW9kZSkgPCBzZWxmLm1vZGVzLmluZGV4T2Yoc2VsZltrZXldKSB8fFxyXG4gICAgICAgICAgICAgIGtleSA9PT0gJ21heE1vZGUnICYmIHNlbGYubW9kZXMuaW5kZXhPZigkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMuZGF0ZXBpY2tlck1vZGUpID4gc2VsZi5tb2Rlcy5pbmRleE9mKHNlbGZba2V5XSkpIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPSBzZWxmW2tleV07XHJcbiAgICAgICAgICAgICAgJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLmRhdGVwaWNrZXJNb2RlID0gc2VsZltrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2VsZltrZXldID0gJHNjb3BlW2tleV0gPSBkYXRlcGlja2VyQ29uZmlnW2tleV0gfHwgbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAkc2NvcGUudW5pcXVlSWQgPSAnZGF0ZXBpY2tlci0nICsgJHNjb3BlLiRpZCArICctJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcclxuXHJcbiAgJHNjb3BlLmRpc2FibGVkID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmRpc2FibGVkKSB8fCBmYWxzZTtcclxuICBpZiAoYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLm5nRGlzYWJsZWQpKSB7XHJcbiAgICB3YXRjaExpc3RlbmVycy5wdXNoKCRzY29wZS4kcGFyZW50LiR3YXRjaCgkYXR0cnMubmdEaXNhYmxlZCwgZnVuY3Rpb24oZGlzYWJsZWQpIHtcclxuICAgICAgJHNjb3BlLmRpc2FibGVkID0gZGlzYWJsZWQ7XHJcbiAgICAgIHNlbGYucmVmcmVzaFZpZXcoKTtcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gICRzY29wZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKGRhdGVPYmplY3QpIHtcclxuICAgIGlmIChzZWxmLmNvbXBhcmUoZGF0ZU9iamVjdC5kYXRlLCBzZWxmLmFjdGl2ZURhdGUpID09PSAwKSB7XHJcbiAgICAgICRzY29wZS5hY3RpdmVEYXRlSWQgPSBkYXRlT2JqZWN0LnVpZDtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmxfKSB7XHJcbiAgICBuZ01vZGVsQ3RybCA9IG5nTW9kZWxDdHJsXztcclxuICAgIG5nTW9kZWxPcHRpb25zID0gZXh0cmFjdE9wdGlvbnMobmdNb2RlbEN0cmwpO1xyXG5cclxuICAgIGlmICgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMuaW5pdERhdGUpIHtcclxuICAgICAgc2VsZi5hY3RpdmVEYXRlID0gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLmluaXREYXRlLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpIHx8IG5ldyBEYXRlKCk7XHJcbiAgICAgICRzY29wZS4kd2F0Y2goJ2RhdGVwaWNrZXJPcHRpb25zLmluaXREYXRlJywgZnVuY3Rpb24oaW5pdERhdGUpIHtcclxuICAgICAgICBpZiAoaW5pdERhdGUgJiYgKG5nTW9kZWxDdHJsLiRpc0VtcHR5KG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlKSB8fCBuZ01vZGVsQ3RybC4kaW52YWxpZCkpIHtcclxuICAgICAgICAgIHNlbGYuYWN0aXZlRGF0ZSA9IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKGluaXREYXRlLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpO1xyXG4gICAgICAgICAgc2VsZi5yZWZyZXNoVmlldygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZWxmLmFjdGl2ZURhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkYXRlID0gbmdNb2RlbEN0cmwuJG1vZGVsVmFsdWUgPyBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kbW9kZWxWYWx1ZSkgOiBuZXcgRGF0ZSgpO1xyXG4gICAgdGhpcy5hY3RpdmVEYXRlID0gIWlzTmFOKGRhdGUpID9cclxuICAgICAgZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUoZGF0ZSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKSA6XHJcbiAgICAgIGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKG5ldyBEYXRlKCksIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XHJcblxyXG4gICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBzZWxmLnJlbmRlcigpO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpIHtcclxuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSxcclxuICAgICAgICAgIGlzVmFsaWQgPSAhaXNOYU4oZGF0ZSk7XHJcblxyXG4gICAgICBpZiAoaXNWYWxpZCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRGF0ZSA9IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKGRhdGUsIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoISRkYXRlcGlja2VyU3VwcHJlc3NFcnJvcikge1xyXG4gICAgICAgICRsb2cuZXJyb3IoJ0RhdGVwaWNrZXIgZGlyZWN0aXZlOiBcIm5nLW1vZGVsXCIgdmFsdWUgbXVzdCBiZSBhIERhdGUgb2JqZWN0Jyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMucmVmcmVzaFZpZXcoKTtcclxuICB9O1xyXG5cclxuICB0aGlzLnJlZnJlc2hWaWV3ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XHJcbiAgICAgICRzY29wZS5zZWxlY3RlZER0ID0gbnVsbDtcclxuICAgICAgdGhpcy5fcmVmcmVzaFZpZXcoKTtcclxuICAgICAgaWYgKCRzY29wZS5hY3RpdmVEdCkge1xyXG4gICAgICAgICRzY29wZS5hY3RpdmVEYXRlSWQgPSAkc2NvcGUuYWN0aXZlRHQudWlkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZGF0ZSA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUgPyBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSA6IG51bGw7XHJcbiAgICAgIGRhdGUgPSBkYXRlUGFyc2VyLmZyb21UaW1lem9uZShkYXRlLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpO1xyXG4gICAgICBuZ01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2RhdGVEaXNhYmxlZCcsICFkYXRlIHx8XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ICYmICF0aGlzLmlzRGlzYWJsZWQoZGF0ZSkpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRoaXMuY3JlYXRlRGF0ZU9iamVjdCA9IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCkge1xyXG4gICAgdmFyIG1vZGVsID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA/IG5ldyBEYXRlKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpIDogbnVsbDtcclxuICAgIG1vZGVsID0gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUobW9kZWwsIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XHJcbiAgICB2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xyXG4gICAgdG9kYXkgPSBkYXRlUGFyc2VyLmZyb21UaW1lem9uZSh0b2RheSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKTtcclxuICAgIHZhciB0aW1lID0gdGhpcy5jb21wYXJlKGRhdGUsIHRvZGF5KTtcclxuICAgIHZhciBkdCA9IHtcclxuICAgICAgZGF0ZTogZGF0ZSxcclxuICAgICAgbGFiZWw6IGRhdGVQYXJzZXIuZmlsdGVyKGRhdGUsIGZvcm1hdCksXHJcbiAgICAgIHNlbGVjdGVkOiBtb2RlbCAmJiB0aGlzLmNvbXBhcmUoZGF0ZSwgbW9kZWwpID09PSAwLFxyXG4gICAgICBkaXNhYmxlZDogdGhpcy5pc0Rpc2FibGVkKGRhdGUpLFxyXG4gICAgICBwYXN0OiB0aW1lIDwgMCxcclxuICAgICAgY3VycmVudDogdGltZSA9PT0gMCxcclxuICAgICAgZnV0dXJlOiB0aW1lID4gMCxcclxuICAgICAgY3VzdG9tQ2xhc3M6IHRoaXMuY3VzdG9tQ2xhc3MoZGF0ZSkgfHwgbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAobW9kZWwgJiYgdGhpcy5jb21wYXJlKGRhdGUsIG1vZGVsKSA9PT0gMCkge1xyXG4gICAgICAkc2NvcGUuc2VsZWN0ZWREdCA9IGR0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZWxmLmFjdGl2ZURhdGUgJiYgdGhpcy5jb21wYXJlKGR0LmRhdGUsIHNlbGYuYWN0aXZlRGF0ZSkgPT09IDApIHtcclxuICAgICAgJHNjb3BlLmFjdGl2ZUR0ID0gZHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGR0O1xyXG4gIH07XHJcblxyXG4gIHRoaXMuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uKGRhdGUpIHtcclxuICAgIHJldHVybiAkc2NvcGUuZGlzYWJsZWQgfHxcclxuICAgICAgdGhpcy5taW5EYXRlICYmIHRoaXMuY29tcGFyZShkYXRlLCB0aGlzLm1pbkRhdGUpIDwgMCB8fFxyXG4gICAgICB0aGlzLm1heERhdGUgJiYgdGhpcy5jb21wYXJlKGRhdGUsIHRoaXMubWF4RGF0ZSkgPiAwIHx8XHJcbiAgICAgICRzY29wZS5kYXRlRGlzYWJsZWQgJiYgJHNjb3BlLmRhdGVEaXNhYmxlZCh7ZGF0ZTogZGF0ZSwgbW9kZTogJHNjb3BlLmRhdGVwaWNrZXJNb2RlfSk7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5jdXN0b21DbGFzcyA9IGZ1bmN0aW9uKGRhdGUpIHtcclxuICAgIHJldHVybiAkc2NvcGUuY3VzdG9tQ2xhc3Moe2RhdGU6IGRhdGUsIG1vZGU6ICRzY29wZS5kYXRlcGlja2VyTW9kZX0pO1xyXG4gIH07XHJcblxyXG4gIC8vIFNwbGl0IGFycmF5IGludG8gc21hbGxlciBhcnJheXNcclxuICB0aGlzLnNwbGl0ID0gZnVuY3Rpb24oYXJyLCBzaXplKSB7XHJcbiAgICB2YXIgYXJyYXlzID0gW107XHJcbiAgICB3aGlsZSAoYXJyLmxlbmd0aCA+IDApIHtcclxuICAgICAgYXJyYXlzLnB1c2goYXJyLnNwbGljZSgwLCBzaXplKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXlzO1xyXG4gIH07XHJcblxyXG4gICRzY29wZS5zZWxlY3QgPSBmdW5jdGlvbihkYXRlKSB7XHJcbiAgICBpZiAoJHNjb3BlLmRhdGVwaWNrZXJNb2RlID09PSBzZWxmLm1pbk1vZGUpIHtcclxuICAgICAgdmFyIGR0ID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA/IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKG5ldyBEYXRlKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpIDogbmV3IERhdGUoMCwgMCwgMCwgMCwgMCwgMCwgMCk7XHJcbiAgICAgIGR0LnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XHJcbiAgICAgIGR0ID0gZGF0ZVBhcnNlci50b1RpbWV6b25lKGR0LCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpO1xyXG4gICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGR0KTtcclxuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2VsZi5hY3RpdmVEYXRlID0gZGF0ZTtcclxuICAgICAgc2V0TW9kZShzZWxmLm1vZGVzW3NlbGYubW9kZXMuaW5kZXhPZigkc2NvcGUuZGF0ZXBpY2tlck1vZGUpIC0gMV0pO1xyXG5cclxuICAgICAgJHNjb3BlLiRlbWl0KCd1aWI6ZGF0ZXBpY2tlci5tb2RlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgJHNjb3BlLiRicm9hZGNhc3QoJ3VpYjpkYXRlcGlja2VyLmZvY3VzJyk7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLm1vdmUgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcclxuICAgIHZhciB5ZWFyID0gc2VsZi5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkgKyBkaXJlY3Rpb24gKiAoc2VsZi5zdGVwLnllYXJzIHx8IDApLFxyXG4gICAgICAgIG1vbnRoID0gc2VsZi5hY3RpdmVEYXRlLmdldE1vbnRoKCkgKyBkaXJlY3Rpb24gKiAoc2VsZi5zdGVwLm1vbnRocyB8fCAwKTtcclxuICAgIHNlbGYuYWN0aXZlRGF0ZS5zZXRGdWxsWWVhcih5ZWFyLCBtb250aCwgMSk7XHJcbiAgICBzZWxmLnJlZnJlc2hWaWV3KCk7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLnRvZ2dsZU1vZGUgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcclxuICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCAxO1xyXG5cclxuICAgIGlmICgkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPT09IHNlbGYubWF4TW9kZSAmJiBkaXJlY3Rpb24gPT09IDEgfHxcclxuICAgICAgJHNjb3BlLmRhdGVwaWNrZXJNb2RlID09PSBzZWxmLm1pbk1vZGUgJiYgZGlyZWN0aW9uID09PSAtMSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc2V0TW9kZShzZWxmLm1vZGVzW3NlbGYubW9kZXMuaW5kZXhPZigkc2NvcGUuZGF0ZXBpY2tlck1vZGUpICsgZGlyZWN0aW9uXSk7XHJcblxyXG4gICAgJHNjb3BlLiRlbWl0KCd1aWI6ZGF0ZXBpY2tlci5tb2RlJyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gS2V5IGV2ZW50IG1hcHBlclxyXG4gICRzY29wZS5rZXlzID0geyAxMzogJ2VudGVyJywgMzI6ICdzcGFjZScsIDMzOiAncGFnZXVwJywgMzQ6ICdwYWdlZG93bicsIDM1OiAnZW5kJywgMzY6ICdob21lJywgMzc6ICdsZWZ0JywgMzg6ICd1cCcsIDM5OiAncmlnaHQnLCA0MDogJ2Rvd24nIH07XHJcblxyXG4gIHZhciBmb2N1c0VsZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHNlbGYuZWxlbWVudFswXS5mb2N1cygpO1xyXG4gIH07XHJcblxyXG4gIC8vIExpc3RlbiBmb3IgZm9jdXMgcmVxdWVzdHMgZnJvbSBwb3B1cCBkaXJlY3RpdmVcclxuICAkc2NvcGUuJG9uKCd1aWI6ZGF0ZXBpY2tlci5mb2N1cycsIGZvY3VzRWxlbWVudCk7XHJcblxyXG4gICRzY29wZS5rZXlkb3duID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICB2YXIga2V5ID0gJHNjb3BlLmtleXNbZXZ0LndoaWNoXTtcclxuXHJcbiAgICBpZiAoIWtleSB8fCBldnQuc2hpZnRLZXkgfHwgZXZ0LmFsdEtleSB8fCAkc2NvcGUuZGlzYWJsZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgaWYgKCFzZWxmLnNob3J0Y3V0UHJvcGFnYXRpb24pIHtcclxuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChrZXkgPT09ICdlbnRlcicgfHwga2V5ID09PSAnc3BhY2UnKSB7XHJcbiAgICAgIGlmIChzZWxmLmlzRGlzYWJsZWQoc2VsZi5hY3RpdmVEYXRlKSkge1xyXG4gICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZ1xyXG4gICAgICB9XHJcbiAgICAgICRzY29wZS5zZWxlY3Qoc2VsZi5hY3RpdmVEYXRlKTtcclxuICAgIH0gZWxzZSBpZiAoZXZ0LmN0cmxLZXkgJiYgKGtleSA9PT0gJ3VwJyB8fCBrZXkgPT09ICdkb3duJykpIHtcclxuICAgICAgJHNjb3BlLnRvZ2dsZU1vZGUoa2V5ID09PSAndXAnID8gMSA6IC0xKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNlbGYuaGFuZGxlS2V5RG93bihrZXksIGV2dCk7XHJcbiAgICAgIHNlbGYucmVmcmVzaFZpZXcoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAkZWxlbWVudC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgJHNjb3BlLmtleWRvd24oZXZ0KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xyXG4gICAgLy9DbGVhciBhbGwgd2F0Y2ggbGlzdGVuZXJzIG9uIGRlc3Ryb3lcclxuICAgIHdoaWxlICh3YXRjaExpc3RlbmVycy5sZW5ndGgpIHtcclxuICAgICAgd2F0Y2hMaXN0ZW5lcnMuc2hpZnQoKSgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBzZXRNb2RlKG1vZGUpIHtcclxuICAgICRzY29wZS5kYXRlcGlja2VyTW9kZSA9IG1vZGU7XHJcbiAgICAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMuZGF0ZXBpY2tlck1vZGUgPSBtb2RlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZXh0cmFjdE9wdGlvbnMobmdNb2RlbEN0cmwpIHtcclxuICAgIHZhciBuZ01vZGVsT3B0aW9ucztcclxuXHJcbiAgICBpZiAoYW5ndWxhci52ZXJzaW9uLm1pbm9yIDwgNikgeyAvLyBpbiBhbmd1bGFyIDwgMS42ICRvcHRpb25zIGNvdWxkIGJlIG1pc3NpbmdcclxuICAgICAgLy8gZ3VhcmFudGVlIGEgdmFsdWVcclxuICAgICAgbmdNb2RlbE9wdGlvbnMgPSBuZ01vZGVsQ3RybC4kb3B0aW9ucyB8fFxyXG4gICAgICAgICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5uZ01vZGVsT3B0aW9ucyB8fFxyXG4gICAgICAgIGRhdGVwaWNrZXJDb25maWcubmdNb2RlbE9wdGlvbnMgfHxcclxuICAgICAgICB7fTtcclxuXHJcbiAgICAgIC8vIG1pbWljIDEuNisgYXBpXHJcbiAgICAgIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbiA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gbmdNb2RlbE9wdGlvbnNba2V5XTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7IC8vIGluIGFuZ3VsYXIgPj0xLjYgJG9wdGlvbnMgaXMgYWx3YXlzIHByZXNlbnRcclxuICAgICAgLy8gbmctbW9kZWwtb3B0aW9ucyBkZWZhdWx0cyB0aW1lem9uZSB0byBudWxsOyBkb24ndCBsZXQgaXRzIHByZWNlZGVuY2Ugc3F1YXNoIGEgbm9uLW51bGwgdmFsdWVcclxuICAgICAgdmFyIHRpbWV6b25lID0gbmdNb2RlbEN0cmwuJG9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpIHx8XHJcbiAgICAgICAgKCRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5uZ01vZGVsT3B0aW9ucyA/ICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5uZ01vZGVsT3B0aW9ucy50aW1lem9uZSA6IG51bGwpIHx8XHJcbiAgICAgICAgKGRhdGVwaWNrZXJDb25maWcubmdNb2RlbE9wdGlvbnMgPyBkYXRlcGlja2VyQ29uZmlnLm5nTW9kZWxPcHRpb25zLnRpbWV6b25lIDogbnVsbCk7XHJcblxyXG4gICAgICAvLyB2YWx1ZXMgcGFzc2VkIHRvIGNyZWF0ZUNoaWxkIG92ZXJyaWRlIGV4aXN0aW5nIHZhbHVlc1xyXG4gICAgICBuZ01vZGVsT3B0aW9ucyA9IG5nTW9kZWxDdHJsLiRvcHRpb25zIC8vIHN0YXJ0IHdpdGggYSBNb2RlbE9wdGlvbnMgaW5zdGFuY2VcclxuICAgICAgICAuY3JlYXRlQ2hpbGQoZGF0ZXBpY2tlckNvbmZpZy5uZ01vZGVsT3B0aW9ucykgLy8gbG93ZXN0IHByZWNlZGVuY2VcclxuICAgICAgICAuY3JlYXRlQ2hpbGQoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLm5nTW9kZWxPcHRpb25zKVxyXG4gICAgICAgIC5jcmVhdGVDaGlsZChuZ01vZGVsQ3RybC4kb3B0aW9ucykgLy8gaGlnaGVzdCBwcmVjZWRlbmNlXHJcbiAgICAgICAgLmNyZWF0ZUNoaWxkKHt0aW1lem9uZTogdGltZXpvbmV9KTsgLy8gdG8ga2VlcCBmcm9tIHNxdWFzaGluZyBhIG5vbi1udWxsIHZhbHVlXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5nTW9kZWxPcHRpb25zO1xyXG4gIH1cclxufV0pXHJcblxyXG4uY29udHJvbGxlcignVWliRGF5cGlja2VyQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJ2RhdGVGaWx0ZXInLCBmdW5jdGlvbihzY29wZSwgJGVsZW1lbnQsIGRhdGVGaWx0ZXIpIHtcclxuICB2YXIgREFZU19JTl9NT05USCA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcclxuXHJcbiAgdGhpcy5zdGVwID0geyBtb250aHM6IDEgfTtcclxuICB0aGlzLmVsZW1lbnQgPSAkZWxlbWVudDtcclxuICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xyXG4gICAgcmV0dXJuIG1vbnRoID09PSAxICYmIHllYXIgJSA0ID09PSAwICYmXHJcbiAgICAgICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApID8gMjkgOiBEQVlTX0lOX01PTlRIW21vbnRoXTtcclxuICB9XHJcblxyXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGN0cmwpIHtcclxuICAgIGFuZ3VsYXIuZXh0ZW5kKGN0cmwsIHRoaXMpO1xyXG4gICAgc2NvcGUuc2hvd1dlZWtzID0gY3RybC5zaG93V2Vla3M7XHJcbiAgICBjdHJsLnJlZnJlc2hWaWV3KCk7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5nZXREYXRlcyA9IGZ1bmN0aW9uKHN0YXJ0RGF0ZSwgbikge1xyXG4gICAgdmFyIGRhdGVzID0gbmV3IEFycmF5KG4pLCBjdXJyZW50ID0gbmV3IERhdGUoc3RhcnREYXRlKSwgaSA9IDAsIGRhdGU7XHJcbiAgICB3aGlsZSAoaSA8IG4pIHtcclxuICAgICAgZGF0ZSA9IG5ldyBEYXRlKGN1cnJlbnQpO1xyXG4gICAgICBkYXRlc1tpKytdID0gZGF0ZTtcclxuICAgICAgY3VycmVudC5zZXREYXRlKGN1cnJlbnQuZ2V0RGF0ZSgpICsgMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0ZXM7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5fcmVmcmVzaFZpZXcgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB5ZWFyID0gdGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgIG1vbnRoID0gdGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCksXHJcbiAgICAgIGZpcnN0RGF5T2ZNb250aCA9IG5ldyBEYXRlKHRoaXMuYWN0aXZlRGF0ZSk7XHJcblxyXG4gICAgZmlyc3REYXlPZk1vbnRoLnNldEZ1bGxZZWFyKHllYXIsIG1vbnRoLCAxKTtcclxuXHJcbiAgICB2YXIgZGlmZmVyZW5jZSA9IHRoaXMuc3RhcnRpbmdEYXkgLSBmaXJzdERheU9mTW9udGguZ2V0RGF5KCksXHJcbiAgICAgIG51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoID0gZGlmZmVyZW5jZSA+IDAgP1xyXG4gICAgICAgIDcgLSBkaWZmZXJlbmNlIDogLSBkaWZmZXJlbmNlLFxyXG4gICAgICBmaXJzdERhdGUgPSBuZXcgRGF0ZShmaXJzdERheU9mTW9udGgpO1xyXG5cclxuICAgIGlmIChudW1EaXNwbGF5ZWRGcm9tUHJldmlvdXNNb250aCA+IDApIHtcclxuICAgICAgZmlyc3REYXRlLnNldERhdGUoLW51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoICsgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gNDIgaXMgdGhlIG51bWJlciBvZiBkYXlzIG9uIGEgc2l4LXdlZWsgY2FsZW5kYXJcclxuICAgIHZhciBkYXlzID0gdGhpcy5nZXREYXRlcyhmaXJzdERhdGUsIDQyKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDI7IGkgKyspIHtcclxuICAgICAgZGF5c1tpXSA9IGFuZ3VsYXIuZXh0ZW5kKHRoaXMuY3JlYXRlRGF0ZU9iamVjdChkYXlzW2ldLCB0aGlzLmZvcm1hdERheSksIHtcclxuICAgICAgICBzZWNvbmRhcnk6IGRheXNbaV0uZ2V0TW9udGgoKSAhPT0gbW9udGgsXHJcbiAgICAgICAgdWlkOiBzY29wZS51bmlxdWVJZCArICctJyArIGlcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2NvcGUubGFiZWxzID0gbmV3IEFycmF5KDcpO1xyXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA3OyBqKyspIHtcclxuICAgICAgc2NvcGUubGFiZWxzW2pdID0ge1xyXG4gICAgICAgIGFiYnI6IGRhdGVGaWx0ZXIoZGF5c1tqXS5kYXRlLCB0aGlzLmZvcm1hdERheUhlYWRlciksXHJcbiAgICAgICAgZnVsbDogZGF0ZUZpbHRlcihkYXlzW2pdLmRhdGUsICdFRUVFJylcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBzY29wZS50aXRsZSA9IGRhdGVGaWx0ZXIodGhpcy5hY3RpdmVEYXRlLCB0aGlzLmZvcm1hdERheVRpdGxlKTtcclxuICAgIHNjb3BlLnJvd3MgPSB0aGlzLnNwbGl0KGRheXMsIDcpO1xyXG5cclxuICAgIGlmIChzY29wZS5zaG93V2Vla3MpIHtcclxuICAgICAgc2NvcGUud2Vla051bWJlcnMgPSBbXTtcclxuICAgICAgdmFyIHRodXJzZGF5SW5kZXggPSAoNCArIDcgLSB0aGlzLnN0YXJ0aW5nRGF5KSAlIDcsXHJcbiAgICAgICAgICBudW1XZWVrcyA9IHNjb3BlLnJvd3MubGVuZ3RoO1xyXG4gICAgICBmb3IgKHZhciBjdXJXZWVrID0gMDsgY3VyV2VlayA8IG51bVdlZWtzOyBjdXJXZWVrKyspIHtcclxuICAgICAgICBzY29wZS53ZWVrTnVtYmVycy5wdXNoKFxyXG4gICAgICAgICAgZ2V0SVNPODYwMVdlZWtOdW1iZXIoc2NvcGUucm93c1tjdXJXZWVrXVt0aHVyc2RheUluZGV4XS5kYXRlKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICB0aGlzLmNvbXBhcmUgPSBmdW5jdGlvbihkYXRlMSwgZGF0ZTIpIHtcclxuICAgIHZhciBfZGF0ZTEgPSBuZXcgRGF0ZShkYXRlMS5nZXRGdWxsWWVhcigpLCBkYXRlMS5nZXRNb250aCgpLCBkYXRlMS5nZXREYXRlKCkpO1xyXG4gICAgdmFyIF9kYXRlMiA9IG5ldyBEYXRlKGRhdGUyLmdldEZ1bGxZZWFyKCksIGRhdGUyLmdldE1vbnRoKCksIGRhdGUyLmdldERhdGUoKSk7XHJcbiAgICBfZGF0ZTEuc2V0RnVsbFllYXIoZGF0ZTEuZ2V0RnVsbFllYXIoKSk7XHJcbiAgICBfZGF0ZTIuc2V0RnVsbFllYXIoZGF0ZTIuZ2V0RnVsbFllYXIoKSk7XHJcbiAgICByZXR1cm4gX2RhdGUxIC0gX2RhdGUyO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGdldElTTzg2MDFXZWVrTnVtYmVyKGRhdGUpIHtcclxuICAgIHZhciBjaGVja0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcclxuICAgIGNoZWNrRGF0ZS5zZXREYXRlKGNoZWNrRGF0ZS5nZXREYXRlKCkgKyA0IC0gKGNoZWNrRGF0ZS5nZXREYXkoKSB8fCA3KSk7IC8vIFRodXJzZGF5XHJcbiAgICB2YXIgdGltZSA9IGNoZWNrRGF0ZS5nZXRUaW1lKCk7XHJcbiAgICBjaGVja0RhdGUuc2V0TW9udGgoMCk7IC8vIENvbXBhcmUgd2l0aCBKYW4gMVxyXG4gICAgY2hlY2tEYXRlLnNldERhdGUoMSk7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJvdW5kKCh0aW1lIC0gY2hlY2tEYXRlKSAvIDg2NDAwMDAwKSAvIDcpICsgMTtcclxuICB9XHJcblxyXG4gIHRoaXMuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uKGtleSwgZXZ0KSB7XHJcbiAgICB2YXIgZGF0ZSA9IHRoaXMuYWN0aXZlRGF0ZS5nZXREYXRlKCk7XHJcblxyXG4gICAgaWYgKGtleSA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgIGRhdGUgPSBkYXRlIC0gMTtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAndXAnKSB7XHJcbiAgICAgIGRhdGUgPSBkYXRlIC0gNztcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncmlnaHQnKSB7XHJcbiAgICAgIGRhdGUgPSBkYXRlICsgMTtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZG93bicpIHtcclxuICAgICAgZGF0ZSA9IGRhdGUgKyA3O1xyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdwYWdldXAnIHx8IGtleSA9PT0gJ3BhZ2Vkb3duJykge1xyXG4gICAgICB2YXIgbW9udGggPSB0aGlzLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSArIChrZXkgPT09ICdwYWdldXAnID8gLSAxIDogMSk7XHJcbiAgICAgIHRoaXMuYWN0aXZlRGF0ZS5zZXRNb250aChtb250aCwgMSk7XHJcbiAgICAgIGRhdGUgPSBNYXRoLm1pbihnZXREYXlzSW5Nb250aCh0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSwgdGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCkpLCBkYXRlKTtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaG9tZScpIHtcclxuICAgICAgZGF0ZSA9IDE7XHJcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2VuZCcpIHtcclxuICAgICAgZGF0ZSA9IGdldERheXNJbk1vbnRoKHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLCB0aGlzLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFjdGl2ZURhdGUuc2V0RGF0ZShkYXRlKTtcclxuICB9O1xyXG59XSlcclxuXHJcbi5jb250cm9sbGVyKCdVaWJNb250aHBpY2tlckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICdkYXRlRmlsdGVyJywgZnVuY3Rpb24oc2NvcGUsICRlbGVtZW50LCBkYXRlRmlsdGVyKSB7XHJcbiAgdGhpcy5zdGVwID0geyB5ZWFyczogMSB9O1xyXG4gIHRoaXMuZWxlbWVudCA9ICRlbGVtZW50O1xyXG5cclxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihjdHJsKSB7XHJcbiAgICBhbmd1bGFyLmV4dGVuZChjdHJsLCB0aGlzKTtcclxuICAgIGN0cmwucmVmcmVzaFZpZXcoKTtcclxuICB9O1xyXG5cclxuICB0aGlzLl9yZWZyZXNoVmlldyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG1vbnRocyA9IG5ldyBBcnJheSgxMiksXHJcbiAgICAgICAgeWVhciA9IHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgIGRhdGU7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XHJcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZSh0aGlzLmFjdGl2ZURhdGUpO1xyXG4gICAgICBkYXRlLnNldEZ1bGxZZWFyKHllYXIsIGksIDEpO1xyXG4gICAgICBtb250aHNbaV0gPSBhbmd1bGFyLmV4dGVuZCh0aGlzLmNyZWF0ZURhdGVPYmplY3QoZGF0ZSwgdGhpcy5mb3JtYXRNb250aCksIHtcclxuICAgICAgICB1aWQ6IHNjb3BlLnVuaXF1ZUlkICsgJy0nICsgaVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzY29wZS50aXRsZSA9IGRhdGVGaWx0ZXIodGhpcy5hY3RpdmVEYXRlLCB0aGlzLmZvcm1hdE1vbnRoVGl0bGUpO1xyXG4gICAgc2NvcGUucm93cyA9IHRoaXMuc3BsaXQobW9udGhzLCB0aGlzLm1vbnRoQ29sdW1ucyk7XHJcbiAgICBzY29wZS55ZWFySGVhZGVyQ29sc3BhbiA9IHRoaXMubW9udGhDb2x1bW5zID4gMyA/IHRoaXMubW9udGhDb2x1bW5zIC0gMiA6IDE7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5jb21wYXJlID0gZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XHJcbiAgICB2YXIgX2RhdGUxID0gbmV3IERhdGUoZGF0ZTEuZ2V0RnVsbFllYXIoKSwgZGF0ZTEuZ2V0TW9udGgoKSk7XHJcbiAgICB2YXIgX2RhdGUyID0gbmV3IERhdGUoZGF0ZTIuZ2V0RnVsbFllYXIoKSwgZGF0ZTIuZ2V0TW9udGgoKSk7XHJcbiAgICBfZGF0ZTEuc2V0RnVsbFllYXIoZGF0ZTEuZ2V0RnVsbFllYXIoKSk7XHJcbiAgICBfZGF0ZTIuc2V0RnVsbFllYXIoZGF0ZTIuZ2V0RnVsbFllYXIoKSk7XHJcbiAgICByZXR1cm4gX2RhdGUxIC0gX2RhdGUyO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uKGtleSwgZXZ0KSB7XHJcbiAgICB2YXIgZGF0ZSA9IHRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpO1xyXG5cclxuICAgIGlmIChrZXkgPT09ICdsZWZ0Jykge1xyXG4gICAgICBkYXRlID0gZGF0ZSAtIDE7XHJcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3VwJykge1xyXG4gICAgICBkYXRlID0gZGF0ZSAtIHRoaXMubW9udGhDb2x1bW5zO1xyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdyaWdodCcpIHtcclxuICAgICAgZGF0ZSA9IGRhdGUgKyAxO1xyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdkb3duJykge1xyXG4gICAgICBkYXRlID0gZGF0ZSArIHRoaXMubW9udGhDb2x1bW5zO1xyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdwYWdldXAnIHx8IGtleSA9PT0gJ3BhZ2Vkb3duJykge1xyXG4gICAgICB2YXIgeWVhciA9IHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpICsgKGtleSA9PT0gJ3BhZ2V1cCcgPyAtIDEgOiAxKTtcclxuICAgICAgdGhpcy5hY3RpdmVEYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdob21lJykge1xyXG4gICAgICBkYXRlID0gMDtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZW5kJykge1xyXG4gICAgICBkYXRlID0gMTE7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFjdGl2ZURhdGUuc2V0TW9udGgoZGF0ZSk7XHJcbiAgfTtcclxufV0pXHJcblxyXG4uY29udHJvbGxlcignVWliWWVhcnBpY2tlckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICdkYXRlRmlsdGVyJywgZnVuY3Rpb24oc2NvcGUsICRlbGVtZW50LCBkYXRlRmlsdGVyKSB7XHJcbiAgdmFyIGNvbHVtbnMsIHJhbmdlO1xyXG4gIHRoaXMuZWxlbWVudCA9ICRlbGVtZW50O1xyXG5cclxuICBmdW5jdGlvbiBnZXRTdGFydGluZ1llYXIoeWVhcikge1xyXG4gICAgcmV0dXJuIHBhcnNlSW50KCh5ZWFyIC0gMSkgLyByYW5nZSwgMTApICogcmFuZ2UgKyAxO1xyXG4gIH1cclxuXHJcbiAgdGhpcy55ZWFycGlja2VySW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgY29sdW1ucyA9IHRoaXMueWVhckNvbHVtbnM7XHJcbiAgICByYW5nZSA9IHRoaXMueWVhclJvd3MgKiBjb2x1bW5zO1xyXG4gICAgdGhpcy5zdGVwID0geyB5ZWFyczogcmFuZ2UgfTtcclxuICB9O1xyXG5cclxuICB0aGlzLl9yZWZyZXNoVmlldyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHllYXJzID0gbmV3IEFycmF5KHJhbmdlKSwgZGF0ZTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgc3RhcnQgPSBnZXRTdGFydGluZ1llYXIodGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkpOyBpIDwgcmFuZ2U7IGkrKykge1xyXG4gICAgICBkYXRlID0gbmV3IERhdGUodGhpcy5hY3RpdmVEYXRlKTtcclxuICAgICAgZGF0ZS5zZXRGdWxsWWVhcihzdGFydCArIGksIDAsIDEpO1xyXG4gICAgICB5ZWFyc1tpXSA9IGFuZ3VsYXIuZXh0ZW5kKHRoaXMuY3JlYXRlRGF0ZU9iamVjdChkYXRlLCB0aGlzLmZvcm1hdFllYXIpLCB7XHJcbiAgICAgICAgdWlkOiBzY29wZS51bmlxdWVJZCArICctJyArIGlcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2NvcGUudGl0bGUgPSBbeWVhcnNbMF0ubGFiZWwsIHllYXJzW3JhbmdlIC0gMV0ubGFiZWxdLmpvaW4oJyAtICcpO1xyXG4gICAgc2NvcGUucm93cyA9IHRoaXMuc3BsaXQoeWVhcnMsIGNvbHVtbnMpO1xyXG4gICAgc2NvcGUuY29sdW1ucyA9IGNvbHVtbnM7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5jb21wYXJlID0gZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XHJcbiAgICByZXR1cm4gZGF0ZTEuZ2V0RnVsbFllYXIoKSAtIGRhdGUyLmdldEZ1bGxZZWFyKCk7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24oa2V5LCBldnQpIHtcclxuICAgIHZhciBkYXRlID0gdGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCk7XHJcblxyXG4gICAgaWYgKGtleSA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgIGRhdGUgPSBkYXRlIC0gMTtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAndXAnKSB7XHJcbiAgICAgIGRhdGUgPSBkYXRlIC0gY29sdW1ucztcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncmlnaHQnKSB7XHJcbiAgICAgIGRhdGUgPSBkYXRlICsgMTtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZG93bicpIHtcclxuICAgICAgZGF0ZSA9IGRhdGUgKyBjb2x1bW5zO1xyXG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdwYWdldXAnIHx8IGtleSA9PT0gJ3BhZ2Vkb3duJykge1xyXG4gICAgICBkYXRlICs9IChrZXkgPT09ICdwYWdldXAnID8gLSAxIDogMSkgKiByYW5nZTtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaG9tZScpIHtcclxuICAgICAgZGF0ZSA9IGdldFN0YXJ0aW5nWWVhcih0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSk7XHJcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2VuZCcpIHtcclxuICAgICAgZGF0ZSA9IGdldFN0YXJ0aW5nWWVhcih0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSkgKyByYW5nZSAtIDE7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFjdGl2ZURhdGUuc2V0RnVsbFllYXIoZGF0ZSk7XHJcbiAgfTtcclxufV0pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJEYXRlcGlja2VyJywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xyXG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbCc7XHJcbiAgICB9LFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgZGF0ZXBpY2tlck9wdGlvbnM6ICc9PydcclxuICAgIH0sXHJcbiAgICByZXF1aXJlOiBbJ3VpYkRhdGVwaWNrZXInLCAnXm5nTW9kZWwnXSxcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICBjb250cm9sbGVyOiAnVWliRGF0ZXBpY2tlckNvbnRyb2xsZXInLFxyXG4gICAgY29udHJvbGxlckFzOiAnZGF0ZXBpY2tlcicsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XHJcbiAgICAgIHZhciBkYXRlcGlja2VyQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xyXG5cclxuICAgICAgZGF0ZXBpY2tlckN0cmwuaW5pdChuZ01vZGVsQ3RybCk7XHJcbiAgICB9XHJcbiAgfTtcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYkRheXBpY2tlcicsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcclxuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9kYXkuaHRtbCc7XHJcbiAgICB9LFxyXG4gICAgcmVxdWlyZTogWydedWliRGF0ZXBpY2tlcicsICd1aWJEYXlwaWNrZXInXSxcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICBjb250cm9sbGVyOiAnVWliRGF5cGlja2VyQ29udHJvbGxlcicsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XHJcbiAgICAgIHZhciBkYXRlcGlja2VyQ3RybCA9IGN0cmxzWzBdLFxyXG4gICAgICAgIGRheXBpY2tlckN0cmwgPSBjdHJsc1sxXTtcclxuXHJcbiAgICAgIGRheXBpY2tlckN0cmwuaW5pdChkYXRlcGlja2VyQ3RybCk7XHJcbiAgICB9XHJcbiAgfTtcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYk1vbnRocGlja2VyJywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xyXG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL21vbnRoLmh0bWwnO1xyXG4gICAgfSxcclxuICAgIHJlcXVpcmU6IFsnXnVpYkRhdGVwaWNrZXInLCAndWliTW9udGhwaWNrZXInXSxcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICBjb250cm9sbGVyOiAnVWliTW9udGhwaWNrZXJDb250cm9sbGVyJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcclxuICAgICAgdmFyIGRhdGVwaWNrZXJDdHJsID0gY3RybHNbMF0sXHJcbiAgICAgICAgbW9udGhwaWNrZXJDdHJsID0gY3RybHNbMV07XHJcblxyXG4gICAgICBtb250aHBpY2tlckN0cmwuaW5pdChkYXRlcGlja2VyQ3RybCk7XHJcbiAgICB9XHJcbiAgfTtcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYlllYXJwaWNrZXInLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sJztcclxuICAgIH0sXHJcbiAgICByZXF1aXJlOiBbJ151aWJEYXRlcGlja2VyJywgJ3VpYlllYXJwaWNrZXInXSxcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICBjb250cm9sbGVyOiAnVWliWWVhcnBpY2tlckNvbnRyb2xsZXInLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xyXG4gICAgICB2YXIgY3RybCA9IGN0cmxzWzBdO1xyXG4gICAgICBhbmd1bGFyLmV4dGVuZChjdHJsLCBjdHJsc1sxXSk7XHJcbiAgICAgIGN0cmwueWVhcnBpY2tlckluaXQoKTtcclxuXHJcbiAgICAgIGN0cmwucmVmcmVzaFZpZXcoKTtcclxuICAgIH1cclxuICB9O1xyXG59KTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucG9zaXRpb24nLCBbXSlcclxuXHJcbi8qKlxyXG4gKiBBIHNldCBvZiB1dGlsaXR5IG1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCB0aGUgRE9NLlxyXG4gKiBJdCBpcyBtZWFudCB0byBiZSB1c2VkIHdoZXJlIHdlIG5lZWQgdG8gYWJzb2x1dGUtcG9zaXRpb24gZWxlbWVudHMgaW5cclxuICogcmVsYXRpb24gdG8gYW5vdGhlciBlbGVtZW50ICh0aGlzIGlzIHRoZSBjYXNlIGZvciB0b29sdGlwcywgcG9wb3ZlcnMsXHJcbiAqIHR5cGVhaGVhZCBzdWdnZXN0aW9ucyBldGMuKS5cclxuICovXHJcbiAgLmZhY3RvcnkoJyR1aWJQb3NpdGlvbicsIFsnJGRvY3VtZW50JywgJyR3aW5kb3cnLCBmdW5jdGlvbigkZG9jdW1lbnQsICR3aW5kb3cpIHtcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCBieSBzY3JvbGxiYXJXaWR0aCgpIGZ1bmN0aW9uIHRvIGNhY2hlIHNjcm9sbGJhcidzIHdpZHRoLlxyXG4gICAgICogRG8gbm90IGFjY2VzcyB0aGlzIHZhcmlhYmxlIGRpcmVjdGx5LCB1c2Ugc2Nyb2xsYmFyV2lkdGgoKSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICB2YXIgU0NST0xMQkFSX1dJRFRIO1xyXG4gICAgLyoqXHJcbiAgICAgKiBzY3JvbGxiYXIgb24gYm9keSBhbmQgaHRtbCBlbGVtZW50IGluIElFIGFuZCBFZGdlIG92ZXJsYXlcclxuICAgICAqIGNvbnRlbnQgYW5kIHNob3VsZCBiZSBjb25zaWRlcmVkIDAgd2lkdGguXHJcbiAgICAgKi9cclxuICAgIHZhciBCT0RZX1NDUk9MTEJBUl9XSURUSDtcclxuICAgIHZhciBPVkVSRkxPV19SRUdFWCA9IHtcclxuICAgICAgbm9ybWFsOiAvKGF1dG98c2Nyb2xsKS8sXHJcbiAgICAgIGhpZGRlbjogLyhhdXRvfHNjcm9sbHxoaWRkZW4pL1xyXG4gICAgfTtcclxuICAgIHZhciBQTEFDRU1FTlRfUkVHRVggPSB7XHJcbiAgICAgIGF1dG86IC9cXHM/YXV0bz9cXHM/L2ksXHJcbiAgICAgIHByaW1hcnk6IC9eKHRvcHxib3R0b218bGVmdHxyaWdodCkkLyxcclxuICAgICAgc2Vjb25kYXJ5OiAvXih0b3B8Ym90dG9tfGxlZnR8cmlnaHR8Y2VudGVyKSQvLFxyXG4gICAgICB2ZXJ0aWNhbDogL14odG9wfGJvdHRvbSkkL1xyXG4gICAgfTtcclxuICAgIHZhciBCT0RZX1JFR0VYID0gLyhIVE1MfEJPRFkpLztcclxuXHJcbiAgICByZXR1cm4ge1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFByb3ZpZGVzIGEgcmF3IERPTSBlbGVtZW50IGZyb20gYSBqUXVlcnkvalFMaXRlIGVsZW1lbnQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbSAtIFRoZSBlbGVtZW50IHRvIGNvbnZlcnQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZXR1cm5zIHtlbGVtZW50fSBBIEhUTUwgZWxlbWVudC5cclxuICAgICAgICovXHJcbiAgICAgIGdldFJhd05vZGU6IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4gZWxlbS5ub2RlTmFtZSA/IGVsZW0gOiBlbGVtWzBdIHx8IGVsZW07XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUHJvdmlkZXMgYSBwYXJzZWQgbnVtYmVyIGZvciBhIHN0eWxlIHByb3BlcnR5LiAgU3RyaXBzXHJcbiAgICAgICAqIHVuaXRzIGFuZCBjYXN0cyBpbnZhbGlkIG51bWJlcnMgdG8gMC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIHN0eWxlIHZhbHVlIHRvIHBhcnNlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBBIHZhbGlkIG51bWJlci5cclxuICAgICAgICovXHJcbiAgICAgIHBhcnNlU3R5bGU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gdmFsdWUgOiAwO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFByb3ZpZGVzIHRoZSBjbG9zZXN0IHBvc2l0aW9uZWQgYW5jZXN0b3IuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGdldCB0aGUgb2ZmZXN0IHBhcmVudCBmb3IuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZXR1cm5zIHtlbGVtZW50fSBUaGUgY2xvc2VzdCBwb3NpdGlvbmVkIGFuY2VzdG9yLlxyXG4gICAgICAgKi9cclxuICAgICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgZWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZShlbGVtKTtcclxuXHJcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8ICRkb2N1bWVudFswXS5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGlzU3RhdGljUG9zaXRpb25lZChlbCkge1xyXG4gICAgICAgICAgcmV0dXJuICgkd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLnBvc2l0aW9uIHx8ICdzdGF0aWMnKSA9PT0gJ3N0YXRpYyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudCAmJiBpc1N0YXRpY1Bvc2l0aW9uZWQob2Zmc2V0UGFyZW50KSkge1xyXG4gICAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBQcm92aWRlcyB0aGUgc2Nyb2xsYmFyIHdpZHRoLCBjb25jZXB0IGZyb20gVFdCUyBtZWFzdXJlU2Nyb2xsYmFyKClcclxuICAgICAgICogZnVuY3Rpb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL2pzL21vZGFsLmpzXHJcbiAgICAgICAqIEluIElFIGFuZCBFZGdlLCBzY29sbGJhciBvbiBib2R5IGFuZCBodG1sIGVsZW1lbnQgb3ZlcmxheSBhbmQgc2hvdWxkXHJcbiAgICAgICAqIHJldHVybiBhIHdpZHRoIG9mIDAuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgYnJvd3NlciBzY29sbGJhci5cclxuICAgICAgICovXHJcbiAgICAgIHNjcm9sbGJhcldpZHRoOiBmdW5jdGlvbihpc0JvZHkpIHtcclxuICAgICAgICBpZiAoaXNCb2R5KSB7XHJcbiAgICAgICAgICBpZiAoYW5ndWxhci5pc1VuZGVmaW5lZChCT0RZX1NDUk9MTEJBUl9XSURUSCkpIHtcclxuICAgICAgICAgICAgdmFyIGJvZHlFbGVtID0gJGRvY3VtZW50LmZpbmQoJ2JvZHknKTtcclxuICAgICAgICAgICAgYm9keUVsZW0uYWRkQ2xhc3MoJ3VpYi1wb3NpdGlvbi1ib2R5LXNjcm9sbGJhci1tZWFzdXJlJyk7XHJcbiAgICAgICAgICAgIEJPRFlfU0NST0xMQkFSX1dJRFRIID0gJHdpbmRvdy5pbm5lcldpZHRoIC0gYm9keUVsZW1bMF0uY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgIEJPRFlfU0NST0xMQkFSX1dJRFRIID0gaXNGaW5pdGUoQk9EWV9TQ1JPTExCQVJfV0lEVEgpID8gQk9EWV9TQ1JPTExCQVJfV0lEVEggOiAwO1xyXG4gICAgICAgICAgICBib2R5RWxlbS5yZW1vdmVDbGFzcygndWliLXBvc2l0aW9uLWJvZHktc2Nyb2xsYmFyLW1lYXN1cmUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBCT0RZX1NDUk9MTEJBUl9XSURUSDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhbmd1bGFyLmlzVW5kZWZpbmVkKFNDUk9MTEJBUl9XSURUSCkpIHtcclxuICAgICAgICAgIHZhciBzY3JvbGxFbGVtID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IGNsYXNzPVwidWliLXBvc2l0aW9uLXNjcm9sbGJhci1tZWFzdXJlXCI+PC9kaXY+Jyk7XHJcbiAgICAgICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmFwcGVuZChzY3JvbGxFbGVtKTtcclxuICAgICAgICAgIFNDUk9MTEJBUl9XSURUSCA9IHNjcm9sbEVsZW1bMF0ub2Zmc2V0V2lkdGggLSBzY3JvbGxFbGVtWzBdLmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgU0NST0xMQkFSX1dJRFRIID0gaXNGaW5pdGUoU0NST0xMQkFSX1dJRFRIKSA/IFNDUk9MTEJBUl9XSURUSCA6IDA7XHJcbiAgICAgICAgICBzY3JvbGxFbGVtLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFNDUk9MTEJBUl9XSURUSDtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBQcm92aWRlcyB0aGUgcGFkZGluZyByZXF1aXJlZCBvbiBhbiBlbGVtZW50IHRvIHJlcGxhY2UgdGhlIHNjcm9sbGJhci5cclxuICAgICAgICpcclxuICAgICAgICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICAgKiAgIDx1bD5cclxuICAgICAgICogICAgIDxsaT4qKnNjcm9sbGJhcldpZHRoKio6IHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsYmFyPC9saT5cclxuICAgICAgICogICAgIDxsaT4qKndpZHRoT3ZlcmZsb3cqKjogd2hldGhlciB0aGUgdGhlIHdpZHRoIGlzIG92ZXJmbG93aW5nPC9saT5cclxuICAgICAgICogICAgIDxsaT4qKnJpZ2h0Kio6IHRoZSBhbW91bnQgb2YgcmlnaHQgcGFkZGluZyBvbiB0aGUgZWxlbWVudCBuZWVkZWQgdG8gcmVwbGFjZSB0aGUgc2Nyb2xsYmFyPC9saT5cclxuICAgICAgICogICAgIDxsaT4qKnJpZ2h0T3JpZ2luYWwqKjogdGhlIGFtb3VudCBvZiByaWdodCBwYWRkaW5nIGN1cnJlbnRseSBvbiB0aGUgZWxlbWVudDwvbGk+XHJcbiAgICAgICAqICAgICA8bGk+KipoZWlnaHRPdmVyZmxvdyoqOiB3aGV0aGVyIHRoZSB0aGUgaGVpZ2h0IGlzIG92ZXJmbG93aW5nPC9saT5cclxuICAgICAgICogICAgIDxsaT4qKmJvdHRvbSoqOiB0aGUgYW1vdW50IG9mIGJvdHRvbSBwYWRkaW5nIG9uIHRoZSBlbGVtZW50IG5lZWRlZCB0byByZXBsYWNlIHRoZSBzY3JvbGxiYXI8L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPioqYm90dG9tT3JpZ2luYWwqKjogdGhlIGFtb3VudCBvZiBib3R0b20gcGFkZGluZyBjdXJyZW50bHkgb24gdGhlIGVsZW1lbnQ8L2xpPlxyXG4gICAgICAgKiAgIDwvdWw+XHJcbiAgICAgICAqL1xyXG4gICAgICBzY3JvbGxiYXJQYWRkaW5nOiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgZWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZShlbGVtKTtcclxuXHJcbiAgICAgICAgdmFyIGVsZW1TdHlsZSA9ICR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcclxuICAgICAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gdGhpcy5wYXJzZVN0eWxlKGVsZW1TdHlsZS5wYWRkaW5nUmlnaHQpO1xyXG4gICAgICAgIHZhciBwYWRkaW5nQm90dG9tID0gdGhpcy5wYXJzZVN0eWxlKGVsZW1TdHlsZS5wYWRkaW5nQm90dG9tKTtcclxuICAgICAgICB2YXIgc2Nyb2xsUGFyZW50ID0gdGhpcy5zY3JvbGxQYXJlbnQoZWxlbSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuc2Nyb2xsYmFyV2lkdGgoQk9EWV9SRUdFWC50ZXN0KHNjcm9sbFBhcmVudC50YWdOYW1lKSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzY3JvbGxiYXJXaWR0aDogc2Nyb2xsYmFyV2lkdGgsXHJcbiAgICAgICAgICB3aWR0aE92ZXJmbG93OiBzY3JvbGxQYXJlbnQuc2Nyb2xsV2lkdGggPiBzY3JvbGxQYXJlbnQuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICByaWdodDogcGFkZGluZ1JpZ2h0ICsgc2Nyb2xsYmFyV2lkdGgsXHJcbiAgICAgICAgICBvcmlnaW5hbFJpZ2h0OiBwYWRkaW5nUmlnaHQsXHJcbiAgICAgICAgICBoZWlnaHRPdmVyZmxvdzogc2Nyb2xsUGFyZW50LnNjcm9sbEhlaWdodCA+IHNjcm9sbFBhcmVudC5jbGllbnRIZWlnaHQsXHJcbiAgICAgICAgICBib3R0b206IHBhZGRpbmdCb3R0b20gKyBzY3JvbGxiYXJXaWR0aCxcclxuICAgICAgICAgIG9yaWdpbmFsQm90dG9tOiBwYWRkaW5nQm90dG9tXHJcbiAgICAgICAgIH07XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgZWxlbWVudCBpcyBzY3JvbGxhYmxlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW0gLSBUaGUgZWxlbWVudCB0byBjaGVjay5cclxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gW2luY2x1ZGVIaWRkZW49ZmFsc2VdIC0gU2hvdWxkIHNjcm9sbCBzdHlsZSBvZiAnaGlkZGVuJyBiZSBjb25zaWRlcmVkLFxyXG4gICAgICAgKiAgIGRlZmF1bHQgaXMgZmFsc2UuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHNjcm9sbGFibGUuXHJcbiAgICAgICAqL1xyXG4gICAgICBpc1Njcm9sbGFibGU6IGZ1bmN0aW9uKGVsZW0sIGluY2x1ZGVIaWRkZW4pIHtcclxuICAgICAgICBlbGVtID0gdGhpcy5nZXRSYXdOb2RlKGVsZW0pO1xyXG5cclxuICAgICAgICB2YXIgb3ZlcmZsb3dSZWdleCA9IGluY2x1ZGVIaWRkZW4gPyBPVkVSRkxPV19SRUdFWC5oaWRkZW4gOiBPVkVSRkxPV19SRUdFWC5ub3JtYWw7XHJcbiAgICAgICAgdmFyIGVsZW1TdHlsZSA9ICR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcclxuICAgICAgICByZXR1cm4gb3ZlcmZsb3dSZWdleC50ZXN0KGVsZW1TdHlsZS5vdmVyZmxvdyArIGVsZW1TdHlsZS5vdmVyZmxvd1kgKyBlbGVtU3R5bGUub3ZlcmZsb3dYKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBQcm92aWRlcyB0aGUgY2xvc2VzdCBzY3JvbGxhYmxlIGFuY2VzdG9yLlxyXG4gICAgICAgKiBBIHBvcnQgb2YgdGhlIGpRdWVyeSBVSSBzY3JvbGxQYXJlbnQgbWV0aG9kOlxyXG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS11aS9ibG9iL21hc3Rlci91aS9zY3JvbGwtcGFyZW50LmpzXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbSAtIFRoZSBlbGVtZW50IHRvIGZpbmQgdGhlIHNjcm9sbCBwYXJlbnQgb2YuXHJcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtpbmNsdWRlSGlkZGVuPWZhbHNlXSAtIFNob3VsZCBzY3JvbGwgc3R5bGUgb2YgJ2hpZGRlbicgYmUgY29uc2lkZXJlZCxcclxuICAgICAgICogICBkZWZhdWx0IGlzIGZhbHNlLlxyXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbaW5jbHVkZVNlbGY9ZmFsc2VdIC0gU2hvdWxkIHRoZSBlbGVtZW50IGJlaW5nIHBhc3NlZCBiZVxyXG4gICAgICAgKiBpbmNsdWRlZCBpbiB0aGUgc2Nyb2xsYWJsZSBsbG9rdXAuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZXR1cm5zIHtlbGVtZW50fSBBIEhUTUwgZWxlbWVudC5cclxuICAgICAgICovXHJcbiAgICAgIHNjcm9sbFBhcmVudDogZnVuY3Rpb24oZWxlbSwgaW5jbHVkZUhpZGRlbiwgaW5jbHVkZVNlbGYpIHtcclxuICAgICAgICBlbGVtID0gdGhpcy5nZXRSYXdOb2RlKGVsZW0pO1xyXG5cclxuICAgICAgICB2YXIgb3ZlcmZsb3dSZWdleCA9IGluY2x1ZGVIaWRkZW4gPyBPVkVSRkxPV19SRUdFWC5oaWRkZW4gOiBPVkVSRkxPV19SRUdFWC5ub3JtYWw7XHJcbiAgICAgICAgdmFyIGRvY3VtZW50RWwgPSAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgIHZhciBlbGVtU3R5bGUgPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSk7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVTZWxmICYmIG92ZXJmbG93UmVnZXgudGVzdChlbGVtU3R5bGUub3ZlcmZsb3cgKyBlbGVtU3R5bGUub3ZlcmZsb3dZICsgZWxlbVN0eWxlLm92ZXJmbG93WCkpIHtcclxuICAgICAgICAgIHJldHVybiBlbGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZXhjbHVkZVN0YXRpYyA9IGVsZW1TdHlsZS5wb3NpdGlvbiA9PT0gJ2Fic29sdXRlJztcclxuICAgICAgICB2YXIgc2Nyb2xsUGFyZW50ID0gZWxlbS5wYXJlbnRFbGVtZW50IHx8IGRvY3VtZW50RWw7XHJcblxyXG4gICAgICAgIGlmIChzY3JvbGxQYXJlbnQgPT09IGRvY3VtZW50RWwgfHwgZWxlbVN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XHJcbiAgICAgICAgICByZXR1cm4gZG9jdW1lbnRFbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlIChzY3JvbGxQYXJlbnQucGFyZW50RWxlbWVudCAmJiBzY3JvbGxQYXJlbnQgIT09IGRvY3VtZW50RWwpIHtcclxuICAgICAgICAgIHZhciBzcFN0eWxlID0gJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNjcm9sbFBhcmVudCk7XHJcbiAgICAgICAgICBpZiAoZXhjbHVkZVN0YXRpYyAmJiBzcFN0eWxlLnBvc2l0aW9uICE9PSAnc3RhdGljJykge1xyXG4gICAgICAgICAgICBleGNsdWRlU3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKCFleGNsdWRlU3RhdGljICYmIG92ZXJmbG93UmVnZXgudGVzdChzcFN0eWxlLm92ZXJmbG93ICsgc3BTdHlsZS5vdmVyZmxvd1kgKyBzcFN0eWxlLm92ZXJmbG93WCkpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzY3JvbGxQYXJlbnQgPSBzY3JvbGxQYXJlbnQucGFyZW50RWxlbWVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzY3JvbGxQYXJlbnQ7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUHJvdmlkZXMgcmVhZC1vbmx5IGVxdWl2YWxlbnQgb2YgalF1ZXJ5J3MgcG9zaXRpb24gZnVuY3Rpb246XHJcbiAgICAgICAqIGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9wb3NpdGlvbi8gLSBkaXN0YW5jZSB0byBjbG9zZXN0IHBvc2l0aW9uZWRcclxuICAgICAgICogYW5jZXN0b3IuICBEb2VzIG5vdCBhY2NvdW50IGZvciBtYXJnaW5zIGJ5IGRlZmF1bHQgbGlrZSBqUXVlcnkgcG9zaXRpb24uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbSAtIFRoZSBlbGVtZW50IHRvIGNhY2x1bGF0ZSB0aGUgcG9zaXRpb24gb24uXHJcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtpbmNsdWRlTWFyZ2lucz1mYWxzZV0gLSBTaG91bGQgbWFyZ2lucyBiZSBhY2NvdW50ZWRcclxuICAgICAgICogZm9yLCBkZWZhdWx0IGlzIGZhbHNlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgICAqICAgPHVsPlxyXG4gICAgICAgKiAgICAgPGxpPioqd2lkdGgqKjogdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50PC9saT5cclxuICAgICAgICogICAgIDxsaT4qKmhlaWdodCoqOiB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50PC9saT5cclxuICAgICAgICogICAgIDxsaT4qKnRvcCoqOiBkaXN0YW5jZSB0byB0b3AgZWRnZSBvZiBvZmZzZXQgcGFyZW50PC9saT5cclxuICAgICAgICogICAgIDxsaT4qKmxlZnQqKjogZGlzdGFuY2UgdG8gbGVmdCBlZGdlIG9mIG9mZnNldCBwYXJlbnQ8L2xpPlxyXG4gICAgICAgKiAgIDwvdWw+XHJcbiAgICAgICAqL1xyXG4gICAgICBwb3NpdGlvbjogZnVuY3Rpb24oZWxlbSwgaW5jbHVkZU1hZ2lucykge1xyXG4gICAgICAgIGVsZW0gPSB0aGlzLmdldFJhd05vZGUoZWxlbSk7XHJcblxyXG4gICAgICAgIHZhciBlbGVtT2Zmc2V0ID0gdGhpcy5vZmZzZXQoZWxlbSk7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVNYWdpbnMpIHtcclxuICAgICAgICAgIHZhciBlbGVtU3R5bGUgPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSk7XHJcbiAgICAgICAgICBlbGVtT2Zmc2V0LnRvcCAtPSB0aGlzLnBhcnNlU3R5bGUoZWxlbVN0eWxlLm1hcmdpblRvcCk7XHJcbiAgICAgICAgICBlbGVtT2Zmc2V0LmxlZnQgLT0gdGhpcy5wYXJzZVN0eWxlKGVsZW1TdHlsZS5tYXJnaW5MZWZ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KGVsZW0pO1xyXG4gICAgICAgIHZhciBwYXJlbnRPZmZzZXQgPSB7dG9wOiAwLCBsZWZ0OiAwfTtcclxuXHJcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgcGFyZW50T2Zmc2V0ID0gdGhpcy5vZmZzZXQocGFyZW50KTtcclxuICAgICAgICAgIHBhcmVudE9mZnNldC50b3AgKz0gcGFyZW50LmNsaWVudFRvcCAtIHBhcmVudC5zY3JvbGxUb3A7XHJcbiAgICAgICAgICBwYXJlbnRPZmZzZXQubGVmdCArPSBwYXJlbnQuY2xpZW50TGVmdCAtIHBhcmVudC5zY3JvbGxMZWZ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKGFuZ3VsYXIuaXNOdW1iZXIoZWxlbU9mZnNldC53aWR0aCkgPyBlbGVtT2Zmc2V0LndpZHRoIDogZWxlbS5vZmZzZXRXaWR0aCksXHJcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQoYW5ndWxhci5pc051bWJlcihlbGVtT2Zmc2V0LmhlaWdodCkgPyBlbGVtT2Zmc2V0LmhlaWdodCA6IGVsZW0ub2Zmc2V0SGVpZ2h0KSxcclxuICAgICAgICAgIHRvcDogTWF0aC5yb3VuZChlbGVtT2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3ApLFxyXG4gICAgICAgICAgbGVmdDogTWF0aC5yb3VuZChlbGVtT2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdClcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFByb3ZpZGVzIHJlYWQtb25seSBlcXVpdmFsZW50IG9mIGpRdWVyeSdzIG9mZnNldCBmdW5jdGlvbjpcclxuICAgICAgICogaHR0cDovL2FwaS5qcXVlcnkuY29tL29mZnNldC8gLSBkaXN0YW5jZSB0byB2aWV3cG9ydC4gIERvZXNcclxuICAgICAgICogbm90IGFjY291bnQgZm9yIGJvcmRlcnMsIG1hcmdpbnMsIG9yIHBhZGRpbmcgb24gdGhlIGJvZHlcclxuICAgICAgICogZWxlbWVudC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtIC0gVGhlIGVsZW1lbnQgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgb24uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAgICogICA8dWw+XHJcbiAgICAgICAqICAgICA8bGk+Kip3aWR0aCoqOiB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQ8L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPioqaGVpZ2h0Kio6IHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQ8L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPioqdG9wKio6IGRpc3RhbmNlIHRvIHRvcCBlZGdlIG9mIHZpZXdwb3J0PC9saT5cclxuICAgICAgICogICAgIDxsaT4qKnJpZ2h0Kio6IGRpc3RhbmNlIHRvIGJvdHRvbSBlZGdlIG9mIHZpZXdwb3J0PC9saT5cclxuICAgICAgICogICA8L3VsPlxyXG4gICAgICAgKi9cclxuICAgICAgb2Zmc2V0OiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgZWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZShlbGVtKTtcclxuXHJcbiAgICAgICAgdmFyIGVsZW1CQ1IgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChhbmd1bGFyLmlzTnVtYmVyKGVsZW1CQ1Iud2lkdGgpID8gZWxlbUJDUi53aWR0aCA6IGVsZW0ub2Zmc2V0V2lkdGgpLFxyXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGFuZ3VsYXIuaXNOdW1iZXIoZWxlbUJDUi5oZWlnaHQpID8gZWxlbUJDUi5oZWlnaHQgOiBlbGVtLm9mZnNldEhlaWdodCksXHJcbiAgICAgICAgICB0b3A6IE1hdGgucm91bmQoZWxlbUJDUi50b3AgKyAoJHdpbmRvdy5wYWdlWU9mZnNldCB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkpLFxyXG4gICAgICAgICAgbGVmdDogTWF0aC5yb3VuZChlbGVtQkNSLmxlZnQgKyAoJHdpbmRvdy5wYWdlWE9mZnNldCB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQpKVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUHJvdmlkZXMgb2Zmc2V0IGRpc3RhbmNlIHRvIHRoZSBjbG9zZXN0IHNjcm9sbGFibGUgYW5jZXN0b3JcclxuICAgICAgICogb3Igdmlld3BvcnQuICBBY2NvdW50cyBmb3IgYm9yZGVyIGFuZCBzY3JvbGxiYXIgd2lkdGguXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFJpZ2h0IGFuZCBib3R0b20gZGltZW5zaW9ucyByZXByZXNlbnQgdGhlIGRpc3RhbmNlIHRvIHRoZVxyXG4gICAgICAgKiByZXNwZWN0aXZlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IGVsZW1lbnQuICBJZiB0aGUgZWxlbWVudFxyXG4gICAgICAgKiBlZGdlIGV4dGVuZHMgYmV5b25kIHRoZSB2aWV3cG9ydCwgYSBuZWdhdGl2ZSB2YWx1ZSB3aWxsIGJlXHJcbiAgICAgICAqIHJlcG9ydGVkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW0gLSBUaGUgZWxlbWVudCB0byBnZXQgdGhlIHZpZXdwb3J0IG9mZnNldCBmb3IuXHJcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IFt1c2VEb2N1bWVudD1mYWxzZV0gLSBTaG91bGQgdGhlIHZpZXdwb3J0IGJlIHRoZSBkb2N1bWVudCBlbGVtZW50IGluc3RlYWRcclxuICAgICAgICogb2YgdGhlIGZpcnN0IHNjcm9sbGFibGUgZWxlbWVudCwgZGVmYXVsdCBpcyBmYWxzZS5cclxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gW2luY2x1ZGVQYWRkaW5nPXRydWVdIC0gU2hvdWxkIHRoZSBwYWRkaW5nIG9uIHRoZSBvZmZzZXQgcGFyZW50IGVsZW1lbnRcclxuICAgICAgICogYmUgYWNjb3VudGVkIGZvciwgZGVmYXVsdCBpcyB0cnVlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgICAqICAgPHVsPlxyXG4gICAgICAgKiAgICAgPGxpPioqdG9wKio6IGRpc3RhbmNlIHRvIHRoZSB0b3AgY29udGVudCBlZGdlIG9mIHZpZXdwb3J0IGVsZW1lbnQ8L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPioqYm90dG9tKio6IGRpc3RhbmNlIHRvIHRoZSBib3R0b20gY29udGVudCBlZGdlIG9mIHZpZXdwb3J0IGVsZW1lbnQ8L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPioqbGVmdCoqOiBkaXN0YW5jZSB0byB0aGUgbGVmdCBjb250ZW50IGVkZ2Ugb2Ygdmlld3BvcnQgZWxlbWVudDwvbGk+XHJcbiAgICAgICAqICAgICA8bGk+KipyaWdodCoqOiBkaXN0YW5jZSB0byB0aGUgcmlnaHQgY29udGVudCBlZGdlIG9mIHZpZXdwb3J0IGVsZW1lbnQ8L2xpPlxyXG4gICAgICAgKiAgIDwvdWw+XHJcbiAgICAgICAqL1xyXG4gICAgICB2aWV3cG9ydE9mZnNldDogZnVuY3Rpb24oZWxlbSwgdXNlRG9jdW1lbnQsIGluY2x1ZGVQYWRkaW5nKSB7XHJcbiAgICAgICAgZWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZShlbGVtKTtcclxuICAgICAgICBpbmNsdWRlUGFkZGluZyA9IGluY2x1ZGVQYWRkaW5nICE9PSBmYWxzZSA/IHRydWUgOiBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIGVsZW1CQ1IgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHZhciBvZmZzZXRCQ1IgPSB7dG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IDAsIHJpZ2h0OiAwfTtcclxuXHJcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IHVzZURvY3VtZW50ID8gJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudCA6IHRoaXMuc2Nyb2xsUGFyZW50KGVsZW0pO1xyXG4gICAgICAgIHZhciBvZmZzZXRQYXJlbnRCQ1IgPSBvZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgICAgIG9mZnNldEJDUi50b3AgPSBvZmZzZXRQYXJlbnRCQ1IudG9wICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcclxuICAgICAgICBvZmZzZXRCQ1IubGVmdCA9IG9mZnNldFBhcmVudEJDUi5sZWZ0ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XHJcbiAgICAgICAgaWYgKG9mZnNldFBhcmVudCA9PT0gJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgb2Zmc2V0QkNSLnRvcCArPSAkd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG4gICAgICAgICAgb2Zmc2V0QkNSLmxlZnQgKz0gJHdpbmRvdy5wYWdlWE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0QkNSLmJvdHRvbSA9IG9mZnNldEJDUi50b3AgKyBvZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIG9mZnNldEJDUi5yaWdodCA9IG9mZnNldEJDUi5sZWZ0ICsgb2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoO1xyXG5cclxuICAgICAgICBpZiAoaW5jbHVkZVBhZGRpbmcpIHtcclxuICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnRTdHlsZSA9ICR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpO1xyXG4gICAgICAgICAgb2Zmc2V0QkNSLnRvcCArPSB0aGlzLnBhcnNlU3R5bGUob2Zmc2V0UGFyZW50U3R5bGUucGFkZGluZ1RvcCk7XHJcbiAgICAgICAgICBvZmZzZXRCQ1IuYm90dG9tIC09IHRoaXMucGFyc2VTdHlsZShvZmZzZXRQYXJlbnRTdHlsZS5wYWRkaW5nQm90dG9tKTtcclxuICAgICAgICAgIG9mZnNldEJDUi5sZWZ0ICs9IHRoaXMucGFyc2VTdHlsZShvZmZzZXRQYXJlbnRTdHlsZS5wYWRkaW5nTGVmdCk7XHJcbiAgICAgICAgICBvZmZzZXRCQ1IucmlnaHQgLT0gdGhpcy5wYXJzZVN0eWxlKG9mZnNldFBhcmVudFN0eWxlLnBhZGRpbmdSaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdG9wOiBNYXRoLnJvdW5kKGVsZW1CQ1IudG9wIC0gb2Zmc2V0QkNSLnRvcCksXHJcbiAgICAgICAgICBib3R0b206IE1hdGgucm91bmQob2Zmc2V0QkNSLmJvdHRvbSAtIGVsZW1CQ1IuYm90dG9tKSxcclxuICAgICAgICAgIGxlZnQ6IE1hdGgucm91bmQoZWxlbUJDUi5sZWZ0IC0gb2Zmc2V0QkNSLmxlZnQpLFxyXG4gICAgICAgICAgcmlnaHQ6IE1hdGgucm91bmQob2Zmc2V0QkNSLnJpZ2h0IC0gZWxlbUJDUi5yaWdodClcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFByb3ZpZGVzIGFuIGFycmF5IG9mIHBsYWNlbWVudCB2YWx1ZXMgcGFyc2VkIGZyb20gYSBwbGFjZW1lbnQgc3RyaW5nLlxyXG4gICAgICAgKiBBbG9uZyB3aXRoIHRoZSAnYXV0bycgaW5kaWNhdG9yLCBzdXBwb3J0ZWQgcGxhY2VtZW50IHN0cmluZ3MgYXJlOlxyXG4gICAgICAgKiAgIDx1bD5cclxuICAgICAgICogICAgIDxsaT50b3A6IGVsZW1lbnQgb24gdG9wLCBob3Jpem9udGFsbHkgY2VudGVyZWQgb24gaG9zdCBlbGVtZW50LjwvbGk+XHJcbiAgICAgICAqICAgICA8bGk+dG9wLWxlZnQ6IGVsZW1lbnQgb24gdG9wLCBsZWZ0IGVkZ2UgYWxpZ25lZCB3aXRoIGhvc3QgZWxlbWVudCBsZWZ0IGVkZ2UuPC9saT5cclxuICAgICAgICogICAgIDxsaT50b3AtcmlnaHQ6IGVsZW1lbnQgb24gdG9wLCBsZXJpZ2h0ZnQgZWRnZSBhbGlnbmVkIHdpdGggaG9zdCBlbGVtZW50IHJpZ2h0IGVkZ2UuPC9saT5cclxuICAgICAgICogICAgIDxsaT5ib3R0b206IGVsZW1lbnQgb24gYm90dG9tLCBob3Jpem9udGFsbHkgY2VudGVyZWQgb24gaG9zdCBlbGVtZW50LjwvbGk+XHJcbiAgICAgICAqICAgICA8bGk+Ym90dG9tLWxlZnQ6IGVsZW1lbnQgb24gYm90dG9tLCBsZWZ0IGVkZ2UgYWxpZ25lZCB3aXRoIGhvc3QgZWxlbWVudCBsZWZ0IGVkZ2UuPC9saT5cclxuICAgICAgICogICAgIDxsaT5ib3R0b20tcmlnaHQ6IGVsZW1lbnQgb24gYm90dG9tLCByaWdodCBlZGdlIGFsaWduZWQgd2l0aCBob3N0IGVsZW1lbnQgcmlnaHQgZWRnZS48L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPmxlZnQ6IGVsZW1lbnQgb24gbGVmdCwgdmVydGljYWxseSBjZW50ZXJlZCBvbiBob3N0IGVsZW1lbnQuPC9saT5cclxuICAgICAgICogICAgIDxsaT5sZWZ0LXRvcDogZWxlbWVudCBvbiBsZWZ0LCB0b3AgZWRnZSBhbGlnbmVkIHdpdGggaG9zdCBlbGVtZW50IHRvcCBlZGdlLjwvbGk+XHJcbiAgICAgICAqICAgICA8bGk+bGVmdC1ib3R0b206IGVsZW1lbnQgb24gbGVmdCwgYm90dG9tIGVkZ2UgYWxpZ25lZCB3aXRoIGhvc3QgZWxlbWVudCBib3R0b20gZWRnZS48L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPnJpZ2h0OiBlbGVtZW50IG9uIHJpZ2h0LCB2ZXJ0aWNhbGx5IGNlbnRlcmVkIG9uIGhvc3QgZWxlbWVudC48L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPnJpZ2h0LXRvcDogZWxlbWVudCBvbiByaWdodCwgdG9wIGVkZ2UgYWxpZ25lZCB3aXRoIGhvc3QgZWxlbWVudCB0b3AgZWRnZS48L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPnJpZ2h0LWJvdHRvbTogZWxlbWVudCBvbiByaWdodCwgYm90dG9tIGVkZ2UgYWxpZ25lZCB3aXRoIGhvc3QgZWxlbWVudCBib3R0b20gZWRnZS48L2xpPlxyXG4gICAgICAgKiAgIDwvdWw+XHJcbiAgICAgICAqIEEgcGxhY2VtZW50IHN0cmluZyB3aXRoIGFuICdhdXRvJyBpbmRpY2F0b3IgaXMgZXhwZWN0ZWQgdG8gYmVcclxuICAgICAgICogc3BhY2Ugc2VwYXJhdGVkIGZyb20gdGhlIHBsYWNlbWVudCwgaS5lOiAnYXV0byBib3R0b20tbGVmdCcgIElmXHJcbiAgICAgICAqIHRoZSBwcmltYXJ5IGFuZCBzZWNvbmRhcnkgcGxhY2VtZW50IHZhbHVlcyBkbyBub3QgbWF0Y2ggJ3RvcCxcclxuICAgICAgICogYm90dG9tLCBsZWZ0LCByaWdodCcgdGhlbiAndG9wJyB3aWxsIGJlIHRoZSBwcmltYXJ5IHBsYWNlbWVudCBhbmRcclxuICAgICAgICogJ2NlbnRlcicgd2lsbCBiZSB0aGUgc2Vjb25kYXJ5IHBsYWNlbWVudC4gIElmICdhdXRvJyBpcyBwYXNzZWQsIHRydWVcclxuICAgICAgICogd2lsbCBiZSByZXR1cm5lZCBhcyB0aGUgM3JkIHZhbHVlIG9mIHRoZSBhcnJheS5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBsYWNlbWVudCAtIFRoZSBwbGFjZW1lbnQgc3RyaW5nIHRvIHBhcnNlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IHdpdGggdGhlIGZvbGxvd2luZyB2YWx1ZXNcclxuICAgICAgICogPHVsPlxyXG4gICAgICAgKiAgIDxsaT4qKlswXSoqOiBUaGUgcHJpbWFyeSBwbGFjZW1lbnQuPC9saT5cclxuICAgICAgICogICA8bGk+KipbMV0qKjogVGhlIHNlY29uZGFyeSBwbGFjZW1lbnQuPC9saT5cclxuICAgICAgICogICA8bGk+KipbMl0qKjogSWYgYXV0byBpcyBwYXNzZWQ6IHRydWUsIGVsc2UgdW5kZWZpbmVkLjwvbGk+XHJcbiAgICAgICAqIDwvdWw+XHJcbiAgICAgICAqL1xyXG4gICAgICBwYXJzZVBsYWNlbWVudDogZnVuY3Rpb24ocGxhY2VtZW50KSB7XHJcbiAgICAgICAgdmFyIGF1dG9QbGFjZSA9IFBMQUNFTUVOVF9SRUdFWC5hdXRvLnRlc3QocGxhY2VtZW50KTtcclxuICAgICAgICBpZiAoYXV0b1BsYWNlKSB7XHJcbiAgICAgICAgICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQucmVwbGFjZShQTEFDRU1FTlRfUkVHRVguYXV0bywgJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJyk7XHJcblxyXG4gICAgICAgIHBsYWNlbWVudFswXSA9IHBsYWNlbWVudFswXSB8fCAndG9wJztcclxuICAgICAgICBpZiAoIVBMQUNFTUVOVF9SRUdFWC5wcmltYXJ5LnRlc3QocGxhY2VtZW50WzBdKSkge1xyXG4gICAgICAgICAgcGxhY2VtZW50WzBdID0gJ3RvcCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwbGFjZW1lbnRbMV0gPSBwbGFjZW1lbnRbMV0gfHwgJ2NlbnRlcic7XHJcbiAgICAgICAgaWYgKCFQTEFDRU1FTlRfUkVHRVguc2Vjb25kYXJ5LnRlc3QocGxhY2VtZW50WzFdKSkge1xyXG4gICAgICAgICAgcGxhY2VtZW50WzFdID0gJ2NlbnRlcic7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXV0b1BsYWNlKSB7XHJcbiAgICAgICAgICBwbGFjZW1lbnRbMl0gPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwbGFjZW1lbnRbMl0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwbGFjZW1lbnQ7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUHJvdmlkZXMgY29vcmRpbmF0ZXMgZm9yIGFuIGVsZW1lbnQgdG8gYmUgcG9zaXRpb25lZCByZWxhdGl2ZSB0b1xyXG4gICAgICAgKiBhbm90aGVyIGVsZW1lbnQuICBQYXNzaW5nICdhdXRvJyBhcyBwYXJ0IG9mIHRoZSBwbGFjZW1lbnQgcGFyYW1ldGVyXHJcbiAgICAgICAqIHdpbGwgZW5hYmxlIHNtYXJ0IHBsYWNlbWVudCAtIHdoZXJlIHRoZSBlbGVtZW50IGZpdHMuIGkuZTpcclxuICAgICAgICogJ2F1dG8gbGVmdC10b3AnIHdpbGwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZSB0byB0aGUgbGVmdFxyXG4gICAgICAgKiBvZiB0aGUgaG9zdEVsZW0gdG8gZml0IHRoZSB0YXJnZXRFbGVtLCBpZiBub3QgcGxhY2UgcmlnaHQgKHNhbWUgZm9yIHNlY29uZGFyeVxyXG4gICAgICAgKiB0b3AgcGxhY2VtZW50KS4gIEF2YWlsYWJsZSBzcGFjZSBpcyBjYWxjdWxhdGVkIHVzaW5nIHRoZSB2aWV3cG9ydE9mZnNldFxyXG4gICAgICAgKiBmdW5jdGlvbi5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtlbGVtZW50fSBob3N0RWxlbSAtIFRoZSBlbGVtZW50IHRvIHBvc2l0aW9uIGFnYWluc3QuXHJcbiAgICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gdGFyZ2V0RWxlbSAtIFRoZSBlbGVtZW50IHRvIHBvc2l0aW9uLlxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IFtwbGFjZW1lbnQ9dG9wXSAtIFRoZSBwbGFjZW1lbnQgZm9yIHRoZSB0YXJnZXRFbGVtLFxyXG4gICAgICAgKiAgIGRlZmF1bHQgaXMgJ3RvcCcuICdjZW50ZXInIGlzIGFzc3VtZWQgYXMgc2Vjb25kYXJ5IHBsYWNlbWVudCBmb3JcclxuICAgICAgICogICAndG9wJywgJ2xlZnQnLCAncmlnaHQnLCBhbmQgJ2JvdHRvbScgcGxhY2VtZW50cy4gIEF2YWlsYWJsZSBwbGFjZW1lbnRzIGFyZTpcclxuICAgICAgICogICA8dWw+XHJcbiAgICAgICAqICAgICA8bGk+dG9wPC9saT5cclxuICAgICAgICogICAgIDxsaT50b3AtcmlnaHQ8L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPnRvcC1sZWZ0PC9saT5cclxuICAgICAgICogICAgIDxsaT5ib3R0b208L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPmJvdHRvbS1sZWZ0PC9saT5cclxuICAgICAgICogICAgIDxsaT5ib3R0b20tcmlnaHQ8L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPmxlZnQ8L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPmxlZnQtdG9wPC9saT5cclxuICAgICAgICogICAgIDxsaT5sZWZ0LWJvdHRvbTwvbGk+XHJcbiAgICAgICAqICAgICA8bGk+cmlnaHQ8L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPnJpZ2h0LXRvcDwvbGk+XHJcbiAgICAgICAqICAgICA8bGk+cmlnaHQtYm90dG9tPC9saT5cclxuICAgICAgICogICA8L3VsPlxyXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbYXBwZW5kVG9Cb2R5PWZhbHNlXSAtIFNob3VsZCB0aGUgdG9wIGFuZCBsZWZ0IHZhbHVlcyByZXR1cm5lZFxyXG4gICAgICAgKiAgIGJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgYm9keSBlbGVtZW50LCBkZWZhdWx0IGlzIGZhbHNlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgICAqICAgPHVsPlxyXG4gICAgICAgKiAgICAgPGxpPioqdG9wKio6IFZhbHVlIGZvciB0YXJnZXRFbGVtIHRvcC48L2xpPlxyXG4gICAgICAgKiAgICAgPGxpPioqbGVmdCoqOiBWYWx1ZSBmb3IgdGFyZ2V0RWxlbSBsZWZ0LjwvbGk+XHJcbiAgICAgICAqICAgICA8bGk+KipwbGFjZW1lbnQqKjogVGhlIHJlc29sdmVkIHBsYWNlbWVudC48L2xpPlxyXG4gICAgICAgKiAgIDwvdWw+XHJcbiAgICAgICAqL1xyXG4gICAgICBwb3NpdGlvbkVsZW1lbnRzOiBmdW5jdGlvbihob3N0RWxlbSwgdGFyZ2V0RWxlbSwgcGxhY2VtZW50LCBhcHBlbmRUb0JvZHkpIHtcclxuICAgICAgICBob3N0RWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZShob3N0RWxlbSk7XHJcbiAgICAgICAgdGFyZ2V0RWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZSh0YXJnZXRFbGVtKTtcclxuXHJcbiAgICAgICAgLy8gbmVlZCB0byByZWFkIGZyb20gcHJvcCB0byBzdXBwb3J0IHRlc3RzLlxyXG4gICAgICAgIHZhciB0YXJnZXRXaWR0aCA9IGFuZ3VsYXIuaXNEZWZpbmVkKHRhcmdldEVsZW0ub2Zmc2V0V2lkdGgpID8gdGFyZ2V0RWxlbS5vZmZzZXRXaWR0aCA6IHRhcmdldEVsZW0ucHJvcCgnb2Zmc2V0V2lkdGgnKTtcclxuICAgICAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gYW5ndWxhci5pc0RlZmluZWQodGFyZ2V0RWxlbS5vZmZzZXRIZWlnaHQpID8gdGFyZ2V0RWxlbS5vZmZzZXRIZWlnaHQgOiB0YXJnZXRFbGVtLnByb3AoJ29mZnNldEhlaWdodCcpO1xyXG5cclxuICAgICAgICBwbGFjZW1lbnQgPSB0aGlzLnBhcnNlUGxhY2VtZW50KHBsYWNlbWVudCk7XHJcblxyXG4gICAgICAgIHZhciBob3N0RWxlbVBvcyA9IGFwcGVuZFRvQm9keSA/IHRoaXMub2Zmc2V0KGhvc3RFbGVtKSA6IHRoaXMucG9zaXRpb24oaG9zdEVsZW0pO1xyXG4gICAgICAgIHZhciB0YXJnZXRFbGVtUG9zID0ge3RvcDogMCwgbGVmdDogMCwgcGxhY2VtZW50OiAnJ307XHJcblxyXG4gICAgICAgIGlmIChwbGFjZW1lbnRbMl0pIHtcclxuICAgICAgICAgIHZhciB2aWV3cG9ydE9mZnNldCA9IHRoaXMudmlld3BvcnRPZmZzZXQoaG9zdEVsZW0sIGFwcGVuZFRvQm9keSk7XHJcblxyXG4gICAgICAgICAgdmFyIHRhcmdldEVsZW1TdHlsZSA9ICR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXRFbGVtKTtcclxuICAgICAgICAgIHZhciBhZGp1c3RlZFNpemUgPSB7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0YXJnZXRXaWR0aCArIE1hdGgucm91bmQoTWF0aC5hYnModGhpcy5wYXJzZVN0eWxlKHRhcmdldEVsZW1TdHlsZS5tYXJnaW5MZWZ0KSArIHRoaXMucGFyc2VTdHlsZSh0YXJnZXRFbGVtU3R5bGUubWFyZ2luUmlnaHQpKSksXHJcbiAgICAgICAgICAgIGhlaWdodDogdGFyZ2V0SGVpZ2h0ICsgTWF0aC5yb3VuZChNYXRoLmFicyh0aGlzLnBhcnNlU3R5bGUodGFyZ2V0RWxlbVN0eWxlLm1hcmdpblRvcCkgKyB0aGlzLnBhcnNlU3R5bGUodGFyZ2V0RWxlbVN0eWxlLm1hcmdpbkJvdHRvbSkpKVxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBwbGFjZW1lbnRbMF0gPSBwbGFjZW1lbnRbMF0gPT09ICd0b3AnICYmIGFkanVzdGVkU2l6ZS5oZWlnaHQgPiB2aWV3cG9ydE9mZnNldC50b3AgJiYgYWRqdXN0ZWRTaXplLmhlaWdodCA8PSB2aWV3cG9ydE9mZnNldC5ib3R0b20gPyAnYm90dG9tJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMF0gPT09ICdib3R0b20nICYmIGFkanVzdGVkU2l6ZS5oZWlnaHQgPiB2aWV3cG9ydE9mZnNldC5ib3R0b20gJiYgYWRqdXN0ZWRTaXplLmhlaWdodCA8PSB2aWV3cG9ydE9mZnNldC50b3AgPyAndG9wJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMF0gPT09ICdsZWZ0JyAmJiBhZGp1c3RlZFNpemUud2lkdGggPiB2aWV3cG9ydE9mZnNldC5sZWZ0ICYmIGFkanVzdGVkU2l6ZS53aWR0aCA8PSB2aWV3cG9ydE9mZnNldC5yaWdodCA/ICdyaWdodCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50WzBdID09PSAncmlnaHQnICYmIGFkanVzdGVkU2l6ZS53aWR0aCA+IHZpZXdwb3J0T2Zmc2V0LnJpZ2h0ICYmIGFkanVzdGVkU2l6ZS53aWR0aCA8PSB2aWV3cG9ydE9mZnNldC5sZWZ0ID8gJ2xlZnQnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudFswXTtcclxuXHJcbiAgICAgICAgICBwbGFjZW1lbnRbMV0gPSBwbGFjZW1lbnRbMV0gPT09ICd0b3AnICYmIGFkanVzdGVkU2l6ZS5oZWlnaHQgLSBob3N0RWxlbVBvcy5oZWlnaHQgPiB2aWV3cG9ydE9mZnNldC5ib3R0b20gJiYgYWRqdXN0ZWRTaXplLmhlaWdodCAtIGhvc3RFbGVtUG9zLmhlaWdodCA8PSB2aWV3cG9ydE9mZnNldC50b3AgPyAnYm90dG9tJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMV0gPT09ICdib3R0b20nICYmIGFkanVzdGVkU2l6ZS5oZWlnaHQgLSBob3N0RWxlbVBvcy5oZWlnaHQgPiB2aWV3cG9ydE9mZnNldC50b3AgJiYgYWRqdXN0ZWRTaXplLmhlaWdodCAtIGhvc3RFbGVtUG9zLmhlaWdodCA8PSB2aWV3cG9ydE9mZnNldC5ib3R0b20gPyAndG9wJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMV0gPT09ICdsZWZ0JyAmJiBhZGp1c3RlZFNpemUud2lkdGggLSBob3N0RWxlbVBvcy53aWR0aCA+IHZpZXdwb3J0T2Zmc2V0LnJpZ2h0ICYmIGFkanVzdGVkU2l6ZS53aWR0aCAtIGhvc3RFbGVtUG9zLndpZHRoIDw9IHZpZXdwb3J0T2Zmc2V0LmxlZnQgPyAncmlnaHQnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudFsxXSA9PT0gJ3JpZ2h0JyAmJiBhZGp1c3RlZFNpemUud2lkdGggLSBob3N0RWxlbVBvcy53aWR0aCA+IHZpZXdwb3J0T2Zmc2V0LmxlZnQgJiYgYWRqdXN0ZWRTaXplLndpZHRoIC0gaG9zdEVsZW1Qb3Mud2lkdGggPD0gdmlld3BvcnRPZmZzZXQucmlnaHQgPyAnbGVmdCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50WzFdO1xyXG5cclxuICAgICAgICAgIGlmIChwbGFjZW1lbnRbMV0gPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICAgIGlmIChQTEFDRU1FTlRfUkVHRVgudmVydGljYWwudGVzdChwbGFjZW1lbnRbMF0pKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHhPdmVyZmxvdyA9IGhvc3RFbGVtUG9zLndpZHRoIC8gMiAtIHRhcmdldFdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICBpZiAodmlld3BvcnRPZmZzZXQubGVmdCArIHhPdmVyZmxvdyA8IDAgJiYgYWRqdXN0ZWRTaXplLndpZHRoIC0gaG9zdEVsZW1Qb3Mud2lkdGggPD0gdmlld3BvcnRPZmZzZXQucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudFsxXSA9ICdsZWZ0JztcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpZXdwb3J0T2Zmc2V0LnJpZ2h0ICsgeE92ZXJmbG93IDwgMCAmJiBhZGp1c3RlZFNpemUud2lkdGggLSBob3N0RWxlbVBvcy53aWR0aCA8PSB2aWV3cG9ydE9mZnNldC5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMV0gPSAncmlnaHQnO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB2YXIgeU92ZXJmbG93ID0gaG9zdEVsZW1Qb3MuaGVpZ2h0IC8gMiAtIGFkanVzdGVkU2l6ZS5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgIGlmICh2aWV3cG9ydE9mZnNldC50b3AgKyB5T3ZlcmZsb3cgPCAwICYmIGFkanVzdGVkU2l6ZS5oZWlnaHQgLSBob3N0RWxlbVBvcy5oZWlnaHQgPD0gdmlld3BvcnRPZmZzZXQuYm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMV0gPSAndG9wJztcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpZXdwb3J0T2Zmc2V0LmJvdHRvbSArIHlPdmVyZmxvdyA8IDAgJiYgYWRqdXN0ZWRTaXplLmhlaWdodCAtIGhvc3RFbGVtUG9zLmhlaWdodCA8PSB2aWV3cG9ydE9mZnNldC50b3ApIHtcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudFsxXSA9ICdib3R0b20nO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3dpdGNoIChwbGFjZW1lbnRbMF0pIHtcclxuICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgIHRhcmdldEVsZW1Qb3MudG9wID0gaG9zdEVsZW1Qb3MudG9wIC0gdGFyZ2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgIHRhcmdldEVsZW1Qb3MudG9wID0gaG9zdEVsZW1Qb3MudG9wICsgaG9zdEVsZW1Qb3MuaGVpZ2h0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICB0YXJnZXRFbGVtUG9zLmxlZnQgPSBob3N0RWxlbVBvcy5sZWZ0IC0gdGFyZ2V0V2lkdGg7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICB0YXJnZXRFbGVtUG9zLmxlZnQgPSBob3N0RWxlbVBvcy5sZWZ0ICsgaG9zdEVsZW1Qb3Mud2lkdGg7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3dpdGNoIChwbGFjZW1lbnRbMV0pIHtcclxuICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgIHRhcmdldEVsZW1Qb3MudG9wID0gaG9zdEVsZW1Qb3MudG9wO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgIHRhcmdldEVsZW1Qb3MudG9wID0gaG9zdEVsZW1Qb3MudG9wICsgaG9zdEVsZW1Qb3MuaGVpZ2h0IC0gdGFyZ2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICB0YXJnZXRFbGVtUG9zLmxlZnQgPSBob3N0RWxlbVBvcy5sZWZ0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgdGFyZ2V0RWxlbVBvcy5sZWZ0ID0gaG9zdEVsZW1Qb3MubGVmdCArIGhvc3RFbGVtUG9zLndpZHRoIC0gdGFyZ2V0V2lkdGg7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcclxuICAgICAgICAgICAgaWYgKFBMQUNFTUVOVF9SRUdFWC52ZXJ0aWNhbC50ZXN0KHBsYWNlbWVudFswXSkpIHtcclxuICAgICAgICAgICAgICB0YXJnZXRFbGVtUG9zLmxlZnQgPSBob3N0RWxlbVBvcy5sZWZ0ICsgaG9zdEVsZW1Qb3Mud2lkdGggLyAyIC0gdGFyZ2V0V2lkdGggLyAyO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRhcmdldEVsZW1Qb3MudG9wID0gaG9zdEVsZW1Qb3MudG9wICsgaG9zdEVsZW1Qb3MuaGVpZ2h0IC8gMiAtIHRhcmdldEhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0YXJnZXRFbGVtUG9zLnRvcCA9IE1hdGgucm91bmQodGFyZ2V0RWxlbVBvcy50b3ApO1xyXG4gICAgICAgIHRhcmdldEVsZW1Qb3MubGVmdCA9IE1hdGgucm91bmQodGFyZ2V0RWxlbVBvcy5sZWZ0KTtcclxuICAgICAgICB0YXJnZXRFbGVtUG9zLnBsYWNlbWVudCA9IHBsYWNlbWVudFsxXSA9PT0gJ2NlbnRlcicgPyBwbGFjZW1lbnRbMF0gOiBwbGFjZW1lbnRbMF0gKyAnLScgKyBwbGFjZW1lbnRbMV07XHJcblxyXG4gICAgICAgIHJldHVybiB0YXJnZXRFbGVtUG9zO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFByb3ZpZGVzIGEgd2F5IHRvIGFkanVzdCB0aGUgdG9wIHBvc2l0aW9uaW5nIGFmdGVyIGZpcnN0XHJcbiAgICAgICAqIHJlbmRlciB0byBjb3JyZWN0bHkgYWxpZ24gZWxlbWVudCB0byB0b3AgYWZ0ZXIgY29udGVudFxyXG4gICAgICAgKiByZW5kZXJpbmcgY2F1c2VzIHJlc2l6ZWQgZWxlbWVudCBoZWlnaHRcclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHthcnJheX0gcGxhY2VtZW50Q2xhc3NlcyAtIFRoZSBhcnJheSBvZiBzdHJpbmdzIG9mIGNsYXNzZXNcclxuICAgICAgICogZWxlbWVudCBzaG91bGQgaGF2ZS5cclxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRhaW5lclBvc2l0aW9uIC0gVGhlIG9iamVjdCB3aXRoIGNvbnRhaW5lclxyXG4gICAgICAgKiBwb3NpdGlvbiBpbmZvcm1hdGlvblxyXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5pdGlhbEhlaWdodCAtIFRoZSBpbml0aWFsIGhlaWdodCBmb3IgdGhlIGVsZW0uXHJcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50SGVpZ2h0IC0gVGhlIGN1cnJlbnQgaGVpZ2h0IGZvciB0aGUgZWxlbS5cclxuICAgICAgICovXHJcbiAgICAgIGFkanVzdFRvcDogZnVuY3Rpb24ocGxhY2VtZW50Q2xhc3NlcywgY29udGFpbmVyUG9zaXRpb24sIGluaXRpYWxIZWlnaHQsIGN1cnJlbnRIZWlnaHQpIHtcclxuICAgICAgICBpZiAocGxhY2VtZW50Q2xhc3Nlcy5pbmRleE9mKCd0b3AnKSAhPT0gLTEgJiYgaW5pdGlhbEhlaWdodCAhPT0gY3VycmVudEhlaWdodCkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdG9wOiBjb250YWluZXJQb3NpdGlvbi50b3AgLSBjdXJyZW50SGVpZ2h0ICsgJ3B4J1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUHJvdmlkZXMgYSB3YXkgZm9yIHBvc2l0aW9uaW5nIHRvb2x0aXAgJiBkcm9wZG93blxyXG4gICAgICAgKiBhcnJvd3Mgd2hlbiB1c2luZyBwbGFjZW1lbnQgb3B0aW9ucyBiZXlvbmQgdGhlIHN0YW5kYXJkXHJcbiAgICAgICAqIGxlZnQsIHJpZ2h0LCB0b3AsIG9yIGJvdHRvbS5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtIC0gVGhlIHRvb2x0aXAvZHJvcGRvd24gZWxlbWVudC5cclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBsYWNlbWVudCAtIFRoZSBwbGFjZW1lbnQgZm9yIHRoZSBlbGVtLlxyXG4gICAgICAgKi9cclxuICAgICAgcG9zaXRpb25BcnJvdzogZnVuY3Rpb24oZWxlbSwgcGxhY2VtZW50KSB7XHJcbiAgICAgICAgZWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZShlbGVtKTtcclxuXHJcbiAgICAgICAgdmFyIGlubmVyRWxlbSA9IGVsZW0ucXVlcnlTZWxlY3RvcignLnRvb2x0aXAtaW5uZXIsIC5wb3BvdmVyLWlubmVyJyk7XHJcbiAgICAgICAgaWYgKCFpbm5lckVsZW0pIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpc1Rvb2x0aXAgPSBhbmd1bGFyLmVsZW1lbnQoaW5uZXJFbGVtKS5oYXNDbGFzcygndG9vbHRpcC1pbm5lcicpO1xyXG5cclxuICAgICAgICB2YXIgYXJyb3dFbGVtID0gaXNUb29sdGlwID8gZWxlbS5xdWVyeVNlbGVjdG9yKCcudG9vbHRpcC1hcnJvdycpIDogZWxlbS5xdWVyeVNlbGVjdG9yKCcuYXJyb3cnKTtcclxuICAgICAgICBpZiAoIWFycm93RWxlbSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGFycm93Q3NzID0ge1xyXG4gICAgICAgICAgdG9wOiAnJyxcclxuICAgICAgICAgIGJvdHRvbTogJycsXHJcbiAgICAgICAgICBsZWZ0OiAnJyxcclxuICAgICAgICAgIHJpZ2h0OiAnJ1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBsYWNlbWVudCA9IHRoaXMucGFyc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcclxuICAgICAgICBpZiAocGxhY2VtZW50WzFdID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgLy8gbm8gYWRqdXN0bWVudCBuZWNlc3NhcnkgLSBqdXN0IHJlc2V0IHN0eWxlc1xyXG4gICAgICAgICAgYW5ndWxhci5lbGVtZW50KGFycm93RWxlbSkuY3NzKGFycm93Q3NzKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBib3JkZXJQcm9wID0gJ2JvcmRlci0nICsgcGxhY2VtZW50WzBdICsgJy13aWR0aCc7XHJcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGFycm93RWxlbSlbYm9yZGVyUHJvcF07XHJcblxyXG4gICAgICAgIHZhciBib3JkZXJSYWRpdXNQcm9wID0gJ2JvcmRlci0nO1xyXG4gICAgICAgIGlmIChQTEFDRU1FTlRfUkVHRVgudmVydGljYWwudGVzdChwbGFjZW1lbnRbMF0pKSB7XHJcbiAgICAgICAgICBib3JkZXJSYWRpdXNQcm9wICs9IHBsYWNlbWVudFswXSArICctJyArIHBsYWNlbWVudFsxXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYm9yZGVyUmFkaXVzUHJvcCArPSBwbGFjZW1lbnRbMV0gKyAnLScgKyBwbGFjZW1lbnRbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJvcmRlclJhZGl1c1Byb3AgKz0gJy1yYWRpdXMnO1xyXG4gICAgICAgIHZhciBib3JkZXJSYWRpdXMgPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoaXNUb29sdGlwID8gaW5uZXJFbGVtIDogZWxlbSlbYm9yZGVyUmFkaXVzUHJvcF07XHJcblxyXG4gICAgICAgIHN3aXRjaCAocGxhY2VtZW50WzBdKSB7XHJcbiAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICBhcnJvd0Nzcy5ib3R0b20gPSBpc1Rvb2x0aXAgPyAnMCcgOiAnLScgKyBib3JkZXJXaWR0aDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICBhcnJvd0Nzcy50b3AgPSBpc1Rvb2x0aXAgPyAnMCcgOiAnLScgKyBib3JkZXJXaWR0aDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgYXJyb3dDc3MucmlnaHQgPSBpc1Rvb2x0aXAgPyAnMCcgOiAnLScgKyBib3JkZXJXaWR0aDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgIGFycm93Q3NzLmxlZnQgPSBpc1Rvb2x0aXAgPyAnMCcgOiAnLScgKyBib3JkZXJXaWR0aDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhcnJvd0Nzc1twbGFjZW1lbnRbMV1dID0gYm9yZGVyUmFkaXVzO1xyXG5cclxuICAgICAgICBhbmd1bGFyLmVsZW1lbnQoYXJyb3dFbGVtKS5jc3MoYXJyb3dDc3MpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZGF0ZXBpY2tlclBvcHVwJywgWyd1aS5ib290c3RyYXAuZGF0ZXBpY2tlcicsICd1aS5ib290c3RyYXAucG9zaXRpb24nXSlcclxuXHJcbi52YWx1ZSgnJGRhdGVwaWNrZXJQb3B1cExpdGVyYWxXYXJuaW5nJywgdHJ1ZSlcclxuXHJcbi5jb25zdGFudCgndWliRGF0ZXBpY2tlclBvcHVwQ29uZmlnJywge1xyXG4gIGFsdElucHV0Rm9ybWF0czogW10sXHJcbiAgYXBwZW5kVG9Cb2R5OiBmYWxzZSxcclxuICBjbGVhclRleHQ6ICdDbGVhcicsXHJcbiAgY2xvc2VPbkRhdGVTZWxlY3Rpb246IHRydWUsXHJcbiAgY2xvc2VUZXh0OiAnRG9uZScsXHJcbiAgY3VycmVudFRleHQ6ICdUb2RheScsXHJcbiAgZGF0ZXBpY2tlclBvcHVwOiAneXl5eS1NTS1kZCcsXHJcbiAgZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlclBvcHVwL3BvcHVwLmh0bWwnLFxyXG4gIGRhdGVwaWNrZXJUZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbCcsXHJcbiAgaHRtbDVUeXBlczoge1xyXG4gICAgZGF0ZTogJ3l5eXktTU0tZGQnLFxyXG4gICAgJ2RhdGV0aW1lLWxvY2FsJzogJ3l5eXktTU0tZGRUSEg6bW06c3Muc3NzJyxcclxuICAgICdtb250aCc6ICd5eXl5LU1NJ1xyXG4gIH0sXHJcbiAgb25PcGVuRm9jdXM6IHRydWUsXHJcbiAgc2hvd0J1dHRvbkJhcjogdHJ1ZSxcclxuICBwbGFjZW1lbnQ6ICdhdXRvIGJvdHRvbS1sZWZ0J1xyXG59KVxyXG5cclxuLmNvbnRyb2xsZXIoJ1VpYkRhdGVwaWNrZXJQb3B1cENvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckYXR0cnMnLCAnJGNvbXBpbGUnLCAnJGxvZycsICckcGFyc2UnLCAnJHdpbmRvdycsICckZG9jdW1lbnQnLCAnJHJvb3RTY29wZScsICckdWliUG9zaXRpb24nLCAnZGF0ZUZpbHRlcicsICd1aWJEYXRlUGFyc2VyJywgJ3VpYkRhdGVwaWNrZXJQb3B1cENvbmZpZycsICckdGltZW91dCcsICd1aWJEYXRlcGlja2VyQ29uZmlnJywgJyRkYXRlcGlja2VyUG9wdXBMaXRlcmFsV2FybmluZycsXHJcbmZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJGNvbXBpbGUsICRsb2csICRwYXJzZSwgJHdpbmRvdywgJGRvY3VtZW50LCAkcm9vdFNjb3BlLCAkcG9zaXRpb24sIGRhdGVGaWx0ZXIsIGRhdGVQYXJzZXIsIGRhdGVwaWNrZXJQb3B1cENvbmZpZywgJHRpbWVvdXQsIGRhdGVwaWNrZXJDb25maWcsICRkYXRlcGlja2VyUG9wdXBMaXRlcmFsV2FybmluZykge1xyXG4gIHZhciBjYWNoZSA9IHt9LFxyXG4gICAgaXNIdG1sNURhdGVJbnB1dCA9IGZhbHNlO1xyXG4gIHZhciBkYXRlRm9ybWF0LCBjbG9zZU9uRGF0ZVNlbGVjdGlvbiwgYXBwZW5kVG9Cb2R5LCBvbk9wZW5Gb2N1cyxcclxuICAgIGRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsLCBkYXRlcGlja2VyVGVtcGxhdGVVcmwsIHBvcHVwRWwsIGRhdGVwaWNrZXJFbCwgc2Nyb2xsUGFyZW50RWwsXHJcbiAgICBuZ01vZGVsLCBuZ01vZGVsT3B0aW9ucywgJHBvcHVwLCBhbHRJbnB1dEZvcm1hdHMsIHdhdGNoTGlzdGVuZXJzID0gW107XHJcblxyXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKF9uZ01vZGVsXykge1xyXG4gICAgbmdNb2RlbCA9IF9uZ01vZGVsXztcclxuICAgIG5nTW9kZWxPcHRpb25zID0gZXh0cmFjdE9wdGlvbnMobmdNb2RlbCk7XHJcbiAgICBjbG9zZU9uRGF0ZVNlbGVjdGlvbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5jbG9zZU9uRGF0ZVNlbGVjdGlvbikgP1xyXG4gICAgICAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuY2xvc2VPbkRhdGVTZWxlY3Rpb24pIDpcclxuICAgICAgZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmNsb3NlT25EYXRlU2VsZWN0aW9uO1xyXG4gICAgYXBwZW5kVG9Cb2R5ID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmRhdGVwaWNrZXJBcHBlbmRUb0JvZHkpID9cclxuICAgICAgJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLmRhdGVwaWNrZXJBcHBlbmRUb0JvZHkpIDpcclxuICAgICAgZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmFwcGVuZFRvQm9keTtcclxuICAgIG9uT3BlbkZvY3VzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLm9uT3BlbkZvY3VzKSA/XHJcbiAgICAgICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5vbk9wZW5Gb2N1cykgOiBkYXRlcGlja2VyUG9wdXBDb25maWcub25PcGVuRm9jdXM7XHJcbiAgICBkYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5kYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybCkgP1xyXG4gICAgICAkYXR0cnMuZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmwgOlxyXG4gICAgICBkYXRlcGlja2VyUG9wdXBDb25maWcuZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmw7XHJcbiAgICBkYXRlcGlja2VyVGVtcGxhdGVVcmwgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuZGF0ZXBpY2tlclRlbXBsYXRlVXJsKSA/XHJcbiAgICAgICRhdHRycy5kYXRlcGlja2VyVGVtcGxhdGVVcmwgOiBkYXRlcGlja2VyUG9wdXBDb25maWcuZGF0ZXBpY2tlclRlbXBsYXRlVXJsO1xyXG4gICAgYWx0SW5wdXRGb3JtYXRzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmFsdElucHV0Rm9ybWF0cykgP1xyXG4gICAgICAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuYWx0SW5wdXRGb3JtYXRzKSA6XHJcbiAgICAgIGRhdGVwaWNrZXJQb3B1cENvbmZpZy5hbHRJbnB1dEZvcm1hdHM7XHJcblxyXG4gICAgJHNjb3BlLnNob3dCdXR0b25CYXIgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuc2hvd0J1dHRvbkJhcikgP1xyXG4gICAgICAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuc2hvd0J1dHRvbkJhcikgOlxyXG4gICAgICBkYXRlcGlja2VyUG9wdXBDb25maWcuc2hvd0J1dHRvbkJhcjtcclxuXHJcbiAgICBpZiAoZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmh0bWw1VHlwZXNbJGF0dHJzLnR5cGVdKSB7XHJcbiAgICAgIGRhdGVGb3JtYXQgPSBkYXRlcGlja2VyUG9wdXBDb25maWcuaHRtbDVUeXBlc1skYXR0cnMudHlwZV07XHJcbiAgICAgIGlzSHRtbDVEYXRlSW5wdXQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGF0ZUZvcm1hdCA9ICRhdHRycy51aWJEYXRlcGlja2VyUG9wdXAgfHwgZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmRhdGVwaWNrZXJQb3B1cDtcclxuICAgICAgJGF0dHJzLiRvYnNlcnZlKCd1aWJEYXRlcGlja2VyUG9wdXAnLCBmdW5jdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICB2YXIgbmV3RGF0ZUZvcm1hdCA9IHZhbHVlIHx8IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5kYXRlcGlja2VyUG9wdXA7XHJcbiAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUgJG1vZGVsVmFsdWUgdG8gZW5zdXJlIHRoYXQgZm9ybWF0dGVycyByZS1ydW5cclxuICAgICAgICAvLyBGSVhNRTogUmVmYWN0b3Igd2hlbiBQUiBpcyBtZXJnZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvcHVsbC8xMDc2NFxyXG4gICAgICAgIGlmIChuZXdEYXRlRm9ybWF0ICE9PSBkYXRlRm9ybWF0KSB7XHJcbiAgICAgICAgICBkYXRlRm9ybWF0ID0gbmV3RGF0ZUZvcm1hdDtcclxuICAgICAgICAgIG5nTW9kZWwuJG1vZGVsVmFsdWUgPSBudWxsO1xyXG5cclxuICAgICAgICAgIGlmICghZGF0ZUZvcm1hdCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpYkRhdGVwaWNrZXJQb3B1cCBtdXN0IGhhdmUgYSBkYXRlIGZvcm1hdCBzcGVjaWZpZWQuJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWRhdGVGb3JtYXQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aWJEYXRlcGlja2VyUG9wdXAgbXVzdCBoYXZlIGEgZGF0ZSBmb3JtYXQgc3BlY2lmaWVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0h0bWw1RGF0ZUlucHV0ICYmICRhdHRycy51aWJEYXRlcGlja2VyUG9wdXApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVE1MNSBkYXRlIGlucHV0IHR5cGVzIGRvIG5vdCBzdXBwb3J0IGN1c3RvbSBmb3JtYXRzLicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHBvcHVwIGVsZW1lbnQgdXNlZCB0byBkaXNwbGF5IGNhbGVuZGFyXHJcbiAgICBwb3B1cEVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IHVpYi1kYXRlcGlja2VyLXBvcHVwLXdyYXA+PGRpdiB1aWItZGF0ZXBpY2tlcj48L2Rpdj48L2Rpdj4nKTtcclxuXHJcbiAgICBwb3B1cEVsLmF0dHIoe1xyXG4gICAgICAnbmctbW9kZWwnOiAnZGF0ZScsXHJcbiAgICAgICduZy1jaGFuZ2UnOiAnZGF0ZVNlbGVjdGlvbihkYXRlKScsXHJcbiAgICAgICd0ZW1wbGF0ZS11cmwnOiBkYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gZGF0ZXBpY2tlciBlbGVtZW50XHJcbiAgICBkYXRlcGlja2VyRWwgPSBhbmd1bGFyLmVsZW1lbnQocG9wdXBFbC5jaGlsZHJlbigpWzBdKTtcclxuICAgIGRhdGVwaWNrZXJFbC5hdHRyKCd0ZW1wbGF0ZS11cmwnLCBkYXRlcGlja2VyVGVtcGxhdGVVcmwpO1xyXG5cclxuICAgIGlmICghJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zKSB7XHJcbiAgICAgICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0h0bWw1RGF0ZUlucHV0KSB7XHJcbiAgICAgIGlmICgkYXR0cnMudHlwZSA9PT0gJ21vbnRoJykge1xyXG4gICAgICAgICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5kYXRlcGlja2VyTW9kZSA9ICdtb250aCc7XHJcbiAgICAgICAgJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLm1pbk1vZGUgPSAnbW9udGgnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZGF0ZXBpY2tlckVsLmF0dHIoJ2RhdGVwaWNrZXItb3B0aW9ucycsICdkYXRlcGlja2VyT3B0aW9ucycpO1xyXG5cclxuICAgIGlmICghaXNIdG1sNURhdGVJbnB1dCkge1xyXG4gICAgICAvLyBJbnRlcm5hbCBBUEkgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3QgbmctaW52YWxpZC1ba2V5XSBjbGFzc1xyXG4gICAgICBuZ01vZGVsLiQkcGFyc2VyTmFtZSA9ICdkYXRlJztcclxuICAgICAgbmdNb2RlbC4kdmFsaWRhdG9ycy5kYXRlID0gdmFsaWRhdG9yO1xyXG4gICAgICBuZ01vZGVsLiRwYXJzZXJzLnVuc2hpZnQocGFyc2VEYXRlKTtcclxuICAgICAgbmdNb2RlbC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5nTW9kZWwuJGlzRW1wdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAkc2NvcGUuZGF0ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICRzY29wZS5kYXRlID0gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUodmFsdWUsIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRlUGFyc2VyLmZpbHRlcigkc2NvcGUuZGF0ZSwgZGF0ZUZvcm1hdCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbmdNb2RlbC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgJHNjb3BlLmRhdGUgPSBkYXRlUGFyc2VyLmZyb21UaW1lem9uZSh2YWx1ZSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVjdCBjaGFuZ2VzIGluIHRoZSB2aWV3IGZyb20gdGhlIHRleHQgYm94XHJcbiAgICBuZ01vZGVsLiR2aWV3Q2hhbmdlTGlzdGVuZXJzLnB1c2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICRzY29wZS5kYXRlID0gcGFyc2VEYXRlU3RyaW5nKG5nTW9kZWwuJHZpZXdWYWx1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAkZWxlbWVudC5vbigna2V5ZG93bicsIGlucHV0S2V5ZG93bkJpbmQpO1xyXG5cclxuICAgICRwb3B1cCA9ICRjb21waWxlKHBvcHVwRWwpKCRzY29wZSk7XHJcbiAgICAvLyBQcmV2ZW50IGpRdWVyeSBjYWNoZSBtZW1vcnkgbGVhayAodGVtcGxhdGUgaXMgbm93IHJlZHVuZGFudCBhZnRlciBsaW5raW5nKVxyXG4gICAgcG9wdXBFbC5yZW1vdmUoKTtcclxuXHJcbiAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XHJcbiAgICAgICRkb2N1bWVudC5maW5kKCdib2R5JykuYXBwZW5kKCRwb3B1cCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAkZWxlbWVudC5hZnRlcigkcG9wdXApO1xyXG4gICAgfVxyXG5cclxuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICgkc2NvcGUuaXNPcGVuID09PSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpIHtcclxuICAgICAgICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5pc09wZW4gPSBmYWxzZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgJHBvcHVwLnJlbW92ZSgpO1xyXG4gICAgICAkZWxlbWVudC5vZmYoJ2tleWRvd24nLCBpbnB1dEtleWRvd25CaW5kKTtcclxuICAgICAgJGRvY3VtZW50Lm9mZignY2xpY2snLCBkb2N1bWVudENsaWNrQmluZCk7XHJcbiAgICAgIGlmIChzY3JvbGxQYXJlbnRFbCkge1xyXG4gICAgICAgIHNjcm9sbFBhcmVudEVsLm9mZignc2Nyb2xsJywgcG9zaXRpb25Qb3B1cCk7XHJcbiAgICAgIH1cclxuICAgICAgYW5ndWxhci5lbGVtZW50KCR3aW5kb3cpLm9mZigncmVzaXplJywgcG9zaXRpb25Qb3B1cCk7XHJcblxyXG4gICAgICAvL0NsZWFyIGFsbCB3YXRjaCBsaXN0ZW5lcnMgb24gZGVzdHJveVxyXG4gICAgICB3aGlsZSAod2F0Y2hMaXN0ZW5lcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgd2F0Y2hMaXN0ZW5lcnMuc2hpZnQoKSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAkc2NvcGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgcmV0dXJuICRzY29wZVtrZXkgKyAnVGV4dCddIHx8IGRhdGVwaWNrZXJQb3B1cENvbmZpZ1trZXkgKyAnVGV4dCddO1xyXG4gIH07XHJcblxyXG4gICRzY29wZS5pc0Rpc2FibGVkID0gZnVuY3Rpb24oZGF0ZSkge1xyXG4gICAgaWYgKGRhdGUgPT09ICd0b2RheScpIHtcclxuICAgICAgZGF0ZSA9IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKG5ldyBEYXRlKCksIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRhdGVzID0ge307XHJcbiAgICBhbmd1bGFyLmZvckVhY2goWydtaW5EYXRlJywgJ21heERhdGUnXSwgZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgIGlmICghJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zW2tleV0pIHtcclxuICAgICAgICBkYXRlc1trZXldID0gbnVsbDtcclxuICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzRGF0ZSgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XSkpIHtcclxuICAgICAgICBkYXRlc1trZXldID0gbmV3IERhdGUoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zW2tleV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICgkZGF0ZXBpY2tlclBvcHVwTGl0ZXJhbFdhcm5pbmcpIHtcclxuICAgICAgICAgICRsb2cud2FybignTGl0ZXJhbCBkYXRlIHN1cHBvcnQgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHN3aXRjaCB0byBkYXRlIG9iamVjdCB1c2FnZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGF0ZXNba2V5XSA9IG5ldyBEYXRlKGRhdGVGaWx0ZXIoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zW2tleV0sICdtZWRpdW0nKSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMgJiZcclxuICAgICAgZGF0ZXMubWluRGF0ZSAmJiAkc2NvcGUuY29tcGFyZShkYXRlLCBkYXRlcy5taW5EYXRlKSA8IDAgfHxcclxuICAgICAgZGF0ZXMubWF4RGF0ZSAmJiAkc2NvcGUuY29tcGFyZShkYXRlLCBkYXRlcy5tYXhEYXRlKSA+IDA7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLmNvbXBhcmUgPSBmdW5jdGlvbihkYXRlMSwgZGF0ZTIpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlMS5nZXRGdWxsWWVhcigpLCBkYXRlMS5nZXRNb250aCgpLCBkYXRlMS5nZXREYXRlKCkpIC0gbmV3IERhdGUoZGF0ZTIuZ2V0RnVsbFllYXIoKSwgZGF0ZTIuZ2V0TW9udGgoKSwgZGF0ZTIuZ2V0RGF0ZSgpKTtcclxuICB9O1xyXG5cclxuICAvLyBJbm5lciBjaGFuZ2VcclxuICAkc2NvcGUuZGF0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKGR0KSB7XHJcbiAgICAkc2NvcGUuZGF0ZSA9IGR0O1xyXG4gICAgdmFyIGRhdGUgPSAkc2NvcGUuZGF0ZSA/IGRhdGVQYXJzZXIuZmlsdGVyKCRzY29wZS5kYXRlLCBkYXRlRm9ybWF0KSA6IG51bGw7IC8vIFNldHRpbmcgdG8gTlVMTCBpcyBuZWNlc3NhcnkgZm9yIGZvcm0gdmFsaWRhdG9ycyB0byBmdW5jdGlvblxyXG4gICAgJGVsZW1lbnQudmFsKGRhdGUpO1xyXG4gICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKGRhdGUpO1xyXG5cclxuICAgIGlmIChjbG9zZU9uRGF0ZVNlbGVjdGlvbikge1xyXG4gICAgICAkc2NvcGUuaXNPcGVuID0gZmFsc2U7XHJcbiAgICAgICRlbGVtZW50WzBdLmZvY3VzKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLmtleWRvd24gPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGlmIChldnQud2hpY2ggPT09IDI3KSB7XHJcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgJHNjb3BlLmlzT3BlbiA9IGZhbHNlO1xyXG4gICAgICAkZWxlbWVudFswXS5mb2N1cygpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gICRzY29wZS5zZWxlY3QgPSBmdW5jdGlvbihkYXRlLCBldnQpIHtcclxuICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICBpZiAoZGF0ZSA9PT0gJ3RvZGF5Jykge1xyXG4gICAgICB2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICBpZiAoYW5ndWxhci5pc0RhdGUoJHNjb3BlLmRhdGUpKSB7XHJcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCRzY29wZS5kYXRlKTtcclxuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHRvZGF5LmdldEZ1bGxZZWFyKCksIHRvZGF5LmdldE1vbnRoKCksIHRvZGF5LmdldERhdGUoKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0ZSA9IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKHRvZGF5LCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpO1xyXG4gICAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgICRzY29wZS5kYXRlU2VsZWN0aW9uKGRhdGUpO1xyXG4gIH07XHJcblxyXG4gICRzY29wZS5jbG9zZSA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICRzY29wZS5pc09wZW4gPSBmYWxzZTtcclxuICAgICRlbGVtZW50WzBdLmZvY3VzKCk7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLmRpc2FibGVkID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmRpc2FibGVkKSB8fCBmYWxzZTtcclxuICBpZiAoJGF0dHJzLm5nRGlzYWJsZWQpIHtcclxuICAgIHdhdGNoTGlzdGVuZXJzLnB1c2goJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMubmdEaXNhYmxlZCksIGZ1bmN0aW9uKGRpc2FibGVkKSB7XHJcbiAgICAgICRzY29wZS5kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gICAgfSkpO1xyXG4gIH1cclxuXHJcbiAgJHNjb3BlLiR3YXRjaCgnaXNPcGVuJywgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICBpZiAoISRzY29wZS5kaXNhYmxlZCkge1xyXG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcG9zaXRpb25Qb3B1cCgpO1xyXG5cclxuICAgICAgICAgIGlmIChvbk9wZW5Gb2N1cykge1xyXG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgndWliOmRhdGVwaWNrZXIuZm9jdXMnKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAkZG9jdW1lbnQub24oJ2NsaWNrJywgZG9jdW1lbnRDbGlja0JpbmQpO1xyXG5cclxuICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkYXR0cnMucG9wdXBQbGFjZW1lbnQgPyAkYXR0cnMucG9wdXBQbGFjZW1lbnQgOiBkYXRlcGlja2VyUG9wdXBDb25maWcucGxhY2VtZW50O1xyXG4gICAgICAgICAgaWYgKGFwcGVuZFRvQm9keSB8fCAkcG9zaXRpb24ucGFyc2VQbGFjZW1lbnQocGxhY2VtZW50KVsyXSkge1xyXG4gICAgICAgICAgICBzY3JvbGxQYXJlbnRFbCA9IHNjcm9sbFBhcmVudEVsIHx8IGFuZ3VsYXIuZWxlbWVudCgkcG9zaXRpb24uc2Nyb2xsUGFyZW50KCRlbGVtZW50KSk7XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxQYXJlbnRFbCkge1xyXG4gICAgICAgICAgICAgIHNjcm9sbFBhcmVudEVsLm9uKCdzY3JvbGwnLCBwb3NpdGlvblBvcHVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2Nyb2xsUGFyZW50RWwgPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudCgkd2luZG93KS5vbigncmVzaXplJywgcG9zaXRpb25Qb3B1cCk7XHJcbiAgICAgICAgfSwgMCwgZmFsc2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICRzY29wZS5pc09wZW4gPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgJGRvY3VtZW50Lm9mZignY2xpY2snLCBkb2N1bWVudENsaWNrQmluZCk7XHJcbiAgICAgIGlmIChzY3JvbGxQYXJlbnRFbCkge1xyXG4gICAgICAgIHNjcm9sbFBhcmVudEVsLm9mZignc2Nyb2xsJywgcG9zaXRpb25Qb3B1cCk7XHJcbiAgICAgIH1cclxuICAgICAgYW5ndWxhci5lbGVtZW50KCR3aW5kb3cpLm9mZigncmVzaXplJywgcG9zaXRpb25Qb3B1cCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIGNhbWVsdG9EYXNoKHN0cmluZykge1xyXG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uKCQxKSB7IHJldHVybiAnLScgKyAkMS50b0xvd2VyQ2FzZSgpOyB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlRGF0ZVN0cmluZyh2aWV3VmFsdWUpIHtcclxuICAgIHZhciBkYXRlID0gZGF0ZVBhcnNlci5wYXJzZSh2aWV3VmFsdWUsIGRhdGVGb3JtYXQsICRzY29wZS5kYXRlKTtcclxuICAgIGlmIChpc05hTihkYXRlKSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsdElucHV0Rm9ybWF0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGRhdGUgPSBkYXRlUGFyc2VyLnBhcnNlKHZpZXdWYWx1ZSwgYWx0SW5wdXRGb3JtYXRzW2ldLCAkc2NvcGUuZGF0ZSk7XHJcbiAgICAgICAgaWYgKCFpc05hTihkYXRlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhcnNlRGF0ZSh2aWV3VmFsdWUpIHtcclxuICAgIGlmIChhbmd1bGFyLmlzTnVtYmVyKHZpZXdWYWx1ZSkpIHtcclxuICAgICAgLy8gcHJlc3VtYWJseSB0aW1lc3RhbXAgdG8gZGF0ZSBvYmplY3RcclxuICAgICAgdmlld1ZhbHVlID0gbmV3IERhdGUodmlld1ZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXZpZXdWYWx1ZSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYW5ndWxhci5pc0RhdGUodmlld1ZhbHVlKSAmJiAhaXNOYU4odmlld1ZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gdmlld1ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKHZpZXdWYWx1ZSkpIHtcclxuICAgICAgdmFyIGRhdGUgPSBwYXJzZURhdGVTdHJpbmcodmlld1ZhbHVlKTtcclxuICAgICAgaWYgKCFpc05hTihkYXRlKSkge1xyXG4gICAgICAgIHJldHVybiBkYXRlUGFyc2VyLnRvVGltZXpvbmUoZGF0ZSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ2FsbG93SW52YWxpZCcpID8gdmlld1ZhbHVlIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdmFsaWRhdG9yKG1vZGVsVmFsdWUsIHZpZXdWYWx1ZSkge1xyXG4gICAgdmFyIHZhbHVlID0gbW9kZWxWYWx1ZSB8fCB2aWV3VmFsdWU7XHJcblxyXG4gICAgaWYgKCEkYXR0cnMubmdSZXF1aXJlZCAmJiAhdmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFuZ3VsYXIuaXNEYXRlKHZhbHVlKSAmJiAhaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRGF0ZVN0cmluZyh2YWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRvY3VtZW50Q2xpY2tCaW5kKGV2ZW50KSB7XHJcbiAgICBpZiAoISRzY29wZS5pc09wZW4gJiYgJHNjb3BlLmRpc2FibGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcG9wdXAgPSAkcG9wdXBbMF07XHJcbiAgICB2YXIgZHBDb250YWluc1RhcmdldCA9ICRlbGVtZW50WzBdLmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XHJcbiAgICAvLyBUaGUgcG9wdXAgbm9kZSBtYXkgbm90IGJlIGFuIGVsZW1lbnQgbm9kZVxyXG4gICAgLy8gSW4gc29tZSBicm93c2VycyAoSUUpIG9ubHkgZWxlbWVudCBub2RlcyBoYXZlIHRoZSAnY29udGFpbnMnIGZ1bmN0aW9uXHJcbiAgICB2YXIgcG9wdXBDb250YWluc1RhcmdldCA9IHBvcHVwLmNvbnRhaW5zICE9PSB1bmRlZmluZWQgJiYgcG9wdXAuY29udGFpbnMoZXZlbnQudGFyZ2V0KTtcclxuICAgIGlmICgkc2NvcGUuaXNPcGVuICYmICEoZHBDb250YWluc1RhcmdldCB8fCBwb3B1cENvbnRhaW5zVGFyZ2V0KSkge1xyXG4gICAgICAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICRzY29wZS5pc09wZW4gPSBmYWxzZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbnB1dEtleWRvd25CaW5kKGV2dCkge1xyXG4gICAgaWYgKGV2dC53aGljaCA9PT0gMjcgJiYgJHNjb3BlLmlzT3Blbikge1xyXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICRzY29wZS5pc09wZW4gPSBmYWxzZTtcclxuICAgICAgfSk7XHJcbiAgICAgICRlbGVtZW50WzBdLmZvY3VzKCk7XHJcbiAgICB9IGVsc2UgaWYgKGV2dC53aGljaCA9PT0gNDAgJiYgISRzY29wZS5pc09wZW4pIHtcclxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICAkc2NvcGUuaXNPcGVuID0gdHJ1ZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwb3NpdGlvblBvcHVwKCkge1xyXG4gICAgaWYgKCRzY29wZS5pc09wZW4pIHtcclxuICAgICAgdmFyIGRwRWxlbWVudCA9IGFuZ3VsYXIuZWxlbWVudCgkcG9wdXBbMF0ucXVlcnlTZWxlY3RvcignLnVpYi1kYXRlcGlja2VyLXBvcHVwJykpO1xyXG4gICAgICB2YXIgcGxhY2VtZW50ID0gJGF0dHJzLnBvcHVwUGxhY2VtZW50ID8gJGF0dHJzLnBvcHVwUGxhY2VtZW50IDogZGF0ZXBpY2tlclBvcHVwQ29uZmlnLnBsYWNlbWVudDtcclxuICAgICAgdmFyIHBvc2l0aW9uID0gJHBvc2l0aW9uLnBvc2l0aW9uRWxlbWVudHMoJGVsZW1lbnQsIGRwRWxlbWVudCwgcGxhY2VtZW50LCBhcHBlbmRUb0JvZHkpO1xyXG4gICAgICBkcEVsZW1lbnQuY3NzKHt0b3A6IHBvc2l0aW9uLnRvcCArICdweCcsIGxlZnQ6IHBvc2l0aW9uLmxlZnQgKyAncHgnfSk7XHJcbiAgICAgIGlmIChkcEVsZW1lbnQuaGFzQ2xhc3MoJ3VpYi1wb3NpdGlvbi1tZWFzdXJlJykpIHtcclxuICAgICAgICBkcEVsZW1lbnQucmVtb3ZlQ2xhc3MoJ3VpYi1wb3NpdGlvbi1tZWFzdXJlJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGV4dHJhY3RPcHRpb25zKG5nTW9kZWxDdHJsKSB7XHJcbiAgICB2YXIgbmdNb2RlbE9wdGlvbnM7XHJcblxyXG4gICAgaWYgKGFuZ3VsYXIudmVyc2lvbi5taW5vciA8IDYpIHsgLy8gaW4gYW5ndWxhciA8IDEuNiAkb3B0aW9ucyBjb3VsZCBiZSBtaXNzaW5nXHJcbiAgICAgIC8vIGd1YXJhbnRlZSBhIHZhbHVlXHJcbiAgICAgIG5nTW9kZWxPcHRpb25zID0gYW5ndWxhci5pc09iamVjdChuZ01vZGVsQ3RybC4kb3B0aW9ucykgP1xyXG4gICAgICAgIG5nTW9kZWxDdHJsLiRvcHRpb25zIDpcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0aW1lem9uZTogbnVsbFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAvLyBtaW1pYyAxLjYrIGFwaVxyXG4gICAgICBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24gPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5nTW9kZWxPcHRpb25zW2tleV07XHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2UgeyAvLyBpbiBhbmd1bGFyID49MS42ICRvcHRpb25zIGlzIGFsd2F5cyBwcmVzZW50XHJcbiAgICAgIG5nTW9kZWxPcHRpb25zID0gbmdNb2RlbEN0cmwuJG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5nTW9kZWxPcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgJHNjb3BlLiRvbigndWliOmRhdGVwaWNrZXIubW9kZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgJHRpbWVvdXQocG9zaXRpb25Qb3B1cCwgMCwgZmFsc2UpO1xyXG4gIH0pO1xyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYkRhdGVwaWNrZXJQb3B1cCcsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXF1aXJlOiBbJ25nTW9kZWwnLCAndWliRGF0ZXBpY2tlclBvcHVwJ10sXHJcbiAgICBjb250cm9sbGVyOiAnVWliRGF0ZXBpY2tlclBvcHVwQ29udHJvbGxlcicsXHJcbiAgICBzY29wZToge1xyXG4gICAgICBkYXRlcGlja2VyT3B0aW9uczogJz0/JyxcclxuICAgICAgaXNPcGVuOiAnPT8nLFxyXG4gICAgICBjdXJyZW50VGV4dDogJ0AnLFxyXG4gICAgICBjbGVhclRleHQ6ICdAJyxcclxuICAgICAgY2xvc2VUZXh0OiAnQCdcclxuICAgIH0sXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XHJcbiAgICAgIHZhciBuZ01vZGVsID0gY3RybHNbMF0sXHJcbiAgICAgICAgY3RybCA9IGN0cmxzWzFdO1xyXG5cclxuICAgICAgY3RybC5pbml0KG5nTW9kZWwpO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJEYXRlcGlja2VyUG9wdXBXcmFwJywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL2RhdGVwaWNrZXJQb3B1cC9wb3B1cC5odG1sJztcclxuICAgIH1cclxuICB9O1xyXG59KTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZGVib3VuY2UnLCBbXSlcclxuLyoqXHJcbiAqIEEgaGVscGVyLCBpbnRlcm5hbCBzZXJ2aWNlIHRoYXQgZGVib3VuY2VzIGEgZnVuY3Rpb25cclxuICovXHJcbiAgLmZhY3RvcnkoJyQkZGVib3VuY2UnLCBbJyR0aW1lb3V0JywgZnVuY3Rpb24oJHRpbWVvdXQpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaywgZGVib3VuY2VUaW1lKSB7XHJcbiAgICAgIHZhciB0aW1lb3V0UHJvbWlzZTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmICh0aW1lb3V0UHJvbWlzZSkge1xyXG4gICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHRpbWVvdXRQcm9taXNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRpbWVvdXRQcm9taXNlID0gJHRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBjYWxsYmFjay5hcHBseShzZWxmLCBhcmdzKTtcclxuICAgICAgICB9LCBkZWJvdW5jZVRpbWUpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICB9XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLm11bHRpTWFwJywgW10pXHJcbi8qKlxyXG4gKiBBIGhlbHBlciwgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBzdG9yZXMgYWxsIHJlZmVyZW5jZXMgYXR0YWNoZWQgdG8ga2V5XHJcbiAqL1xyXG4gIC5mYWN0b3J5KCckJG11bHRpTWFwJywgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjcmVhdGVOZXc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtYXAgPSB7fTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobWFwKS5tYXAoZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1hcFtrZXldXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hcFtrZXldO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGhhc0tleTogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIW1hcFtrZXldO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBwdXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKCFtYXBba2V5XSkge1xyXG4gICAgICAgICAgICAgIG1hcFtrZXldID0gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1hcFtrZXldLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gbWFwW2tleV07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXZhbHVlcykge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGlkeCA9IHZhbHVlcy5pbmRleE9mKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgdmFsdWVzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICBkZWxldGUgbWFwW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5kcm9wZG93bicsIFsndWkuYm9vdHN0cmFwLm11bHRpTWFwJywgJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbiddKVxyXG5cclxuLmNvbnN0YW50KCd1aWJEcm9wZG93bkNvbmZpZycsIHtcclxuICBhcHBlbmRUb09wZW5DbGFzczogJ3VpYi1kcm9wZG93bi1vcGVuJyxcclxuICBvcGVuQ2xhc3M6ICdvcGVuJ1xyXG59KVxyXG5cclxuLnNlcnZpY2UoJ3VpYkRyb3Bkb3duU2VydmljZScsIFsnJGRvY3VtZW50JywgJyRyb290U2NvcGUnLCAnJCRtdWx0aU1hcCcsIGZ1bmN0aW9uKCRkb2N1bWVudCwgJHJvb3RTY29wZSwgJCRtdWx0aU1hcCkge1xyXG4gIHZhciBvcGVuU2NvcGUgPSBudWxsO1xyXG4gIHZhciBvcGVuZWRDb250YWluZXJzID0gJCRtdWx0aU1hcC5jcmVhdGVOZXcoKTtcclxuXHJcbiAgdGhpcy5pc09ubHlPcGVuID0gZnVuY3Rpb24oZHJvcGRvd25TY29wZSwgYXBwZW5kVG8pIHtcclxuICAgIHZhciBvcGVuZWREcm9wZG93bnMgPSBvcGVuZWRDb250YWluZXJzLmdldChhcHBlbmRUbyk7XHJcbiAgICBpZiAob3BlbmVkRHJvcGRvd25zKSB7XHJcbiAgICAgIHZhciBvcGVuRHJvcGRvd24gPSBvcGVuZWREcm9wZG93bnMucmVkdWNlKGZ1bmN0aW9uKHRvQ2xvc2UsIGRyb3Bkb3duKSB7XHJcbiAgICAgICAgaWYgKGRyb3Bkb3duLnNjb3BlID09PSBkcm9wZG93blNjb3BlKSB7XHJcbiAgICAgICAgICByZXR1cm4gZHJvcGRvd247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdG9DbG9zZTtcclxuICAgICAgfSwge30pO1xyXG4gICAgICBpZiAob3BlbkRyb3Bkb3duKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wZW5lZERyb3Bkb3ducy5sZW5ndGggPT09IDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5vcGVuID0gZnVuY3Rpb24oZHJvcGRvd25TY29wZSwgZWxlbWVudCwgYXBwZW5kVG8pIHtcclxuICAgIGlmICghb3BlblNjb3BlKSB7XHJcbiAgICAgICRkb2N1bWVudC5vbignY2xpY2snLCBjbG9zZURyb3Bkb3duKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3BlblNjb3BlICYmIG9wZW5TY29wZSAhPT0gZHJvcGRvd25TY29wZSkge1xyXG4gICAgICBvcGVuU2NvcGUuaXNPcGVuID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgb3BlblNjb3BlID0gZHJvcGRvd25TY29wZTtcclxuXHJcbiAgICBpZiAoIWFwcGVuZFRvKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb3BlbmVkRHJvcGRvd25zID0gb3BlbmVkQ29udGFpbmVycy5nZXQoYXBwZW5kVG8pO1xyXG4gICAgaWYgKG9wZW5lZERyb3Bkb3ducykge1xyXG4gICAgICB2YXIgb3BlbmVkU2NvcGVzID0gb3BlbmVkRHJvcGRvd25zLm1hcChmdW5jdGlvbihkcm9wZG93bikge1xyXG4gICAgICAgIHJldHVybiBkcm9wZG93bi5zY29wZTtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChvcGVuZWRTY29wZXMuaW5kZXhPZihkcm9wZG93blNjb3BlKSA9PT0gLTEpIHtcclxuICAgICAgICBvcGVuZWRDb250YWluZXJzLnB1dChhcHBlbmRUbywge1xyXG4gICAgICAgICAgc2NvcGU6IGRyb3Bkb3duU2NvcGVcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3BlbmVkQ29udGFpbmVycy5wdXQoYXBwZW5kVG8sIHtcclxuICAgICAgICBzY29wZTogZHJvcGRvd25TY29wZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB0aGlzLmNsb3NlID0gZnVuY3Rpb24oZHJvcGRvd25TY29wZSwgZWxlbWVudCwgYXBwZW5kVG8pIHtcclxuICAgIGlmIChvcGVuU2NvcGUgPT09IGRyb3Bkb3duU2NvcGUpIHtcclxuICAgICAgJGRvY3VtZW50Lm9mZignY2xpY2snLCBjbG9zZURyb3Bkb3duKTtcclxuICAgICAgJGRvY3VtZW50Lm9mZigna2V5ZG93bicsIHRoaXMua2V5YmluZEZpbHRlcik7XHJcbiAgICAgIG9wZW5TY29wZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFhcHBlbmRUbykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9wZW5lZERyb3Bkb3ducyA9IG9wZW5lZENvbnRhaW5lcnMuZ2V0KGFwcGVuZFRvKTtcclxuICAgIGlmIChvcGVuZWREcm9wZG93bnMpIHtcclxuICAgICAgdmFyIGRyb3Bkb3duVG9DbG9zZSA9IG9wZW5lZERyb3Bkb3ducy5yZWR1Y2UoZnVuY3Rpb24odG9DbG9zZSwgZHJvcGRvd24pIHtcclxuICAgICAgICBpZiAoZHJvcGRvd24uc2NvcGUgPT09IGRyb3Bkb3duU2NvcGUpIHtcclxuICAgICAgICAgIHJldHVybiBkcm9wZG93bjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0b0Nsb3NlO1xyXG4gICAgICB9LCB7fSk7XHJcbiAgICAgIGlmIChkcm9wZG93blRvQ2xvc2UpIHtcclxuICAgICAgICBvcGVuZWRDb250YWluZXJzLnJlbW92ZShhcHBlbmRUbywgZHJvcGRvd25Ub0Nsb3NlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBjbG9zZURyb3Bkb3duID0gZnVuY3Rpb24oZXZ0KSB7XHJcbiAgICAvLyBUaGlzIG1ldGhvZCBtYXkgc3RpbGwgYmUgY2FsbGVkIGR1cmluZyB0aGUgc2FtZSBtb3VzZSBldmVudCB0aGF0XHJcbiAgICAvLyB1bmJvdW5kIHRoaXMgZXZlbnQgaGFuZGxlci4gU28gY2hlY2sgb3BlblNjb3BlIGJlZm9yZSBwcm9jZWVkaW5nLlxyXG4gICAgaWYgKCFvcGVuU2NvcGUgfHwgIW9wZW5TY29wZS5pc09wZW4pIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgaWYgKGV2dCAmJiBvcGVuU2NvcGUuZ2V0QXV0b0Nsb3NlKCkgPT09ICdkaXNhYmxlZCcpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgaWYgKGV2dCAmJiBldnQud2hpY2ggPT09IDMpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgdmFyIHRvZ2dsZUVsZW1lbnQgPSBvcGVuU2NvcGUuZ2V0VG9nZ2xlRWxlbWVudCgpO1xyXG4gICAgaWYgKGV2dCAmJiB0b2dnbGVFbGVtZW50ICYmIHRvZ2dsZUVsZW1lbnRbMF0uY29udGFpbnMoZXZ0LnRhcmdldCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkcm9wZG93bkVsZW1lbnQgPSBvcGVuU2NvcGUuZ2V0RHJvcGRvd25FbGVtZW50KCk7XHJcbiAgICBpZiAoZXZ0ICYmIG9wZW5TY29wZS5nZXRBdXRvQ2xvc2UoKSA9PT0gJ291dHNpZGVDbGljaycgJiZcclxuICAgICAgZHJvcGRvd25FbGVtZW50ICYmIGRyb3Bkb3duRWxlbWVudFswXS5jb250YWlucyhldnQudGFyZ2V0KSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgb3BlblNjb3BlLmZvY3VzVG9nZ2xlRWxlbWVudCgpO1xyXG4gICAgb3BlblNjb3BlLmlzT3BlbiA9IGZhbHNlO1xyXG5cclxuICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XHJcbiAgICAgIG9wZW5TY29wZS4kYXBwbHkoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB0aGlzLmtleWJpbmRGaWx0ZXIgPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGlmICghb3BlblNjb3BlKSB7XHJcbiAgICAgIC8vIHNlZSB0aGlzLmNsb3NlIGFzIEVTQyBjb3VsZCBoYXZlIGJlZW4gcHJlc3NlZCB3aGljaCBraWxscyB0aGUgc2NvcGUgc28gd2UgY2FuIG5vdCBwcm9jZWVkXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZHJvcGRvd25FbGVtZW50ID0gb3BlblNjb3BlLmdldERyb3Bkb3duRWxlbWVudCgpO1xyXG4gICAgdmFyIHRvZ2dsZUVsZW1lbnQgPSBvcGVuU2NvcGUuZ2V0VG9nZ2xlRWxlbWVudCgpO1xyXG4gICAgdmFyIGRyb3Bkb3duRWxlbWVudFRhcmdldGVkID0gZHJvcGRvd25FbGVtZW50ICYmIGRyb3Bkb3duRWxlbWVudFswXS5jb250YWlucyhldnQudGFyZ2V0KTtcclxuICAgIHZhciB0b2dnbGVFbGVtZW50VGFyZ2V0ZWQgPSB0b2dnbGVFbGVtZW50ICYmIHRvZ2dsZUVsZW1lbnRbMF0uY29udGFpbnMoZXZ0LnRhcmdldCk7XHJcbiAgICBpZiAoZXZ0LndoaWNoID09PSAyNykge1xyXG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIG9wZW5TY29wZS5mb2N1c1RvZ2dsZUVsZW1lbnQoKTtcclxuICAgICAgY2xvc2VEcm9wZG93bigpO1xyXG4gICAgfSBlbHNlIGlmIChvcGVuU2NvcGUuaXNLZXluYXZFbmFibGVkKCkgJiYgWzM4LCA0MF0uaW5kZXhPZihldnQud2hpY2gpICE9PSAtMSAmJiBvcGVuU2NvcGUuaXNPcGVuICYmIChkcm9wZG93bkVsZW1lbnRUYXJnZXRlZCB8fCB0b2dnbGVFbGVtZW50VGFyZ2V0ZWQpKSB7XHJcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIG9wZW5TY29wZS5mb2N1c0Ryb3Bkb3duRW50cnkoZXZ0LndoaWNoKTtcclxuICAgIH1cclxuICB9O1xyXG59XSlcclxuXHJcbi5jb250cm9sbGVyKCdVaWJEcm9wZG93bkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckYXR0cnMnLCAnJHBhcnNlJywgJ3VpYkRyb3Bkb3duQ29uZmlnJywgJ3VpYkRyb3Bkb3duU2VydmljZScsICckYW5pbWF0ZScsICckdWliUG9zaXRpb24nLCAnJGRvY3VtZW50JywgJyRjb21waWxlJywgJyR0ZW1wbGF0ZVJlcXVlc3QnLCBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMsICRwYXJzZSwgZHJvcGRvd25Db25maWcsIHVpYkRyb3Bkb3duU2VydmljZSwgJGFuaW1hdGUsICRwb3NpdGlvbiwgJGRvY3VtZW50LCAkY29tcGlsZSwgJHRlbXBsYXRlUmVxdWVzdCkge1xyXG4gIHZhciBzZWxmID0gdGhpcyxcclxuICAgIHNjb3BlID0gJHNjb3BlLiRuZXcoKSwgLy8gY3JlYXRlIGEgY2hpbGQgc2NvcGUgc28gd2UgYXJlIG5vdCBwb2xsdXRpbmcgb3JpZ2luYWwgb25lXHJcbiAgICB0ZW1wbGF0ZVNjb3BlLFxyXG4gICAgYXBwZW5kVG9PcGVuQ2xhc3MgPSBkcm9wZG93bkNvbmZpZy5hcHBlbmRUb09wZW5DbGFzcyxcclxuICAgIG9wZW5DbGFzcyA9IGRyb3Bkb3duQ29uZmlnLm9wZW5DbGFzcyxcclxuICAgIGdldElzT3BlbixcclxuICAgIHNldElzT3BlbiA9IGFuZ3VsYXIubm9vcCxcclxuICAgIHRvZ2dsZUludm9rZXIgPSAkYXR0cnMub25Ub2dnbGUgPyAkcGFyc2UoJGF0dHJzLm9uVG9nZ2xlKSA6IGFuZ3VsYXIubm9vcCxcclxuICAgIGtleW5hdkVuYWJsZWQgPSBmYWxzZSxcclxuICAgIHNlbGVjdGVkT3B0aW9uID0gbnVsbCxcclxuICAgIGJvZHkgPSAkZG9jdW1lbnQuZmluZCgnYm9keScpO1xyXG5cclxuICAkZWxlbWVudC5hZGRDbGFzcygnZHJvcGRvd24nKTtcclxuXHJcbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoJGF0dHJzLmlzT3Blbikge1xyXG4gICAgICBnZXRJc09wZW4gPSAkcGFyc2UoJGF0dHJzLmlzT3Blbik7XHJcbiAgICAgIHNldElzT3BlbiA9IGdldElzT3Blbi5hc3NpZ247XHJcblxyXG4gICAgICAkc2NvcGUuJHdhdGNoKGdldElzT3BlbiwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBzY29wZS5pc09wZW4gPSAhIXZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBrZXluYXZFbmFibGVkID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmtleWJvYXJkTmF2KTtcclxuICB9O1xyXG5cclxuICB0aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uKG9wZW4pIHtcclxuICAgIHNjb3BlLmlzT3BlbiA9IGFyZ3VtZW50cy5sZW5ndGggPyAhIW9wZW4gOiAhc2NvcGUuaXNPcGVuO1xyXG4gICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihzZXRJc09wZW4pKSB7XHJcbiAgICAgIHNldElzT3BlbihzY29wZSwgc2NvcGUuaXNPcGVuKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2NvcGUuaXNPcGVuO1xyXG4gIH07XHJcblxyXG4gIC8vIEFsbG93IG90aGVyIGRpcmVjdGl2ZXMgdG8gd2F0Y2ggc3RhdHVzXHJcbiAgdGhpcy5pc09wZW4gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBzY29wZS5pc09wZW47XHJcbiAgfTtcclxuXHJcbiAgc2NvcGUuZ2V0VG9nZ2xlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHNlbGYudG9nZ2xlRWxlbWVudDtcclxuICB9O1xyXG5cclxuICBzY29wZS5nZXRBdXRvQ2xvc2UgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAkYXR0cnMuYXV0b0Nsb3NlIHx8ICdhbHdheXMnOyAvL29yICdvdXRzaWRlQ2xpY2snIG9yICdkaXNhYmxlZCdcclxuICB9O1xyXG5cclxuICBzY29wZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gJGVsZW1lbnQ7XHJcbiAgfTtcclxuXHJcbiAgc2NvcGUuaXNLZXluYXZFbmFibGVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ga2V5bmF2RW5hYmxlZDtcclxuICB9O1xyXG5cclxuICBzY29wZS5mb2N1c0Ryb3Bkb3duRW50cnkgPSBmdW5jdGlvbihrZXlDb2RlKSB7XHJcbiAgICB2YXIgZWxlbXMgPSBzZWxmLmRyb3Bkb3duTWVudSA/IC8vSWYgYXBwZW5kIHRvIGJvZHkgaXMgdXNlZC5cclxuICAgICAgYW5ndWxhci5lbGVtZW50KHNlbGYuZHJvcGRvd25NZW51KS5maW5kKCdhJykgOlxyXG4gICAgICAkZWxlbWVudC5maW5kKCd1bCcpLmVxKDApLmZpbmQoJ2EnKTtcclxuXHJcbiAgICBzd2l0Y2ggKGtleUNvZGUpIHtcclxuICAgICAgY2FzZSA0MDoge1xyXG4gICAgICAgIGlmICghYW5ndWxhci5pc051bWJlcihzZWxmLnNlbGVjdGVkT3B0aW9uKSkge1xyXG4gICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gPSBzZWxmLnNlbGVjdGVkT3B0aW9uID09PSBlbGVtcy5sZW5ndGggLSAxID9cclxuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA6XHJcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlIDM4OiB7XHJcbiAgICAgICAgaWYgKCFhbmd1bGFyLmlzTnVtYmVyKHNlbGYuc2VsZWN0ZWRPcHRpb24pKSB7XHJcbiAgICAgICAgICBzZWxmLnNlbGVjdGVkT3B0aW9uID0gZWxlbXMubGVuZ3RoIC0gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IHNlbGYuc2VsZWN0ZWRPcHRpb24gPT09IDAgP1xyXG4gICAgICAgICAgICAwIDogc2VsZi5zZWxlY3RlZE9wdGlvbiAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbGVtc1tzZWxmLnNlbGVjdGVkT3B0aW9uXS5mb2N1cygpO1xyXG4gIH07XHJcblxyXG4gIHNjb3BlLmdldERyb3Bkb3duRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHNlbGYuZHJvcGRvd25NZW51O1xyXG4gIH07XHJcblxyXG4gIHNjb3BlLmZvY3VzVG9nZ2xlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHNlbGYudG9nZ2xlRWxlbWVudCkge1xyXG4gICAgICBzZWxmLnRvZ2dsZUVsZW1lbnRbMF0uZm9jdXMoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiByZW1vdmVEcm9wZG93bk1lbnUoKSB7XHJcbiAgICAkZWxlbWVudC5hcHBlbmQoc2VsZi5kcm9wZG93bk1lbnUpO1xyXG4gIH1cclxuXHJcbiAgc2NvcGUuJHdhdGNoKCdpc09wZW4nLCBmdW5jdGlvbihpc09wZW4sIHdhc09wZW4pIHtcclxuICAgIHZhciBhcHBlbmRUbyA9IG51bGwsXHJcbiAgICAgIGFwcGVuZFRvQm9keSA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuZHJvcGRvd25BcHBlbmRUbykpIHtcclxuICAgICAgdmFyIGFwcGVuZFRvRWwgPSAkcGFyc2UoJGF0dHJzLmRyb3Bkb3duQXBwZW5kVG8pKHNjb3BlKTtcclxuICAgICAgaWYgKGFwcGVuZFRvRWwpIHtcclxuICAgICAgICBhcHBlbmRUbyA9IGFuZ3VsYXIuZWxlbWVudChhcHBlbmRUb0VsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuZHJvcGRvd25BcHBlbmRUb0JvZHkpKSB7XHJcbiAgICAgIHZhciBhcHBlbmRUb0JvZHlWYWx1ZSA9ICRwYXJzZSgkYXR0cnMuZHJvcGRvd25BcHBlbmRUb0JvZHkpKHNjb3BlKTtcclxuICAgICAgaWYgKGFwcGVuZFRvQm9keVZhbHVlICE9PSBmYWxzZSkge1xyXG4gICAgICAgIGFwcGVuZFRvQm9keSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXBwZW5kVG9Cb2R5ICYmICFhcHBlbmRUbykge1xyXG4gICAgICBhcHBlbmRUbyA9IGJvZHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFwcGVuZFRvICYmIHNlbGYuZHJvcGRvd25NZW51KSB7XHJcbiAgICAgIGlmIChpc09wZW4pIHtcclxuICAgICAgICBhcHBlbmRUby5hcHBlbmQoc2VsZi5kcm9wZG93bk1lbnUpO1xyXG4gICAgICAgICRlbGVtZW50Lm9uKCckZGVzdHJveScsIHJlbW92ZURyb3Bkb3duTWVudSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJGVsZW1lbnQub2ZmKCckZGVzdHJveScsIHJlbW92ZURyb3Bkb3duTWVudSk7XHJcbiAgICAgICAgcmVtb3ZlRHJvcGRvd25NZW51KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXBwZW5kVG8gJiYgc2VsZi5kcm9wZG93bk1lbnUpIHtcclxuICAgICAgdmFyIHBvcyA9ICRwb3NpdGlvbi5wb3NpdGlvbkVsZW1lbnRzKCRlbGVtZW50LCBzZWxmLmRyb3Bkb3duTWVudSwgJ2JvdHRvbS1sZWZ0JywgdHJ1ZSksXHJcbiAgICAgICAgY3NzLFxyXG4gICAgICAgIHJpZ2h0YWxpZ24sXHJcbiAgICAgICAgc2Nyb2xsYmFyUGFkZGluZyxcclxuICAgICAgICBzY3JvbGxiYXJXaWR0aCA9IDA7XHJcblxyXG4gICAgICBjc3MgPSB7XHJcbiAgICAgICAgdG9wOiBwb3MudG9wICsgJ3B4JyxcclxuICAgICAgICBkaXNwbGF5OiBpc09wZW4gPyAnYmxvY2snIDogJ25vbmUnXHJcbiAgICAgIH07XHJcblxyXG4gICAgICByaWdodGFsaWduID0gc2VsZi5kcm9wZG93bk1lbnUuaGFzQ2xhc3MoJ2Ryb3Bkb3duLW1lbnUtcmlnaHQnKTtcclxuICAgICAgaWYgKCFyaWdodGFsaWduKSB7XHJcbiAgICAgICAgY3NzLmxlZnQgPSBwb3MubGVmdCArICdweCc7XHJcbiAgICAgICAgY3NzLnJpZ2h0ID0gJ2F1dG8nO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNzcy5sZWZ0ID0gJ2F1dG8nO1xyXG4gICAgICAgIHNjcm9sbGJhclBhZGRpbmcgPSAkcG9zaXRpb24uc2Nyb2xsYmFyUGFkZGluZyhhcHBlbmRUbyk7XHJcblxyXG4gICAgICAgIGlmIChzY3JvbGxiYXJQYWRkaW5nLmhlaWdodE92ZXJmbG93ICYmIHNjcm9sbGJhclBhZGRpbmcuc2Nyb2xsYmFyV2lkdGgpIHtcclxuICAgICAgICAgIHNjcm9sbGJhcldpZHRoID0gc2Nyb2xsYmFyUGFkZGluZy5zY3JvbGxiYXJXaWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNzcy5yaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gc2Nyb2xsYmFyV2lkdGggLVxyXG4gICAgICAgICAgKHBvcy5sZWZ0ICsgJGVsZW1lbnQucHJvcCgnb2Zmc2V0V2lkdGgnKSkgKyAncHgnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBOZWVkIHRvIGFkanVzdCBvdXIgcG9zaXRpb25pbmcgdG8gYmUgcmVsYXRpdmUgdG8gdGhlIGFwcGVuZFRvIGNvbnRhaW5lclxyXG4gICAgICAvLyBpZiBpdCdzIG5vdCB0aGUgYm9keSBlbGVtZW50XHJcbiAgICAgIGlmICghYXBwZW5kVG9Cb2R5KSB7XHJcbiAgICAgICAgdmFyIGFwcGVuZE9mZnNldCA9ICRwb3NpdGlvbi5vZmZzZXQoYXBwZW5kVG8pO1xyXG5cclxuICAgICAgICBjc3MudG9wID0gcG9zLnRvcCAtIGFwcGVuZE9mZnNldC50b3AgKyAncHgnO1xyXG5cclxuICAgICAgICBpZiAoIXJpZ2h0YWxpZ24pIHtcclxuICAgICAgICAgIGNzcy5sZWZ0ID0gcG9zLmxlZnQgLSBhcHBlbmRPZmZzZXQubGVmdCArICdweCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNzcy5yaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIC1cclxuICAgICAgICAgICAgKHBvcy5sZWZ0IC0gYXBwZW5kT2Zmc2V0LmxlZnQgKyAkZWxlbWVudC5wcm9wKCdvZmZzZXRXaWR0aCcpKSArICdweCc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzZWxmLmRyb3Bkb3duTWVudS5jc3MoY3NzKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb3BlbkNvbnRhaW5lciA9IGFwcGVuZFRvID8gYXBwZW5kVG8gOiAkZWxlbWVudDtcclxuICAgIHZhciBkcm9wZG93bk9wZW5DbGFzcyA9IGFwcGVuZFRvID8gYXBwZW5kVG9PcGVuQ2xhc3MgOiBvcGVuQ2xhc3M7XHJcbiAgICB2YXIgaGFzT3BlbkNsYXNzID0gb3BlbkNvbnRhaW5lci5oYXNDbGFzcyhkcm9wZG93bk9wZW5DbGFzcyk7XHJcbiAgICB2YXIgaXNPbmx5T3BlbiA9IHVpYkRyb3Bkb3duU2VydmljZS5pc09ubHlPcGVuKCRzY29wZSwgYXBwZW5kVG8pO1xyXG5cclxuICAgIGlmIChoYXNPcGVuQ2xhc3MgPT09ICFpc09wZW4pIHtcclxuICAgICAgdmFyIHRvZ2dsZUNsYXNzO1xyXG4gICAgICBpZiAoYXBwZW5kVG8pIHtcclxuICAgICAgICB0b2dnbGVDbGFzcyA9ICFpc09ubHlPcGVuID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdG9nZ2xlQ2xhc3MgPSBpc09wZW4gPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJztcclxuICAgICAgfVxyXG4gICAgICAkYW5pbWF0ZVt0b2dnbGVDbGFzc10ob3BlbkNvbnRhaW5lciwgZHJvcGRvd25PcGVuQ2xhc3MpLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGlzT3BlbikgJiYgaXNPcGVuICE9PSB3YXNPcGVuKSB7XHJcbiAgICAgICAgICB0b2dnbGVJbnZva2VyKCRzY29wZSwgeyBvcGVuOiAhIWlzT3BlbiB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc09wZW4pIHtcclxuICAgICAgaWYgKHNlbGYuZHJvcGRvd25NZW51VGVtcGxhdGVVcmwpIHtcclxuICAgICAgICAkdGVtcGxhdGVSZXF1ZXN0KHNlbGYuZHJvcGRvd25NZW51VGVtcGxhdGVVcmwpLnRoZW4oZnVuY3Rpb24odHBsQ29udGVudCkge1xyXG4gICAgICAgICAgdGVtcGxhdGVTY29wZSA9IHNjb3BlLiRuZXcoKTtcclxuICAgICAgICAgICRjb21waWxlKHRwbENvbnRlbnQudHJpbSgpKSh0ZW1wbGF0ZVNjb3BlLCBmdW5jdGlvbihkcm9wZG93bkVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIG5ld0VsID0gZHJvcGRvd25FbGVtZW50O1xyXG4gICAgICAgICAgICBzZWxmLmRyb3Bkb3duTWVudS5yZXBsYWNlV2l0aChuZXdFbCk7XHJcbiAgICAgICAgICAgIHNlbGYuZHJvcGRvd25NZW51ID0gbmV3RWw7XHJcbiAgICAgICAgICAgICRkb2N1bWVudC5vbigna2V5ZG93bicsIHVpYkRyb3Bkb3duU2VydmljZS5rZXliaW5kRmlsdGVyKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICRkb2N1bWVudC5vbigna2V5ZG93bicsIHVpYkRyb3Bkb3duU2VydmljZS5rZXliaW5kRmlsdGVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2NvcGUuZm9jdXNUb2dnbGVFbGVtZW50KCk7XHJcbiAgICAgIHVpYkRyb3Bkb3duU2VydmljZS5vcGVuKHNjb3BlLCAkZWxlbWVudCwgYXBwZW5kVG8pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdWliRHJvcGRvd25TZXJ2aWNlLmNsb3NlKHNjb3BlLCAkZWxlbWVudCwgYXBwZW5kVG8pO1xyXG4gICAgICBpZiAoc2VsZi5kcm9wZG93bk1lbnVUZW1wbGF0ZVVybCkge1xyXG4gICAgICAgIGlmICh0ZW1wbGF0ZVNjb3BlKSB7XHJcbiAgICAgICAgICB0ZW1wbGF0ZVNjb3BlLiRkZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXdFbCA9IGFuZ3VsYXIuZWxlbWVudCgnPHVsIGNsYXNzPVwiZHJvcGRvd24tbWVudVwiPjwvdWw+Jyk7XHJcbiAgICAgICAgc2VsZi5kcm9wZG93bk1lbnUucmVwbGFjZVdpdGgobmV3RWwpO1xyXG4gICAgICAgIHNlbGYuZHJvcGRvd25NZW51ID0gbmV3RWw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24oc2V0SXNPcGVuKSkge1xyXG4gICAgICBzZXRJc09wZW4oJHNjb3BlLCBpc09wZW4pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYkRyb3Bkb3duJywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGNvbnRyb2xsZXI6ICdVaWJEcm9wZG93bkNvbnRyb2xsZXInLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBkcm9wZG93bkN0cmwpIHtcclxuICAgICAgZHJvcGRvd25DdHJsLmluaXQoKTtcclxuICAgIH1cclxuICB9O1xyXG59KVxyXG5cclxuLmRpcmVjdGl2ZSgndWliRHJvcGRvd25NZW51JywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICByZXF1aXJlOiAnP151aWJEcm9wZG93bicsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGRyb3Bkb3duQ3RybCkge1xyXG4gICAgICBpZiAoIWRyb3Bkb3duQ3RybCB8fCBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5kcm9wZG93bk5lc3RlZCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2Ryb3Bkb3duLW1lbnUnKTtcclxuXHJcbiAgICAgIHZhciB0cGxVcmwgPSBhdHRycy50ZW1wbGF0ZVVybDtcclxuICAgICAgaWYgKHRwbFVybCkge1xyXG4gICAgICAgIGRyb3Bkb3duQ3RybC5kcm9wZG93bk1lbnVUZW1wbGF0ZVVybCA9IHRwbFVybDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFkcm9wZG93bkN0cmwuZHJvcGRvd25NZW51KSB7XHJcbiAgICAgICAgZHJvcGRvd25DdHJsLmRyb3Bkb3duTWVudSA9IGVsZW1lbnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59KVxyXG5cclxuLmRpcmVjdGl2ZSgndWliRHJvcGRvd25Ub2dnbGUnLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVxdWlyZTogJz9edWliRHJvcGRvd24nLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBkcm9wZG93bkN0cmwpIHtcclxuICAgICAgaWYgKCFkcm9wZG93bkN0cmwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2Ryb3Bkb3duLXRvZ2dsZScpO1xyXG5cclxuICAgICAgZHJvcGRvd25DdHJsLnRvZ2dsZUVsZW1lbnQgPSBlbGVtZW50O1xyXG5cclxuICAgICAgdmFyIHRvZ2dsZURyb3Bkb3duID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQ2xhc3MoJ2Rpc2FibGVkJykgJiYgIWF0dHJzLmRpc2FibGVkKSB7XHJcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGRyb3Bkb3duQ3RybC50b2dnbGUoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGVsZW1lbnQub24oJ2NsaWNrJywgdG9nZ2xlRHJvcGRvd24pO1xyXG5cclxuICAgICAgLy8gV0FJLUFSSUFcclxuICAgICAgZWxlbWVudC5hdHRyKHsgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLCAnYXJpYS1leHBhbmRlZCc6IGZhbHNlIH0pO1xyXG4gICAgICBzY29wZS4kd2F0Y2goZHJvcGRvd25DdHJsLmlzT3BlbiwgZnVuY3Rpb24oaXNPcGVuKSB7XHJcbiAgICAgICAgZWxlbWVudC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgISFpc09wZW4pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBlbGVtZW50Lm9mZignY2xpY2snLCB0b2dnbGVEcm9wZG93bik7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5zdGFja2VkTWFwJywgW10pXHJcbi8qKlxyXG4gKiBBIGhlbHBlciwgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBhY3RzIGFzIGEgbWFwIGJ1dCBhbHNvIGFsbG93cyBnZXR0aW5nIC8gcmVtb3ZpbmdcclxuICogZWxlbWVudHMgaW4gdGhlIExJRk8gb3JkZXJcclxuICovXHJcbiAgLmZhY3RvcnkoJyQkc3RhY2tlZE1hcCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY3JlYXRlTmV3OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGFkZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBzdGFjay5wdXNoKHtcclxuICAgICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGlmIChrZXkgPT09IHN0YWNrW2ldLmtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrW2ldO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAga2V5cy5wdXNoKHN0YWNrW2ldLmtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSAtMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGlmIChrZXkgPT09IHN0YWNrW2ldLmtleSkge1xyXG4gICAgICAgICAgICAgICAgaWR4ID0gaTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suc3BsaWNlKGlkeCwgMSlbMF07XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgcmVtb3ZlVG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KTtcclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5tb2RhbCcsIFsndWkuYm9vdHN0cmFwLm11bHRpTWFwJywgJ3VpLmJvb3RzdHJhcC5zdGFja2VkTWFwJywgJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbiddKVxyXG4vKipcclxuICogUGx1Z2dhYmxlIHJlc29sdmUgbWVjaGFuaXNtIGZvciB0aGUgbW9kYWwgcmVzb2x2ZSByZXNvbHV0aW9uXHJcbiAqIFN1cHBvcnRzIFVJIFJvdXRlcidzICRyZXNvbHZlIHNlcnZpY2VcclxuICovXHJcbiAgLnByb3ZpZGVyKCckdWliUmVzb2x2ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHJlc29sdmUgPSB0aGlzO1xyXG4gICAgdGhpcy5yZXNvbHZlciA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5zZXRSZXNvbHZlciA9IGZ1bmN0aW9uKHJlc29sdmVyKSB7XHJcbiAgICAgIHRoaXMucmVzb2x2ZXIgPSByZXNvbHZlcjtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy4kZ2V0ID0gWyckaW5qZWN0b3InLCAnJHEnLCBmdW5jdGlvbigkaW5qZWN0b3IsICRxKSB7XHJcbiAgICAgIHZhciByZXNvbHZlciA9IHJlc29sdmUucmVzb2x2ZXIgPyAkaW5qZWN0b3IuZ2V0KHJlc29sdmUucmVzb2x2ZXIpIDogbnVsbDtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICByZXNvbHZlOiBmdW5jdGlvbihpbnZvY2FibGVzLCBsb2NhbHMsIHBhcmVudCwgc2VsZikge1xyXG4gICAgICAgICAgaWYgKHJlc29sdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGludm9jYWJsZXMsIGxvY2FscywgcGFyZW50LCBzZWxmKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaW52b2NhYmxlcywgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbih2YWx1ZSkgfHwgYW5ndWxhci5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgIHByb21pc2VzLnB1c2goJHEucmVzb2x2ZSgkaW5qZWN0b3IuaW52b2tlKHZhbHVlKSkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkcS5yZXNvbHZlKCRpbmplY3Rvci5nZXQodmFsdWUpKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkcS5yZXNvbHZlKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24ocmVzb2x2ZXMpIHtcclxuICAgICAgICAgICAgdmFyIHJlc29sdmVPYmogPSB7fTtcclxuICAgICAgICAgICAgdmFyIHJlc29sdmVJdGVyID0gMDtcclxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGludm9jYWJsZXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgICByZXNvbHZlT2JqW2tleV0gPSByZXNvbHZlc1tyZXNvbHZlSXRlcisrXTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZU9iajtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1dO1xyXG4gIH0pXHJcblxyXG4vKipcclxuICogQSBoZWxwZXIgZGlyZWN0aXZlIGZvciB0aGUgJG1vZGFsIHNlcnZpY2UuIEl0IGNyZWF0ZXMgYSBiYWNrZHJvcCBlbGVtZW50LlxyXG4gKi9cclxuICAuZGlyZWN0aXZlKCd1aWJNb2RhbEJhY2tkcm9wJywgWyckYW5pbWF0ZScsICckaW5qZWN0b3InLCAnJHVpYk1vZGFsU3RhY2snLFxyXG4gIGZ1bmN0aW9uKCRhbmltYXRlLCAkaW5qZWN0b3IsICRtb2RhbFN0YWNrKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XHJcbiAgICAgICAgdEVsZW1lbnQuYWRkQ2xhc3ModEF0dHJzLmJhY2tkcm9wQ2xhc3MpO1xyXG4gICAgICAgIHJldHVybiBsaW5rRm47XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbGlua0ZuKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xyXG4gICAgICBpZiAoYXR0cnMubW9kYWxJbkNsYXNzKSB7XHJcbiAgICAgICAgJGFuaW1hdGUuYWRkQ2xhc3MoZWxlbWVudCwgYXR0cnMubW9kYWxJbkNsYXNzKTtcclxuXHJcbiAgICAgICAgc2NvcGUuJG9uKCRtb2RhbFN0YWNrLk5PV19DTE9TSU5HX0VWRU5ULCBmdW5jdGlvbihlLCBzZXRJc0FzeW5jKSB7XHJcbiAgICAgICAgICB2YXIgZG9uZSA9IHNldElzQXN5bmMoKTtcclxuICAgICAgICAgIGlmIChzY29wZS5tb2RhbE9wdGlvbnMuYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgICRhbmltYXRlLnJlbW92ZUNsYXNzKGVsZW1lbnQsIGF0dHJzLm1vZGFsSW5DbGFzcykudGhlbihkb25lKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1dKVxyXG5cclxuICAuZGlyZWN0aXZlKCd1aWJNb2RhbFdpbmRvdycsIFsnJHVpYk1vZGFsU3RhY2snLCAnJHEnLCAnJGFuaW1hdGVDc3MnLCAnJGRvY3VtZW50JyxcclxuICBmdW5jdGlvbigkbW9kYWxTdGFjaywgJHEsICRhbmltYXRlQ3NzLCAkZG9jdW1lbnQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgaW5kZXg6ICdAJ1xyXG4gICAgICB9LFxyXG4gICAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24odEVsZW1lbnQsIHRBdHRycykge1xyXG4gICAgICAgIHJldHVybiB0QXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbCc7XHJcbiAgICAgIH0sXHJcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xyXG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoYXR0cnMud2luZG93VG9wQ2xhc3MgfHwgJycpO1xyXG4gICAgICAgIHNjb3BlLnNpemUgPSBhdHRycy5zaXplO1xyXG5cclxuICAgICAgICBzY29wZS5jbG9zZSA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgdmFyIG1vZGFsID0gJG1vZGFsU3RhY2suZ2V0VG9wKCk7XHJcbiAgICAgICAgICBpZiAobW9kYWwgJiYgbW9kYWwudmFsdWUuYmFja2Ryb3AgJiZcclxuICAgICAgICAgICAgbW9kYWwudmFsdWUuYmFja2Ryb3AgIT09ICdzdGF0aWMnICYmXHJcbiAgICAgICAgICAgIGV2dC50YXJnZXQgPT09IGV2dC5jdXJyZW50VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICRtb2RhbFN0YWNrLmRpc21pc3MobW9kYWwua2V5LCAnYmFja2Ryb3AgY2xpY2snKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBtb3ZlZCBmcm9tIHRlbXBsYXRlIHRvIGZpeCBpc3N1ZSAjMjI4MFxyXG4gICAgICAgIGVsZW1lbnQub24oJ2NsaWNrJywgc2NvcGUuY2xvc2UpO1xyXG5cclxuICAgICAgICAvLyBUaGlzIHByb3BlcnR5IGlzIG9ubHkgYWRkZWQgdG8gdGhlIHNjb3BlIGZvciB0aGUgcHVycG9zZSBvZiBkZXRlY3Rpbmcgd2hlbiB0aGlzIGRpcmVjdGl2ZSBpcyByZW5kZXJlZC5cclxuICAgICAgICAvLyBXZSBjYW4gZGV0ZWN0IHRoYXQgYnkgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgdGVtcGxhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZGlyZWN0aXZlIGFuZCB0aGVuIHVzZVxyXG4gICAgICAgIC8vIHtAbGluayBBdHRyaWJ1dGUjJG9ic2VydmV9IG9uIGl0LiBGb3IgbW9yZSBkZXRhaWxzIHBsZWFzZSBzZWUge0BsaW5rIFRhYmxlQ29sdW1uUmVzaXplfS5cclxuICAgICAgICBzY29wZS4kaXNSZW5kZXJlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIERlZmVycmVkIG9iamVjdCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGlzIG1vZGFsIGlzIHJlbmRlcmVkLlxyXG4gICAgICAgIHZhciBtb2RhbFJlbmRlckRlZmVyT2JqID0gJHEuZGVmZXIoKTtcclxuICAgICAgICAvLyBSZXNvbHZlIHJlbmRlciBwcm9taXNlIHBvc3QtZGlnZXN0XHJcbiAgICAgICAgc2NvcGUuJCRwb3N0RGlnZXN0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgbW9kYWxSZW5kZXJEZWZlck9iai5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG1vZGFsUmVuZGVyRGVmZXJPYmoucHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIGFuaW1hdGlvblByb21pc2UgPSBudWxsO1xyXG5cclxuICAgICAgICAgIGlmIChhdHRycy5tb2RhbEluQ2xhc3MpIHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uUHJvbWlzZSA9ICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcclxuICAgICAgICAgICAgICBhZGRDbGFzczogYXR0cnMubW9kYWxJbkNsYXNzXHJcbiAgICAgICAgICAgIH0pLnN0YXJ0KCk7XHJcblxyXG4gICAgICAgICAgICBzY29wZS4kb24oJG1vZGFsU3RhY2suTk9XX0NMT1NJTkdfRVZFTlQsIGZ1bmN0aW9uKGUsIHNldElzQXN5bmMpIHtcclxuICAgICAgICAgICAgICB2YXIgZG9uZSA9IHNldElzQXN5bmMoKTtcclxuICAgICAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzczogYXR0cnMubW9kYWxJbkNsYXNzXHJcbiAgICAgICAgICAgICAgfSkuc3RhcnQoKS50aGVuKGRvbmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgJHEud2hlbihhbmltYXRpb25Qcm9taXNlKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBOb3RpZnkge0BsaW5rICRtb2RhbFN0YWNrfSB0aGF0IG1vZGFsIGlzIHJlbmRlcmVkLlxyXG4gICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW9kYWxTdGFjay5nZXRUb3AoKTtcclxuICAgICAgICAgICAgaWYgKG1vZGFsKSB7XHJcbiAgICAgICAgICAgICAgJG1vZGFsU3RhY2subW9kYWxSZW5kZXJlZChtb2RhbC5rZXkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSWYgc29tZXRoaW5nIHdpdGhpbiB0aGUgZnJlc2hseS1vcGVuZWQgbW9kYWwgYWxyZWFkeSBoYXMgZm9jdXMgKHBlcmhhcHMgdmlhIGFcclxuICAgICAgICAgICAgICogZGlyZWN0aXZlIHRoYXQgY2F1c2VzIGZvY3VzKSB0aGVuIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cnkgdG8gZm9jdXMgYW55dGhpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAoISgkZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCAmJiBlbGVtZW50WzBdLmNvbnRhaW5zKCRkb2N1bWVudFswXS5hY3RpdmVFbGVtZW50KSkpIHtcclxuICAgICAgICAgICAgICB2YXIgaW5wdXRXaXRoQXV0b2ZvY3VzID0gZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yKCdbYXV0b2ZvY3VzXScpO1xyXG4gICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAqIEF1dG8tZm9jdXNpbmcgb2YgYSBmcmVzaGx5LW9wZW5lZCBtb2RhbCBlbGVtZW50IGNhdXNlcyBhbnkgY2hpbGQgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgKiB3aXRoIHRoZSBhdXRvZm9jdXMgYXR0cmlidXRlIHRvIGxvc2UgZm9jdXMuIFRoaXMgaXMgYW4gaXNzdWUgb24gdG91Y2hcclxuICAgICAgICAgICAgICAgKiBiYXNlZCBkZXZpY2VzIHdoaWNoIHdpbGwgc2hvdyBhbmQgdGhlbiBoaWRlIHRoZSBvbnNjcmVlbiBrZXlib2FyZC5cclxuICAgICAgICAgICAgICAgKiBBdHRlbXB0cyB0byByZWZvY3VzIHRoZSBhdXRvZm9jdXMgZWxlbWVudCB2aWEgSmF2YVNjcmlwdCB3aWxsIG5vdCByZW9wZW5cclxuICAgICAgICAgICAgICAgKiB0aGUgb25zY3JlZW4ga2V5Ym9hcmQuIEZpeGVkIGJ5IHVwZGF0ZWQgdGhlIGZvY3VzaW5nIGxvZ2ljIHRvIG9ubHkgYXV0b2ZvY3VzXHJcbiAgICAgICAgICAgICAgICogdGhlIG1vZGFsIGVsZW1lbnQgaWYgdGhlIG1vZGFsIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0b2ZvY3VzIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgaWYgKGlucHV0V2l0aEF1dG9mb2N1cykge1xyXG4gICAgICAgICAgICAgICAgaW5wdXRXaXRoQXV0b2ZvY3VzLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRbMF0uZm9jdXMoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1dKVxyXG5cclxuICAuZGlyZWN0aXZlKCd1aWJNb2RhbEFuaW1hdGlvbkNsYXNzJywgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XHJcbiAgICAgICAgaWYgKHRBdHRycy5tb2RhbEFuaW1hdGlvbikge1xyXG4gICAgICAgICAgdEVsZW1lbnQuYWRkQ2xhc3ModEF0dHJzLnVpYk1vZGFsQW5pbWF0aW9uQ2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KVxyXG5cclxuICAuZGlyZWN0aXZlKCd1aWJNb2RhbFRyYW5zY2x1ZGUnLCBbJyRhbmltYXRlJywgZnVuY3Rpb24oJGFuaW1hdGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlciwgdHJhbnNjbHVkZSkge1xyXG4gICAgICAgIHRyYW5zY2x1ZGUoc2NvcGUuJHBhcmVudCwgZnVuY3Rpb24oY2xvbmUpIHtcclxuICAgICAgICAgIGVsZW1lbnQuZW1wdHkoKTtcclxuICAgICAgICAgICRhbmltYXRlLmVudGVyKGNsb25lLCBlbGVtZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XSlcclxuXHJcbiAgLmZhY3RvcnkoJyR1aWJNb2RhbFN0YWNrJywgWyckYW5pbWF0ZScsICckYW5pbWF0ZUNzcycsICckZG9jdW1lbnQnLFxyXG4gICAgJyRjb21waWxlJywgJyRyb290U2NvcGUnLCAnJHEnLCAnJCRtdWx0aU1hcCcsICckJHN0YWNrZWRNYXAnLCAnJHVpYlBvc2l0aW9uJyxcclxuICAgIGZ1bmN0aW9uKCRhbmltYXRlLCAkYW5pbWF0ZUNzcywgJGRvY3VtZW50LCAkY29tcGlsZSwgJHJvb3RTY29wZSwgJHEsICQkbXVsdGlNYXAsICQkc3RhY2tlZE1hcCwgJHVpYlBvc2l0aW9uKSB7XHJcbiAgICAgIHZhciBPUEVORURfTU9EQUxfQ0xBU1MgPSAnbW9kYWwtb3Blbic7XHJcblxyXG4gICAgICB2YXIgYmFja2Ryb3BEb21FbCwgYmFja2Ryb3BTY29wZTtcclxuICAgICAgdmFyIG9wZW5lZFdpbmRvd3MgPSAkJHN0YWNrZWRNYXAuY3JlYXRlTmV3KCk7XHJcbiAgICAgIHZhciBvcGVuZWRDbGFzc2VzID0gJCRtdWx0aU1hcC5jcmVhdGVOZXcoKTtcclxuICAgICAgdmFyICRtb2RhbFN0YWNrID0ge1xyXG4gICAgICAgIE5PV19DTE9TSU5HX0VWRU5UOiAnbW9kYWwuc3RhY2subm93LWNsb3NpbmcnXHJcbiAgICAgIH07XHJcbiAgICAgIHZhciB0b3BNb2RhbEluZGV4ID0gMDtcclxuICAgICAgdmFyIHByZXZpb3VzVG9wT3BlbmVkTW9kYWwgPSBudWxsO1xyXG4gICAgICB2YXIgQVJJQV9ISURERU5fQVRUUklCVVRFX05BTUUgPSAnZGF0YS1ib290c3RyYXAtbW9kYWwtYXJpYS1oaWRkZW4tY291bnQnO1xyXG5cclxuICAgICAgLy9Nb2RhbCBmb2N1cyBiZWhhdmlvclxyXG4gICAgICB2YXIgdGFiYmFibGVTZWxlY3RvciA9ICdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD1cXCctMVxcJ10pLCAnICtcclxuICAgICAgICAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVxcJy0xXFwnXSksc2VsZWN0Om5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVxcJy0xXFwnXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVxcJy0xXFwnXSksICcgK1xyXG4gICAgICAgICdpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XFwnLTFcXCddKSwgKltjb250ZW50ZWRpdGFibGU9dHJ1ZV0nO1xyXG4gICAgICB2YXIgc2Nyb2xsYmFyUGFkZGluZztcclxuICAgICAgdmFyIFNOQUtFX0NBU0VfUkVHRVhQID0gL1tBLVpdL2c7XHJcblxyXG4gICAgICAvLyBUT0RPOiBleHRyYWN0IGludG8gY29tbW9uIGRlcGVuZGVuY3kgd2l0aCB0b29sdGlwXHJcbiAgICAgIGZ1bmN0aW9uIHNuYWtlX2Nhc2UobmFtZSkge1xyXG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnLSc7XHJcbiAgICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZShTTkFLRV9DQVNFX1JFR0VYUCwgZnVuY3Rpb24obGV0dGVyLCBwb3MpIHtcclxuICAgICAgICAgIHJldHVybiAocG9zID8gc2VwYXJhdG9yIDogJycpICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGlzVmlzaWJsZShlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICEhKGVsZW1lbnQub2Zmc2V0V2lkdGggfHxcclxuICAgICAgICAgIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8XHJcbiAgICAgICAgICBlbGVtZW50LmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gYmFja2Ryb3BJbmRleCgpIHtcclxuICAgICAgICB2YXIgdG9wQmFja2Ryb3BJbmRleCA9IC0xO1xyXG4gICAgICAgIHZhciBvcGVuZWQgPSBvcGVuZWRXaW5kb3dzLmtleXMoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZW5lZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKG9wZW5lZFdpbmRvd3MuZ2V0KG9wZW5lZFtpXSkudmFsdWUuYmFja2Ryb3ApIHtcclxuICAgICAgICAgICAgdG9wQmFja2Ryb3BJbmRleCA9IGk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBhbnkgYmFja2Ryb3AgZXhpc3QsIGVuc3VyZSB0aGF0IGl0J3MgaW5kZXggaXMgYWx3YXlzXHJcbiAgICAgICAgLy8gcmlnaHQgYmVsb3cgdGhlIHRvcCBtb2RhbFxyXG4gICAgICAgIGlmICh0b3BCYWNrZHJvcEluZGV4ID4gLTEgJiYgdG9wQmFja2Ryb3BJbmRleCA8IHRvcE1vZGFsSW5kZXgpIHtcclxuICAgICAgICAgIHRvcEJhY2tkcm9wSW5kZXggPSB0b3BNb2RhbEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9wQmFja2Ryb3BJbmRleDtcclxuICAgICAgfVxyXG5cclxuICAgICAgJHJvb3RTY29wZS4kd2F0Y2goYmFja2Ryb3BJbmRleCwgZnVuY3Rpb24obmV3QmFja2Ryb3BJbmRleCkge1xyXG4gICAgICAgIGlmIChiYWNrZHJvcFNjb3BlKSB7XHJcbiAgICAgICAgICBiYWNrZHJvcFNjb3BlLmluZGV4ID0gbmV3QmFja2Ryb3BJbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gcmVtb3ZlTW9kYWxXaW5kb3cobW9kYWxJbnN0YW5jZSwgZWxlbWVudFRvUmVjZWl2ZUZvY3VzKSB7XHJcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSkudmFsdWU7XHJcbiAgICAgICAgdmFyIGFwcGVuZFRvRWxlbWVudCA9IG1vZGFsV2luZG93LmFwcGVuZFRvO1xyXG5cclxuICAgICAgICAvL2NsZWFuIHVwIHRoZSBzdGFja1xyXG4gICAgICAgIG9wZW5lZFdpbmRvd3MucmVtb3ZlKG1vZGFsSW5zdGFuY2UpO1xyXG4gICAgICAgIHByZXZpb3VzVG9wT3BlbmVkTW9kYWwgPSBvcGVuZWRXaW5kb3dzLnRvcCgpO1xyXG4gICAgICAgIGlmIChwcmV2aW91c1RvcE9wZW5lZE1vZGFsKSB7XHJcbiAgICAgICAgICB0b3BNb2RhbEluZGV4ID0gcGFyc2VJbnQocHJldmlvdXNUb3BPcGVuZWRNb2RhbC52YWx1ZS5tb2RhbERvbUVsLmF0dHIoJ2luZGV4JyksIDEwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbW92ZUFmdGVyQW5pbWF0ZShtb2RhbFdpbmRvdy5tb2RhbERvbUVsLCBtb2RhbFdpbmRvdy5tb2RhbFNjb3BlLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBtb2RhbEJvZHlDbGFzcyA9IG1vZGFsV2luZG93Lm9wZW5lZENsYXNzIHx8IE9QRU5FRF9NT0RBTF9DTEFTUztcclxuICAgICAgICAgIG9wZW5lZENsYXNzZXMucmVtb3ZlKG1vZGFsQm9keUNsYXNzLCBtb2RhbEluc3RhbmNlKTtcclxuICAgICAgICAgIHZhciBhcmVBbnlPcGVuID0gb3BlbmVkQ2xhc3Nlcy5oYXNLZXkobW9kYWxCb2R5Q2xhc3MpO1xyXG4gICAgICAgICAgYXBwZW5kVG9FbGVtZW50LnRvZ2dsZUNsYXNzKG1vZGFsQm9keUNsYXNzLCBhcmVBbnlPcGVuKTtcclxuICAgICAgICAgIGlmICghYXJlQW55T3BlbiAmJiBzY3JvbGxiYXJQYWRkaW5nICYmIHNjcm9sbGJhclBhZGRpbmcuaGVpZ2h0T3ZlcmZsb3cgJiYgc2Nyb2xsYmFyUGFkZGluZy5zY3JvbGxiYXJXaWR0aCkge1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFyUGFkZGluZy5vcmlnaW5hbFJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgYXBwZW5kVG9FbGVtZW50LmNzcyh7cGFkZGluZ1JpZ2h0OiBzY3JvbGxiYXJQYWRkaW5nLm9yaWdpbmFsUmlnaHQgKyAncHgnfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYXBwZW5kVG9FbGVtZW50LmNzcyh7cGFkZGluZ1JpZ2h0OiAnJ30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNjcm9sbGJhclBhZGRpbmcgPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdG9nZ2xlVG9wV2luZG93Q2xhc3ModHJ1ZSk7XHJcbiAgICAgICAgfSwgbW9kYWxXaW5kb3cuY2xvc2VkRGVmZXJyZWQpO1xyXG4gICAgICAgIGNoZWNrUmVtb3ZlQmFja2Ryb3AoKTtcclxuXHJcbiAgICAgICAgLy9tb3ZlIGZvY3VzIHRvIHNwZWNpZmllZCBlbGVtZW50IGlmIGF2YWlsYWJsZSwgb3IgZWxzZSB0byBib2R5XHJcbiAgICAgICAgaWYgKGVsZW1lbnRUb1JlY2VpdmVGb2N1cyAmJiBlbGVtZW50VG9SZWNlaXZlRm9jdXMuZm9jdXMpIHtcclxuICAgICAgICAgIGVsZW1lbnRUb1JlY2VpdmVGb2N1cy5mb2N1cygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXBwZW5kVG9FbGVtZW50LmZvY3VzKSB7XHJcbiAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFkZCBvciByZW1vdmUgXCJ3aW5kb3dUb3BDbGFzc1wiIGZyb20gdGhlIHRvcCB3aW5kb3cgaW4gdGhlIHN0YWNrXHJcbiAgICAgIGZ1bmN0aW9uIHRvZ2dsZVRvcFdpbmRvd0NsYXNzKHRvZ2dsZVN3aXRjaCkge1xyXG4gICAgICAgIHZhciBtb2RhbFdpbmRvdztcclxuXHJcbiAgICAgICAgaWYgKG9wZW5lZFdpbmRvd3MubGVuZ3RoKCkgPiAwKSB7XHJcbiAgICAgICAgICBtb2RhbFdpbmRvdyA9IG9wZW5lZFdpbmRvd3MudG9wKCkudmFsdWU7XHJcbiAgICAgICAgICBtb2RhbFdpbmRvdy5tb2RhbERvbUVsLnRvZ2dsZUNsYXNzKG1vZGFsV2luZG93LndpbmRvd1RvcENsYXNzIHx8ICcnLCB0b2dnbGVTd2l0Y2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY2hlY2tSZW1vdmVCYWNrZHJvcCgpIHtcclxuICAgICAgICAvL3JlbW92ZSBiYWNrZHJvcCBpZiBubyBsb25nZXIgbmVlZGVkXHJcbiAgICAgICAgaWYgKGJhY2tkcm9wRG9tRWwgJiYgYmFja2Ryb3BJbmRleCgpID09PSAtMSkge1xyXG4gICAgICAgICAgdmFyIGJhY2tkcm9wU2NvcGVSZWYgPSBiYWNrZHJvcFNjb3BlO1xyXG4gICAgICAgICAgcmVtb3ZlQWZ0ZXJBbmltYXRlKGJhY2tkcm9wRG9tRWwsIGJhY2tkcm9wU2NvcGUsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBiYWNrZHJvcFNjb3BlUmVmID0gbnVsbDtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYmFja2Ryb3BEb21FbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIGJhY2tkcm9wU2NvcGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiByZW1vdmVBZnRlckFuaW1hdGUoZG9tRWwsIHNjb3BlLCBkb25lLCBjbG9zZWREZWZlcnJlZCkge1xyXG4gICAgICAgIHZhciBhc3luY0RlZmVycmVkO1xyXG4gICAgICAgIHZhciBhc3luY1Byb21pc2UgPSBudWxsO1xyXG4gICAgICAgIHZhciBzZXRJc0FzeW5jID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAoIWFzeW5jRGVmZXJyZWQpIHtcclxuICAgICAgICAgICAgYXN5bmNEZWZlcnJlZCA9ICRxLmRlZmVyKCk7XHJcbiAgICAgICAgICAgIGFzeW5jUHJvbWlzZSA9IGFzeW5jRGVmZXJyZWQucHJvbWlzZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXN5bmNEb25lKCkge1xyXG4gICAgICAgICAgICBhc3luY0RlZmVycmVkLnJlc29sdmUoKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzY29wZS4kYnJvYWRjYXN0KCRtb2RhbFN0YWNrLk5PV19DTE9TSU5HX0VWRU5ULCBzZXRJc0FzeW5jKTtcclxuXHJcbiAgICAgICAgLy8gTm90ZSB0aGF0IGl0J3MgaW50ZW50aW9uYWwgdGhhdCBhc3luY1Byb21pc2UgbWlnaHQgYmUgbnVsbC5cclxuICAgICAgICAvLyBUaGF0J3Mgd2hlbiBzZXRJc0FzeW5jIGhhcyBub3QgYmVlbiBjYWxsZWQgZHVyaW5nIHRoZVxyXG4gICAgICAgIC8vIE5PV19DTE9TSU5HX0VWRU5UIGJyb2FkY2FzdC5cclxuICAgICAgICByZXR1cm4gJHEud2hlbihhc3luY1Byb21pc2UpLnRoZW4oYWZ0ZXJBbmltYXRpbmcpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhZnRlckFuaW1hdGluZygpIHtcclxuICAgICAgICAgIGlmIChhZnRlckFuaW1hdGluZy5kb25lKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGFmdGVyQW5pbWF0aW5nLmRvbmUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICRhbmltYXRlLmxlYXZlKGRvbUVsKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoZG9uZSkge1xyXG4gICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZG9tRWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGlmIChjbG9zZWREZWZlcnJlZCkge1xyXG4gICAgICAgICAgICAgIGNsb3NlZERlZmVycmVkLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgc2NvcGUuJGRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICRkb2N1bWVudC5vbigna2V5ZG93bicsIGtleWRvd25MaXN0ZW5lcik7XHJcblxyXG4gICAgICAkcm9vdFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAkZG9jdW1lbnQub2ZmKCdrZXlkb3duJywga2V5ZG93bkxpc3RlbmVyKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBrZXlkb3duTGlzdGVuZXIoZXZ0KSB7XHJcbiAgICAgICAgaWYgKGV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGV2dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtb2RhbCA9IG9wZW5lZFdpbmRvd3MudG9wKCk7XHJcbiAgICAgICAgaWYgKG1vZGFsKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKGV2dC53aGljaCkge1xyXG4gICAgICAgICAgICBjYXNlIDI3OiB7XHJcbiAgICAgICAgICAgICAgaWYgKG1vZGFsLnZhbHVlLmtleWJvYXJkKSB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsLmtleSwgJ2VzY2FwZSBrZXkgcHJlc3MnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIDk6IHtcclxuICAgICAgICAgICAgICB2YXIgbGlzdCA9ICRtb2RhbFN0YWNrLmxvYWRGb2N1c0VsZW1lbnRMaXN0KG1vZGFsKTtcclxuICAgICAgICAgICAgICB2YXIgZm9jdXNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgaWYgKGV2dC5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCRtb2RhbFN0YWNrLmlzRm9jdXNJbkZpcnN0SXRlbShldnQsIGxpc3QpIHx8ICRtb2RhbFN0YWNrLmlzTW9kYWxGb2N1c2VkKGV2dCwgbW9kYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZvY3VzQ2hhbmdlZCA9ICRtb2RhbFN0YWNrLmZvY3VzTGFzdEZvY3VzYWJsZUVsZW1lbnQobGlzdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICgkbW9kYWxTdGFjay5pc0ZvY3VzSW5MYXN0SXRlbShldnQsIGxpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZvY3VzQ2hhbmdlZCA9ICRtb2RhbFN0YWNrLmZvY3VzRmlyc3RGb2N1c2FibGVFbGVtZW50KGxpc3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKGZvY3VzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgJG1vZGFsU3RhY2sub3BlbiA9IGZ1bmN0aW9uKG1vZGFsSW5zdGFuY2UsIG1vZGFsKSB7XHJcbiAgICAgICAgdmFyIG1vZGFsT3BlbmVyID0gJGRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQsXHJcbiAgICAgICAgICBtb2RhbEJvZHlDbGFzcyA9IG1vZGFsLm9wZW5lZENsYXNzIHx8IE9QRU5FRF9NT0RBTF9DTEFTUztcclxuXHJcbiAgICAgICAgdG9nZ2xlVG9wV2luZG93Q2xhc3MoZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCB0b3AgZmlyc3QsIHRvIGRldGVybWluZSB3aGF0IGluZGV4IHdlIG91Z2h0IHRvIHVzZVxyXG4gICAgICAgIC8vIGZvciB0aGUgY3VycmVudCB0b3AgbW9kYWxcclxuICAgICAgICBwcmV2aW91c1RvcE9wZW5lZE1vZGFsID0gb3BlbmVkV2luZG93cy50b3AoKTtcclxuXHJcbiAgICAgICAgb3BlbmVkV2luZG93cy5hZGQobW9kYWxJbnN0YW5jZSwge1xyXG4gICAgICAgICAgZGVmZXJyZWQ6IG1vZGFsLmRlZmVycmVkLFxyXG4gICAgICAgICAgcmVuZGVyRGVmZXJyZWQ6IG1vZGFsLnJlbmRlckRlZmVycmVkLFxyXG4gICAgICAgICAgY2xvc2VkRGVmZXJyZWQ6IG1vZGFsLmNsb3NlZERlZmVycmVkLFxyXG4gICAgICAgICAgbW9kYWxTY29wZTogbW9kYWwuc2NvcGUsXHJcbiAgICAgICAgICBiYWNrZHJvcDogbW9kYWwuYmFja2Ryb3AsXHJcbiAgICAgICAgICBrZXlib2FyZDogbW9kYWwua2V5Ym9hcmQsXHJcbiAgICAgICAgICBvcGVuZWRDbGFzczogbW9kYWwub3BlbmVkQ2xhc3MsXHJcbiAgICAgICAgICB3aW5kb3dUb3BDbGFzczogbW9kYWwud2luZG93VG9wQ2xhc3MsXHJcbiAgICAgICAgICBhbmltYXRpb246IG1vZGFsLmFuaW1hdGlvbixcclxuICAgICAgICAgIGFwcGVuZFRvOiBtb2RhbC5hcHBlbmRUb1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBvcGVuZWRDbGFzc2VzLnB1dChtb2RhbEJvZHlDbGFzcywgbW9kYWxJbnN0YW5jZSk7XHJcblxyXG4gICAgICAgIHZhciBhcHBlbmRUb0VsZW1lbnQgPSBtb2RhbC5hcHBlbmRUbyxcclxuICAgICAgICAgICAgY3VyckJhY2tkcm9wSW5kZXggPSBiYWNrZHJvcEluZGV4KCk7XHJcblxyXG4gICAgICAgIGlmIChjdXJyQmFja2Ryb3BJbmRleCA+PSAwICYmICFiYWNrZHJvcERvbUVsKSB7XHJcbiAgICAgICAgICBiYWNrZHJvcFNjb3BlID0gJHJvb3RTY29wZS4kbmV3KHRydWUpO1xyXG4gICAgICAgICAgYmFja2Ryb3BTY29wZS5tb2RhbE9wdGlvbnMgPSBtb2RhbDtcclxuICAgICAgICAgIGJhY2tkcm9wU2NvcGUuaW5kZXggPSBjdXJyQmFja2Ryb3BJbmRleDtcclxuICAgICAgICAgIGJhY2tkcm9wRG9tRWwgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXYgdWliLW1vZGFsLWJhY2tkcm9wPVwibW9kYWwtYmFja2Ryb3BcIj48L2Rpdj4nKTtcclxuICAgICAgICAgIGJhY2tkcm9wRG9tRWwuYXR0cih7XHJcbiAgICAgICAgICAgICdjbGFzcyc6ICdtb2RhbC1iYWNrZHJvcCcsXHJcbiAgICAgICAgICAgICduZy1zdHlsZSc6ICd7XFwnei1pbmRleFxcJzogMTA0MCArIChpbmRleCAmJiAxIHx8IDApICsgaW5kZXgqMTB9JyxcclxuICAgICAgICAgICAgJ3VpYi1tb2RhbC1hbmltYXRpb24tY2xhc3MnOiAnZmFkZScsXHJcbiAgICAgICAgICAgICdtb2RhbC1pbi1jbGFzcyc6ICdpbidcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgaWYgKG1vZGFsLmJhY2tkcm9wQ2xhc3MpIHtcclxuICAgICAgICAgICAgYmFja2Ryb3BEb21FbC5hZGRDbGFzcyhtb2RhbC5iYWNrZHJvcENsYXNzKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAobW9kYWwuYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgIGJhY2tkcm9wRG9tRWwuYXR0cignbW9kYWwtYW5pbWF0aW9uJywgJ3RydWUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgICRjb21waWxlKGJhY2tkcm9wRG9tRWwpKGJhY2tkcm9wU2NvcGUpO1xyXG4gICAgICAgICAgJGFuaW1hdGUuZW50ZXIoYmFja2Ryb3BEb21FbCwgYXBwZW5kVG9FbGVtZW50KTtcclxuICAgICAgICAgIGlmICgkdWliUG9zaXRpb24uaXNTY3JvbGxhYmxlKGFwcGVuZFRvRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgc2Nyb2xsYmFyUGFkZGluZyA9ICR1aWJQb3NpdGlvbi5zY3JvbGxiYXJQYWRkaW5nKGFwcGVuZFRvRWxlbWVudCk7XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxiYXJQYWRkaW5nLmhlaWdodE92ZXJmbG93ICYmIHNjcm9sbGJhclBhZGRpbmcuc2Nyb2xsYmFyV2lkdGgpIHtcclxuICAgICAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQuY3NzKHtwYWRkaW5nUmlnaHQ6IHNjcm9sbGJhclBhZGRpbmcucmlnaHQgKyAncHgnfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjb250ZW50O1xyXG4gICAgICAgIGlmIChtb2RhbC5jb21wb25lbnQpIHtcclxuICAgICAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHNuYWtlX2Nhc2UobW9kYWwuY29tcG9uZW50Lm5hbWUpKTtcclxuICAgICAgICAgIGNvbnRlbnQgPSBhbmd1bGFyLmVsZW1lbnQoY29udGVudCk7XHJcbiAgICAgICAgICBjb250ZW50LmF0dHIoe1xyXG4gICAgICAgICAgICByZXNvbHZlOiAnJHJlc29sdmUnLFxyXG4gICAgICAgICAgICAnbW9kYWwtaW5zdGFuY2UnOiAnJHVpYk1vZGFsSW5zdGFuY2UnLFxyXG4gICAgICAgICAgICBjbG9zZTogJyRjbG9zZSgkdmFsdWUpJyxcclxuICAgICAgICAgICAgZGlzbWlzczogJyRkaXNtaXNzKCR2YWx1ZSknXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29udGVudCA9IG1vZGFsLmNvbnRlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHRvcCBtb2RhbCBpbmRleCBiYXNlZCBvbiB0aGUgaW5kZXggb2YgdGhlIHByZXZpb3VzIHRvcCBtb2RhbFxyXG4gICAgICAgIHRvcE1vZGFsSW5kZXggPSBwcmV2aW91c1RvcE9wZW5lZE1vZGFsID8gcGFyc2VJbnQocHJldmlvdXNUb3BPcGVuZWRNb2RhbC52YWx1ZS5tb2RhbERvbUVsLmF0dHIoJ2luZGV4JyksIDEwKSArIDEgOiAwO1xyXG4gICAgICAgIHZhciBhbmd1bGFyRG9tRWwgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXYgdWliLW1vZGFsLXdpbmRvdz1cIm1vZGFsLXdpbmRvd1wiPjwvZGl2PicpO1xyXG4gICAgICAgIGFuZ3VsYXJEb21FbC5hdHRyKHtcclxuICAgICAgICAgICdjbGFzcyc6ICdtb2RhbCcsXHJcbiAgICAgICAgICAndGVtcGxhdGUtdXJsJzogbW9kYWwud2luZG93VGVtcGxhdGVVcmwsXHJcbiAgICAgICAgICAnd2luZG93LXRvcC1jbGFzcyc6IG1vZGFsLndpbmRvd1RvcENsYXNzLFxyXG4gICAgICAgICAgJ3JvbGUnOiAnZGlhbG9nJyxcclxuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBtb2RhbC5hcmlhTGFiZWxsZWRCeSxcclxuICAgICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogbW9kYWwuYXJpYURlc2NyaWJlZEJ5LFxyXG4gICAgICAgICAgJ3NpemUnOiBtb2RhbC5zaXplLFxyXG4gICAgICAgICAgJ2luZGV4JzogdG9wTW9kYWxJbmRleCxcclxuICAgICAgICAgICdhbmltYXRlJzogJ2FuaW1hdGUnLFxyXG4gICAgICAgICAgJ25nLXN0eWxlJzogJ3tcXCd6LWluZGV4XFwnOiAxMDUwICsgJCR0b3BNb2RhbEluZGV4KjEwLCBkaXNwbGF5OiBcXCdibG9ja1xcJ30nLFxyXG4gICAgICAgICAgJ3RhYmluZGV4JzogLTEsXHJcbiAgICAgICAgICAndWliLW1vZGFsLWFuaW1hdGlvbi1jbGFzcyc6ICdmYWRlJyxcclxuICAgICAgICAgICdtb2RhbC1pbi1jbGFzcyc6ICdpbidcclxuICAgICAgICB9KS5hcHBlbmQoY29udGVudCk7XHJcbiAgICAgICAgaWYgKG1vZGFsLndpbmRvd0NsYXNzKSB7XHJcbiAgICAgICAgICBhbmd1bGFyRG9tRWwuYWRkQ2xhc3MobW9kYWwud2luZG93Q2xhc3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1vZGFsLmFuaW1hdGlvbikge1xyXG4gICAgICAgICAgYW5ndWxhckRvbUVsLmF0dHIoJ21vZGFsLWFuaW1hdGlvbicsICd0cnVlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhcHBlbmRUb0VsZW1lbnQuYWRkQ2xhc3MobW9kYWxCb2R5Q2xhc3MpO1xyXG4gICAgICAgIGlmIChtb2RhbC5zY29wZSkge1xyXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBleHBsaWNpdGx5IGFkZCB0aGUgbW9kYWwgaW5kZXggdG8gdGhlIG1vZGFsIHNjb3BlXHJcbiAgICAgICAgICAvLyBiZWNhdXNlIGl0IGlzIG5lZWRlZCBieSBuZ1N0eWxlIHRvIGNvbXB1dGUgdGhlIHpJbmRleCBwcm9wZXJ0eS5cclxuICAgICAgICAgIG1vZGFsLnNjb3BlLiQkdG9wTW9kYWxJbmRleCA9IHRvcE1vZGFsSW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRhbmltYXRlLmVudGVyKCRjb21waWxlKGFuZ3VsYXJEb21FbCkobW9kYWwuc2NvcGUpLCBhcHBlbmRUb0VsZW1lbnQpO1xyXG5cclxuICAgICAgICBvcGVuZWRXaW5kb3dzLnRvcCgpLnZhbHVlLm1vZGFsRG9tRWwgPSBhbmd1bGFyRG9tRWw7XHJcbiAgICAgICAgb3BlbmVkV2luZG93cy50b3AoKS52YWx1ZS5tb2RhbE9wZW5lciA9IG1vZGFsT3BlbmVyO1xyXG5cclxuICAgICAgICBhcHBseUFyaWFIaWRkZW4oYW5ndWxhckRvbUVsKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYXBwbHlBcmlhSGlkZGVuKGVsKSB7XHJcbiAgICAgICAgICBpZiAoIWVsIHx8IGVsWzBdLnRhZ05hbWUgPT09ICdCT0RZJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZ2V0U2libGluZ3MoZWwpLmZvckVhY2goZnVuY3Rpb24oc2libGluZykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbUlzQWxyZWFkeUhpZGRlbiA9IHNpYmxpbmcuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpID09PSAndHJ1ZScsXHJcbiAgICAgICAgICAgICAgYXJpYUhpZGRlbkNvdW50ID0gcGFyc2VJbnQoc2libGluZy5nZXRBdHRyaWJ1dGUoQVJJQV9ISURERU5fQVRUUklCVVRFX05BTUUpLCAxMCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWFyaWFIaWRkZW5Db3VudCkge1xyXG4gICAgICAgICAgICAgIGFyaWFIaWRkZW5Db3VudCA9IGVsZW1Jc0FscmVhZHlIaWRkZW4gPyAxIDogMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2libGluZy5zZXRBdHRyaWJ1dGUoQVJJQV9ISURERU5fQVRUUklCVVRFX05BTUUsIGFyaWFIaWRkZW5Db3VudCArIDEpO1xyXG4gICAgICAgICAgICBzaWJsaW5nLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGFwcGx5QXJpYUhpZGRlbihlbC5wYXJlbnQoKSk7XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0U2libGluZ3MoZWwpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwucGFyZW50KCkgPyBlbC5wYXJlbnQoKS5jaGlsZHJlbigpIDogW107XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjaGlsZCAhPT0gZWxbMF07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGJyb2FkY2FzdENsb3NpbmcobW9kYWxXaW5kb3csIHJlc3VsdE9yUmVhc29uLCBjbG9zaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuICFtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbFNjb3BlLiRicm9hZGNhc3QoJ21vZGFsLmNsb3NpbmcnLCByZXN1bHRPclJlYXNvbiwgY2xvc2luZykuZGVmYXVsdFByZXZlbnRlZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gdW5oaWRlQmFja2dyb3VuZEVsZW1lbnRzKCkge1xyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoXHJcbiAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbJyArIEFSSUFfSElEREVOX0FUVFJJQlVURV9OQU1FICsgJ10nKSxcclxuICAgICAgICAgIGZ1bmN0aW9uKGhpZGRlbkVsKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmlhSGlkZGVuQ291bnQgPSBwYXJzZUludChoaWRkZW5FbC5nZXRBdHRyaWJ1dGUoQVJJQV9ISURERU5fQVRUUklCVVRFX05BTUUpLCAxMCksXHJcbiAgICAgICAgICAgICAgbmV3SGlkZGVuQ291bnQgPSBhcmlhSGlkZGVuQ291bnQgLSAxO1xyXG4gICAgICAgICAgICBoaWRkZW5FbC5zZXRBdHRyaWJ1dGUoQVJJQV9ISURERU5fQVRUUklCVVRFX05BTUUsIG5ld0hpZGRlbkNvdW50KTtcclxuXHJcbiAgICAgICAgICAgIGlmICghbmV3SGlkZGVuQ291bnQpIHtcclxuICAgICAgICAgICAgICBoaWRkZW5FbC5yZW1vdmVBdHRyaWJ1dGUoQVJJQV9ISURERU5fQVRUUklCVVRFX05BTUUpO1xyXG4gICAgICAgICAgICAgIGhpZGRlbkVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICRtb2RhbFN0YWNrLmNsb3NlID0gZnVuY3Rpb24obW9kYWxJbnN0YW5jZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSk7XHJcbiAgICAgICAgdW5oaWRlQmFja2dyb3VuZEVsZW1lbnRzKCk7XHJcbiAgICAgICAgaWYgKG1vZGFsV2luZG93ICYmIGJyb2FkY2FzdENsb3NpbmcobW9kYWxXaW5kb3csIHJlc3VsdCwgdHJ1ZSkpIHtcclxuICAgICAgICAgIG1vZGFsV2luZG93LnZhbHVlLm1vZGFsU2NvcGUuJCR1aWJEZXN0cnVjdGlvblNjaGVkdWxlZCA9IHRydWU7XHJcbiAgICAgICAgICBtb2RhbFdpbmRvdy52YWx1ZS5kZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICByZW1vdmVNb2RhbFdpbmRvdyhtb2RhbEluc3RhbmNlLCBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbE9wZW5lcik7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAhbW9kYWxXaW5kb3c7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAkbW9kYWxTdGFjay5kaXNtaXNzID0gZnVuY3Rpb24obW9kYWxJbnN0YW5jZSwgcmVhc29uKSB7XHJcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSk7XHJcbiAgICAgICAgdW5oaWRlQmFja2dyb3VuZEVsZW1lbnRzKCk7XHJcbiAgICAgICAgaWYgKG1vZGFsV2luZG93ICYmIGJyb2FkY2FzdENsb3NpbmcobW9kYWxXaW5kb3csIHJlYXNvbiwgZmFsc2UpKSB7XHJcbiAgICAgICAgICBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbFNjb3BlLiQkdWliRGVzdHJ1Y3Rpb25TY2hlZHVsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgbW9kYWxXaW5kb3cudmFsdWUuZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XHJcbiAgICAgICAgICByZW1vdmVNb2RhbFdpbmRvdyhtb2RhbEluc3RhbmNlLCBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbE9wZW5lcik7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICFtb2RhbFdpbmRvdztcclxuICAgICAgfTtcclxuXHJcbiAgICAgICRtb2RhbFN0YWNrLmRpc21pc3NBbGwgPSBmdW5jdGlvbihyZWFzb24pIHtcclxuICAgICAgICB2YXIgdG9wTW9kYWwgPSB0aGlzLmdldFRvcCgpO1xyXG4gICAgICAgIHdoaWxlICh0b3BNb2RhbCAmJiB0aGlzLmRpc21pc3ModG9wTW9kYWwua2V5LCByZWFzb24pKSB7XHJcbiAgICAgICAgICB0b3BNb2RhbCA9IHRoaXMuZ2V0VG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgJG1vZGFsU3RhY2suZ2V0VG9wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wZW5lZFdpbmRvd3MudG9wKCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAkbW9kYWxTdGFjay5tb2RhbFJlbmRlcmVkID0gZnVuY3Rpb24obW9kYWxJbnN0YW5jZSkge1xyXG4gICAgICAgIHZhciBtb2RhbFdpbmRvdyA9IG9wZW5lZFdpbmRvd3MuZ2V0KG1vZGFsSW5zdGFuY2UpO1xyXG4gICAgICAgIGlmIChtb2RhbFdpbmRvdykge1xyXG4gICAgICAgICAgbW9kYWxXaW5kb3cudmFsdWUucmVuZGVyRGVmZXJyZWQucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgICRtb2RhbFN0YWNrLmZvY3VzRmlyc3RGb2N1c2FibGVFbGVtZW50ID0gZnVuY3Rpb24obGlzdCkge1xyXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGxpc3RbMF0uZm9jdXMoKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAkbW9kYWxTdGFjay5mb2N1c0xhc3RGb2N1c2FibGVFbGVtZW50ID0gZnVuY3Rpb24obGlzdCkge1xyXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGxpc3RbbGlzdC5sZW5ndGggLSAxXS5mb2N1cygpO1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgICRtb2RhbFN0YWNrLmlzTW9kYWxGb2N1c2VkID0gZnVuY3Rpb24oZXZ0LCBtb2RhbFdpbmRvdykge1xyXG4gICAgICAgIGlmIChldnQgJiYgbW9kYWxXaW5kb3cpIHtcclxuICAgICAgICAgIHZhciBtb2RhbERvbUVsID0gbW9kYWxXaW5kb3cudmFsdWUubW9kYWxEb21FbDtcclxuICAgICAgICAgIGlmIChtb2RhbERvbUVsICYmIG1vZGFsRG9tRWwubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZXZ0LnRhcmdldCB8fCBldnQuc3JjRWxlbWVudCkgPT09IG1vZGFsRG9tRWxbMF07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgICRtb2RhbFN0YWNrLmlzRm9jdXNJbkZpcnN0SXRlbSA9IGZ1bmN0aW9uKGV2dCwgbGlzdCkge1xyXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHJldHVybiAoZXZ0LnRhcmdldCB8fCBldnQuc3JjRWxlbWVudCkgPT09IGxpc3RbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgICRtb2RhbFN0YWNrLmlzRm9jdXNJbkxhc3RJdGVtID0gZnVuY3Rpb24oZXZ0LCBsaXN0KSB7XHJcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIChldnQudGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50KSA9PT0gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAkbW9kYWxTdGFjay5sb2FkRm9jdXNFbGVtZW50TGlzdCA9IGZ1bmN0aW9uKG1vZGFsV2luZG93KSB7XHJcbiAgICAgICAgaWYgKG1vZGFsV2luZG93KSB7XHJcbiAgICAgICAgICB2YXIgbW9kYWxEb21FMSA9IG1vZGFsV2luZG93LnZhbHVlLm1vZGFsRG9tRWw7XHJcbiAgICAgICAgICBpZiAobW9kYWxEb21FMSAmJiBtb2RhbERvbUUxLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBtb2RhbERvbUUxWzBdLnF1ZXJ5U2VsZWN0b3JBbGwodGFiYmFibGVTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cyA/XHJcbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWaXNpYmxlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgIH0pIDogZWxlbWVudHM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuICRtb2RhbFN0YWNrO1xyXG4gICAgfV0pXHJcblxyXG4gIC5wcm92aWRlcignJHVpYk1vZGFsJywgZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgJG1vZGFsUHJvdmlkZXIgPSB7XHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICBhbmltYXRpb246IHRydWUsXHJcbiAgICAgICAgYmFja2Ryb3A6IHRydWUsIC8vY2FuIGFsc28gYmUgZmFsc2Ugb3IgJ3N0YXRpYydcclxuICAgICAgICBrZXlib2FyZDogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICAkZ2V0OiBbJyRyb290U2NvcGUnLCAnJHEnLCAnJGRvY3VtZW50JywgJyR0ZW1wbGF0ZVJlcXVlc3QnLCAnJGNvbnRyb2xsZXInLCAnJHVpYlJlc29sdmUnLCAnJHVpYk1vZGFsU3RhY2snLFxyXG4gICAgICAgIGZ1bmN0aW9uICgkcm9vdFNjb3BlLCAkcSwgJGRvY3VtZW50LCAkdGVtcGxhdGVSZXF1ZXN0LCAkY29udHJvbGxlciwgJHVpYlJlc29sdmUsICRtb2RhbFN0YWNrKSB7XHJcbiAgICAgICAgICB2YXIgJG1vZGFsID0ge307XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0VGVtcGxhdGVQcm9taXNlKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMudGVtcGxhdGUgPyAkcS53aGVuKG9wdGlvbnMudGVtcGxhdGUpIDpcclxuICAgICAgICAgICAgICAkdGVtcGxhdGVSZXF1ZXN0KGFuZ3VsYXIuaXNGdW5jdGlvbihvcHRpb25zLnRlbXBsYXRlVXJsKSA/XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRlbXBsYXRlVXJsKCkgOiBvcHRpb25zLnRlbXBsYXRlVXJsKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgcHJvbWlzZUNoYWluID0gbnVsbDtcclxuICAgICAgICAgICRtb2RhbC5nZXRQcm9taXNlQ2hhaW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VDaGFpbjtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgJG1vZGFsLm9wZW4gPSBmdW5jdGlvbihtb2RhbE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIG1vZGFsUmVzdWx0RGVmZXJyZWQgPSAkcS5kZWZlcigpO1xyXG4gICAgICAgICAgICB2YXIgbW9kYWxPcGVuZWREZWZlcnJlZCA9ICRxLmRlZmVyKCk7XHJcbiAgICAgICAgICAgIHZhciBtb2RhbENsb3NlZERlZmVycmVkID0gJHEuZGVmZXIoKTtcclxuICAgICAgICAgICAgdmFyIG1vZGFsUmVuZGVyRGVmZXJyZWQgPSAkcS5kZWZlcigpO1xyXG5cclxuICAgICAgICAgICAgLy9wcmVwYXJlIGFuIGluc3RhbmNlIG9mIGEgbW9kYWwgdG8gYmUgaW5qZWN0ZWQgaW50byBjb250cm9sbGVycyBhbmQgcmV0dXJuZWQgdG8gYSBjYWxsZXJcclxuICAgICAgICAgICAgdmFyIG1vZGFsSW5zdGFuY2UgPSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0OiBtb2RhbFJlc3VsdERlZmVycmVkLnByb21pc2UsXHJcbiAgICAgICAgICAgICAgb3BlbmVkOiBtb2RhbE9wZW5lZERlZmVycmVkLnByb21pc2UsXHJcbiAgICAgICAgICAgICAgY2xvc2VkOiBtb2RhbENsb3NlZERlZmVycmVkLnByb21pc2UsXHJcbiAgICAgICAgICAgICAgcmVuZGVyZWQ6IG1vZGFsUmVuZGVyRGVmZXJyZWQucHJvbWlzZSxcclxuICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICRtb2RhbFN0YWNrLmNsb3NlKG1vZGFsSW5zdGFuY2UsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBkaXNtaXNzOiBmdW5jdGlvbiAocmVhc29uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1vZGFsU3RhY2suZGlzbWlzcyhtb2RhbEluc3RhbmNlLCByZWFzb24pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vbWVyZ2UgYW5kIGNsZWFuIHVwIG9wdGlvbnNcclxuICAgICAgICAgICAgbW9kYWxPcHRpb25zID0gYW5ndWxhci5leHRlbmQoe30sICRtb2RhbFByb3ZpZGVyLm9wdGlvbnMsIG1vZGFsT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIG1vZGFsT3B0aW9ucy5yZXNvbHZlID0gbW9kYWxPcHRpb25zLnJlc29sdmUgfHwge307XHJcbiAgICAgICAgICAgIG1vZGFsT3B0aW9ucy5hcHBlbmRUbyA9IG1vZGFsT3B0aW9ucy5hcHBlbmRUbyB8fCAkZG9jdW1lbnQuZmluZCgnYm9keScpLmVxKDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFtb2RhbE9wdGlvbnMuYXBwZW5kVG8ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcHBlbmRUbyBlbGVtZW50IG5vdCBmb3VuZC4gTWFrZSBzdXJlIHRoYXQgdGhlIGVsZW1lbnQgcGFzc2VkIGlzIGluIERPTS4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy92ZXJpZnkgb3B0aW9uc1xyXG4gICAgICAgICAgICBpZiAoIW1vZGFsT3B0aW9ucy5jb21wb25lbnQgJiYgIW1vZGFsT3B0aW9ucy50ZW1wbGF0ZSAmJiAhbW9kYWxPcHRpb25zLnRlbXBsYXRlVXJsKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgb2YgY29tcG9uZW50IG9yIHRlbXBsYXRlIG9yIHRlbXBsYXRlVXJsIG9wdGlvbnMgaXMgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUFuZFJlc29sdmVQcm9taXNlO1xyXG4gICAgICAgICAgICBpZiAobW9kYWxPcHRpb25zLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgIHRlbXBsYXRlQW5kUmVzb2x2ZVByb21pc2UgPSAkcS53aGVuKCR1aWJSZXNvbHZlLnJlc29sdmUobW9kYWxPcHRpb25zLnJlc29sdmUsIHt9LCBudWxsLCBudWxsKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGVtcGxhdGVBbmRSZXNvbHZlUHJvbWlzZSA9XHJcbiAgICAgICAgICAgICAgICAkcS5hbGwoW2dldFRlbXBsYXRlUHJvbWlzZShtb2RhbE9wdGlvbnMpLCAkdWliUmVzb2x2ZS5yZXNvbHZlKG1vZGFsT3B0aW9ucy5yZXNvbHZlLCB7fSwgbnVsbCwgbnVsbCldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZVdpdGhUZW1wbGF0ZSgpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVBbmRSZXNvbHZlUHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGV4aXN0aW5nIHByb21pc2UgY2hhaW4uXHJcbiAgICAgICAgICAgIC8vIFRoZW4gc3dpdGNoIHRvIG91ciBvd24gY29tYmluZWQgcHJvbWlzZSBkZXBlbmRlbmN5IChyZWdhcmRsZXNzIG9mIGhvdyB0aGUgcHJldmlvdXMgbW9kYWwgZmFyZWQpLlxyXG4gICAgICAgICAgICAvLyBUaGVuIGFkZCB0byAkbW9kYWxTdGFjayBhbmQgcmVzb2x2ZSBvcGVuZWQuXHJcbiAgICAgICAgICAgIC8vIEZpbmFsbHkgY2xlYW4gdXAgdGhlIGNoYWluIHZhcmlhYmxlIGlmIG5vIHN1YnNlcXVlbnQgbW9kYWwgaGFzIG92ZXJ3cml0dGVuIGl0LlxyXG4gICAgICAgICAgICB2YXIgc2FtZVByb21pc2U7XHJcbiAgICAgICAgICAgIHNhbWVQcm9taXNlID0gcHJvbWlzZUNoYWluID0gJHEuYWxsKFtwcm9taXNlQ2hhaW5dKVxyXG4gICAgICAgICAgICAgIC50aGVuKHJlc29sdmVXaXRoVGVtcGxhdGUsIHJlc29sdmVXaXRoVGVtcGxhdGUpXHJcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gcmVzb2x2ZVN1Y2Nlc3ModHBsQW5kVmFycykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVkU2NvcGUgPSBtb2RhbE9wdGlvbnMuc2NvcGUgfHwgJHJvb3RTY29wZTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kYWxTY29wZSA9IHByb3ZpZGVkU2NvcGUuJG5ldygpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWxTY29wZS4kY2xvc2UgPSBtb2RhbEluc3RhbmNlLmNsb3NlO1xyXG4gICAgICAgICAgICAgICAgbW9kYWxTY29wZS4kZGlzbWlzcyA9IG1vZGFsSW5zdGFuY2UuZGlzbWlzcztcclxuXHJcbiAgICAgICAgICAgICAgICBtb2RhbFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFtb2RhbFNjb3BlLiQkdWliRGVzdHJ1Y3Rpb25TY2hlZHVsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RhbFNjb3BlLiRkaXNtaXNzKCckdWliVW5zY2hlZHVsZWREZXN0cnVjdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kYWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgIHNjb3BlOiBtb2RhbFNjb3BlLFxyXG4gICAgICAgICAgICAgICAgICBkZWZlcnJlZDogbW9kYWxSZXN1bHREZWZlcnJlZCxcclxuICAgICAgICAgICAgICAgICAgcmVuZGVyRGVmZXJyZWQ6IG1vZGFsUmVuZGVyRGVmZXJyZWQsXHJcbiAgICAgICAgICAgICAgICAgIGNsb3NlZERlZmVycmVkOiBtb2RhbENsb3NlZERlZmVycmVkLFxyXG4gICAgICAgICAgICAgICAgICBhbmltYXRpb246IG1vZGFsT3B0aW9ucy5hbmltYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgIGJhY2tkcm9wOiBtb2RhbE9wdGlvbnMuYmFja2Ryb3AsXHJcbiAgICAgICAgICAgICAgICAgIGtleWJvYXJkOiBtb2RhbE9wdGlvbnMua2V5Ym9hcmQsXHJcbiAgICAgICAgICAgICAgICAgIGJhY2tkcm9wQ2xhc3M6IG1vZGFsT3B0aW9ucy5iYWNrZHJvcENsYXNzLFxyXG4gICAgICAgICAgICAgICAgICB3aW5kb3dUb3BDbGFzczogbW9kYWxPcHRpb25zLndpbmRvd1RvcENsYXNzLFxyXG4gICAgICAgICAgICAgICAgICB3aW5kb3dDbGFzczogbW9kYWxPcHRpb25zLndpbmRvd0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgICB3aW5kb3dUZW1wbGF0ZVVybDogbW9kYWxPcHRpb25zLndpbmRvd1RlbXBsYXRlVXJsLFxyXG4gICAgICAgICAgICAgICAgICBhcmlhTGFiZWxsZWRCeTogbW9kYWxPcHRpb25zLmFyaWFMYWJlbGxlZEJ5LFxyXG4gICAgICAgICAgICAgICAgICBhcmlhRGVzY3JpYmVkQnk6IG1vZGFsT3B0aW9ucy5hcmlhRGVzY3JpYmVkQnksXHJcbiAgICAgICAgICAgICAgICAgIHNpemU6IG1vZGFsT3B0aW9ucy5zaXplLFxyXG4gICAgICAgICAgICAgICAgICBvcGVuZWRDbGFzczogbW9kYWxPcHRpb25zLm9wZW5lZENsYXNzLFxyXG4gICAgICAgICAgICAgICAgICBhcHBlbmRUbzogbW9kYWxPcHRpb25zLmFwcGVuZFRvXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBjdHJsSW5zdGFuY2UsIGN0cmxJbnN0YW50aWF0ZSwgY3RybExvY2FscyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtb2RhbE9wdGlvbnMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdExvY2Fscyhjb21wb25lbnQsIGZhbHNlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5uYW1lID0gbW9kYWxPcHRpb25zLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgICAgbW9kYWwuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RhbE9wdGlvbnMuY29udHJvbGxlcikge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RMb2NhbHMoY3RybExvY2FscywgdHJ1ZSwgZmFsc2UsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gdGhlIHRoaXJkIHBhcmFtIHdpbGwgbWFrZSB0aGUgY29udHJvbGxlciBpbnN0YW50aWF0ZSBsYXRlcixwcml2YXRlIGFwaVxyXG4gICAgICAgICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvYmxvYi9tYXN0ZXIvc3JjL25nL2NvbnRyb2xsZXIuanMjTDEyNlxyXG4gICAgICAgICAgICAgICAgICBjdHJsSW5zdGFudGlhdGUgPSAkY29udHJvbGxlcihtb2RhbE9wdGlvbnMuY29udHJvbGxlciwgY3RybExvY2FscywgdHJ1ZSwgbW9kYWxPcHRpb25zLmNvbnRyb2xsZXJBcyk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChtb2RhbE9wdGlvbnMuY29udHJvbGxlckFzICYmIG1vZGFsT3B0aW9ucy5iaW5kVG9Db250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3RybEluc3RhbmNlID0gY3RybEluc3RhbnRpYXRlLmluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0cmxJbnN0YW5jZS4kY2xvc2UgPSBtb2RhbFNjb3BlLiRjbG9zZTtcclxuICAgICAgICAgICAgICAgICAgICBjdHJsSW5zdGFuY2UuJGRpc21pc3MgPSBtb2RhbFNjb3BlLiRkaXNtaXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZXh0ZW5kKGN0cmxJbnN0YW5jZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgJHJlc29sdmU6IGN0cmxMb2NhbHMuJHNjb3BlLiRyZXNvbHZlXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcHJvdmlkZWRTY29wZSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIGN0cmxJbnN0YW5jZSA9IGN0cmxJbnN0YW50aWF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihjdHJsSW5zdGFuY2UuJG9uSW5pdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHJsSW5zdGFuY2UuJG9uSW5pdCgpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFtb2RhbE9wdGlvbnMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgIG1vZGFsLmNvbnRlbnQgPSB0cGxBbmRWYXJzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICRtb2RhbFN0YWNrLm9wZW4obW9kYWxJbnN0YW5jZSwgbW9kYWwpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWxPcGVuZWREZWZlcnJlZC5yZXNvbHZlKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbnN0cnVjdExvY2FscyhvYmosIHRlbXBsYXRlLCBpbnN0YW5jZU9uU2NvcGUsIGluamVjdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgb2JqLiRzY29wZSA9IG1vZGFsU2NvcGU7XHJcbiAgICAgICAgICAgICAgICAgIG9iai4kc2NvcGUuJHJlc29sdmUgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlT25TY29wZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iai4kc2NvcGUuJHVpYk1vZGFsSW5zdGFuY2UgPSBtb2RhbEluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iai4kdWliTW9kYWxJbnN0YW5jZSA9IG1vZGFsSW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlcyA9IHRlbXBsYXRlID8gdHBsQW5kVmFyc1sxXSA6IHRwbEFuZFZhcnM7XHJcbiAgICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXNvbHZlcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmplY3RhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRzY29wZS4kcmVzb2x2ZVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiByZXNvbHZlRXJyb3IocmVhc29uKSB7XHJcbiAgICAgICAgICAgICAgbW9kYWxPcGVuZWREZWZlcnJlZC5yZWplY3QocmVhc29uKTtcclxuICAgICAgICAgICAgICBtb2RhbFJlc3VsdERlZmVycmVkLnJlamVjdChyZWFzb24pO1xyXG4gICAgICAgICAgICB9KVsnZmluYWxseSddKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIGlmIChwcm9taXNlQ2hhaW4gPT09IHNhbWVQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlQ2hhaW4gPSBudWxsO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbW9kYWxJbnN0YW5jZTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgcmV0dXJuICRtb2RhbDtcclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuICRtb2RhbFByb3ZpZGVyO1xyXG4gIH0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wYWdpbmcnLCBbXSlcclxuLyoqXHJcbiAqIEhlbHBlciBpbnRlcm5hbCBzZXJ2aWNlIGZvciBnZW5lcmF0aW5nIGNvbW1vbiBjb250cm9sbGVyIGNvZGUgYmV0d2VlbiB0aGVcclxuICogcGFnZXIgYW5kIHBhZ2luYXRpb24gY29tcG9uZW50c1xyXG4gKi9cclxuLmZhY3RvcnkoJ3VpYlBhZ2luZycsIFsnJHBhcnNlJywgZnVuY3Rpb24oJHBhcnNlKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGNyZWF0ZTogZnVuY3Rpb24oY3RybCwgJHNjb3BlLCAkYXR0cnMpIHtcclxuICAgICAgY3RybC5zZXROdW1QYWdlcyA9ICRhdHRycy5udW1QYWdlcyA/ICRwYXJzZSgkYXR0cnMubnVtUGFnZXMpLmFzc2lnbiA6IGFuZ3VsYXIubm9vcDtcclxuICAgICAgY3RybC5uZ01vZGVsQ3RybCA9IHsgJHNldFZpZXdWYWx1ZTogYW5ndWxhci5ub29wIH07IC8vIG51bGxNb2RlbEN0cmxcclxuICAgICAgY3RybC5fd2F0Y2hlcnMgPSBbXTtcclxuXHJcbiAgICAgIGN0cmwuaW5pdCA9IGZ1bmN0aW9uKG5nTW9kZWxDdHJsLCBjb25maWcpIHtcclxuICAgICAgICBjdHJsLm5nTW9kZWxDdHJsID0gbmdNb2RlbEN0cmw7XHJcbiAgICAgICAgY3RybC5jb25maWcgPSBjb25maWc7XHJcblxyXG4gICAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGN0cmwucmVuZGVyKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCRhdHRycy5pdGVtc1BlclBhZ2UpIHtcclxuICAgICAgICAgIGN0cmwuX3dhdGNoZXJzLnB1c2goJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRhdHRycy5pdGVtc1BlclBhZ2UsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGN0cmwuaXRlbXNQZXJQYWdlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcclxuICAgICAgICAgICAgJHNjb3BlLnRvdGFsUGFnZXMgPSBjdHJsLmNhbGN1bGF0ZVRvdGFsUGFnZXMoKTtcclxuICAgICAgICAgICAgY3RybC51cGRhdGVQYWdlKCk7XHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGN0cmwuaXRlbXNQZXJQYWdlID0gY29uZmlnLml0ZW1zUGVyUGFnZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICRzY29wZS4kd2F0Y2goJ3RvdGFsSXRlbXMnLCBmdW5jdGlvbihuZXdUb3RhbCwgb2xkVG90YWwpIHtcclxuICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChuZXdUb3RhbCkgfHwgbmV3VG90YWwgIT09IG9sZFRvdGFsKSB7XHJcbiAgICAgICAgICAgICRzY29wZS50b3RhbFBhZ2VzID0gY3RybC5jYWxjdWxhdGVUb3RhbFBhZ2VzKCk7XHJcbiAgICAgICAgICAgIGN0cmwudXBkYXRlUGFnZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgY3RybC5jYWxjdWxhdGVUb3RhbFBhZ2VzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRvdGFsUGFnZXMgPSBjdHJsLml0ZW1zUGVyUGFnZSA8IDEgPyAxIDogTWF0aC5jZWlsKCRzY29wZS50b3RhbEl0ZW1zIC8gY3RybC5pdGVtc1BlclBhZ2UpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0b3RhbFBhZ2VzIHx8IDAsIDEpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgY3RybC5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAkc2NvcGUucGFnZSA9IHBhcnNlSW50KGN0cmwubmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSwgMTApIHx8IDE7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAkc2NvcGUuc2VsZWN0UGFnZSA9IGZ1bmN0aW9uKHBhZ2UsIGV2dCkge1xyXG4gICAgICAgIGlmIChldnQpIHtcclxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNsaWNrQWxsb3dlZCA9ICEkc2NvcGUubmdEaXNhYmxlZCB8fCAhZXZ0O1xyXG4gICAgICAgIGlmIChjbGlja0FsbG93ZWQgJiYgJHNjb3BlLnBhZ2UgIT09IHBhZ2UgJiYgcGFnZSA+IDAgJiYgcGFnZSA8PSAkc2NvcGUudG90YWxQYWdlcykge1xyXG4gICAgICAgICAgaWYgKGV2dCAmJiBldnQudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGV2dC50YXJnZXQuYmx1cigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY3RybC5uZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKHBhZ2UpO1xyXG4gICAgICAgICAgY3RybC5uZ01vZGVsQ3RybC4kcmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgJHNjb3BlLmdldFRleHQgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICByZXR1cm4gJHNjb3BlW2tleSArICdUZXh0J10gfHwgY3RybC5jb25maWdba2V5ICsgJ1RleHQnXTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgICRzY29wZS5ub1ByZXZpb3VzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICRzY29wZS5wYWdlID09PSAxO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgJHNjb3BlLm5vTmV4dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAkc2NvcGUucGFnZSA9PT0gJHNjb3BlLnRvdGFsUGFnZXM7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjdHJsLnVwZGF0ZVBhZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBjdHJsLnNldE51bVBhZ2VzKCRzY29wZS4kcGFyZW50LCAkc2NvcGUudG90YWxQYWdlcyk7IC8vIFJlYWRvbmx5IHZhcmlhYmxlXHJcblxyXG4gICAgICAgIGlmICgkc2NvcGUucGFnZSA+ICRzY29wZS50b3RhbFBhZ2VzKSB7XHJcbiAgICAgICAgICAkc2NvcGUuc2VsZWN0UGFnZSgkc2NvcGUudG90YWxQYWdlcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGN0cmwubmdNb2RlbEN0cmwuJHJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgd2hpbGUgKGN0cmwuX3dhdGNoZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgY3RybC5fd2F0Y2hlcnMuc2hpZnQoKSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wYWdlcicsIFsndWkuYm9vdHN0cmFwLnBhZ2luZycsICd1aS5ib290c3RyYXAudGFiaW5kZXgnXSlcclxuXHJcbi5jb250cm9sbGVyKCdVaWJQYWdlckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAndWliUGFnaW5nJywgJ3VpYlBhZ2VyQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsIHVpYlBhZ2luZywgdWliUGFnZXJDb25maWcpIHtcclxuICAkc2NvcGUuYWxpZ24gPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuYWxpZ24pID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLmFsaWduKSA6IHVpYlBhZ2VyQ29uZmlnLmFsaWduO1xyXG5cclxuICB1aWJQYWdpbmcuY3JlYXRlKHRoaXMsICRzY29wZSwgJGF0dHJzKTtcclxufV0pXHJcblxyXG4uY29uc3RhbnQoJ3VpYlBhZ2VyQ29uZmlnJywge1xyXG4gIGl0ZW1zUGVyUGFnZTogMTAsXHJcbiAgcHJldmlvdXNUZXh0OiAnwqsgUHJldmlvdXMnLFxyXG4gIG5leHRUZXh0OiAnTmV4dCDCuycsXHJcbiAgYWxpZ246IHRydWVcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYlBhZ2VyJywgWyd1aWJQYWdlckNvbmZpZycsIGZ1bmN0aW9uKHVpYlBhZ2VyQ29uZmlnKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHNjb3BlOiB7XHJcbiAgICAgIHRvdGFsSXRlbXM6ICc9JyxcclxuICAgICAgcHJldmlvdXNUZXh0OiAnQCcsXHJcbiAgICAgIG5leHRUZXh0OiAnQCcsXHJcbiAgICAgIG5nRGlzYWJsZWQ6ICc9J1xyXG4gICAgfSxcclxuICAgIHJlcXVpcmU6IFsndWliUGFnZXInLCAnP25nTW9kZWwnXSxcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICBjb250cm9sbGVyOiAnVWliUGFnZXJDb250cm9sbGVyJyxcclxuICAgIGNvbnRyb2xsZXJBczogJ3BhZ2VyJyxcclxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xyXG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9wYWdlci9wYWdlci5odG1sJztcclxuICAgIH0sXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XHJcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ3BhZ2VyJyk7XHJcbiAgICAgIHZhciBwYWdpbmF0aW9uQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xyXG5cclxuICAgICAgaWYgKCFuZ01vZGVsQ3RybCkge1xyXG4gICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZyBpZiBubyBuZy1tb2RlbFxyXG4gICAgICB9XHJcblxyXG4gICAgICBwYWdpbmF0aW9uQ3RybC5pbml0KG5nTW9kZWxDdHJsLCB1aWJQYWdlckNvbmZpZyk7XHJcbiAgICB9XHJcbiAgfTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wYWdpbmF0aW9uJywgWyd1aS5ib290c3RyYXAucGFnaW5nJywgJ3VpLmJvb3RzdHJhcC50YWJpbmRleCddKVxyXG4uY29udHJvbGxlcignVWliUGFnaW5hdGlvbkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAnJHBhcnNlJywgJ3VpYlBhZ2luZycsICd1aWJQYWdpbmF0aW9uQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsICRwYXJzZSwgdWliUGFnaW5nLCB1aWJQYWdpbmF0aW9uQ29uZmlnKSB7XHJcbiAgdmFyIGN0cmwgPSB0aGlzO1xyXG4gIC8vIFNldHVwIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xyXG4gIHZhciBtYXhTaXplID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLm1heFNpemUpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLm1heFNpemUpIDogdWliUGFnaW5hdGlvbkNvbmZpZy5tYXhTaXplLFxyXG4gICAgcm90YXRlID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnJvdGF0ZSkgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMucm90YXRlKSA6IHVpYlBhZ2luYXRpb25Db25maWcucm90YXRlLFxyXG4gICAgZm9yY2VFbGxpcHNlcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5mb3JjZUVsbGlwc2VzKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5mb3JjZUVsbGlwc2VzKSA6IHVpYlBhZ2luYXRpb25Db25maWcuZm9yY2VFbGxpcHNlcyxcclxuICAgIGJvdW5kYXJ5TGlua051bWJlcnMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuYm91bmRhcnlMaW5rTnVtYmVycykgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuYm91bmRhcnlMaW5rTnVtYmVycykgOiB1aWJQYWdpbmF0aW9uQ29uZmlnLmJvdW5kYXJ5TGlua051bWJlcnMsXHJcbiAgICBwYWdlTGFiZWwgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMucGFnZUxhYmVsKSA/IGZ1bmN0aW9uKGlkeCkgeyByZXR1cm4gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnBhZ2VMYWJlbCwgeyRwYWdlOiBpZHh9KTsgfSA6IGFuZ3VsYXIuaWRlbnRpdHk7XHJcbiAgJHNjb3BlLmJvdW5kYXJ5TGlua3MgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuYm91bmRhcnlMaW5rcykgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuYm91bmRhcnlMaW5rcykgOiB1aWJQYWdpbmF0aW9uQ29uZmlnLmJvdW5kYXJ5TGlua3M7XHJcbiAgJHNjb3BlLmRpcmVjdGlvbkxpbmtzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmRpcmVjdGlvbkxpbmtzKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5kaXJlY3Rpb25MaW5rcykgOiB1aWJQYWdpbmF0aW9uQ29uZmlnLmRpcmVjdGlvbkxpbmtzO1xyXG4gICRhdHRycy4kc2V0KCdyb2xlJywgJ21lbnUnKTtcclxuXHJcbiAgdWliUGFnaW5nLmNyZWF0ZSh0aGlzLCAkc2NvcGUsICRhdHRycyk7XHJcblxyXG4gIGlmICgkYXR0cnMubWF4U2l6ZSkge1xyXG4gICAgY3RybC5fd2F0Y2hlcnMucHVzaCgkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5tYXhTaXplKSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgbWF4U2l6ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XHJcbiAgICAgIGN0cmwucmVuZGVyKCk7XHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgcGFnZSBvYmplY3QgdXNlZCBpbiB0ZW1wbGF0ZVxyXG4gIGZ1bmN0aW9uIG1ha2VQYWdlKG51bWJlciwgdGV4dCwgaXNBY3RpdmUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG51bWJlcjogbnVtYmVyLFxyXG4gICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICBhY3RpdmU6IGlzQWN0aXZlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UGFnZXMoY3VycmVudFBhZ2UsIHRvdGFsUGFnZXMpIHtcclxuICAgIHZhciBwYWdlcyA9IFtdO1xyXG5cclxuICAgIC8vIERlZmF1bHQgcGFnZSBsaW1pdHNcclxuICAgIHZhciBzdGFydFBhZ2UgPSAxLCBlbmRQYWdlID0gdG90YWxQYWdlcztcclxuICAgIHZhciBpc01heFNpemVkID0gYW5ndWxhci5pc0RlZmluZWQobWF4U2l6ZSkgJiYgbWF4U2l6ZSA8IHRvdGFsUGFnZXM7XHJcblxyXG4gICAgLy8gcmVjb21wdXRlIGlmIG1heFNpemVcclxuICAgIGlmIChpc01heFNpemVkKSB7XHJcbiAgICAgIGlmIChyb3RhdGUpIHtcclxuICAgICAgICAvLyBDdXJyZW50IHBhZ2UgaXMgZGlzcGxheWVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIHZpc2libGUgb25lc1xyXG4gICAgICAgIHN0YXJ0UGFnZSA9IE1hdGgubWF4KGN1cnJlbnRQYWdlIC0gTWF0aC5mbG9vcihtYXhTaXplIC8gMiksIDEpO1xyXG4gICAgICAgIGVuZFBhZ2UgPSBzdGFydFBhZ2UgKyBtYXhTaXplIC0gMTtcclxuXHJcbiAgICAgICAgLy8gQWRqdXN0IGlmIGxpbWl0IGlzIGV4Y2VlZGVkXHJcbiAgICAgICAgaWYgKGVuZFBhZ2UgPiB0b3RhbFBhZ2VzKSB7XHJcbiAgICAgICAgICBlbmRQYWdlID0gdG90YWxQYWdlcztcclxuICAgICAgICAgIHN0YXJ0UGFnZSA9IGVuZFBhZ2UgLSBtYXhTaXplICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVmlzaWJsZSBwYWdlcyBhcmUgcGFnaW5hdGVkIHdpdGggbWF4U2l6ZVxyXG4gICAgICAgIHN0YXJ0UGFnZSA9IChNYXRoLmNlaWwoY3VycmVudFBhZ2UgLyBtYXhTaXplKSAtIDEpICogbWF4U2l6ZSArIDE7XHJcblxyXG4gICAgICAgIC8vIEFkanVzdCBsYXN0IHBhZ2UgaWYgbGltaXQgaXMgZXhjZWVkZWRcclxuICAgICAgICBlbmRQYWdlID0gTWF0aC5taW4oc3RhcnRQYWdlICsgbWF4U2l6ZSAtIDEsIHRvdGFsUGFnZXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIHBhZ2UgbnVtYmVyIGxpbmtzXHJcbiAgICBmb3IgKHZhciBudW1iZXIgPSBzdGFydFBhZ2U7IG51bWJlciA8PSBlbmRQYWdlOyBudW1iZXIrKykge1xyXG4gICAgICB2YXIgcGFnZSA9IG1ha2VQYWdlKG51bWJlciwgcGFnZUxhYmVsKG51bWJlciksIG51bWJlciA9PT0gY3VycmVudFBhZ2UpO1xyXG4gICAgICBwYWdlcy5wdXNoKHBhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBsaW5rcyB0byBtb3ZlIGJldHdlZW4gcGFnZSBzZXRzXHJcbiAgICBpZiAoaXNNYXhTaXplZCAmJiBtYXhTaXplID4gMCAmJiAoIXJvdGF0ZSB8fCBmb3JjZUVsbGlwc2VzIHx8IGJvdW5kYXJ5TGlua051bWJlcnMpKSB7XHJcbiAgICAgIGlmIChzdGFydFBhZ2UgPiAxKSB7XHJcbiAgICAgICAgaWYgKCFib3VuZGFyeUxpbmtOdW1iZXJzIHx8IHN0YXJ0UGFnZSA+IDMpIHsgLy9uZWVkIGVsbGlwc2lzIGZvciBhbGwgb3B0aW9ucyB1bmxlc3MgcmFuZ2UgaXMgdG9vIGNsb3NlIHRvIGJlZ2lubmluZ1xyXG4gICAgICAgIHZhciBwcmV2aW91c1BhZ2VTZXQgPSBtYWtlUGFnZShzdGFydFBhZ2UgLSAxLCAnLi4uJywgZmFsc2UpO1xyXG4gICAgICAgIHBhZ2VzLnVuc2hpZnQocHJldmlvdXNQYWdlU2V0KTtcclxuICAgICAgfVxyXG4gICAgICAgIGlmIChib3VuZGFyeUxpbmtOdW1iZXJzKSB7XHJcbiAgICAgICAgICBpZiAoc3RhcnRQYWdlID09PSAzKSB7IC8vbmVlZCB0byByZXBsYWNlIGVsbGlwc2lzIHdoZW4gdGhlIGJ1dHRvbnMgd291bGQgYmUgc2VxdWVudGlhbFxyXG4gICAgICAgICAgICB2YXIgc2Vjb25kUGFnZUxpbmsgPSBtYWtlUGFnZSgyLCAnMicsIGZhbHNlKTtcclxuICAgICAgICAgICAgcGFnZXMudW5zaGlmdChzZWNvbmRQYWdlTGluayk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvL2FkZCB0aGUgZmlyc3QgcGFnZVxyXG4gICAgICAgICAgdmFyIGZpcnN0UGFnZUxpbmsgPSBtYWtlUGFnZSgxLCAnMScsIGZhbHNlKTtcclxuICAgICAgICAgIHBhZ2VzLnVuc2hpZnQoZmlyc3RQYWdlTGluayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZW5kUGFnZSA8IHRvdGFsUGFnZXMpIHtcclxuICAgICAgICBpZiAoIWJvdW5kYXJ5TGlua051bWJlcnMgfHwgZW5kUGFnZSA8IHRvdGFsUGFnZXMgLSAyKSB7IC8vbmVlZCBlbGxpcHNpcyBmb3IgYWxsIG9wdGlvbnMgdW5sZXNzIHJhbmdlIGlzIHRvbyBjbG9zZSB0byBlbmRcclxuICAgICAgICB2YXIgbmV4dFBhZ2VTZXQgPSBtYWtlUGFnZShlbmRQYWdlICsgMSwgJy4uLicsIGZhbHNlKTtcclxuICAgICAgICBwYWdlcy5wdXNoKG5leHRQYWdlU2V0KTtcclxuICAgICAgfVxyXG4gICAgICAgIGlmIChib3VuZGFyeUxpbmtOdW1iZXJzKSB7XHJcbiAgICAgICAgICBpZiAoZW5kUGFnZSA9PT0gdG90YWxQYWdlcyAtIDIpIHsgLy9uZWVkIHRvIHJlcGxhY2UgZWxsaXBzaXMgd2hlbiB0aGUgYnV0dG9ucyB3b3VsZCBiZSBzZXF1ZW50aWFsXHJcbiAgICAgICAgICAgIHZhciBzZWNvbmRUb0xhc3RQYWdlTGluayA9IG1ha2VQYWdlKHRvdGFsUGFnZXMgLSAxLCB0b3RhbFBhZ2VzIC0gMSwgZmFsc2UpO1xyXG4gICAgICAgICAgICBwYWdlcy5wdXNoKHNlY29uZFRvTGFzdFBhZ2VMaW5rKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vYWRkIHRoZSBsYXN0IHBhZ2VcclxuICAgICAgICAgIHZhciBsYXN0UGFnZUxpbmsgPSBtYWtlUGFnZSh0b3RhbFBhZ2VzLCB0b3RhbFBhZ2VzLCBmYWxzZSk7XHJcbiAgICAgICAgICBwYWdlcy5wdXNoKGxhc3RQYWdlTGluayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFnZXM7XHJcbiAgfVxyXG5cclxuICB2YXIgb3JpZ2luYWxSZW5kZXIgPSB0aGlzLnJlbmRlcjtcclxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgb3JpZ2luYWxSZW5kZXIoKTtcclxuICAgIGlmICgkc2NvcGUucGFnZSA+IDAgJiYgJHNjb3BlLnBhZ2UgPD0gJHNjb3BlLnRvdGFsUGFnZXMpIHtcclxuICAgICAgJHNjb3BlLnBhZ2VzID0gZ2V0UGFnZXMoJHNjb3BlLnBhZ2UsICRzY29wZS50b3RhbFBhZ2VzKTtcclxuICAgIH1cclxuICB9O1xyXG59XSlcclxuXHJcbi5jb25zdGFudCgndWliUGFnaW5hdGlvbkNvbmZpZycsIHtcclxuICBpdGVtc1BlclBhZ2U6IDEwLFxyXG4gIGJvdW5kYXJ5TGlua3M6IGZhbHNlLFxyXG4gIGJvdW5kYXJ5TGlua051bWJlcnM6IGZhbHNlLFxyXG4gIGRpcmVjdGlvbkxpbmtzOiB0cnVlLFxyXG4gIGZpcnN0VGV4dDogJ0ZpcnN0JyxcclxuICBwcmV2aW91c1RleHQ6ICdQcmV2aW91cycsXHJcbiAgbmV4dFRleHQ6ICdOZXh0JyxcclxuICBsYXN0VGV4dDogJ0xhc3QnLFxyXG4gIHJvdGF0ZTogdHJ1ZSxcclxuICBmb3JjZUVsbGlwc2VzOiBmYWxzZVxyXG59KVxyXG5cclxuLmRpcmVjdGl2ZSgndWliUGFnaW5hdGlvbicsIFsnJHBhcnNlJywgJ3VpYlBhZ2luYXRpb25Db25maWcnLCBmdW5jdGlvbigkcGFyc2UsIHVpYlBhZ2luYXRpb25Db25maWcpIHtcclxuICByZXR1cm4ge1xyXG4gICAgc2NvcGU6IHtcclxuICAgICAgdG90YWxJdGVtczogJz0nLFxyXG4gICAgICBmaXJzdFRleHQ6ICdAJyxcclxuICAgICAgcHJldmlvdXNUZXh0OiAnQCcsXHJcbiAgICAgIG5leHRUZXh0OiAnQCcsXHJcbiAgICAgIGxhc3RUZXh0OiAnQCcsXHJcbiAgICAgIG5nRGlzYWJsZWQ6Jz0nXHJcbiAgICB9LFxyXG4gICAgcmVxdWlyZTogWyd1aWJQYWdpbmF0aW9uJywgJz9uZ01vZGVsJ10sXHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgY29udHJvbGxlcjogJ1VpYlBhZ2luYXRpb25Db250cm9sbGVyJyxcclxuICAgIGNvbnRyb2xsZXJBczogJ3BhZ2luYXRpb24nLFxyXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sJztcclxuICAgIH0sXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XHJcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ3BhZ2luYXRpb24nKTtcclxuICAgICAgdmFyIHBhZ2luYXRpb25DdHJsID0gY3RybHNbMF0sIG5nTW9kZWxDdHJsID0gY3RybHNbMV07XHJcblxyXG4gICAgICBpZiAoIW5nTW9kZWxDdHJsKSB7XHJcbiAgICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZyBpZiBubyBuZy1tb2RlbFxyXG4gICAgICB9XHJcblxyXG4gICAgICBwYWdpbmF0aW9uQ3RybC5pbml0KG5nTW9kZWxDdHJsLCB1aWJQYWdpbmF0aW9uQ29uZmlnKTtcclxuICAgIH1cclxuICB9O1xyXG59XSk7XHJcblxyXG4vKipcclxuICogVGhlIGZvbGxvd2luZyBmZWF0dXJlcyBhcmUgc3RpbGwgb3V0c3RhbmRpbmc6IGFuaW1hdGlvbiBhcyBhXHJcbiAqIGZ1bmN0aW9uLCBwbGFjZW1lbnQgYXMgYSBmdW5jdGlvbiwgaW5zaWRlLCBzdXBwb3J0IGZvciBtb3JlIHRyaWdnZXJzIHRoYW5cclxuICoganVzdCBtb3VzZSBlbnRlci9sZWF2ZSwgaHRtbCB0b29sdGlwcywgYW5kIHNlbGVjdG9yIGRlbGVnYXRpb24uXHJcbiAqL1xyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRvb2x0aXAnLCBbJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbicsICd1aS5ib290c3RyYXAuc3RhY2tlZE1hcCddKVxyXG5cclxuLyoqXHJcbiAqIFRoZSAkdG9vbHRpcCBzZXJ2aWNlIGNyZWF0ZXMgdG9vbHRpcC0gYW5kIHBvcG92ZXItbGlrZSBkaXJlY3RpdmVzIGFzIHdlbGwgYXNcclxuICogaG91c2VzIGdsb2JhbCBvcHRpb25zIGZvciB0aGVtLlxyXG4gKi9cclxuLnByb3ZpZGVyKCckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCkge1xyXG4gIC8vIFRoZSBkZWZhdWx0IG9wdGlvbnMgdG9vbHRpcCBhbmQgcG9wb3Zlci5cclxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxyXG4gICAgcGxhY2VtZW50Q2xhc3NQcmVmaXg6ICcnLFxyXG4gICAgYW5pbWF0aW9uOiB0cnVlLFxyXG4gICAgcG9wdXBEZWxheTogMCxcclxuICAgIHBvcHVwQ2xvc2VEZWxheTogMCxcclxuICAgIHVzZUNvbnRlbnRFeHA6IGZhbHNlXHJcbiAgfTtcclxuXHJcbiAgLy8gRGVmYXVsdCBoaWRlIHRyaWdnZXJzIGZvciBlYWNoIHNob3cgdHJpZ2dlclxyXG4gIHZhciB0cmlnZ2VyTWFwID0ge1xyXG4gICAgJ21vdXNlZW50ZXInOiAnbW91c2VsZWF2ZScsXHJcbiAgICAnY2xpY2snOiAnY2xpY2snLFxyXG4gICAgJ291dHNpZGVDbGljayc6ICdvdXRzaWRlQ2xpY2snLFxyXG4gICAgJ2ZvY3VzJzogJ2JsdXInLFxyXG4gICAgJ25vbmUnOiAnJ1xyXG4gIH07XHJcblxyXG4gIC8vIFRoZSBvcHRpb25zIHNwZWNpZmllZCB0byB0aGUgcHJvdmlkZXIgZ2xvYmFsbHkuXHJcbiAgdmFyIGdsb2JhbE9wdGlvbnMgPSB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogYG9wdGlvbnMoe30pYCBhbGxvd3MgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb2YgYWxsIHRvb2x0aXBzIGluIHRoZVxyXG4gICAqIGFwcGxpY2F0aW9uLlxyXG4gICAqXHJcbiAgICogICB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoICdBcHAnLCBbJ3VpLmJvb3RzdHJhcC50b29sdGlwJ10sIGZ1bmN0aW9uKCAkdG9vbHRpcFByb3ZpZGVyICkge1xyXG4gICAqICAgICAvLyBwbGFjZSB0b29sdGlwcyBsZWZ0IGluc3RlYWQgb2YgdG9wIGJ5IGRlZmF1bHRcclxuICAgKiAgICAgJHRvb2x0aXBQcm92aWRlci5vcHRpb25zKCB7IHBsYWNlbWVudDogJ2xlZnQnIH0gKTtcclxuICAgKiAgIH0pO1xyXG4gICAqL1xyXG5cdHRoaXMub3B0aW9ucyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRhbmd1bGFyLmV4dGVuZChnbG9iYWxPcHRpb25zLCB2YWx1ZSk7XHJcblx0fTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBhbGxvd3MgeW91IHRvIGV4dGVuZCB0aGUgc2V0IG9mIHRyaWdnZXIgbWFwcGluZ3MgYXZhaWxhYmxlLiBFLmcuOlxyXG4gICAqXHJcbiAgICogICAkdG9vbHRpcFByb3ZpZGVyLnNldFRyaWdnZXJzKCB7ICdvcGVuVHJpZ2dlcic6ICdjbG9zZVRyaWdnZXInIH0gKTtcclxuICAgKi9cclxuICB0aGlzLnNldFRyaWdnZXJzID0gZnVuY3Rpb24gc2V0VHJpZ2dlcnModHJpZ2dlcnMpIHtcclxuICAgIGFuZ3VsYXIuZXh0ZW5kKHRyaWdnZXJNYXAsIHRyaWdnZXJzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciB0cmFuc2xhdGluZyBjYW1lbC1jYXNlIHRvIHNuYWtlX2Nhc2UuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc25ha2VfY2FzZShuYW1lKSB7XHJcbiAgICB2YXIgcmVnZXhwID0gL1tBLVpdL2c7XHJcbiAgICB2YXIgc2VwYXJhdG9yID0gJy0nO1xyXG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZShyZWdleHAsIGZ1bmN0aW9uKGxldHRlciwgcG9zKSB7XHJcbiAgICAgIHJldHVybiAocG9zID8gc2VwYXJhdG9yIDogJycpICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGFjdHVhbCBpbnN0YW5jZSBvZiB0aGUgJHRvb2x0aXAgc2VydmljZS5cclxuICAgKiBUT0RPIHN1cHBvcnQgbXVsdGlwbGUgdHJpZ2dlcnNcclxuICAgKi9cclxuICB0aGlzLiRnZXQgPSBbJyR3aW5kb3cnLCAnJGNvbXBpbGUnLCAnJHRpbWVvdXQnLCAnJGRvY3VtZW50JywgJyR1aWJQb3NpdGlvbicsICckaW50ZXJwb2xhdGUnLCAnJHJvb3RTY29wZScsICckcGFyc2UnLCAnJCRzdGFja2VkTWFwJywgZnVuY3Rpb24oJHdpbmRvdywgJGNvbXBpbGUsICR0aW1lb3V0LCAkZG9jdW1lbnQsICRwb3NpdGlvbiwgJGludGVycG9sYXRlLCAkcm9vdFNjb3BlLCAkcGFyc2UsICQkc3RhY2tlZE1hcCkge1xyXG4gICAgdmFyIG9wZW5lZFRvb2x0aXBzID0gJCRzdGFja2VkTWFwLmNyZWF0ZU5ldygpO1xyXG4gICAgJGRvY3VtZW50Lm9uKCdrZXl1cCcsIGtleXByZXNzTGlzdGVuZXIpO1xyXG5cclxuICAgICRyb290U2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAkZG9jdW1lbnQub2ZmKCdrZXl1cCcsIGtleXByZXNzTGlzdGVuZXIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24ga2V5cHJlc3NMaXN0ZW5lcihlKSB7XHJcbiAgICAgIGlmIChlLndoaWNoID09PSAyNykge1xyXG4gICAgICAgIHZhciBsYXN0ID0gb3BlbmVkVG9vbHRpcHMudG9wKCk7XHJcbiAgICAgICAgaWYgKGxhc3QpIHtcclxuICAgICAgICAgIGxhc3QudmFsdWUuY2xvc2UoKTtcclxuICAgICAgICAgIGxhc3QgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAkdG9vbHRpcCh0dFR5cGUsIHByZWZpeCwgZGVmYXVsdFRyaWdnZXJTaG93LCBvcHRpb25zKSB7XHJcbiAgICAgIG9wdGlvbnMgPSBhbmd1bGFyLmV4dGVuZCh7fSwgZGVmYXVsdE9wdGlvbnMsIGdsb2JhbE9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHNob3cgYW5kIGhpZGUgdHJpZ2dlcnMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIElmIGEgdHJpZ2dlciBpcyBzdXBwbGllZCxcclxuICAgICAgICogaXQgaXMgdXNlZCB0byBzaG93IHRoZSB0b29sdGlwOyBvdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdHJpZ2dlcmBcclxuICAgICAgICogb3B0aW9uIHBhc3NlZCB0byB0aGUgYCR0b29sdGlwUHJvdmlkZXIub3B0aW9uc2AgbWV0aG9kOyBlbHNlIGl0IHdpbGxcclxuICAgICAgICogZGVmYXVsdCB0byB0aGUgdHJpZ2dlciBzdXBwbGllZCB0byB0aGlzIGRpcmVjdGl2ZSBmYWN0b3J5LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBUaGUgaGlkZSB0cmlnZ2VyIGlzIGJhc2VkIG9uIHRoZSBzaG93IHRyaWdnZXIuIElmIHRoZSBgdHJpZ2dlcmAgb3B0aW9uXHJcbiAgICAgICAqIHdhcyBwYXNzZWQgdG8gdGhlIGAkdG9vbHRpcFByb3ZpZGVyLm9wdGlvbnNgIG1ldGhvZCwgaXQgd2lsbCB1c2UgdGhlXHJcbiAgICAgICAqIG1hcHBlZCB0cmlnZ2VyIGZyb20gYHRyaWdnZXJNYXBgIG9yIHRoZSBwYXNzZWQgdHJpZ2dlciBpZiB0aGUgbWFwIGlzXHJcbiAgICAgICAqIHVuZGVmaW5lZDsgb3RoZXJ3aXNlLCBpdCB1c2VzIHRoZSBgdHJpZ2dlck1hcGAgdmFsdWUgb2YgdGhlIHNob3dcclxuICAgICAgICogdHJpZ2dlcjsgZWxzZSBpdCB3aWxsIGp1c3QgdXNlIHRoZSBzaG93IHRyaWdnZXIuXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiBnZXRUcmlnZ2Vycyh0cmlnZ2VyKSB7XHJcbiAgICAgICAgdmFyIHNob3cgPSAodHJpZ2dlciB8fCBvcHRpb25zLnRyaWdnZXIgfHwgZGVmYXVsdFRyaWdnZXJTaG93KS5zcGxpdCgnICcpO1xyXG4gICAgICAgIHZhciBoaWRlID0gc2hvdy5tYXAoZnVuY3Rpb24odHJpZ2dlcikge1xyXG4gICAgICAgICAgcmV0dXJuIHRyaWdnZXJNYXBbdHJpZ2dlcl0gfHwgdHJpZ2dlcjtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc2hvdzogc2hvdyxcclxuICAgICAgICAgIGhpZGU6IGhpZGVcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZGlyZWN0aXZlTmFtZSA9IHNuYWtlX2Nhc2UodHRUeXBlKTtcclxuXHJcbiAgICAgIHZhciBzdGFydFN5bSA9ICRpbnRlcnBvbGF0ZS5zdGFydFN5bWJvbCgpO1xyXG4gICAgICB2YXIgZW5kU3ltID0gJGludGVycG9sYXRlLmVuZFN5bWJvbCgpO1xyXG4gICAgICB2YXIgdGVtcGxhdGUgPVxyXG4gICAgICAgICc8ZGl2ICcrIGRpcmVjdGl2ZU5hbWUgKyAnLXBvcHVwICcgK1xyXG4gICAgICAgICAgJ3VpYi10aXRsZT1cIicgKyBzdGFydFN5bSArICd0aXRsZScgKyBlbmRTeW0gKyAnXCIgJyArXHJcbiAgICAgICAgICAob3B0aW9ucy51c2VDb250ZW50RXhwID9cclxuICAgICAgICAgICAgJ2NvbnRlbnQtZXhwPVwiY29udGVudEV4cCgpXCIgJyA6XHJcbiAgICAgICAgICAgICdjb250ZW50PVwiJyArIHN0YXJ0U3ltICsgJ2NvbnRlbnQnICsgZW5kU3ltICsgJ1wiICcpICtcclxuICAgICAgICAgICdvcmlnaW4tc2NvcGU9XCJvcmlnU2NvcGVcIiAnICtcclxuICAgICAgICAgICdjbGFzcz1cInVpYi1wb3NpdGlvbi1tZWFzdXJlICcgKyBwcmVmaXggKyAnXCIgJyArXHJcbiAgICAgICAgICAndG9vbHRpcC1hbmltYXRpb24tY2xhc3M9XCJmYWRlXCInICtcclxuICAgICAgICAgICd1aWItdG9vbHRpcC1jbGFzc2VzICcgK1xyXG4gICAgICAgICAgJ25nLWNsYXNzPVwieyBpbjogaXNPcGVuIH1cIiAnICtcclxuICAgICAgICAgICc+JyArXHJcbiAgICAgICAgJzwvZGl2Pic7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRFbGVtLCB0QXR0cnMpIHtcclxuICAgICAgICAgIHZhciB0b29sdGlwTGlua2VyID0gJGNvbXBpbGUodGVtcGxhdGUpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBsaW5rKHNjb3BlLCBlbGVtZW50LCBhdHRycywgdG9vbHRpcEN0cmwpIHtcclxuICAgICAgICAgICAgdmFyIHRvb2x0aXA7XHJcbiAgICAgICAgICAgIHZhciB0b29sdGlwTGlua2VkU2NvcGU7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uVGltZW91dDtcclxuICAgICAgICAgICAgdmFyIHNob3dUaW1lb3V0O1xyXG4gICAgICAgICAgICB2YXIgaGlkZVRpbWVvdXQ7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvblRpbWVvdXQ7XHJcbiAgICAgICAgICAgIHZhciBhZGp1c3RtZW50VGltZW91dDtcclxuICAgICAgICAgICAgdmFyIGFwcGVuZFRvQm9keSA9IGFuZ3VsYXIuaXNEZWZpbmVkKG9wdGlvbnMuYXBwZW5kVG9Cb2R5KSA/IG9wdGlvbnMuYXBwZW5kVG9Cb2R5IDogZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciB0cmlnZ2VycyA9IGdldFRyaWdnZXJzKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHZhciBoYXNFbmFibGVFeHAgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRyc1twcmVmaXggKyAnRW5hYmxlJ10pO1xyXG4gICAgICAgICAgICB2YXIgdHRTY29wZSA9IHNjb3BlLiRuZXcodHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciByZXBvc2l0aW9uU2NoZWR1bGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBpc09wZW5QYXJzZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzW3ByZWZpeCArICdJc09wZW4nXSkgPyAkcGFyc2UoYXR0cnNbcHJlZml4ICsgJ0lzT3BlbiddKSA6IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgY29udGVudFBhcnNlID0gb3B0aW9ucy51c2VDb250ZW50RXhwID8gJHBhcnNlKGF0dHJzW3R0VHlwZV0pIDogZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBvYnNlcnZlcnMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGxhc3RQbGFjZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25Ub29sdGlwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdG9vbHRpcCBleGlzdHMgYW5kIGlzIG5vdCBlbXB0eVxyXG4gICAgICAgICAgICAgIGlmICghdG9vbHRpcCB8fCAhdG9vbHRpcC5odG1sKCkpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgICAgICAgIGlmICghcG9zaXRpb25UaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvblRpbWVvdXQgPSAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIHR0UG9zaXRpb24gPSAkcG9zaXRpb24ucG9zaXRpb25FbGVtZW50cyhlbGVtZW50LCB0b29sdGlwLCB0dFNjb3BlLnBsYWNlbWVudCwgYXBwZW5kVG9Cb2R5KTtcclxuICAgICAgICAgICAgICAgICAgdmFyIGluaXRpYWxIZWlnaHQgPSBhbmd1bGFyLmlzRGVmaW5lZCh0b29sdGlwLm9mZnNldEhlaWdodCkgPyB0b29sdGlwLm9mZnNldEhlaWdodCA6IHRvb2x0aXAucHJvcCgnb2Zmc2V0SGVpZ2h0Jyk7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50UG9zID0gYXBwZW5kVG9Cb2R5ID8gJHBvc2l0aW9uLm9mZnNldChlbGVtZW50KSA6ICRwb3NpdGlvbi5wb3NpdGlvbihlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgdG9vbHRpcC5jc3MoeyB0b3A6IHR0UG9zaXRpb24udG9wICsgJ3B4JywgbGVmdDogdHRQb3NpdGlvbi5sZWZ0ICsgJ3B4JyB9KTtcclxuICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudENsYXNzZXMgPSB0dFBvc2l0aW9uLnBsYWNlbWVudC5zcGxpdCgnLScpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgaWYgKCF0b29sdGlwLmhhc0NsYXNzKHBsYWNlbWVudENsYXNzZXNbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmVDbGFzcyhsYXN0UGxhY2VtZW50LnNwbGl0KCctJylbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuYWRkQ2xhc3MocGxhY2VtZW50Q2xhc3Nlc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmICghdG9vbHRpcC5oYXNDbGFzcyhvcHRpb25zLnBsYWNlbWVudENsYXNzUHJlZml4ICsgdHRQb3NpdGlvbi5wbGFjZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmVDbGFzcyhvcHRpb25zLnBsYWNlbWVudENsYXNzUHJlZml4ICsgbGFzdFBsYWNlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5hZGRDbGFzcyhvcHRpb25zLnBsYWNlbWVudENsYXNzUHJlZml4ICsgdHRQb3NpdGlvbi5wbGFjZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICBhZGp1c3RtZW50VGltZW91dCA9ICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SGVpZ2h0ID0gYW5ndWxhci5pc0RlZmluZWQodG9vbHRpcC5vZmZzZXRIZWlnaHQpID8gdG9vbHRpcC5vZmZzZXRIZWlnaHQgOiB0b29sdGlwLnByb3AoJ29mZnNldEhlaWdodCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGp1c3RtZW50ID0gJHBvc2l0aW9uLmFkanVzdFRvcChwbGFjZW1lbnRDbGFzc2VzLCBlbGVtZW50UG9zLCBpbml0aWFsSGVpZ2h0LCBjdXJyZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRqdXN0bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5jc3MoYWRqdXN0bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFkanVzdG1lbnRUaW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgfSwgMCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgdGltZSB0aHJvdWdoIHR0IGVsZW1lbnQgd2lsbCBoYXZlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAvLyB1aWItcG9zaXRpb24tbWVhc3VyZSBjbGFzcyBvciBpZiB0aGUgcGxhY2VtZW50XHJcbiAgICAgICAgICAgICAgICAgIC8vIGhhcyBjaGFuZ2VkIHdlIG5lZWQgdG8gcG9zaXRpb24gdGhlIGFycm93LlxyXG4gICAgICAgICAgICAgICAgICBpZiAodG9vbHRpcC5oYXNDbGFzcygndWliLXBvc2l0aW9uLW1lYXN1cmUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICRwb3NpdGlvbi5wb3NpdGlvbkFycm93KHRvb2x0aXAsIHR0UG9zaXRpb24ucGxhY2VtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLnJlbW92ZUNsYXNzKCd1aWItcG9zaXRpb24tbWVhc3VyZScpO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RQbGFjZW1lbnQgIT09IHR0UG9zaXRpb24ucGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHBvc2l0aW9uLnBvc2l0aW9uQXJyb3codG9vbHRpcCwgdHRQb3NpdGlvbi5wbGFjZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGxhc3RQbGFjZW1lbnQgPSB0dFBvc2l0aW9uLnBsYWNlbWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9LCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHVwIHRoZSBjb3JyZWN0IHNjb3BlIHRvIGFsbG93IHRyYW5zY2x1c2lvbiBsYXRlclxyXG4gICAgICAgICAgICB0dFNjb3BlLm9yaWdTY29wZSA9IHNjb3BlO1xyXG5cclxuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIHRvb2x0aXAgaXMgbm90IG9wZW4uXHJcbiAgICAgICAgICAgIC8vIFRPRE8gYWRkIGFiaWxpdHkgdG8gc3RhcnQgdG9vbHRpcCBvcGVuZWRcclxuICAgICAgICAgICAgdHRTY29wZS5pc09wZW4gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHRvZ2dsZVRvb2x0aXBCaW5kKCkge1xyXG4gICAgICAgICAgICAgIGlmICghdHRTY29wZS5pc09wZW4pIHtcclxuICAgICAgICAgICAgICAgIHNob3dUb29sdGlwQmluZCgpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoaWRlVG9vbHRpcEJpbmQoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNob3cgdGhlIHRvb2x0aXAgd2l0aCBkZWxheSBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBzaG93IGl0IGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwQmluZCgpIHtcclxuICAgICAgICAgICAgICBpZiAoaGFzRW5hYmxlRXhwICYmICFzY29wZS4kZXZhbChhdHRyc1twcmVmaXggKyAnRW5hYmxlJ10pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBjYW5jZWxIaWRlKCk7XHJcbiAgICAgICAgICAgICAgcHJlcGFyZVRvb2x0aXAoKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHR0U2NvcGUucG9wdXBEZWxheSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgdG9vbHRpcCB3YXMgYWxyZWFkeSBzY2hlZHVsZWQgdG8gcG9wLXVwLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBoYXBwZW5zIGlmIHNob3cgaXMgdHJpZ2dlcmVkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSBhbnkgaGlkZSBpcyB0cmlnZ2VyZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNob3dUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgIHNob3dUaW1lb3V0ID0gJHRpbWVvdXQoc2hvdywgdHRTY29wZS5wb3B1cERlbGF5LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNob3coKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhpZGVUb29sdGlwQmluZCgpIHtcclxuICAgICAgICAgICAgICBjYW5jZWxTaG93KCk7XHJcblxyXG4gICAgICAgICAgICAgIGlmICh0dFNjb3BlLnBvcHVwQ2xvc2VEZWxheSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoaWRlVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgICBoaWRlVGltZW91dCA9ICR0aW1lb3V0KGhpZGUsIHR0U2NvcGUucG9wdXBDbG9zZURlbGF5LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhpZGUoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNob3cgdGhlIHRvb2x0aXAgcG9wdXAgZWxlbWVudC5cclxuICAgICAgICAgICAgZnVuY3Rpb24gc2hvdygpIHtcclxuICAgICAgICAgICAgICBjYW5jZWxTaG93KCk7XHJcbiAgICAgICAgICAgICAgY2FuY2VsSGlkZSgpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBEb24ndCBzaG93IGVtcHR5IHRvb2x0aXBzLlxyXG4gICAgICAgICAgICAgIGlmICghdHRTY29wZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ndWxhci5ub29wO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgY3JlYXRlVG9vbHRpcCgpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBBbmQgc2hvdyB0aGUgdG9vbHRpcC5cclxuICAgICAgICAgICAgICB0dFNjb3BlLiRldmFsQXN5bmMoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0dFNjb3BlLmlzT3BlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBhc3NpZ25Jc09wZW4odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvblRvb2x0aXAoKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gY2FuY2VsU2hvdygpIHtcclxuICAgICAgICAgICAgICBpZiAoc2hvd1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChzaG93VGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBzaG93VGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocG9zaXRpb25UaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwocG9zaXRpb25UaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uVGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBIaWRlIHRoZSB0b29sdGlwIHBvcHVwIGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhpZGUoKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCF0dFNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBGaXJzdCB0aGluZ3MgZmlyc3Q6IHdlIGRvbid0IHNob3cgaXQgYW55bW9yZS5cclxuICAgICAgICAgICAgICB0dFNjb3BlLiRldmFsQXN5bmMoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHRTY29wZSkge1xyXG4gICAgICAgICAgICAgICAgICB0dFNjb3BlLmlzT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICBhc3NpZ25Jc09wZW4oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAvLyBBbmQgbm93IHdlIHJlbW92ZSBpdCBmcm9tIHRoZSBET00uIEhvd2V2ZXIsIGlmIHdlIGhhdmUgYW5pbWF0aW9uLCB3ZVxyXG4gICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHdhaXQgZm9yIGl0IHRvIGV4cGlyZSBiZWZvcmVoYW5kLlxyXG4gICAgICAgICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBpcyBhIHBsYWNlaG9sZGVyIGZvciBhIHBvcnQgb2YgdGhlIHRyYW5zaXRpb25zIGxpYnJhcnkuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBmYWRlIHRyYW5zaXRpb24gaW4gVFdCUyBpcyAxNTBtcy5cclxuICAgICAgICAgICAgICAgICAgaWYgKHR0U2NvcGUuYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFuc2l0aW9uVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWVvdXQgPSAkdGltZW91dChyZW1vdmVUb29sdGlwLCAxNTAsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcCgpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbmNlbEhpZGUoKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGhpZGVUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwoaGlkZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgaGlkZVRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwodHJhbnNpdGlvblRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlVG9vbHRpcCgpIHtcclxuICAgICAgICAgICAgICAvLyBUaGVyZSBjYW4gb25seSBiZSBvbmUgdG9vbHRpcCBlbGVtZW50IHBlciBkaXJlY3RpdmUgc2hvd24gYXQgb25jZS5cclxuICAgICAgICAgICAgICBpZiAodG9vbHRpcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgdG9vbHRpcExpbmtlZFNjb3BlID0gdHRTY29wZS4kbmV3KCk7XHJcbiAgICAgICAgICAgICAgdG9vbHRpcCA9IHRvb2x0aXBMaW5rZXIodG9vbHRpcExpbmtlZFNjb3BlLCBmdW5jdGlvbih0b29sdGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XHJcbiAgICAgICAgICAgICAgICAgICRkb2N1bWVudC5maW5kKCdib2R5JykuYXBwZW5kKHRvb2x0aXApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZnRlcih0b29sdGlwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgb3BlbmVkVG9vbHRpcHMuYWRkKHR0U2NvcGUsIHtcclxuICAgICAgICAgICAgICAgIGNsb3NlOiBoaWRlXHJcbiAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgIHByZXBPYnNlcnZlcnMoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVG9vbHRpcCgpIHtcclxuICAgICAgICAgICAgICBjYW5jZWxTaG93KCk7XHJcbiAgICAgICAgICAgICAgY2FuY2VsSGlkZSgpO1xyXG4gICAgICAgICAgICAgIHVucmVnaXN0ZXJPYnNlcnZlcnMoKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXAucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRvb2x0aXAgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFkanVzdG1lbnRUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChhZGp1c3RtZW50VGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBvcGVuZWRUb29sdGlwcy5yZW1vdmUodHRTY29wZSk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgaWYgKHRvb2x0aXBMaW5rZWRTY29wZSkge1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcExpbmtlZFNjb3BlLiRkZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwTGlua2VkU2NvcGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldCB0aGUgaW5pdGlhbCBzY29wZSB2YWx1ZXMuIE9uY2VcclxuICAgICAgICAgICAgICogdGhlIHRvb2x0aXAgaXMgY3JlYXRlZCwgdGhlIG9ic2VydmVyc1xyXG4gICAgICAgICAgICAgKiB3aWxsIGJlIGFkZGVkIHRvIGtlZXAgdGhpbmdzIGluIHN5bmMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBwcmVwYXJlVG9vbHRpcCgpIHtcclxuICAgICAgICAgICAgICB0dFNjb3BlLnRpdGxlID0gYXR0cnNbcHJlZml4ICsgJ1RpdGxlJ107XHJcbiAgICAgICAgICAgICAgaWYgKGNvbnRlbnRQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgdHRTY29wZS5jb250ZW50ID0gY29udGVudFBhcnNlKHNjb3BlKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHRTY29wZS5jb250ZW50ID0gYXR0cnNbdHRUeXBlXTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHR0U2NvcGUucG9wdXBDbGFzcyA9IGF0dHJzW3ByZWZpeCArICdDbGFzcyddO1xyXG4gICAgICAgICAgICAgIHR0U2NvcGUucGxhY2VtZW50ID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnNbcHJlZml4ICsgJ1BsYWNlbWVudCddKSA/IGF0dHJzW3ByZWZpeCArICdQbGFjZW1lbnQnXSA6IG9wdGlvbnMucGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkcG9zaXRpb24ucGFyc2VQbGFjZW1lbnQodHRTY29wZS5wbGFjZW1lbnQpO1xyXG4gICAgICAgICAgICAgIGxhc3RQbGFjZW1lbnQgPSBwbGFjZW1lbnRbMV0gPyBwbGFjZW1lbnRbMF0gKyAnLScgKyBwbGFjZW1lbnRbMV0gOiBwbGFjZW1lbnRbMF07XHJcblxyXG4gICAgICAgICAgICAgIHZhciBkZWxheSA9IHBhcnNlSW50KGF0dHJzW3ByZWZpeCArICdQb3B1cERlbGF5J10sIDEwKTtcclxuICAgICAgICAgICAgICB2YXIgY2xvc2VEZWxheSA9IHBhcnNlSW50KGF0dHJzW3ByZWZpeCArICdQb3B1cENsb3NlRGVsYXknXSwgMTApO1xyXG4gICAgICAgICAgICAgIHR0U2NvcGUucG9wdXBEZWxheSA9ICFpc05hTihkZWxheSkgPyBkZWxheSA6IG9wdGlvbnMucG9wdXBEZWxheTtcclxuICAgICAgICAgICAgICB0dFNjb3BlLnBvcHVwQ2xvc2VEZWxheSA9ICFpc05hTihjbG9zZURlbGF5KSA/IGNsb3NlRGVsYXkgOiBvcHRpb25zLnBvcHVwQ2xvc2VEZWxheTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYXNzaWduSXNPcGVuKGlzT3Blbikge1xyXG4gICAgICAgICAgICAgIGlmIChpc09wZW5QYXJzZSAmJiBhbmd1bGFyLmlzRnVuY3Rpb24oaXNPcGVuUGFyc2UuYXNzaWduKSkge1xyXG4gICAgICAgICAgICAgICAgaXNPcGVuUGFyc2UuYXNzaWduKHNjb3BlLCBpc09wZW4pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdHRTY29wZS5jb250ZW50RXhwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHR0U2NvcGUuY29udGVudDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPYnNlcnZlIHRoZSByZWxldmFudCBhdHRyaWJ1dGVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUoJ2Rpc2FibGVkJywgZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsU2hvdygpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHZhbCAmJiB0dFNjb3BlLmlzT3Blbikge1xyXG4gICAgICAgICAgICAgICAgaGlkZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNPcGVuUGFyc2UpIHtcclxuICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goaXNPcGVuUGFyc2UsIGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR0U2NvcGUgJiYgIXZhbCA9PT0gdHRTY29wZS5pc09wZW4pIHtcclxuICAgICAgICAgICAgICAgICAgdG9nZ2xlVG9vbHRpcEJpbmQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcHJlcE9ic2VydmVycygpIHtcclxuICAgICAgICAgICAgICBvYnNlcnZlcnMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGNvbnRlbnRQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChjb250ZW50UGFyc2UsIGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR0U2NvcGUuY29udGVudCA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbCAmJiB0dFNjb3BlLmlzT3Blbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgIHRvb2x0aXBMaW5rZWRTY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXBvc2l0aW9uU2NoZWR1bGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvc2l0aW9uU2NoZWR1bGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBMaW5rZWRTY29wZS4kJHBvc3REaWdlc3QoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9zaXRpb25TY2hlZHVsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR0U2NvcGUgJiYgdHRTY29wZS5pc09wZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblRvb2x0aXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKHR0VHlwZSwgZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHRTY29wZS5jb250ZW50ID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsICYmIHR0U2NvcGUuaXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBoaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVG9vbHRpcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBvYnNlcnZlcnMucHVzaChcclxuICAgICAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKHByZWZpeCArICdUaXRsZScsIGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICB0dFNjb3BlLnRpdGxlID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICBpZiAodHRTY29wZS5pc09wZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblRvb2x0aXAoKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICBvYnNlcnZlcnMucHVzaChcclxuICAgICAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKHByZWZpeCArICdQbGFjZW1lbnQnLCBmdW5jdGlvbih2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgdHRTY29wZS5wbGFjZW1lbnQgPSB2YWwgPyB2YWwgOiBvcHRpb25zLnBsYWNlbWVudDtcclxuICAgICAgICAgICAgICAgICAgaWYgKHR0U2NvcGUuaXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25Ub29sdGlwKCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gdW5yZWdpc3Rlck9ic2VydmVycygpIHtcclxuICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG9ic2VydmVycywgZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBoaWRlIHRvb2x0aXBzL3BvcG92ZXJzIGZvciBvdXRzaWRlQ2xpY2sgdHJpZ2dlclxyXG4gICAgICAgICAgICBmdW5jdGlvbiBib2R5SGlkZVRvb2x0aXBCaW5kKGUpIHtcclxuICAgICAgICAgICAgICBpZiAoIXR0U2NvcGUgfHwgIXR0U2NvcGUuaXNPcGVuIHx8ICF0b29sdGlwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgdG9vbHRpcC9wb3BvdmVyIGxpbmsgb3IgdG9vbCB0b29sdGlwL3BvcG92ZXIgaXRzZWxmIHdlcmUgbm90IGNsaWNrZWRcclxuICAgICAgICAgICAgICBpZiAoIWVsZW1lbnRbMF0uY29udGFpbnMoZS50YXJnZXQpICYmICF0b29sdGlwWzBdLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgaGlkZVRvb2x0aXBCaW5kKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBLZXlib2FyZEV2ZW50IGhhbmRsZXIgdG8gaGlkZSB0aGUgdG9vbHRpcCBvbiBFc2NhcGUga2V5IHByZXNzXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhpZGVPbkVzY2FwZUtleShlKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDI3KSB7XHJcbiAgICAgICAgICAgICAgICBoaWRlVG9vbHRpcEJpbmQoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB1bnJlZ2lzdGVyVHJpZ2dlcnMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICB0cmlnZ2Vycy5zaG93LmZvckVhY2goZnVuY3Rpb24odHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXIgPT09ICdvdXRzaWRlQ2xpY2snKSB7XHJcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQub2ZmKCdjbGljaycsIHRvZ2dsZVRvb2x0aXBCaW5kKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQub2ZmKHRyaWdnZXIsIHNob3dUb29sdGlwQmluZCk7XHJcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQub2ZmKHRyaWdnZXIsIHRvZ2dsZVRvb2x0aXBCaW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQub2ZmKCdrZXlwcmVzcycsIGhpZGVPbkVzY2FwZUtleSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgdHJpZ2dlcnMuaGlkZS5mb3JFYWNoKGZ1bmN0aW9uKHRyaWdnZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyID09PSAnb3V0c2lkZUNsaWNrJykge1xyXG4gICAgICAgICAgICAgICAgICAkZG9jdW1lbnQub2ZmKCdjbGljaycsIGJvZHlIaWRlVG9vbHRpcEJpbmQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgZWxlbWVudC5vZmYodHJpZ2dlciwgaGlkZVRvb2x0aXBCaW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBUcmlnZ2VycygpIHtcclxuICAgICAgICAgICAgICB2YXIgc2hvd1RyaWdnZXJzID0gW10sIGhpZGVUcmlnZ2VycyA9IFtdO1xyXG4gICAgICAgICAgICAgIHZhciB2YWwgPSBzY29wZS4kZXZhbChhdHRyc1twcmVmaXggKyAnVHJpZ2dlciddKTtcclxuICAgICAgICAgICAgICB1bnJlZ2lzdGVyVHJpZ2dlcnMoKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNPYmplY3QodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICBzaG93VHJpZ2dlcnMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICBoaWRlVHJpZ2dlcnMucHVzaCh2YWxba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJzID0ge1xyXG4gICAgICAgICAgICAgICAgICBzaG93OiBzaG93VHJpZ2dlcnMsXHJcbiAgICAgICAgICAgICAgICAgIGhpZGU6IGhpZGVUcmlnZ2Vyc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcnMgPSBnZXRUcmlnZ2Vycyh2YWwpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHRyaWdnZXJzLnNob3cgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcnMuc2hvdy5mb3JFYWNoKGZ1bmN0aW9uKHRyaWdnZXIsIGlkeCkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlciA9PT0gJ291dHNpZGVDbGljaycpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm9uKCdjbGljaycsIHRvZ2dsZVRvb2x0aXBCaW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAkZG9jdW1lbnQub24oJ2NsaWNrJywgYm9keUhpZGVUb29sdGlwQmluZCk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciA9PT0gdHJpZ2dlcnMuaGlkZVtpZHhdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5vbih0cmlnZ2VyLCB0b2dnbGVUb29sdGlwQmluZCk7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQub24odHJpZ2dlciwgc2hvd1Rvb2x0aXBCaW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm9uKHRyaWdnZXJzLmhpZGVbaWR4XSwgaGlkZVRvb2x0aXBCaW5kKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBlbGVtZW50Lm9uKCdrZXlwcmVzcycsIGhpZGVPbkVzY2FwZUtleSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByZXBUcmlnZ2VycygpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHNjb3BlLiRldmFsKGF0dHJzW3ByZWZpeCArICdBbmltYXRpb24nXSk7XHJcbiAgICAgICAgICAgIHR0U2NvcGUuYW5pbWF0aW9uID0gYW5ndWxhci5pc0RlZmluZWQoYW5pbWF0aW9uKSA/ICEhYW5pbWF0aW9uIDogb3B0aW9ucy5hbmltYXRpb247XHJcblxyXG4gICAgICAgICAgICB2YXIgYXBwZW5kVG9Cb2R5VmFsO1xyXG4gICAgICAgICAgICB2YXIgYXBwZW5kS2V5ID0gcHJlZml4ICsgJ0FwcGVuZFRvQm9keSc7XHJcbiAgICAgICAgICAgIGlmIChhcHBlbmRLZXkgaW4gYXR0cnMgJiYgYXR0cnNbYXBwZW5kS2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgYXBwZW5kVG9Cb2R5VmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBhcHBlbmRUb0JvZHlWYWwgPSBzY29wZS4kZXZhbChhdHRyc1thcHBlbmRLZXldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYXBwZW5kVG9Cb2R5ID0gYW5ndWxhci5pc0RlZmluZWQoYXBwZW5kVG9Cb2R5VmFsKSA/IGFwcGVuZFRvQm9keVZhbCA6IGFwcGVuZFRvQm9keTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0b29sdGlwIGlzIGRlc3Ryb3llZCBhbmQgcmVtb3ZlZC5cclxuICAgICAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uIG9uRGVzdHJveVRvb2x0aXAoKSB7XHJcbiAgICAgICAgICAgICAgdW5yZWdpc3RlclRyaWdnZXJzKCk7XHJcbiAgICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcCgpO1xyXG4gICAgICAgICAgICAgIHR0U2NvcGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICB9XTtcclxufSlcclxuXHJcbi8vIFRoaXMgaXMgbW9zdGx5IG5nSW5jbHVkZSBjb2RlIGJ1dCB3aXRoIGEgY3VzdG9tIHNjb3BlXHJcbi5kaXJlY3RpdmUoJ3VpYlRvb2x0aXBUZW1wbGF0ZVRyYW5zY2x1ZGUnLCBbXHJcbiAgICAgICAgICckYW5pbWF0ZScsICckc2NlJywgJyRjb21waWxlJywgJyR0ZW1wbGF0ZVJlcXVlc3QnLFxyXG5mdW5jdGlvbiAoJGFuaW1hdGUsICRzY2UsICRjb21waWxlLCAkdGVtcGxhdGVSZXF1ZXN0KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtLCBhdHRycykge1xyXG4gICAgICB2YXIgb3JpZ1Njb3BlID0gc2NvcGUuJGV2YWwoYXR0cnMudG9vbHRpcFRlbXBsYXRlVHJhbnNjbHVkZVNjb3BlKTtcclxuXHJcbiAgICAgIHZhciBjaGFuZ2VDb3VudGVyID0gMCxcclxuICAgICAgICBjdXJyZW50U2NvcGUsXHJcbiAgICAgICAgcHJldmlvdXNFbGVtZW50LFxyXG4gICAgICAgIGN1cnJlbnRFbGVtZW50O1xyXG5cclxuICAgICAgdmFyIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAocHJldmlvdXNFbGVtZW50KSB7XHJcbiAgICAgICAgICBwcmV2aW91c0VsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgICAgICBwcmV2aW91c0VsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnRTY29wZSkge1xyXG4gICAgICAgICAgY3VycmVudFNjb3BlLiRkZXN0cm95KCk7XHJcbiAgICAgICAgICBjdXJyZW50U2NvcGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShjdXJyZW50RWxlbWVudCkudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcHJldmlvdXNFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcHJldmlvdXNFbGVtZW50ID0gY3VycmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgc2NvcGUuJHdhdGNoKCRzY2UucGFyc2VBc1Jlc291cmNlVXJsKGF0dHJzLnVpYlRvb2x0aXBUZW1wbGF0ZVRyYW5zY2x1ZGUpLCBmdW5jdGlvbihzcmMpIHtcclxuICAgICAgICB2YXIgdGhpc0NoYW5nZUlkID0gKytjaGFuZ2VDb3VudGVyO1xyXG5cclxuICAgICAgICBpZiAoc3JjKSB7XHJcbiAgICAgICAgICAvL3NldCB0aGUgMm5kIHBhcmFtIHRvIHRydWUgdG8gaWdub3JlIHRoZSB0ZW1wbGF0ZSByZXF1ZXN0IGVycm9yIHNvIHRoYXQgdGhlIGlubmVyXHJcbiAgICAgICAgICAvL2NvbnRlbnRzIGFuZCBzY29wZSBjYW4gYmUgY2xlYW5lZCB1cC5cclxuICAgICAgICAgICR0ZW1wbGF0ZVJlcXVlc3Qoc3JjLCB0cnVlKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzQ2hhbmdlSWQgIT09IGNoYW5nZUNvdW50ZXIpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgIHZhciBuZXdTY29wZSA9IG9yaWdTY29wZS4kbmV3KCk7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHJlc3BvbnNlO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNsb25lID0gJGNvbXBpbGUodGVtcGxhdGUpKG5ld1Njb3BlLCBmdW5jdGlvbihjbG9uZSkge1xyXG4gICAgICAgICAgICAgIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQoKTtcclxuICAgICAgICAgICAgICAkYW5pbWF0ZS5lbnRlcihjbG9uZSwgZWxlbSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbmV3U2NvcGU7XHJcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gY2xvbmU7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50U2NvcGUuJGVtaXQoJyRpbmNsdWRlQ29udGVudExvYWRlZCcsIHNyYyk7XHJcbiAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXNDaGFuZ2VJZCA9PT0gY2hhbmdlQ291bnRlcikge1xyXG4gICAgICAgICAgICAgIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQoKTtcclxuICAgICAgICAgICAgICBzY29wZS4kZW1pdCgnJGluY2x1ZGVDb250ZW50RXJyb3InLCBzcmMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHNjb3BlLiRlbWl0KCckaW5jbHVkZUNvbnRlbnRSZXF1ZXN0ZWQnLCBzcmMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KTtcclxuICAgIH1cclxuICB9O1xyXG59XSlcclxuXHJcbi8qKlxyXG4gKiBOb3RlIHRoYXQgaXQncyBpbnRlbnRpb25hbCB0aGF0IHRoZXNlIGNsYXNzZXMgYXJlICpub3QqIGFwcGxpZWQgdGhyb3VnaCAkYW5pbWF0ZS5cclxuICogVGhleSBtdXN0IG5vdCBiZSBhbmltYXRlZCBhcyB0aGV5J3JlIGV4cGVjdGVkIHRvIGJlIHByZXNlbnQgb24gdGhlIHRvb2x0aXAgb25cclxuICogaW5pdGlhbGl6YXRpb24uXHJcbiAqL1xyXG4uZGlyZWN0aXZlKCd1aWJUb29sdGlwQ2xhc3NlcycsIFsnJHVpYlBvc2l0aW9uJywgZnVuY3Rpb24oJHVpYlBvc2l0aW9uKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcclxuICAgICAgLy8gbmVlZCB0byBzZXQgdGhlIHByaW1hcnkgcG9zaXRpb24gc28gdGhlXHJcbiAgICAgIC8vIGFycm93IGhhcyBzcGFjZSBkdXJpbmcgcG9zaXRpb24gbWVhc3VyZS5cclxuICAgICAgLy8gdG9vbHRpcC5wb3NpdGlvblRvb2x0aXAoKVxyXG4gICAgICBpZiAoc2NvcGUucGxhY2VtZW50KSB7XHJcbiAgICAgICAgLy8gLy8gVGhlcmUgYXJlIG5vIHRvcC1sZWZ0IGV0Yy4uLiBjbGFzc2VzXHJcbiAgICAgICAgLy8gLy8gaW4gVFdCUywgc28gd2UgbmVlZCB0aGUgcHJpbWFyeSBwb3NpdGlvbi5cclxuICAgICAgICB2YXIgcG9zaXRpb24gPSAkdWliUG9zaXRpb24ucGFyc2VQbGFjZW1lbnQoc2NvcGUucGxhY2VtZW50KTtcclxuICAgICAgICBlbGVtZW50LmFkZENsYXNzKHBvc2l0aW9uWzBdKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNjb3BlLnBvcHVwQ2xhc3MpIHtcclxuICAgICAgICBlbGVtZW50LmFkZENsYXNzKHNjb3BlLnBvcHVwQ2xhc3MpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2NvcGUuYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhhdHRycy50b29sdGlwQW5pbWF0aW9uQ2xhc3MpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufV0pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJUb29sdGlwUG9wdXAnLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgIHNjb3BlOiB7IGNvbnRlbnQ6ICdAJyB9LFxyXG4gICAgdGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWwnXHJcbiAgfTtcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYlRvb2x0aXAnLCBbICckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCR1aWJUb29sdGlwKSB7XHJcbiAgcmV0dXJuICR1aWJUb29sdGlwKCd1aWJUb29sdGlwJywgJ3Rvb2x0aXAnLCAnbW91c2VlbnRlcicpO1xyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYlRvb2x0aXBUZW1wbGF0ZVBvcHVwJywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICBzY29wZTogeyBjb250ZW50RXhwOiAnJicsIG9yaWdpblNjb3BlOiAnJicgfSxcclxuICAgIHRlbXBsYXRlVXJsOiAndWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cC5odG1sJ1xyXG4gIH07XHJcbn0pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJUb29sdGlwVGVtcGxhdGUnLCBbJyR1aWJUb29sdGlwJywgZnVuY3Rpb24oJHVpYlRvb2x0aXApIHtcclxuICByZXR1cm4gJHVpYlRvb2x0aXAoJ3VpYlRvb2x0aXBUZW1wbGF0ZScsICd0b29sdGlwJywgJ21vdXNlZW50ZXInLCB7XHJcbiAgICB1c2VDb250ZW50RXhwOiB0cnVlXHJcbiAgfSk7XHJcbn1dKVxyXG5cclxuLmRpcmVjdGl2ZSgndWliVG9vbHRpcEh0bWxQb3B1cCcsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgc2NvcGU6IHsgY29udGVudEV4cDogJyYnIH0sXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC1wb3B1cC5odG1sJ1xyXG4gIH07XHJcbn0pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJUb29sdGlwSHRtbCcsIFsnJHVpYlRvb2x0aXAnLCBmdW5jdGlvbigkdWliVG9vbHRpcCkge1xyXG4gIHJldHVybiAkdWliVG9vbHRpcCgndWliVG9vbHRpcEh0bWwnLCAndG9vbHRpcCcsICdtb3VzZWVudGVyJywge1xyXG4gICAgdXNlQ29udGVudEV4cDogdHJ1ZVxyXG4gIH0pO1xyXG59XSk7XHJcblxyXG4vKipcclxuICogVGhlIGZvbGxvd2luZyBmZWF0dXJlcyBhcmUgc3RpbGwgb3V0c3RhbmRpbmc6IHBvcHVwIGRlbGF5LCBhbmltYXRpb24gYXMgYVxyXG4gKiBmdW5jdGlvbiwgcGxhY2VtZW50IGFzIGEgZnVuY3Rpb24sIGluc2lkZSwgc3VwcG9ydCBmb3IgbW9yZSB0cmlnZ2VycyB0aGFuXHJcbiAqIGp1c3QgbW91c2UgZW50ZXIvbGVhdmUsIGFuZCBzZWxlY3RvciBkZWxlZ2F0YXRpb24uXHJcbiAqL1xyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnBvcG92ZXInLCBbJ3VpLmJvb3RzdHJhcC50b29sdGlwJ10pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJQb3BvdmVyVGVtcGxhdGVQb3B1cCcsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgc2NvcGU6IHsgdWliVGl0bGU6ICdAJywgY29udGVudEV4cDogJyYnLCBvcmlnaW5TY29wZTogJyYnIH0sXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUuaHRtbCdcclxuICB9O1xyXG59KVxyXG5cclxuLmRpcmVjdGl2ZSgndWliUG9wb3ZlclRlbXBsYXRlJywgWyckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCR1aWJUb29sdGlwKSB7XHJcbiAgcmV0dXJuICR1aWJUb29sdGlwKCd1aWJQb3BvdmVyVGVtcGxhdGUnLCAncG9wb3ZlcicsICdjbGljaycsIHtcclxuICAgIHVzZUNvbnRlbnRFeHA6IHRydWVcclxuICB9KTtcclxufV0pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJQb3BvdmVySHRtbFBvcHVwJywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICBzY29wZTogeyBjb250ZW50RXhwOiAnJicsIHVpYlRpdGxlOiAnQCcgfSxcclxuICAgIHRlbXBsYXRlVXJsOiAndWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci1odG1sLmh0bWwnXHJcbiAgfTtcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYlBvcG92ZXJIdG1sJywgWyckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCR1aWJUb29sdGlwKSB7XHJcbiAgcmV0dXJuICR1aWJUb29sdGlwKCd1aWJQb3BvdmVySHRtbCcsICdwb3BvdmVyJywgJ2NsaWNrJywge1xyXG4gICAgdXNlQ29udGVudEV4cDogdHJ1ZVxyXG4gIH0pO1xyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYlBvcG92ZXJQb3B1cCcsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgc2NvcGU6IHsgdWliVGl0bGU6ICdAJywgY29udGVudDogJ0AnIH0sXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXIuaHRtbCdcclxuICB9O1xyXG59KVxyXG5cclxuLmRpcmVjdGl2ZSgndWliUG9wb3ZlcicsIFsnJHVpYlRvb2x0aXAnLCBmdW5jdGlvbigkdWliVG9vbHRpcCkge1xyXG4gIHJldHVybiAkdWliVG9vbHRpcCgndWliUG9wb3ZlcicsICdwb3BvdmVyJywgJ2NsaWNrJyk7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucHJvZ3Jlc3NiYXInLCBbXSlcclxuXHJcbi5jb25zdGFudCgndWliUHJvZ3Jlc3NDb25maWcnLCB7XHJcbiAgYW5pbWF0ZTogdHJ1ZSxcclxuICBtYXg6IDEwMFxyXG59KVxyXG5cclxuLmNvbnRyb2xsZXIoJ1VpYlByb2dyZXNzQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICd1aWJQcm9ncmVzc0NvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCBwcm9ncmVzc0NvbmZpZykge1xyXG4gIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgYW5pbWF0ZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5hbmltYXRlKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5hbmltYXRlKSA6IHByb2dyZXNzQ29uZmlnLmFuaW1hdGU7XHJcblxyXG4gIHRoaXMuYmFycyA9IFtdO1xyXG4gICRzY29wZS5tYXggPSBnZXRNYXhPckRlZmF1bHQoKTtcclxuXHJcbiAgdGhpcy5hZGRCYXIgPSBmdW5jdGlvbihiYXIsIGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICBpZiAoIWFuaW1hdGUpIHtcclxuICAgICAgZWxlbWVudC5jc3Moeyd0cmFuc2l0aW9uJzogJ25vbmUnfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5iYXJzLnB1c2goYmFyKTtcclxuXHJcbiAgICBiYXIubWF4ID0gZ2V0TWF4T3JEZWZhdWx0KCk7XHJcbiAgICBiYXIudGl0bGUgPSBhdHRycyAmJiBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50aXRsZSkgPyBhdHRycy50aXRsZSA6ICdwcm9ncmVzc2Jhcic7XHJcblxyXG4gICAgYmFyLiR3YXRjaCgndmFsdWUnLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBiYXIucmVjYWxjdWxhdGVQZXJjZW50YWdlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBiYXIucmVjYWxjdWxhdGVQZXJjZW50YWdlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciB0b3RhbFBlcmNlbnRhZ2UgPSBzZWxmLmJhcnMucmVkdWNlKGZ1bmN0aW9uKHRvdGFsLCBiYXIpIHtcclxuICAgICAgICBiYXIucGVyY2VudCA9ICsoMTAwICogYmFyLnZhbHVlIC8gYmFyLm1heCkudG9GaXhlZCgyKTtcclxuICAgICAgICByZXR1cm4gdG90YWwgKyBiYXIucGVyY2VudDtcclxuICAgICAgfSwgMCk7XHJcblxyXG4gICAgICBpZiAodG90YWxQZXJjZW50YWdlID4gMTAwKSB7XHJcbiAgICAgICAgYmFyLnBlcmNlbnQgLT0gdG90YWxQZXJjZW50YWdlIC0gMTAwO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGJhci4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGVsZW1lbnQgPSBudWxsO1xyXG4gICAgICBzZWxmLnJlbW92ZUJhcihiYXIpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5yZW1vdmVCYXIgPSBmdW5jdGlvbihiYXIpIHtcclxuICAgIHRoaXMuYmFycy5zcGxpY2UodGhpcy5iYXJzLmluZGV4T2YoYmFyKSwgMSk7XHJcbiAgICB0aGlzLmJhcnMuZm9yRWFjaChmdW5jdGlvbiAoYmFyKSB7XHJcbiAgICAgIGJhci5yZWNhbGN1bGF0ZVBlcmNlbnRhZ2UoKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vJGF0dHJzLiRvYnNlcnZlKCdtYXhQYXJhbScsIGZ1bmN0aW9uKG1heFBhcmFtKSB7XHJcbiAgJHNjb3BlLiR3YXRjaCgnbWF4UGFyYW0nLCBmdW5jdGlvbihtYXhQYXJhbSkge1xyXG4gICAgc2VsZi5iYXJzLmZvckVhY2goZnVuY3Rpb24oYmFyKSB7XHJcbiAgICAgIGJhci5tYXggPSBnZXRNYXhPckRlZmF1bHQoKTtcclxuICAgICAgYmFyLnJlY2FsY3VsYXRlUGVyY2VudGFnZSgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIGdldE1heE9yRGVmYXVsdCAoKSB7XHJcbiAgICByZXR1cm4gYW5ndWxhci5pc0RlZmluZWQoJHNjb3BlLm1heFBhcmFtKSA/ICRzY29wZS5tYXhQYXJhbSA6IHByb2dyZXNzQ29uZmlnLm1heDtcclxuICB9XHJcbn1dKVxyXG5cclxuLmRpcmVjdGl2ZSgndWliUHJvZ3Jlc3MnLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICBjb250cm9sbGVyOiAnVWliUHJvZ3Jlc3NDb250cm9sbGVyJyxcclxuICAgIHJlcXVpcmU6ICd1aWJQcm9ncmVzcycsXHJcbiAgICBzY29wZToge1xyXG4gICAgICBtYXhQYXJhbTogJz0/bWF4J1xyXG4gICAgfSxcclxuICAgIHRlbXBsYXRlVXJsOiAndWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWwnXHJcbiAgfTtcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYkJhcicsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgIHJlcXVpcmU6ICdedWliUHJvZ3Jlc3MnLFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgdmFsdWU6ICc9JyxcclxuICAgICAgdHlwZTogJ0AnXHJcbiAgICB9LFxyXG4gICAgdGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWwnLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBwcm9ncmVzc0N0cmwpIHtcclxuICAgICAgcHJvZ3Jlc3NDdHJsLmFkZEJhcihzY29wZSwgZWxlbWVudCwgYXR0cnMpO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJQcm9ncmVzc2JhcicsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgIGNvbnRyb2xsZXI6ICdVaWJQcm9ncmVzc0NvbnRyb2xsZXInLFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgdmFsdWU6ICc9JyxcclxuICAgICAgbWF4UGFyYW06ICc9P21heCcsXHJcbiAgICAgIHR5cGU6ICdAJ1xyXG4gICAgfSxcclxuICAgIHRlbXBsYXRlVXJsOiAndWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmh0bWwnLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBwcm9ncmVzc0N0cmwpIHtcclxuICAgICAgcHJvZ3Jlc3NDdHJsLmFkZEJhcihzY29wZSwgYW5ndWxhci5lbGVtZW50KGVsZW1lbnQuY2hpbGRyZW4oKVswXSksIHt0aXRsZTogYXR0cnMudGl0bGV9KTtcclxuICAgIH1cclxuICB9O1xyXG59KTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucmF0aW5nJywgW10pXHJcblxyXG4uY29uc3RhbnQoJ3VpYlJhdGluZ0NvbmZpZycsIHtcclxuICBtYXg6IDUsXHJcbiAgc3RhdGVPbjogbnVsbCxcclxuICBzdGF0ZU9mZjogbnVsbCxcclxuICBlbmFibGVSZXNldDogdHJ1ZSxcclxuICB0aXRsZXM6IFsnb25lJywgJ3R3bycsICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnXVxyXG59KVxyXG5cclxuLmNvbnRyb2xsZXIoJ1VpYlJhdGluZ0NvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAndWliUmF0aW5nQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsIHJhdGluZ0NvbmZpZykge1xyXG4gIHZhciBuZ01vZGVsQ3RybCA9IHsgJHNldFZpZXdWYWx1ZTogYW5ndWxhci5ub29wIH0sXHJcbiAgICBzZWxmID0gdGhpcztcclxuXHJcbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmxfKSB7XHJcbiAgICBuZ01vZGVsQ3RybCA9IG5nTW9kZWxDdHJsXztcclxuICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSB0aGlzLnJlbmRlcjtcclxuXHJcbiAgICBuZ01vZGVsQ3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGlmIChhbmd1bGFyLmlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA8PCAwICE9PSB2YWx1ZSkge1xyXG4gICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc3RhdGVPbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zdGF0ZU9uKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5zdGF0ZU9uKSA6IHJhdGluZ0NvbmZpZy5zdGF0ZU9uO1xyXG4gICAgdGhpcy5zdGF0ZU9mZiA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zdGF0ZU9mZikgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuc3RhdGVPZmYpIDogcmF0aW5nQ29uZmlnLnN0YXRlT2ZmO1xyXG4gICAgdGhpcy5lbmFibGVSZXNldCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5lbmFibGVSZXNldCkgP1xyXG4gICAgICAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuZW5hYmxlUmVzZXQpIDogcmF0aW5nQ29uZmlnLmVuYWJsZVJlc2V0O1xyXG4gICAgdmFyIHRtcFRpdGxlcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy50aXRsZXMpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnRpdGxlcykgOiByYXRpbmdDb25maWcudGl0bGVzO1xyXG4gICAgdGhpcy50aXRsZXMgPSBhbmd1bGFyLmlzQXJyYXkodG1wVGl0bGVzKSAmJiB0bXBUaXRsZXMubGVuZ3RoID4gMCA/XHJcbiAgICAgIHRtcFRpdGxlcyA6IHJhdGluZ0NvbmZpZy50aXRsZXM7XHJcblxyXG4gICAgdmFyIHJhdGluZ1N0YXRlcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5yYXRpbmdTdGF0ZXMpID9cclxuICAgICAgJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnJhdGluZ1N0YXRlcykgOlxyXG4gICAgICBuZXcgQXJyYXkoYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLm1heCkgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMubWF4KSA6IHJhdGluZ0NvbmZpZy5tYXgpO1xyXG4gICAgJHNjb3BlLnJhbmdlID0gdGhpcy5idWlsZFRlbXBsYXRlT2JqZWN0cyhyYXRpbmdTdGF0ZXMpO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuYnVpbGRUZW1wbGF0ZU9iamVjdHMgPSBmdW5jdGlvbihzdGF0ZXMpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gc3RhdGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICBzdGF0ZXNbaV0gPSBhbmd1bGFyLmV4dGVuZCh7IGluZGV4OiBpIH0sIHsgc3RhdGVPbjogdGhpcy5zdGF0ZU9uLCBzdGF0ZU9mZjogdGhpcy5zdGF0ZU9mZiwgdGl0bGU6IHRoaXMuZ2V0VGl0bGUoaSkgfSwgc3RhdGVzW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdGF0ZXM7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5nZXRUaXRsZSA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICBpZiAoaW5kZXggPj0gdGhpcy50aXRsZXMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBpbmRleCArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudGl0bGVzW2luZGV4XTtcclxuICB9O1xyXG5cclxuICAkc2NvcGUucmF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZiAoISRzY29wZS5yZWFkb25seSAmJiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9ICRzY29wZS5yYW5nZS5sZW5ndGgpIHtcclxuICAgICAgdmFyIG5ld1ZpZXdWYWx1ZSA9IHNlbGYuZW5hYmxlUmVzZXQgJiYgbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA9PT0gdmFsdWUgPyAwIDogdmFsdWU7XHJcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUobmV3Vmlld1ZhbHVlKTtcclxuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gICRzY29wZS5lbnRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZiAoISRzY29wZS5yZWFkb25seSkge1xyXG4gICAgICAkc2NvcGUudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgICRzY29wZS5vbkhvdmVyKHt2YWx1ZTogdmFsdWV9KTtcclxuICB9O1xyXG5cclxuICAkc2NvcGUucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICRzY29wZS52YWx1ZSA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWU7XHJcbiAgICAkc2NvcGUub25MZWF2ZSgpO1xyXG4gIH07XHJcblxyXG4gICRzY29wZS5vbktleWRvd24gPSBmdW5jdGlvbihldnQpIHtcclxuICAgIGlmICgvKDM3fDM4fDM5fDQwKS8udGVzdChldnQud2hpY2gpKSB7XHJcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICRzY29wZS5yYXRlKCRzY29wZS52YWx1ZSArIChldnQud2hpY2ggPT09IDM4IHx8IGV2dC53aGljaCA9PT0gMzkgPyAxIDogLTEpKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgJHNjb3BlLnZhbHVlID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZTtcclxuICAgICRzY29wZS50aXRsZSA9IHNlbGYuZ2V0VGl0bGUoJHNjb3BlLnZhbHVlIC0gMSk7XHJcbiAgfTtcclxufV0pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJSYXRpbmcnLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVxdWlyZTogWyd1aWJSYXRpbmcnLCAnbmdNb2RlbCddLFxyXG4gICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgIHNjb3BlOiB7XHJcbiAgICAgIHJlYWRvbmx5OiAnPT9yZWFkT25seScsXHJcbiAgICAgIG9uSG92ZXI6ICcmJyxcclxuICAgICAgb25MZWF2ZTogJyYnXHJcbiAgICB9LFxyXG4gICAgY29udHJvbGxlcjogJ1VpYlJhdGluZ0NvbnRyb2xsZXInLFxyXG4gICAgdGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcclxuICAgICAgdmFyIHJhdGluZ0N0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcclxuICAgICAgcmF0aW5nQ3RybC5pbml0KG5nTW9kZWxDdHJsKTtcclxuICAgIH1cclxuICB9O1xyXG59KTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudGFicycsIFtdKVxyXG5cclxuLmNvbnRyb2xsZXIoJ1VpYlRhYnNldENvbnRyb2xsZXInLCBbJyRzY29wZScsIGZ1bmN0aW9uICgkc2NvcGUpIHtcclxuICB2YXIgY3RybCA9IHRoaXMsXHJcbiAgICBvbGRJbmRleDtcclxuICBjdHJsLnRhYnMgPSBbXTtcclxuXHJcbiAgY3RybC5zZWxlY3QgPSBmdW5jdGlvbihpbmRleCwgZXZ0KSB7XHJcbiAgICBpZiAoIWRlc3Ryb3llZCkge1xyXG4gICAgICB2YXIgcHJldmlvdXNJbmRleCA9IGZpbmRUYWJJbmRleChvbGRJbmRleCk7XHJcbiAgICAgIHZhciBwcmV2aW91c1NlbGVjdGVkID0gY3RybC50YWJzW3ByZXZpb3VzSW5kZXhdO1xyXG4gICAgICBpZiAocHJldmlvdXNTZWxlY3RlZCkge1xyXG4gICAgICAgIHByZXZpb3VzU2VsZWN0ZWQudGFiLm9uRGVzZWxlY3Qoe1xyXG4gICAgICAgICAgJGV2ZW50OiBldnQsXHJcbiAgICAgICAgICAkc2VsZWN0ZWRJbmRleDogaW5kZXhcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZXZ0ICYmIGV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2aW91c1NlbGVjdGVkLnRhYi5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNlbGVjdGVkID0gY3RybC50YWJzW2luZGV4XTtcclxuICAgICAgaWYgKHNlbGVjdGVkKSB7XHJcbiAgICAgICAgc2VsZWN0ZWQudGFiLm9uU2VsZWN0KHtcclxuICAgICAgICAgICRldmVudDogZXZ0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2VsZWN0ZWQudGFiLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgY3RybC5hY3RpdmUgPSBzZWxlY3RlZC5pbmRleDtcclxuICAgICAgICBvbGRJbmRleCA9IHNlbGVjdGVkLmluZGV4O1xyXG4gICAgICB9IGVsc2UgaWYgKCFzZWxlY3RlZCAmJiBhbmd1bGFyLmlzRGVmaW5lZChvbGRJbmRleCkpIHtcclxuICAgICAgICBjdHJsLmFjdGl2ZSA9IG51bGw7XHJcbiAgICAgICAgb2xkSW5kZXggPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY3RybC5hZGRUYWIgPSBmdW5jdGlvbiBhZGRUYWIodGFiKSB7XHJcbiAgICBjdHJsLnRhYnMucHVzaCh7XHJcbiAgICAgIHRhYjogdGFiLFxyXG4gICAgICBpbmRleDogdGFiLmluZGV4XHJcbiAgICB9KTtcclxuICAgIGN0cmwudGFicy5zb3J0KGZ1bmN0aW9uKHQxLCB0Mikge1xyXG4gICAgICBpZiAodDEuaW5kZXggPiB0Mi5pbmRleCkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodDEuaW5kZXggPCB0Mi5pbmRleCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGFiLmluZGV4ID09PSBjdHJsLmFjdGl2ZSB8fCAhYW5ndWxhci5pc0RlZmluZWQoY3RybC5hY3RpdmUpICYmIGN0cmwudGFicy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgdmFyIG5ld0FjdGl2ZUluZGV4ID0gZmluZFRhYkluZGV4KHRhYi5pbmRleCk7XHJcbiAgICAgIGN0cmwuc2VsZWN0KG5ld0FjdGl2ZUluZGV4KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjdHJsLnJlbW92ZVRhYiA9IGZ1bmN0aW9uIHJlbW92ZVRhYih0YWIpIHtcclxuICAgIHZhciBpbmRleDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3RybC50YWJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChjdHJsLnRhYnNbaV0udGFiID09PSB0YWIpIHtcclxuICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoY3RybC50YWJzW2luZGV4XS5pbmRleCA9PT0gY3RybC5hY3RpdmUpIHtcclxuICAgICAgdmFyIG5ld0FjdGl2ZVRhYkluZGV4ID0gaW5kZXggPT09IGN0cmwudGFicy5sZW5ndGggLSAxID9cclxuICAgICAgICBpbmRleCAtIDEgOiBpbmRleCArIDEgJSBjdHJsLnRhYnMubGVuZ3RoO1xyXG4gICAgICBjdHJsLnNlbGVjdChuZXdBY3RpdmVUYWJJbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgY3RybC50YWJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLiR3YXRjaCgndGFic2V0LmFjdGl2ZScsIGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKHZhbCkgJiYgdmFsICE9PSBvbGRJbmRleCkge1xyXG4gICAgICBjdHJsLnNlbGVjdChmaW5kVGFiSW5kZXgodmFsKSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHZhciBkZXN0cm95ZWQ7XHJcbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgIGRlc3Ryb3llZCA9IHRydWU7XHJcbiAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIGZpbmRUYWJJbmRleChpbmRleCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHJsLnRhYnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGN0cmwudGFic1tpXS5pbmRleCA9PT0gaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gaTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufV0pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJUYWJzZXQnLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICBzY29wZToge30sXHJcbiAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgIGFjdGl2ZTogJz0/JyxcclxuICAgICAgdHlwZTogJ0AnXHJcbiAgICB9LFxyXG4gICAgY29udHJvbGxlcjogJ1VpYlRhYnNldENvbnRyb2xsZXInLFxyXG4gICAgY29udHJvbGxlckFzOiAndGFic2V0JyxcclxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xyXG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sJztcclxuICAgIH0sXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcclxuICAgICAgc2NvcGUudmVydGljYWwgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy52ZXJ0aWNhbCkgP1xyXG4gICAgICAgIHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMudmVydGljYWwpIDogZmFsc2U7XHJcbiAgICAgIHNjb3BlLmp1c3RpZmllZCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmp1c3RpZmllZCkgP1xyXG4gICAgICAgIHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMuanVzdGlmaWVkKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJUYWInLCBbJyRwYXJzZScsIGZ1bmN0aW9uKCRwYXJzZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXF1aXJlOiAnXnVpYlRhYnNldCcsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL3RhYnMvdGFiLmh0bWwnO1xyXG4gICAgfSxcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICBzY29wZToge1xyXG4gICAgICBoZWFkaW5nOiAnQCcsXHJcbiAgICAgIGluZGV4OiAnPT8nLFxyXG4gICAgICBjbGFzc2VzOiAnQD8nLFxyXG4gICAgICBvblNlbGVjdDogJyZzZWxlY3QnLCAvL1RoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIGluIGNvbnRlbnRIZWFkaW5nVHJhbnNjbHVkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vb25jZSBpdCBpbnNlcnRzIHRoZSB0YWIncyBjb250ZW50IGludG8gdGhlIGRvbVxyXG4gICAgICBvbkRlc2VsZWN0OiAnJmRlc2VsZWN0J1xyXG4gICAgfSxcclxuICAgIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAvL0VtcHR5IGNvbnRyb2xsZXIgc28gb3RoZXIgZGlyZWN0aXZlcyBjYW4gcmVxdWlyZSBiZWluZyAndW5kZXInIGEgdGFiXHJcbiAgICB9LFxyXG4gICAgY29udHJvbGxlckFzOiAndGFiJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbG0sIGF0dHJzLCB0YWJzZXRDdHJsLCB0cmFuc2NsdWRlKSB7XHJcbiAgICAgIHNjb3BlLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgIGlmIChhdHRycy5kaXNhYmxlKSB7XHJcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLmRpc2FibGUpLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgc2NvcGUuZGlzYWJsZWQgPSAhISB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGFuZ3VsYXIuaXNVbmRlZmluZWQoYXR0cnMuaW5kZXgpKSB7XHJcbiAgICAgICAgaWYgKHRhYnNldEN0cmwudGFicyAmJiB0YWJzZXRDdHJsLnRhYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBzY29wZS5pbmRleCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHRhYnNldEN0cmwudGFicy5tYXAoZnVuY3Rpb24odCkgeyByZXR1cm4gdC5pbmRleDsgfSkpICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2NvcGUuaW5kZXggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGFuZ3VsYXIuaXNVbmRlZmluZWQoYXR0cnMuY2xhc3NlcykpIHtcclxuICAgICAgICBzY29wZS5jbGFzc2VzID0gJyc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgIGlmICghc2NvcGUuZGlzYWJsZWQpIHtcclxuICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFic2V0Q3RybC50YWJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0YWJzZXRDdHJsLnRhYnNbaV0udGFiID09PSBzY29wZSkge1xyXG4gICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRhYnNldEN0cmwuc2VsZWN0KGluZGV4LCBldnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRhYnNldEN0cmwuYWRkVGFiKHNjb3BlKTtcclxuICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRhYnNldEN0cmwucmVtb3ZlVGFiKHNjb3BlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvL1dlIG5lZWQgdG8gdHJhbnNjbHVkZSBsYXRlciwgb25jZSB0aGUgY29udGVudCBjb250YWluZXIgaXMgcmVhZHkuXHJcbiAgICAgIC8vd2hlbiB0aGlzIGxpbmsgaGFwcGVucywgd2UncmUgaW5zaWRlIGEgdGFiIGhlYWRpbmcuXHJcbiAgICAgIHNjb3BlLiR0cmFuc2NsdWRlRm4gPSB0cmFuc2NsdWRlO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKVxyXG5cclxuLmRpcmVjdGl2ZSgndWliVGFiSGVhZGluZ1RyYW5zY2x1ZGUnLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgIHJlcXVpcmU6ICdedWliVGFiJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbG0pIHtcclxuICAgICAgc2NvcGUuJHdhdGNoKCdoZWFkaW5nRWxlbWVudCcsIGZ1bmN0aW9uIHVwZGF0ZUhlYWRpbmdFbGVtZW50KGhlYWRpbmcpIHtcclxuICAgICAgICBpZiAoaGVhZGluZykge1xyXG4gICAgICAgICAgZWxtLmh0bWwoJycpO1xyXG4gICAgICAgICAgZWxtLmFwcGVuZChoZWFkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pXHJcblxyXG4uZGlyZWN0aXZlKCd1aWJUYWJDb250ZW50VHJhbnNjbHVkZScsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgcmVxdWlyZTogJ151aWJUYWJzZXQnLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMpIHtcclxuICAgICAgdmFyIHRhYiA9IHNjb3BlLiRldmFsKGF0dHJzLnVpYlRhYkNvbnRlbnRUcmFuc2NsdWRlKS50YWI7XHJcblxyXG4gICAgICAvL05vdyBvdXIgdGFiIGlzIHJlYWR5IHRvIGJlIHRyYW5zY2x1ZGVkOiBib3RoIHRoZSB0YWIgaGVhZGluZyBhcmVhXHJcbiAgICAgIC8vYW5kIHRoZSB0YWIgY29udGVudCBhcmVhIGFyZSBsb2FkZWQuICBUcmFuc2NsdWRlICdlbSBib3RoLlxyXG4gICAgICB0YWIuJHRyYW5zY2x1ZGVGbih0YWIuJHBhcmVudCwgZnVuY3Rpb24oY29udGVudHMpIHtcclxuICAgICAgICBhbmd1bGFyLmZvckVhY2goY29udGVudHMsIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgIGlmIChpc1RhYkhlYWRpbmcobm9kZSkpIHtcclxuICAgICAgICAgICAgLy9MZXQgdGFiSGVhZGluZ1RyYW5zY2x1ZGUga25vdy5cclxuICAgICAgICAgICAgdGFiLmhlYWRpbmdFbGVtZW50ID0gbm9kZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsbS5hcHBlbmQobm9kZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGlzVGFiSGVhZGluZyhub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS50YWdOYW1lICYmIChcclxuICAgICAgbm9kZS5oYXNBdHRyaWJ1dGUoJ3VpYi10YWItaGVhZGluZycpIHx8XHJcbiAgICAgIG5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXVpYi10YWItaGVhZGluZycpIHx8XHJcbiAgICAgIG5vZGUuaGFzQXR0cmlidXRlKCd4LXVpYi10YWItaGVhZGluZycpIHx8XHJcbiAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndWliLXRhYi1oZWFkaW5nJyB8fFxyXG4gICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RhdGEtdWliLXRhYi1oZWFkaW5nJyB8fFxyXG4gICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3gtdWliLXRhYi1oZWFkaW5nJyB8fFxyXG4gICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3VpYjp0YWItaGVhZGluZydcclxuICAgICk7XHJcbiAgfVxyXG59KTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudGltZXBpY2tlcicsIFtdKVxyXG5cclxuLmNvbnN0YW50KCd1aWJUaW1lcGlja2VyQ29uZmlnJywge1xyXG4gIGhvdXJTdGVwOiAxLFxyXG4gIG1pbnV0ZVN0ZXA6IDEsXHJcbiAgc2Vjb25kU3RlcDogMSxcclxuICBzaG93TWVyaWRpYW46IHRydWUsXHJcbiAgc2hvd1NlY29uZHM6IGZhbHNlLFxyXG4gIG1lcmlkaWFuczogbnVsbCxcclxuICByZWFkb25seUlucHV0OiBmYWxzZSxcclxuICBtb3VzZXdoZWVsOiB0cnVlLFxyXG4gIGFycm93a2V5czogdHJ1ZSxcclxuICBzaG93U3Bpbm5lcnM6IHRydWUsXHJcbiAgdGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWwnXHJcbn0pXHJcblxyXG4uY29udHJvbGxlcignVWliVGltZXBpY2tlckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckYXR0cnMnLCAnJHBhcnNlJywgJyRsb2cnLCAnJGxvY2FsZScsICd1aWJUaW1lcGlja2VyQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzLCAkcGFyc2UsICRsb2csICRsb2NhbGUsIHRpbWVwaWNrZXJDb25maWcpIHtcclxuICB2YXIgaG91cnNNb2RlbEN0cmwsIG1pbnV0ZXNNb2RlbEN0cmwsIHNlY29uZHNNb2RlbEN0cmw7XHJcbiAgdmFyIHNlbGVjdGVkID0gbmV3IERhdGUoKSxcclxuICAgIHdhdGNoZXJzID0gW10sXHJcbiAgICBuZ01vZGVsQ3RybCA9IHsgJHNldFZpZXdWYWx1ZTogYW5ndWxhci5ub29wIH0sIC8vIG51bGxNb2RlbEN0cmxcclxuICAgIG1lcmlkaWFucyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5tZXJpZGlhbnMpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLm1lcmlkaWFucykgOiB0aW1lcGlja2VyQ29uZmlnLm1lcmlkaWFucyB8fCAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuQU1QTVMsXHJcbiAgICBwYWRIb3VycyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5wYWRIb3VycykgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMucGFkSG91cnMpIDogdHJ1ZTtcclxuXHJcbiAgJHNjb3BlLnRhYmluZGV4ID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnRhYmluZGV4KSA/ICRhdHRycy50YWJpbmRleCA6IDA7XHJcbiAgJGVsZW1lbnQucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcclxuXHJcbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmxfLCBpbnB1dHMpIHtcclxuICAgIG5nTW9kZWxDdHJsID0gbmdNb2RlbEN0cmxfO1xyXG4gICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IHRoaXMucmVuZGVyO1xyXG5cclxuICAgIG5nTW9kZWxDdHJsLiRmb3JtYXR0ZXJzLnVuc2hpZnQoZnVuY3Rpb24obW9kZWxWYWx1ZSkge1xyXG4gICAgICByZXR1cm4gbW9kZWxWYWx1ZSA/IG5ldyBEYXRlKG1vZGVsVmFsdWUpIDogbnVsbDtcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBob3Vyc0lucHV0RWwgPSBpbnB1dHMuZXEoMCksXHJcbiAgICAgICAgbWludXRlc0lucHV0RWwgPSBpbnB1dHMuZXEoMSksXHJcbiAgICAgICAgc2Vjb25kc0lucHV0RWwgPSBpbnB1dHMuZXEoMik7XHJcblxyXG4gICAgaG91cnNNb2RlbEN0cmwgPSBob3Vyc0lucHV0RWwuY29udHJvbGxlcignbmdNb2RlbCcpO1xyXG4gICAgbWludXRlc01vZGVsQ3RybCA9IG1pbnV0ZXNJbnB1dEVsLmNvbnRyb2xsZXIoJ25nTW9kZWwnKTtcclxuICAgIHNlY29uZHNNb2RlbEN0cmwgPSBzZWNvbmRzSW5wdXRFbC5jb250cm9sbGVyKCduZ01vZGVsJyk7XHJcblxyXG4gICAgdmFyIG1vdXNld2hlZWwgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMubW91c2V3aGVlbCkgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMubW91c2V3aGVlbCkgOiB0aW1lcGlja2VyQ29uZmlnLm1vdXNld2hlZWw7XHJcblxyXG4gICAgaWYgKG1vdXNld2hlZWwpIHtcclxuICAgICAgdGhpcy5zZXR1cE1vdXNld2hlZWxFdmVudHMoaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCwgc2Vjb25kc0lucHV0RWwpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhcnJvd2tleXMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuYXJyb3drZXlzKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5hcnJvd2tleXMpIDogdGltZXBpY2tlckNvbmZpZy5hcnJvd2tleXM7XHJcbiAgICBpZiAoYXJyb3drZXlzKSB7XHJcbiAgICAgIHRoaXMuc2V0dXBBcnJvd2tleUV2ZW50cyhob3Vyc0lucHV0RWwsIG1pbnV0ZXNJbnB1dEVsLCBzZWNvbmRzSW5wdXRFbCk7XHJcbiAgICB9XHJcblxyXG4gICAgJHNjb3BlLnJlYWRvbmx5SW5wdXQgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMucmVhZG9ubHlJbnB1dCkgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMucmVhZG9ubHlJbnB1dCkgOiB0aW1lcGlja2VyQ29uZmlnLnJlYWRvbmx5SW5wdXQ7XHJcbiAgICB0aGlzLnNldHVwSW5wdXRFdmVudHMoaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCwgc2Vjb25kc0lucHV0RWwpO1xyXG4gIH07XHJcblxyXG4gIHZhciBob3VyU3RlcCA9IHRpbWVwaWNrZXJDb25maWcuaG91clN0ZXA7XHJcbiAgaWYgKCRhdHRycy5ob3VyU3RlcCkge1xyXG4gICAgd2F0Y2hlcnMucHVzaCgkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5ob3VyU3RlcCksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGhvdXJTdGVwID0gK3ZhbHVlO1xyXG4gICAgfSkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIG1pbnV0ZVN0ZXAgPSB0aW1lcGlja2VyQ29uZmlnLm1pbnV0ZVN0ZXA7XHJcbiAgaWYgKCRhdHRycy5taW51dGVTdGVwKSB7XHJcbiAgICB3YXRjaGVycy5wdXNoKCRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLm1pbnV0ZVN0ZXApLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBtaW51dGVTdGVwID0gK3ZhbHVlO1xyXG4gICAgfSkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIG1pbjtcclxuICB3YXRjaGVycy5wdXNoKCRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLm1pbiksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICB2YXIgZHQgPSBuZXcgRGF0ZSh2YWx1ZSk7XHJcbiAgICBtaW4gPSBpc05hTihkdCkgPyB1bmRlZmluZWQgOiBkdDtcclxuICB9KSk7XHJcblxyXG4gIHZhciBtYXg7XHJcbiAgd2F0Y2hlcnMucHVzaCgkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5tYXgpLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgdmFyIGR0ID0gbmV3IERhdGUodmFsdWUpO1xyXG4gICAgbWF4ID0gaXNOYU4oZHQpID8gdW5kZWZpbmVkIDogZHQ7XHJcbiAgfSkpO1xyXG5cclxuICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcclxuICBpZiAoJGF0dHJzLm5nRGlzYWJsZWQpIHtcclxuICAgIHdhdGNoZXJzLnB1c2goJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMubmdEaXNhYmxlZCksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGRpc2FibGVkID0gdmFsdWU7XHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxuICAkc2NvcGUubm9JbmNyZW1lbnRIb3VycyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGluY3JlbWVudGVkU2VsZWN0ZWQgPSBhZGRNaW51dGVzKHNlbGVjdGVkLCBob3VyU3RlcCAqIDYwKTtcclxuICAgIHJldHVybiBkaXNhYmxlZCB8fCBpbmNyZW1lbnRlZFNlbGVjdGVkID4gbWF4IHx8XHJcbiAgICAgIGluY3JlbWVudGVkU2VsZWN0ZWQgPCBzZWxlY3RlZCAmJiBpbmNyZW1lbnRlZFNlbGVjdGVkIDwgbWluO1xyXG4gIH07XHJcblxyXG4gICRzY29wZS5ub0RlY3JlbWVudEhvdXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZGVjcmVtZW50ZWRTZWxlY3RlZCA9IGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIC1ob3VyU3RlcCAqIDYwKTtcclxuICAgIHJldHVybiBkaXNhYmxlZCB8fCBkZWNyZW1lbnRlZFNlbGVjdGVkIDwgbWluIHx8XHJcbiAgICAgIGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBzZWxlY3RlZCAmJiBkZWNyZW1lbnRlZFNlbGVjdGVkID4gbWF4O1xyXG4gIH07XHJcblxyXG4gICRzY29wZS5ub0luY3JlbWVudE1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpbmNyZW1lbnRlZFNlbGVjdGVkID0gYWRkTWludXRlcyhzZWxlY3RlZCwgbWludXRlU3RlcCk7XHJcbiAgICByZXR1cm4gZGlzYWJsZWQgfHwgaW5jcmVtZW50ZWRTZWxlY3RlZCA+IG1heCB8fFxyXG4gICAgICBpbmNyZW1lbnRlZFNlbGVjdGVkIDwgc2VsZWN0ZWQgJiYgaW5jcmVtZW50ZWRTZWxlY3RlZCA8IG1pbjtcclxuICB9O1xyXG5cclxuICAkc2NvcGUubm9EZWNyZW1lbnRNaW51dGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZGVjcmVtZW50ZWRTZWxlY3RlZCA9IGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIC1taW51dGVTdGVwKTtcclxuICAgIHJldHVybiBkaXNhYmxlZCB8fCBkZWNyZW1lbnRlZFNlbGVjdGVkIDwgbWluIHx8XHJcbiAgICAgIGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBzZWxlY3RlZCAmJiBkZWNyZW1lbnRlZFNlbGVjdGVkID4gbWF4O1xyXG4gIH07XHJcblxyXG4gICRzY29wZS5ub0luY3JlbWVudFNlY29uZHMgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpbmNyZW1lbnRlZFNlbGVjdGVkID0gYWRkU2Vjb25kcyhzZWxlY3RlZCwgc2Vjb25kU3RlcCk7XHJcbiAgICByZXR1cm4gZGlzYWJsZWQgfHwgaW5jcmVtZW50ZWRTZWxlY3RlZCA+IG1heCB8fFxyXG4gICAgICBpbmNyZW1lbnRlZFNlbGVjdGVkIDwgc2VsZWN0ZWQgJiYgaW5jcmVtZW50ZWRTZWxlY3RlZCA8IG1pbjtcclxuICB9O1xyXG5cclxuICAkc2NvcGUubm9EZWNyZW1lbnRTZWNvbmRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZGVjcmVtZW50ZWRTZWxlY3RlZCA9IGFkZFNlY29uZHMoc2VsZWN0ZWQsIC1zZWNvbmRTdGVwKTtcclxuICAgIHJldHVybiBkaXNhYmxlZCB8fCBkZWNyZW1lbnRlZFNlbGVjdGVkIDwgbWluIHx8XHJcbiAgICAgIGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBzZWxlY3RlZCAmJiBkZWNyZW1lbnRlZFNlbGVjdGVkID4gbWF4O1xyXG4gIH07XHJcblxyXG4gICRzY29wZS5ub1RvZ2dsZU1lcmlkaWFuID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoc2VsZWN0ZWQuZ2V0SG91cnMoKSA8IDEyKSB7XHJcbiAgICAgIHJldHVybiBkaXNhYmxlZCB8fCBhZGRNaW51dGVzKHNlbGVjdGVkLCAxMiAqIDYwKSA+IG1heDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGlzYWJsZWQgfHwgYWRkTWludXRlcyhzZWxlY3RlZCwgLTEyICogNjApIDwgbWluO1xyXG4gIH07XHJcblxyXG4gIHZhciBzZWNvbmRTdGVwID0gdGltZXBpY2tlckNvbmZpZy5zZWNvbmRTdGVwO1xyXG4gIGlmICgkYXR0cnMuc2Vjb25kU3RlcCkge1xyXG4gICAgd2F0Y2hlcnMucHVzaCgkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5zZWNvbmRTdGVwKSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgc2Vjb25kU3RlcCA9ICt2YWx1ZTtcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gICRzY29wZS5zaG93U2Vjb25kcyA9IHRpbWVwaWNrZXJDb25maWcuc2hvd1NlY29uZHM7XHJcbiAgaWYgKCRhdHRycy5zaG93U2Vjb25kcykge1xyXG4gICAgd2F0Y2hlcnMucHVzaCgkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5zaG93U2Vjb25kcyksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICRzY29wZS5zaG93U2Vjb25kcyA9ICEhdmFsdWU7XHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxuICAvLyAxMkggLyAyNEggbW9kZVxyXG4gICRzY29wZS5zaG93TWVyaWRpYW4gPSB0aW1lcGlja2VyQ29uZmlnLnNob3dNZXJpZGlhbjtcclxuICBpZiAoJGF0dHJzLnNob3dNZXJpZGlhbikge1xyXG4gICAgd2F0Y2hlcnMucHVzaCgkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5zaG93TWVyaWRpYW4pLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAkc2NvcGUuc2hvd01lcmlkaWFuID0gISF2YWx1ZTtcclxuXHJcbiAgICAgIGlmIChuZ01vZGVsQ3RybC4kZXJyb3IudGltZSkge1xyXG4gICAgICAgIC8vIEV2YWx1YXRlIGZyb20gdGVtcGxhdGVcclxuICAgICAgICB2YXIgaG91cnMgPSBnZXRIb3Vyc0Zyb21UZW1wbGF0ZSgpLCBtaW51dGVzID0gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpO1xyXG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChob3VycykgJiYgYW5ndWxhci5pc0RlZmluZWQobWludXRlcykpIHtcclxuICAgICAgICAgIHNlbGVjdGVkLnNldEhvdXJzKGhvdXJzKTtcclxuICAgICAgICAgIHJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdXBkYXRlVGVtcGxhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0ICRzY29wZS5ob3VycyBpbiAyNEggbW9kZSBpZiB2YWxpZFxyXG4gIGZ1bmN0aW9uIGdldEhvdXJzRnJvbVRlbXBsYXRlKCkge1xyXG4gICAgdmFyIGhvdXJzID0gKyRzY29wZS5ob3VycztcclxuICAgIHZhciB2YWxpZCA9ICRzY29wZS5zaG93TWVyaWRpYW4gPyBob3VycyA+IDAgJiYgaG91cnMgPCAxMyA6XHJcbiAgICAgIGhvdXJzID49IDAgJiYgaG91cnMgPCAyNDtcclxuICAgIGlmICghdmFsaWQgfHwgJHNjb3BlLmhvdXJzID09PSAnJykge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgkc2NvcGUuc2hvd01lcmlkaWFuKSB7XHJcbiAgICAgIGlmIChob3VycyA9PT0gMTIpIHtcclxuICAgICAgICBob3VycyA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCRzY29wZS5tZXJpZGlhbiA9PT0gbWVyaWRpYW5zWzFdKSB7XHJcbiAgICAgICAgaG91cnMgPSBob3VycyArIDEyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaG91cnM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRNaW51dGVzRnJvbVRlbXBsYXRlKCkge1xyXG4gICAgdmFyIG1pbnV0ZXMgPSArJHNjb3BlLm1pbnV0ZXM7XHJcbiAgICB2YXIgdmFsaWQgPSBtaW51dGVzID49IDAgJiYgbWludXRlcyA8IDYwO1xyXG4gICAgaWYgKCF2YWxpZCB8fCAkc2NvcGUubWludXRlcyA9PT0gJycpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiBtaW51dGVzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0U2Vjb25kc0Zyb21UZW1wbGF0ZSgpIHtcclxuICAgIHZhciBzZWNvbmRzID0gKyRzY29wZS5zZWNvbmRzO1xyXG4gICAgcmV0dXJuIHNlY29uZHMgPj0gMCAmJiBzZWNvbmRzIDwgNjAgPyBzZWNvbmRzIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGFkKHZhbHVlLCBub1BhZCkge1xyXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYW5ndWxhci5pc0RlZmluZWQodmFsdWUpICYmIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoIDwgMiAmJiAhbm9QYWQgP1xyXG4gICAgICAnMCcgKyB2YWx1ZSA6IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXNwb25kIG9uIG1vdXNld2hlZWwgc3BpblxyXG4gIHRoaXMuc2V0dXBNb3VzZXdoZWVsRXZlbnRzID0gZnVuY3Rpb24oaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCwgc2Vjb25kc0lucHV0RWwpIHtcclxuICAgIHZhciBpc1Njcm9sbGluZ1VwID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7XHJcbiAgICAgICAgZSA9IGUub3JpZ2luYWxFdmVudDtcclxuICAgICAgfVxyXG4gICAgICAvL3BpY2sgY29ycmVjdCBkZWx0YSB2YXJpYWJsZSBkZXBlbmRpbmcgb24gZXZlbnRcclxuICAgICAgdmFyIGRlbHRhID0gZS53aGVlbERlbHRhID8gZS53aGVlbERlbHRhIDogLWUuZGVsdGFZO1xyXG4gICAgICByZXR1cm4gZS5kZXRhaWwgfHwgZGVsdGEgPiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBob3Vyc0lucHV0RWwub24oJ21vdXNld2hlZWwgd2hlZWwnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGlmICghZGlzYWJsZWQpIHtcclxuICAgICAgICAkc2NvcGUuJGFwcGx5KGlzU2Nyb2xsaW5nVXAoZSkgPyAkc2NvcGUuaW5jcmVtZW50SG91cnMoKSA6ICRzY29wZS5kZWNyZW1lbnRIb3VycygpKTtcclxuICAgICAgfVxyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBtaW51dGVzSW5wdXRFbC5vbignbW91c2V3aGVlbCB3aGVlbCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgaWYgKCFkaXNhYmxlZCkge1xyXG4gICAgICAgICRzY29wZS4kYXBwbHkoaXNTY3JvbGxpbmdVcChlKSA/ICRzY29wZS5pbmNyZW1lbnRNaW51dGVzKCkgOiAkc2NvcGUuZGVjcmVtZW50TWludXRlcygpKTtcclxuICAgICAgfVxyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAgc2Vjb25kc0lucHV0RWwub24oJ21vdXNld2hlZWwgd2hlZWwnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGlmICghZGlzYWJsZWQpIHtcclxuICAgICAgICAkc2NvcGUuJGFwcGx5KGlzU2Nyb2xsaW5nVXAoZSkgPyAkc2NvcGUuaW5jcmVtZW50U2Vjb25kcygpIDogJHNjb3BlLmRlY3JlbWVudFNlY29uZHMoKSk7XHJcbiAgICAgIH1cclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmVzcG9uZCBvbiB1cC9kb3duIGFycm93a2V5c1xyXG4gIHRoaXMuc2V0dXBBcnJvd2tleUV2ZW50cyA9IGZ1bmN0aW9uKGhvdXJzSW5wdXRFbCwgbWludXRlc0lucHV0RWwsIHNlY29uZHNJbnB1dEVsKSB7XHJcbiAgICBob3Vyc0lucHV0RWwub24oJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGlmICghZGlzYWJsZWQpIHtcclxuICAgICAgICBpZiAoZS53aGljaCA9PT0gMzgpIHsgLy8gdXBcclxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICRzY29wZS5pbmNyZW1lbnRIb3VycygpO1xyXG4gICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PT0gNDApIHsgLy8gZG93blxyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgJHNjb3BlLmRlY3JlbWVudEhvdXJzKCk7XHJcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtaW51dGVzSW5wdXRFbC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgaWYgKCFkaXNhYmxlZCkge1xyXG4gICAgICAgIGlmIChlLndoaWNoID09PSAzOCkgeyAvLyB1cFxyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgJHNjb3BlLmluY3JlbWVudE1pbnV0ZXMoKTtcclxuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IDQwKSB7IC8vIGRvd25cclxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICRzY29wZS5kZWNyZW1lbnRNaW51dGVzKCk7XHJcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBzZWNvbmRzSW5wdXRFbC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgaWYgKCFkaXNhYmxlZCkge1xyXG4gICAgICAgIGlmIChlLndoaWNoID09PSAzOCkgeyAvLyB1cFxyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgJHNjb3BlLmluY3JlbWVudFNlY29uZHMoKTtcclxuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IDQwKSB7IC8vIGRvd25cclxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICRzY29wZS5kZWNyZW1lbnRTZWNvbmRzKCk7XHJcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICB0aGlzLnNldHVwSW5wdXRFdmVudHMgPSBmdW5jdGlvbihob3Vyc0lucHV0RWwsIG1pbnV0ZXNJbnB1dEVsLCBzZWNvbmRzSW5wdXRFbCkge1xyXG4gICAgaWYgKCRzY29wZS5yZWFkb25seUlucHV0KSB7XHJcbiAgICAgICRzY29wZS51cGRhdGVIb3VycyA9IGFuZ3VsYXIubm9vcDtcclxuICAgICAgJHNjb3BlLnVwZGF0ZU1pbnV0ZXMgPSBhbmd1bGFyLm5vb3A7XHJcbiAgICAgICRzY29wZS51cGRhdGVTZWNvbmRzID0gYW5ndWxhci5ub29wO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGludmFsaWRhdGUgPSBmdW5jdGlvbihpbnZhbGlkSG91cnMsIGludmFsaWRNaW51dGVzLCBpbnZhbGlkU2Vjb25kcykge1xyXG4gICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKG51bGwpO1xyXG4gICAgICBuZ01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3RpbWUnLCBmYWxzZSk7XHJcbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChpbnZhbGlkSG91cnMpKSB7XHJcbiAgICAgICAgJHNjb3BlLmludmFsaWRIb3VycyA9IGludmFsaWRIb3VycztcclxuICAgICAgICBpZiAoaG91cnNNb2RlbEN0cmwpIHtcclxuICAgICAgICAgIGhvdXJzTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnaG91cnMnLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoaW52YWxpZE1pbnV0ZXMpKSB7XHJcbiAgICAgICAgJHNjb3BlLmludmFsaWRNaW51dGVzID0gaW52YWxpZE1pbnV0ZXM7XHJcbiAgICAgICAgaWYgKG1pbnV0ZXNNb2RlbEN0cmwpIHtcclxuICAgICAgICAgIG1pbnV0ZXNNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdtaW51dGVzJywgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGludmFsaWRTZWNvbmRzKSkge1xyXG4gICAgICAgICRzY29wZS5pbnZhbGlkU2Vjb25kcyA9IGludmFsaWRTZWNvbmRzO1xyXG4gICAgICAgIGlmIChzZWNvbmRzTW9kZWxDdHJsKSB7XHJcbiAgICAgICAgICBzZWNvbmRzTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnc2Vjb25kcycsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLnVwZGF0ZUhvdXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBob3VycyA9IGdldEhvdXJzRnJvbVRlbXBsYXRlKCksXHJcbiAgICAgICAgbWludXRlcyA9IGdldE1pbnV0ZXNGcm9tVGVtcGxhdGUoKTtcclxuXHJcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXREaXJ0eSgpO1xyXG5cclxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGhvdXJzKSAmJiBhbmd1bGFyLmlzRGVmaW5lZChtaW51dGVzKSkge1xyXG4gICAgICAgIHNlbGVjdGVkLnNldEhvdXJzKGhvdXJzKTtcclxuICAgICAgICBzZWxlY3RlZC5zZXRNaW51dGVzKG1pbnV0ZXMpO1xyXG4gICAgICAgIGlmIChzZWxlY3RlZCA8IG1pbiB8fCBzZWxlY3RlZCA+IG1heCkge1xyXG4gICAgICAgICAgaW52YWxpZGF0ZSh0cnVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVmcmVzaCgnaCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbnZhbGlkYXRlKHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGhvdXJzSW5wdXRFbC5vbignYmx1cicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgbmdNb2RlbEN0cmwuJHNldFRvdWNoZWQoKTtcclxuICAgICAgaWYgKG1vZGVsSXNFbXB0eSgpKSB7XHJcbiAgICAgICAgbWFrZVZhbGlkKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoJHNjb3BlLmhvdXJzID09PSBudWxsIHx8ICRzY29wZS5ob3VycyA9PT0gJycpIHtcclxuICAgICAgICBpbnZhbGlkYXRlKHRydWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKCEkc2NvcGUuaW52YWxpZEhvdXJzICYmICRzY29wZS5ob3VycyA8IDEwKSB7XHJcbiAgICAgICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICRzY29wZS5ob3VycyA9IHBhZCgkc2NvcGUuaG91cnMsICFwYWRIb3Vycyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgICRzY29wZS51cGRhdGVNaW51dGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBtaW51dGVzID0gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpLFxyXG4gICAgICAgIGhvdXJzID0gZ2V0SG91cnNGcm9tVGVtcGxhdGUoKTtcclxuXHJcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXREaXJ0eSgpO1xyXG5cclxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKG1pbnV0ZXMpICYmIGFuZ3VsYXIuaXNEZWZpbmVkKGhvdXJzKSkge1xyXG4gICAgICAgIHNlbGVjdGVkLnNldEhvdXJzKGhvdXJzKTtcclxuICAgICAgICBzZWxlY3RlZC5zZXRNaW51dGVzKG1pbnV0ZXMpO1xyXG4gICAgICAgIGlmIChzZWxlY3RlZCA8IG1pbiB8fCBzZWxlY3RlZCA+IG1heCkge1xyXG4gICAgICAgICAgaW52YWxpZGF0ZSh1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZWZyZXNoKCdtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGludmFsaWRhdGUodW5kZWZpbmVkLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtaW51dGVzSW5wdXRFbC5vbignYmx1cicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgbmdNb2RlbEN0cmwuJHNldFRvdWNoZWQoKTtcclxuICAgICAgaWYgKG1vZGVsSXNFbXB0eSgpKSB7XHJcbiAgICAgICAgbWFrZVZhbGlkKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoJHNjb3BlLm1pbnV0ZXMgPT09IG51bGwpIHtcclxuICAgICAgICBpbnZhbGlkYXRlKHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoISRzY29wZS5pbnZhbGlkTWludXRlcyAmJiAkc2NvcGUubWludXRlcyA8IDEwKSB7XHJcbiAgICAgICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICRzY29wZS5taW51dGVzID0gcGFkKCRzY29wZS5taW51dGVzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgJHNjb3BlLnVwZGF0ZVNlY29uZHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHNlY29uZHMgPSBnZXRTZWNvbmRzRnJvbVRlbXBsYXRlKCk7XHJcblxyXG4gICAgICBuZ01vZGVsQ3RybC4kc2V0RGlydHkoKTtcclxuXHJcbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChzZWNvbmRzKSkge1xyXG4gICAgICAgIHNlbGVjdGVkLnNldFNlY29uZHMoc2Vjb25kcyk7XHJcbiAgICAgICAgcmVmcmVzaCgncycpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGludmFsaWRhdGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlY29uZHNJbnB1dEVsLm9uKCdibHVyJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICBpZiAobW9kZWxJc0VtcHR5KCkpIHtcclxuICAgICAgICBtYWtlVmFsaWQoKTtcclxuICAgICAgfSBlbHNlIGlmICghJHNjb3BlLmludmFsaWRTZWNvbmRzICYmICRzY29wZS5zZWNvbmRzIDwgMTApIHtcclxuICAgICAgICAkc2NvcGUuJGFwcGx5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICRzY29wZS5zZWNvbmRzID0gcGFkKCRzY29wZS5zZWNvbmRzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gIH07XHJcblxyXG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZGF0ZSA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWU7XHJcblxyXG4gICAgaWYgKGlzTmFOKGRhdGUpKSB7XHJcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgndGltZScsIGZhbHNlKTtcclxuICAgICAgJGxvZy5lcnJvcignVGltZXBpY2tlciBkaXJlY3RpdmU6IFwibmctbW9kZWxcIiB2YWx1ZSBtdXN0IGJlIGEgRGF0ZSBvYmplY3QsIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAwMS4wMS4xOTcwIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBSRkMyODIyIG9yIElTTyA4NjAxIGRhdGUuJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoZGF0ZSkge1xyXG4gICAgICAgIHNlbGVjdGVkID0gZGF0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNlbGVjdGVkIDwgbWluIHx8IHNlbGVjdGVkID4gbWF4KSB7XHJcbiAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCd0aW1lJywgZmFsc2UpO1xyXG4gICAgICAgICRzY29wZS5pbnZhbGlkSG91cnMgPSB0cnVlO1xyXG4gICAgICAgICRzY29wZS5pbnZhbGlkTWludXRlcyA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWFrZVZhbGlkKCk7XHJcbiAgICAgIH1cclxuICAgICAgdXBkYXRlVGVtcGxhdGUoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBDYWxsIGludGVybmFsbHkgd2hlbiB3ZSBrbm93IHRoYXQgbW9kZWwgaXMgdmFsaWQuXHJcbiAgZnVuY3Rpb24gcmVmcmVzaChrZXlib2FyZENoYW5nZSkge1xyXG4gICAgbWFrZVZhbGlkKCk7XHJcbiAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKG5ldyBEYXRlKHNlbGVjdGVkKSk7XHJcbiAgICB1cGRhdGVUZW1wbGF0ZShrZXlib2FyZENoYW5nZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtYWtlVmFsaWQoKSB7XHJcbiAgICBpZiAoaG91cnNNb2RlbEN0cmwpIHtcclxuICAgICAgaG91cnNNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdob3VycycsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtaW51dGVzTW9kZWxDdHJsKSB7XHJcbiAgICAgIG1pbnV0ZXNNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdtaW51dGVzJywgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlY29uZHNNb2RlbEN0cmwpIHtcclxuICAgICAgc2Vjb25kc01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3NlY29uZHMnLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3RpbWUnLCB0cnVlKTtcclxuICAgICRzY29wZS5pbnZhbGlkSG91cnMgPSBmYWxzZTtcclxuICAgICRzY29wZS5pbnZhbGlkTWludXRlcyA9IGZhbHNlO1xyXG4gICAgJHNjb3BlLmludmFsaWRTZWNvbmRzID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVUZW1wbGF0ZShrZXlib2FyZENoYW5nZSkge1xyXG4gICAgaWYgKCFuZ01vZGVsQ3RybC4kbW9kZWxWYWx1ZSkge1xyXG4gICAgICAkc2NvcGUuaG91cnMgPSBudWxsO1xyXG4gICAgICAkc2NvcGUubWludXRlcyA9IG51bGw7XHJcbiAgICAgICRzY29wZS5zZWNvbmRzID0gbnVsbDtcclxuICAgICAgJHNjb3BlLm1lcmlkaWFuID0gbWVyaWRpYW5zWzBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGhvdXJzID0gc2VsZWN0ZWQuZ2V0SG91cnMoKSxcclxuICAgICAgICBtaW51dGVzID0gc2VsZWN0ZWQuZ2V0TWludXRlcygpLFxyXG4gICAgICAgIHNlY29uZHMgPSBzZWxlY3RlZC5nZXRTZWNvbmRzKCk7XHJcblxyXG4gICAgICBpZiAoJHNjb3BlLnNob3dNZXJpZGlhbikge1xyXG4gICAgICAgIGhvdXJzID0gaG91cnMgPT09IDAgfHwgaG91cnMgPT09IDEyID8gMTIgOiBob3VycyAlIDEyOyAvLyBDb252ZXJ0IDI0IHRvIDEyIGhvdXIgc3lzdGVtXHJcbiAgICAgIH1cclxuXHJcbiAgICAgICRzY29wZS5ob3VycyA9IGtleWJvYXJkQ2hhbmdlID09PSAnaCcgPyBob3VycyA6IHBhZChob3VycywgIXBhZEhvdXJzKTtcclxuICAgICAgaWYgKGtleWJvYXJkQ2hhbmdlICE9PSAnbScpIHtcclxuICAgICAgICAkc2NvcGUubWludXRlcyA9IHBhZChtaW51dGVzKTtcclxuICAgICAgfVxyXG4gICAgICAkc2NvcGUubWVyaWRpYW4gPSBzZWxlY3RlZC5nZXRIb3VycygpIDwgMTIgPyBtZXJpZGlhbnNbMF0gOiBtZXJpZGlhbnNbMV07XHJcblxyXG4gICAgICBpZiAoa2V5Ym9hcmRDaGFuZ2UgIT09ICdzJykge1xyXG4gICAgICAgICRzY29wZS5zZWNvbmRzID0gcGFkKHNlY29uZHMpO1xyXG4gICAgICB9XHJcbiAgICAgICRzY29wZS5tZXJpZGlhbiA9IHNlbGVjdGVkLmdldEhvdXJzKCkgPCAxMiA/IG1lcmlkaWFuc1swXSA6IG1lcmlkaWFuc1sxXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFkZFNlY29uZHNUb1NlbGVjdGVkKHNlY29uZHMpIHtcclxuICAgIHNlbGVjdGVkID0gYWRkU2Vjb25kcyhzZWxlY3RlZCwgc2Vjb25kcyk7XHJcbiAgICByZWZyZXNoKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGRNaW51dGVzKHNlbGVjdGVkLCBtaW51dGVzKSB7XHJcbiAgICByZXR1cm4gYWRkU2Vjb25kcyhzZWxlY3RlZCwgbWludXRlcyo2MCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGRTZWNvbmRzKGRhdGUsIHNlY29uZHMpIHtcclxuICAgIHZhciBkdCA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgc2Vjb25kcyAqIDEwMDApO1xyXG4gICAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcclxuICAgIG5ld0RhdGUuc2V0SG91cnMoZHQuZ2V0SG91cnMoKSwgZHQuZ2V0TWludXRlcygpLCBkdC5nZXRTZWNvbmRzKCkpO1xyXG4gICAgcmV0dXJuIG5ld0RhdGU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtb2RlbElzRW1wdHkoKSB7XHJcbiAgICByZXR1cm4gKCRzY29wZS5ob3VycyA9PT0gbnVsbCB8fCAkc2NvcGUuaG91cnMgPT09ICcnKSAmJlxyXG4gICAgICAoJHNjb3BlLm1pbnV0ZXMgPT09IG51bGwgfHwgJHNjb3BlLm1pbnV0ZXMgPT09ICcnKSAmJlxyXG4gICAgICAoISRzY29wZS5zaG93U2Vjb25kcyB8fCAkc2NvcGUuc2hvd1NlY29uZHMgJiYgKCRzY29wZS5zZWNvbmRzID09PSBudWxsIHx8ICRzY29wZS5zZWNvbmRzID09PSAnJykpO1xyXG4gIH1cclxuXHJcbiAgJHNjb3BlLnNob3dTcGlubmVycyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zaG93U3Bpbm5lcnMpID9cclxuICAgICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5zaG93U3Bpbm5lcnMpIDogdGltZXBpY2tlckNvbmZpZy5zaG93U3Bpbm5lcnM7XHJcblxyXG4gICRzY29wZS5pbmNyZW1lbnRIb3VycyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCEkc2NvcGUubm9JbmNyZW1lbnRIb3VycygpKSB7XHJcbiAgICAgIGFkZFNlY29uZHNUb1NlbGVjdGVkKGhvdXJTdGVwICogNjAgKiA2MCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLmRlY3JlbWVudEhvdXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoISRzY29wZS5ub0RlY3JlbWVudEhvdXJzKCkpIHtcclxuICAgICAgYWRkU2Vjb25kc1RvU2VsZWN0ZWQoLWhvdXJTdGVwICogNjAgKiA2MCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLmluY3JlbWVudE1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICghJHNjb3BlLm5vSW5jcmVtZW50TWludXRlcygpKSB7XHJcbiAgICAgIGFkZFNlY29uZHNUb1NlbGVjdGVkKG1pbnV0ZVN0ZXAgKiA2MCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLmRlY3JlbWVudE1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICghJHNjb3BlLm5vRGVjcmVtZW50TWludXRlcygpKSB7XHJcbiAgICAgIGFkZFNlY29uZHNUb1NlbGVjdGVkKC1taW51dGVTdGVwICogNjApO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gICRzY29wZS5pbmNyZW1lbnRTZWNvbmRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoISRzY29wZS5ub0luY3JlbWVudFNlY29uZHMoKSkge1xyXG4gICAgICBhZGRTZWNvbmRzVG9TZWxlY3RlZChzZWNvbmRTdGVwKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAkc2NvcGUuZGVjcmVtZW50U2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCEkc2NvcGUubm9EZWNyZW1lbnRTZWNvbmRzKCkpIHtcclxuICAgICAgYWRkU2Vjb25kc1RvU2VsZWN0ZWQoLXNlY29uZFN0ZXApO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gICRzY29wZS50b2dnbGVNZXJpZGlhbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG1pbnV0ZXMgPSBnZXRNaW51dGVzRnJvbVRlbXBsYXRlKCksXHJcbiAgICAgICAgaG91cnMgPSBnZXRIb3Vyc0Zyb21UZW1wbGF0ZSgpO1xyXG5cclxuICAgIGlmICghJHNjb3BlLm5vVG9nZ2xlTWVyaWRpYW4oKSkge1xyXG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQobWludXRlcykgJiYgYW5ndWxhci5pc0RlZmluZWQoaG91cnMpKSB7XHJcbiAgICAgICAgYWRkU2Vjb25kc1RvU2VsZWN0ZWQoMTIgKiA2MCAqIChzZWxlY3RlZC5nZXRIb3VycygpIDwgMTIgPyA2MCA6IC02MCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICRzY29wZS5tZXJpZGlhbiA9ICRzY29wZS5tZXJpZGlhbiA9PT0gbWVyaWRpYW5zWzBdID8gbWVyaWRpYW5zWzFdIDogbWVyaWRpYW5zWzBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLmJsdXIgPSBmdW5jdGlvbigpIHtcclxuICAgIG5nTW9kZWxDdHJsLiRzZXRUb3VjaGVkKCk7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgIHdoaWxlICh3YXRjaGVycy5sZW5ndGgpIHtcclxuICAgICAgd2F0Y2hlcnMuc2hpZnQoKSgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoJ3VpYlRpbWVwaWNrZXInLCBbJ3VpYlRpbWVwaWNrZXJDb25maWcnLCBmdW5jdGlvbih1aWJUaW1lcGlja2VyQ29uZmlnKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlcXVpcmU6IFsndWliVGltZXBpY2tlcicsICc/Xm5nTW9kZWwnXSxcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICBjb250cm9sbGVyOiAnVWliVGltZXBpY2tlckNvbnRyb2xsZXInLFxyXG4gICAgY29udHJvbGxlckFzOiAndGltZXBpY2tlcicsXHJcbiAgICBzY29wZToge30sXHJcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcclxuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8IHVpYlRpbWVwaWNrZXJDb25maWcudGVtcGxhdGVVcmw7XHJcbiAgICB9LFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xyXG4gICAgICB2YXIgdGltZXBpY2tlckN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcclxuXHJcbiAgICAgIGlmIChuZ01vZGVsQ3RybCkge1xyXG4gICAgICAgIHRpbWVwaWNrZXJDdHJsLmluaXQobmdNb2RlbEN0cmwsIGVsZW1lbnQuZmluZCgnaW5wdXQnKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnR5cGVhaGVhZCcsIFsndWkuYm9vdHN0cmFwLmRlYm91bmNlJywgJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbiddKVxyXG5cclxuLyoqXHJcbiAqIEEgaGVscGVyIHNlcnZpY2UgdGhhdCBjYW4gcGFyc2UgdHlwZWFoZWFkJ3Mgc3ludGF4IChzdHJpbmcgcHJvdmlkZWQgYnkgdXNlcnMpXHJcbiAqIEV4dHJhY3RlZCB0byBhIHNlcGFyYXRlIHNlcnZpY2UgZm9yIGVhc2Ugb2YgdW5pdCB0ZXN0aW5nXHJcbiAqL1xyXG4gIC5mYWN0b3J5KCd1aWJUeXBlYWhlYWRQYXJzZXInLCBbJyRwYXJzZScsIGZ1bmN0aW9uKCRwYXJzZSkge1xyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgMDAwMDAxMTExMTExMTAwMDAwMDAwMDAwMDAyMjIyMjIyMjAwMDAwMDAwMDAwMDAwMDAzMzMzMzMzMzMzMzMzMzMwMDAwMDAwMDAwMDQ0NDQ0NDQ0MDAwXHJcbiAgICB2YXIgVFlQRUFIRUFEX1JFR0VYUCA9IC9eXFxzKihbXFxzXFxTXSs/KSg/Olxccythc1xccysoW1xcc1xcU10rPykpP1xccytmb3JcXHMrKD86KFtcXCRcXHddW1xcJFxcd1xcZF0qKSlcXHMraW5cXHMrKFtcXHNcXFNdKz8pJC87XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICB2YXIgbWF0Y2ggPSBpbnB1dC5tYXRjaChUWVBFQUhFQURfUkVHRVhQKTtcclxuICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICdFeHBlY3RlZCB0eXBlYWhlYWQgc3BlY2lmaWNhdGlvbiBpbiBmb3JtIG9mIFwiX21vZGVsVmFsdWVfIChhcyBfbGFiZWxfKT8gZm9yIF9pdGVtXyBpbiBfY29sbGVjdGlvbl9cIicgK1xyXG4gICAgICAgICAgICAgICcgYnV0IGdvdCBcIicgKyBpbnB1dCArICdcIi4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBpdGVtTmFtZTogbWF0Y2hbM10sXHJcbiAgICAgICAgICBzb3VyY2U6ICRwYXJzZShtYXRjaFs0XSksXHJcbiAgICAgICAgICB2aWV3TWFwcGVyOiAkcGFyc2UobWF0Y2hbMl0gfHwgbWF0Y2hbMV0pLFxyXG4gICAgICAgICAgbW9kZWxNYXBwZXI6ICRwYXJzZShtYXRjaFsxXSlcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1dKVxyXG5cclxuICAuY29udHJvbGxlcignVWliVHlwZWFoZWFkQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsICckY29tcGlsZScsICckcGFyc2UnLCAnJHEnLCAnJHRpbWVvdXQnLCAnJGRvY3VtZW50JywgJyR3aW5kb3cnLCAnJHJvb3RTY29wZScsICckJGRlYm91bmNlJywgJyR1aWJQb3NpdGlvbicsICd1aWJUeXBlYWhlYWRQYXJzZXInLFxyXG4gICAgZnVuY3Rpb24ob3JpZ2luYWxTY29wZSwgZWxlbWVudCwgYXR0cnMsICRjb21waWxlLCAkcGFyc2UsICRxLCAkdGltZW91dCwgJGRvY3VtZW50LCAkd2luZG93LCAkcm9vdFNjb3BlLCAkJGRlYm91bmNlLCAkcG9zaXRpb24sIHR5cGVhaGVhZFBhcnNlcikge1xyXG4gICAgdmFyIEhPVF9LRVlTID0gWzksIDEzLCAyNywgMzgsIDQwXTtcclxuICAgIHZhciBldmVudERlYm91bmNlVGltZSA9IDIwMDtcclxuICAgIHZhciBtb2RlbEN0cmwsIG5nTW9kZWxPcHRpb25zO1xyXG4gICAgLy9TVVBQT1JURUQgQVRUUklCVVRFUyAoT1BUSU9OUylcclxuXHJcbiAgICAvL21pbmltYWwgbm8gb2YgY2hhcmFjdGVycyB0aGF0IG5lZWRzIHRvIGJlIGVudGVyZWQgYmVmb3JlIHR5cGVhaGVhZCBraWNrcy1pblxyXG4gICAgdmFyIG1pbkxlbmd0aCA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkTWluTGVuZ3RoKTtcclxuICAgIGlmICghbWluTGVuZ3RoICYmIG1pbkxlbmd0aCAhPT0gMCkge1xyXG4gICAgICBtaW5MZW5ndGggPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIG9yaWdpbmFsU2NvcGUuJHdhdGNoKGF0dHJzLnR5cGVhaGVhZE1pbkxlbmd0aCwgZnVuY3Rpb24gKG5ld1ZhbCkge1xyXG4gICAgICAgIG1pbkxlbmd0aCA9ICFuZXdWYWwgJiYgbmV3VmFsICE9PSAwID8gMSA6IG5ld1ZhbDtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vbWluaW1hbCB3YWl0IHRpbWUgYWZ0ZXIgbGFzdCBjaGFyYWN0ZXIgdHlwZWQgYmVmb3JlIHR5cGVhaGVhZCBraWNrcy1pblxyXG4gICAgdmFyIHdhaXRUaW1lID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRXYWl0TXMpIHx8IDA7XHJcblxyXG4gICAgLy9zaG91bGQgaXQgcmVzdHJpY3QgbW9kZWwgdmFsdWVzIHRvIHRoZSBvbmVzIHNlbGVjdGVkIGZyb20gdGhlIHBvcHVwIG9ubHk/XHJcbiAgICB2YXIgaXNFZGl0YWJsZSA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkRWRpdGFibGUpICE9PSBmYWxzZTtcclxuICAgIG9yaWdpbmFsU2NvcGUuJHdhdGNoKGF0dHJzLnR5cGVhaGVhZEVkaXRhYmxlLCBmdW5jdGlvbiAobmV3VmFsKSB7XHJcbiAgICAgIGlzRWRpdGFibGUgPSBuZXdWYWwgIT09IGZhbHNlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy9iaW5kaW5nIHRvIGEgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgaWYgbWF0Y2hlcyBhcmUgYmVpbmcgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5XHJcbiAgICB2YXIgaXNMb2FkaW5nU2V0dGVyID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZExvYWRpbmcpLmFzc2lnbiB8fCBhbmd1bGFyLm5vb3A7XHJcblxyXG4gICAgLy9hIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhbiBldmVudCBzaG91bGQgY2F1c2Ugc2VsZWN0aW9uXHJcbiAgICB2YXIgaXNTZWxlY3RFdmVudCA9IGF0dHJzLnR5cGVhaGVhZFNob3VsZFNlbGVjdCA/ICRwYXJzZShhdHRycy50eXBlYWhlYWRTaG91bGRTZWxlY3QpIDogZnVuY3Rpb24oc2NvcGUsIHZhbHMpIHtcclxuICAgICAgdmFyIGV2dCA9IHZhbHMuJGV2ZW50O1xyXG4gICAgICByZXR1cm4gZXZ0LndoaWNoID09PSAxMyB8fCBldnQud2hpY2ggPT09IDk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vYSBjYWxsYmFjayBleGVjdXRlZCB3aGVuIGEgbWF0Y2ggaXMgc2VsZWN0ZWRcclxuICAgIHZhciBvblNlbGVjdENhbGxiYWNrID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZE9uU2VsZWN0KTtcclxuXHJcbiAgICAvL3Nob3VsZCBpdCBzZWxlY3QgaGlnaGxpZ2h0ZWQgcG9wdXAgdmFsdWUgd2hlbiBsb3NpbmcgZm9jdXM/XHJcbiAgICB2YXIgaXNTZWxlY3RPbkJsdXIgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50eXBlYWhlYWRTZWxlY3RPbkJsdXIpID8gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRTZWxlY3RPbkJsdXIpIDogZmFsc2U7XHJcblxyXG4gICAgLy9iaW5kaW5nIHRvIGEgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgaWYgdGhlcmUgd2VyZSBubyByZXN1bHRzIGFmdGVyIHRoZSBxdWVyeSBpcyBjb21wbGV0ZWRcclxuICAgIHZhciBpc05vUmVzdWx0c1NldHRlciA9ICRwYXJzZShhdHRycy50eXBlYWhlYWROb1Jlc3VsdHMpLmFzc2lnbiB8fCBhbmd1bGFyLm5vb3A7XHJcblxyXG4gICAgdmFyIGlucHV0Rm9ybWF0dGVyID0gYXR0cnMudHlwZWFoZWFkSW5wdXRGb3JtYXR0ZXIgPyAkcGFyc2UoYXR0cnMudHlwZWFoZWFkSW5wdXRGb3JtYXR0ZXIpIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIHZhciBhcHBlbmRUb0JvZHkgPSBhdHRycy50eXBlYWhlYWRBcHBlbmRUb0JvZHkgPyBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZEFwcGVuZFRvQm9keSkgOiBmYWxzZTtcclxuXHJcbiAgICB2YXIgYXBwZW5kVG8gPSBhdHRycy50eXBlYWhlYWRBcHBlbmRUbyA/XHJcbiAgICAgIG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkQXBwZW5kVG8pIDogbnVsbDtcclxuXHJcbiAgICB2YXIgZm9jdXNGaXJzdCA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkRm9jdXNGaXJzdCkgIT09IGZhbHNlO1xyXG5cclxuICAgIC8vSWYgaW5wdXQgbWF0Y2hlcyBhbiBpdGVtIG9mIHRoZSBsaXN0IGV4YWN0bHksIHNlbGVjdCBpdCBhdXRvbWF0aWNhbGx5XHJcbiAgICB2YXIgc2VsZWN0T25FeGFjdCA9IGF0dHJzLnR5cGVhaGVhZFNlbGVjdE9uRXhhY3QgPyBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZFNlbGVjdE9uRXhhY3QpIDogZmFsc2U7XHJcblxyXG4gICAgLy9iaW5kaW5nIHRvIGEgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgaWYgZHJvcGRvd24gaXMgb3BlblxyXG4gICAgdmFyIGlzT3BlblNldHRlciA9ICRwYXJzZShhdHRycy50eXBlYWhlYWRJc09wZW4pLmFzc2lnbiB8fCBhbmd1bGFyLm5vb3A7XHJcblxyXG4gICAgdmFyIHNob3dIaW50ID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRTaG93SGludCkgfHwgZmFsc2U7XHJcblxyXG4gICAgLy9JTlRFUk5BTCBWQVJJQUJMRVNcclxuXHJcbiAgICAvL21vZGVsIHNldHRlciBleGVjdXRlZCB1cG9uIG1hdGNoIHNlbGVjdGlvblxyXG4gICAgdmFyIHBhcnNlZE1vZGVsID0gJHBhcnNlKGF0dHJzLm5nTW9kZWwpO1xyXG4gICAgdmFyIGludm9rZU1vZGVsU2V0dGVyID0gJHBhcnNlKGF0dHJzLm5nTW9kZWwgKyAnKCQkJHApJyk7XHJcbiAgICB2YXIgJHNldE1vZGVsVmFsdWUgPSBmdW5jdGlvbihzY29wZSwgbmV3VmFsdWUpIHtcclxuICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihwYXJzZWRNb2RlbChvcmlnaW5hbFNjb3BlKSkgJiZcclxuICAgICAgICBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ2dldHRlclNldHRlcicpKSB7XHJcbiAgICAgICAgcmV0dXJuIGludm9rZU1vZGVsU2V0dGVyKHNjb3BlLCB7JCQkcDogbmV3VmFsdWV9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHBhcnNlZE1vZGVsLmFzc2lnbihzY29wZSwgbmV3VmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvL2V4cHJlc3Npb25zIHVzZWQgYnkgdHlwZWFoZWFkXHJcbiAgICB2YXIgcGFyc2VyUmVzdWx0ID0gdHlwZWFoZWFkUGFyc2VyLnBhcnNlKGF0dHJzLnVpYlR5cGVhaGVhZCk7XHJcblxyXG4gICAgdmFyIGhhc0ZvY3VzO1xyXG5cclxuICAgIC8vVXNlZCB0byBhdm9pZCBidWcgaW4gaU9TIHdlYnZpZXcgd2hlcmUgaU9TIGtleWJvYXJkIGRvZXMgbm90IGZpcmVcclxuICAgIC8vbW91c2Vkb3duICYgbW91c2V1cCBldmVudHNcclxuICAgIC8vSXNzdWUgIzM2OTlcclxuICAgIHZhciBzZWxlY3RlZDtcclxuXHJcbiAgICAvL2NyZWF0ZSBhIGNoaWxkIHNjb3BlIGZvciB0aGUgdHlwZWFoZWFkIGRpcmVjdGl2ZSBzbyB3ZSBhcmUgbm90IHBvbGx1dGluZyBvcmlnaW5hbCBzY29wZVxyXG4gICAgLy93aXRoIHR5cGVhaGVhZC1zcGVjaWZpYyBkYXRhIChtYXRjaGVzLCBxdWVyeSBldGMuKVxyXG4gICAgdmFyIHNjb3BlID0gb3JpZ2luYWxTY29wZS4kbmV3KCk7XHJcbiAgICB2YXIgb2ZmRGVzdHJveSA9IG9yaWdpbmFsU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICBzY29wZS4kZGVzdHJveSgpO1xyXG4gICAgfSk7XHJcbiAgICBzY29wZS4kb24oJyRkZXN0cm95Jywgb2ZmRGVzdHJveSk7XHJcblxyXG4gICAgLy8gV0FJLUFSSUFcclxuICAgIHZhciBwb3B1cElkID0gJ3R5cGVhaGVhZC0nICsgc2NvcGUuJGlkICsgJy0nICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xyXG4gICAgZWxlbWVudC5hdHRyKHtcclxuICAgICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogJ2xpc3QnLFxyXG4gICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlLFxyXG4gICAgICAnYXJpYS1vd25zJzogcG9wdXBJZFxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGlucHV0c0NvbnRhaW5lciwgaGludElucHV0RWxlbTtcclxuICAgIC8vYWRkIHJlYWQtb25seSBpbnB1dCB0byBzaG93IGhpbnRcclxuICAgIGlmIChzaG93SGludCkge1xyXG4gICAgICBpbnB1dHNDb250YWluZXIgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXY+PC9kaXY+Jyk7XHJcbiAgICAgIGlucHV0c0NvbnRhaW5lci5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XHJcbiAgICAgIGVsZW1lbnQuYWZ0ZXIoaW5wdXRzQ29udGFpbmVyKTtcclxuICAgICAgaGludElucHV0RWxlbSA9IGVsZW1lbnQuY2xvbmUoKTtcclxuICAgICAgaGludElucHV0RWxlbS5hdHRyKCdwbGFjZWhvbGRlcicsICcnKTtcclxuICAgICAgaGludElucHV0RWxlbS5hdHRyKCd0YWJpbmRleCcsICctMScpO1xyXG4gICAgICBoaW50SW5wdXRFbGVtLnZhbCgnJyk7XHJcbiAgICAgIGhpbnRJbnB1dEVsZW0uY3NzKHtcclxuICAgICAgICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICd0b3AnOiAnMHB4JyxcclxuICAgICAgICAnbGVmdCc6ICcwcHgnLFxyXG4gICAgICAgICdib3JkZXItY29sb3InOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgICdib3gtc2hhZG93JzogJ25vbmUnLFxyXG4gICAgICAgICdvcGFjaXR5JzogMSxcclxuICAgICAgICAnYmFja2dyb3VuZCc6ICdub25lIDAlIDAlIC8gYXV0byByZXBlYXQgc2Nyb2xsIHBhZGRpbmctYm94IGJvcmRlci1ib3ggcmdiKDI1NSwgMjU1LCAyNTUpJyxcclxuICAgICAgICAnY29sb3InOiAnIzk5OSdcclxuICAgICAgfSk7XHJcbiAgICAgIGVsZW1lbnQuY3NzKHtcclxuICAgICAgICAncG9zaXRpb24nOiAncmVsYXRpdmUnLFxyXG4gICAgICAgICd2ZXJ0aWNhbC1hbGlnbic6ICd0b3AnLFxyXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJ3RyYW5zcGFyZW50J1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChoaW50SW5wdXRFbGVtLmF0dHIoJ2lkJykpIHtcclxuICAgICAgICBoaW50SW5wdXRFbGVtLnJlbW92ZUF0dHIoJ2lkJyk7IC8vIHJlbW92ZSBkdXBsaWNhdGUgaWQgaWYgcHJlc2VudC5cclxuICAgICAgfVxyXG4gICAgICBpbnB1dHNDb250YWluZXIuYXBwZW5kKGhpbnRJbnB1dEVsZW0pO1xyXG4gICAgICBoaW50SW5wdXRFbGVtLmFmdGVyKGVsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vcG9wLXVwIGVsZW1lbnQgdXNlZCB0byBkaXNwbGF5IG1hdGNoZXNcclxuICAgIHZhciBwb3BVcEVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IHVpYi10eXBlYWhlYWQtcG9wdXA+PC9kaXY+Jyk7XHJcbiAgICBwb3BVcEVsLmF0dHIoe1xyXG4gICAgICBpZDogcG9wdXBJZCxcclxuICAgICAgbWF0Y2hlczogJ21hdGNoZXMnLFxyXG4gICAgICBhY3RpdmU6ICdhY3RpdmVJZHgnLFxyXG4gICAgICBzZWxlY3Q6ICdzZWxlY3QoYWN0aXZlSWR4LCBldnQpJyxcclxuICAgICAgJ21vdmUtaW4tcHJvZ3Jlc3MnOiAnbW92ZUluUHJvZ3Jlc3MnLFxyXG4gICAgICBxdWVyeTogJ3F1ZXJ5JyxcclxuICAgICAgcG9zaXRpb246ICdwb3NpdGlvbicsXHJcbiAgICAgICdhc3NpZ24taXMtb3Blbic6ICdhc3NpZ25Jc09wZW4oaXNPcGVuKScsXHJcbiAgICAgIGRlYm91bmNlOiAnZGVib3VuY2VVcGRhdGUnXHJcbiAgICB9KTtcclxuICAgIC8vY3VzdG9tIGl0ZW0gdGVtcGxhdGVcclxuICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50eXBlYWhlYWRUZW1wbGF0ZVVybCkpIHtcclxuICAgICAgcG9wVXBFbC5hdHRyKCd0ZW1wbGF0ZS11cmwnLCBhdHRycy50eXBlYWhlYWRUZW1wbGF0ZVVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnR5cGVhaGVhZFBvcHVwVGVtcGxhdGVVcmwpKSB7XHJcbiAgICAgIHBvcFVwRWwuYXR0cigncG9wdXAtdGVtcGxhdGUtdXJsJywgYXR0cnMudHlwZWFoZWFkUG9wdXBUZW1wbGF0ZVVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlc2V0SGludCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoc2hvd0hpbnQpIHtcclxuICAgICAgICBoaW50SW5wdXRFbGVtLnZhbCgnJyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHJlc2V0TWF0Y2hlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBzY29wZS5tYXRjaGVzID0gW107XHJcbiAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IC0xO1xyXG4gICAgICBlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XHJcbiAgICAgIHJlc2V0SGludCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZ2V0TWF0Y2hJZCA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICAgIHJldHVybiBwb3B1cElkICsgJy1vcHRpb24tJyArIGluZGV4O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJbmRpY2F0ZSB0aGF0IHRoZSBzcGVjaWZpZWQgbWF0Y2ggaXMgdGhlIGFjdGl2ZSAocHJlLXNlbGVjdGVkKSBpdGVtIGluIHRoZSBsaXN0IG93bmVkIGJ5IHRoaXMgdHlwZWFoZWFkLlxyXG4gICAgLy8gVGhpcyBhdHRyaWJ1dGUgaXMgYWRkZWQgb3IgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIGBhY3RpdmVJZHhgIGNoYW5nZXMuXHJcbiAgICBzY29wZS4kd2F0Y2goJ2FjdGl2ZUlkeCcsIGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgZ2V0TWF0Y2hJZChpbmRleCkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgaW5wdXRJc0V4YWN0TWF0Y2ggPSBmdW5jdGlvbihpbnB1dFZhbHVlLCBpbmRleCkge1xyXG4gICAgICBpZiAoc2NvcGUubWF0Y2hlcy5sZW5ndGggPiBpbmRleCAmJiBpbnB1dFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWUudG9VcHBlckNhc2UoKSA9PT0gc2NvcGUubWF0Y2hlc1tpbmRleF0ubGFiZWwudG9VcHBlckNhc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZ2V0TWF0Y2hlc0FzeW5jID0gZnVuY3Rpb24oaW5wdXRWYWx1ZSwgZXZ0KSB7XHJcbiAgICAgIHZhciBsb2NhbHMgPSB7JHZpZXdWYWx1ZTogaW5wdXRWYWx1ZX07XHJcbiAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCB0cnVlKTtcclxuICAgICAgaXNOb1Jlc3VsdHNTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xyXG4gICAgICAkcS53aGVuKHBhcnNlclJlc3VsdC5zb3VyY2Uob3JpZ2luYWxTY29wZSwgbG9jYWxzKSkudGhlbihmdW5jdGlvbihtYXRjaGVzKSB7XHJcbiAgICAgICAgLy9pdCBtaWdodCBoYXBwZW4gdGhhdCBzZXZlcmFsIGFzeW5jIHF1ZXJpZXMgd2VyZSBpbiBwcm9ncmVzcyBpZiBhIHVzZXIgd2VyZSB0eXBpbmcgZmFzdFxyXG4gICAgICAgIC8vYnV0IHdlIGFyZSBpbnRlcmVzdGVkIG9ubHkgaW4gcmVzcG9uc2VzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgY3VycmVudCB2aWV3IHZhbHVlXHJcbiAgICAgICAgdmFyIG9uQ3VycmVudFJlcXVlc3QgPSBpbnB1dFZhbHVlID09PSBtb2RlbEN0cmwuJHZpZXdWYWx1ZTtcclxuICAgICAgICBpZiAob25DdXJyZW50UmVxdWVzdCAmJiBoYXNGb2N1cykge1xyXG4gICAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IGZvY3VzRmlyc3QgPyAwIDogLTE7XHJcbiAgICAgICAgICAgIGlzTm9SZXN1bHRzU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgc2NvcGUubWF0Y2hlcy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgLy90cmFuc2Zvcm0gbGFiZWxzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gbWF0Y2hlc1tpXTtcclxuICAgICAgICAgICAgICBzY29wZS5tYXRjaGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaWQ6IGdldE1hdGNoSWQoaSksXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIoc2NvcGUsIGxvY2FscyksXHJcbiAgICAgICAgICAgICAgICBtb2RlbDogbWF0Y2hlc1tpXVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzY29wZS5xdWVyeSA9IGlucHV0VmFsdWU7XHJcbiAgICAgICAgICAgIC8vcG9zaXRpb24gcG9wLXVwIHdpdGggbWF0Y2hlcyAtIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIGl0cyBwb3NpdGlvbiBlYWNoIHRpbWUgd2UgYXJlIG9wZW5pbmcgYSB3aW5kb3dcclxuICAgICAgICAgICAgLy93aXRoIG1hdGNoZXMgYXMgYSBwb3AtdXAgbWlnaHQgYmUgYWJzb2x1dGUtcG9zaXRpb25lZCBhbmQgcG9zaXRpb24gb2YgYW4gaW5wdXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIG9uIGEgcGFnZVxyXG4gICAgICAgICAgICAvL2R1ZSB0byBvdGhlciBlbGVtZW50cyBiZWluZyByZW5kZXJlZFxyXG4gICAgICAgICAgICByZWNhbGN1bGF0ZVBvc2l0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICBlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vU2VsZWN0IHRoZSBzaW5nbGUgcmVtYWluaW5nIG9wdGlvbiBpZiB1c2VyIGlucHV0IG1hdGNoZXNcclxuICAgICAgICAgICAgaWYgKHNlbGVjdE9uRXhhY3QgJiYgc2NvcGUubWF0Y2hlcy5sZW5ndGggPT09IDEgJiYgaW5wdXRJc0V4YWN0TWF0Y2goaW5wdXRWYWx1ZSwgMCkpIHtcclxuICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc051bWJlcihzY29wZS5kZWJvdW5jZVVwZGF0ZSkgfHwgYW5ndWxhci5pc09iamVjdChzY29wZS5kZWJvdW5jZVVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICQkZGVib3VuY2UoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgIHNjb3BlLnNlbGVjdCgwLCBldnQpO1xyXG4gICAgICAgICAgICAgICAgfSwgYW5ndWxhci5pc051bWJlcihzY29wZS5kZWJvdW5jZVVwZGF0ZSkgPyBzY29wZS5kZWJvdW5jZVVwZGF0ZSA6IHNjb3BlLmRlYm91bmNlVXBkYXRlWydkZWZhdWx0J10pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5zZWxlY3QoMCwgZXZ0KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzaG93SGludCkge1xyXG4gICAgICAgICAgICAgIHZhciBmaXJzdExhYmVsID0gc2NvcGUubWF0Y2hlc1swXS5sYWJlbDtcclxuICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc1N0cmluZyhpbnB1dFZhbHVlKSAmJlxyXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZS5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgICAgICBmaXJzdExhYmVsLnNsaWNlKDAsIGlucHV0VmFsdWUubGVuZ3RoKS50b1VwcGVyQ2FzZSgpID09PSBpbnB1dFZhbHVlLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGhpbnRJbnB1dEVsZW0udmFsKGlucHV0VmFsdWUgKyBmaXJzdExhYmVsLnNsaWNlKGlucHV0VmFsdWUubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhpbnRJbnB1dEVsZW0udmFsKCcnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xyXG4gICAgICAgICAgICBpc05vUmVzdWx0c1NldHRlcihvcmlnaW5hbFNjb3BlLCB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9uQ3VycmVudFJlcXVlc3QpIHtcclxuICAgICAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXNldE1hdGNoZXMoKTtcclxuICAgICAgICBpc0xvYWRpbmdTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xyXG4gICAgICAgIGlzTm9SZXN1bHRzU2V0dGVyKG9yaWdpbmFsU2NvcGUsIHRydWUpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gYmluZCBldmVudHMgb25seSBpZiBhcHBlbmRUb0JvZHkgcGFyYW1zIGV4aXN0IC0gcGVyZm9ybWFuY2UgZmVhdHVyZVxyXG4gICAgaWYgKGFwcGVuZFRvQm9keSkge1xyXG4gICAgICBhbmd1bGFyLmVsZW1lbnQoJHdpbmRvdykub24oJ3Jlc2l6ZScsIGZpcmVSZWNhbGN1bGF0aW5nKTtcclxuICAgICAgJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5vbignc2Nyb2xsJywgZmlyZVJlY2FsY3VsYXRpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlY2xhcmUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBvdXRzaWRlIHJlY2FsY3VsYXRpbmcgZm9yXHJcbiAgICAvLyBwcm9wZXIgZGVib3VuY2luZ1xyXG4gICAgdmFyIGRlYm91bmNlZFJlY2FsY3VsYXRlID0gJCRkZWJvdW5jZShmdW5jdGlvbigpIHtcclxuICAgICAgLy8gaWYgcG9wdXAgaXMgdmlzaWJsZVxyXG4gICAgICBpZiAoc2NvcGUubWF0Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICByZWNhbGN1bGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNjb3BlLm1vdmVJblByb2dyZXNzID0gZmFsc2U7XHJcbiAgICB9LCBldmVudERlYm91bmNlVGltZSk7XHJcblxyXG4gICAgLy8gRGVmYXVsdCBwcm9ncmVzcyB0eXBlXHJcbiAgICBzY29wZS5tb3ZlSW5Qcm9ncmVzcyA9IGZhbHNlO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZpcmVSZWNhbGN1bGF0aW5nKCkge1xyXG4gICAgICBpZiAoIXNjb3BlLm1vdmVJblByb2dyZXNzKSB7XHJcbiAgICAgICAgc2NvcGUubW92ZUluUHJvZ3Jlc3MgPSB0cnVlO1xyXG4gICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGVib3VuY2VkUmVjYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZWNhbGN1bGF0ZSBhY3R1YWwgcG9zaXRpb24gYW5kIHNldCBuZXcgdmFsdWVzIHRvIHNjb3BlXHJcbiAgICAvLyBhZnRlciBkaWdlc3QgbG9vcCBpcyBwb3B1cCBpbiByaWdodCBwb3NpdGlvblxyXG4gICAgZnVuY3Rpb24gcmVjYWxjdWxhdGVQb3NpdGlvbigpIHtcclxuICAgICAgc2NvcGUucG9zaXRpb24gPSBhcHBlbmRUb0JvZHkgPyAkcG9zaXRpb24ub2Zmc2V0KGVsZW1lbnQpIDogJHBvc2l0aW9uLnBvc2l0aW9uKGVsZW1lbnQpO1xyXG4gICAgICBzY29wZS5wb3NpdGlvbi50b3AgKz0gZWxlbWVudC5wcm9wKCdvZmZzZXRIZWlnaHQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvL3dlIG5lZWQgdG8gcHJvcGFnYXRlIHVzZXIncyBxdWVyeSBzbyB3ZSBjYW4gaGlnbGlnaHQgbWF0Y2hlc1xyXG4gICAgc2NvcGUucXVlcnkgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgLy9EZWNsYXJlIHRoZSB0aW1lb3V0IHByb21pc2UgdmFyIG91dHNpZGUgdGhlIGZ1bmN0aW9uIHNjb3BlIHNvIHRoYXQgc3RhY2tlZCBjYWxscyBjYW4gYmUgY2FuY2VsbGVkIGxhdGVyXHJcbiAgICB2YXIgdGltZW91dFByb21pc2U7XHJcblxyXG4gICAgdmFyIHNjaGVkdWxlU2VhcmNoV2l0aFRpbWVvdXQgPSBmdW5jdGlvbihpbnB1dFZhbHVlKSB7XHJcbiAgICAgIHRpbWVvdXRQcm9taXNlID0gJHRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZ2V0TWF0Y2hlc0FzeW5jKGlucHV0VmFsdWUpO1xyXG4gICAgICB9LCB3YWl0VGltZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjYW5jZWxQcmV2aW91c1RpbWVvdXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRpbWVvdXRQcm9taXNlKSB7XHJcbiAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHRpbWVvdXRQcm9taXNlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXNldE1hdGNoZXMoKTtcclxuXHJcbiAgICBzY29wZS5hc3NpZ25Jc09wZW4gPSBmdW5jdGlvbiAoaXNPcGVuKSB7XHJcbiAgICAgIGlzT3BlblNldHRlcihvcmlnaW5hbFNjb3BlLCBpc09wZW4pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzY29wZS5zZWxlY3QgPSBmdW5jdGlvbihhY3RpdmVJZHgsIGV2dCkge1xyXG4gICAgICAvL2NhbGxlZCBmcm9tIHdpdGhpbiB0aGUgJGRpZ2VzdCgpIGN5Y2xlXHJcbiAgICAgIHZhciBsb2NhbHMgPSB7fTtcclxuICAgICAgdmFyIG1vZGVsLCBpdGVtO1xyXG5cclxuICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICBsb2NhbHNbcGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IGl0ZW0gPSBzY29wZS5tYXRjaGVzW2FjdGl2ZUlkeF0ubW9kZWw7XHJcbiAgICAgIG1vZGVsID0gcGFyc2VyUmVzdWx0Lm1vZGVsTWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XHJcbiAgICAgICRzZXRNb2RlbFZhbHVlKG9yaWdpbmFsU2NvcGUsIG1vZGVsKTtcclxuICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZWRpdGFibGUnLCB0cnVlKTtcclxuICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgncGFyc2UnLCB0cnVlKTtcclxuXHJcbiAgICAgIG9uU2VsZWN0Q2FsbGJhY2sob3JpZ2luYWxTY29wZSwge1xyXG4gICAgICAgICRpdGVtOiBpdGVtLFxyXG4gICAgICAgICRtb2RlbDogbW9kZWwsXHJcbiAgICAgICAgJGxhYmVsOiBwYXJzZXJSZXN1bHQudmlld01hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpLFxyXG4gICAgICAgICRldmVudDogZXZ0XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmVzZXRNYXRjaGVzKCk7XHJcblxyXG4gICAgICAvL3JldHVybiBmb2N1cyB0byB0aGUgaW5wdXQgZWxlbWVudCBpZiBhIG1hdGNoIHdhcyBzZWxlY3RlZCB2aWEgYSBtb3VzZSBjbGljayBldmVudFxyXG4gICAgICAvLyB1c2UgdGltZW91dCB0byBhdm9pZCAkcm9vdFNjb3BlOmlucHJvZyBlcnJvclxyXG4gICAgICBpZiAoc2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkRm9jdXNPblNlbGVjdCkgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7IGVsZW1lbnRbMF0uZm9jdXMoKTsgfSwgMCwgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vYmluZCBrZXlib2FyZCBldmVudHM6IGFycm93cyB1cCgzOCkgLyBkb3duKDQwKSwgZW50ZXIoMTMpIGFuZCB0YWIoOSksIGVzYygyNylcclxuICAgIGVsZW1lbnQub24oJ2tleWRvd24nLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgLy90eXBlYWhlYWQgaXMgb3BlbiBhbmQgYW4gXCJpbnRlcmVzdGluZ1wiIGtleSB3YXMgcHJlc3NlZFxyXG4gICAgICBpZiAoc2NvcGUubWF0Y2hlcy5sZW5ndGggPT09IDAgfHwgSE9UX0tFWVMuaW5kZXhPZihldnQud2hpY2gpID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNob3VsZFNlbGVjdCA9IGlzU2VsZWN0RXZlbnQob3JpZ2luYWxTY29wZSwgeyRldmVudDogZXZ0fSk7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogaWYgdGhlcmUncyBub3RoaW5nIHNlbGVjdGVkIChpLmUuIGZvY3VzRmlyc3QpIGFuZCBlbnRlciBvciB0YWIgaXMgaGl0XHJcbiAgICAgICAqIG9yXHJcbiAgICAgICAqIHNoaWZ0ICsgdGFiIGlzIHByZXNzZWQgdG8gYnJpbmcgZm9jdXMgdG8gdGhlIHByZXZpb3VzIGVsZW1lbnRcclxuICAgICAgICogdGhlbiBjbGVhciB0aGUgcmVzdWx0c1xyXG4gICAgICAgKi9cclxuICAgICAgaWYgKHNjb3BlLmFjdGl2ZUlkeCA9PT0gLTEgJiYgc2hvdWxkU2VsZWN0IHx8IGV2dC53aGljaCA9PT0gOSAmJiAhIWV2dC5zaGlmdEtleSkge1xyXG4gICAgICAgIHJlc2V0TWF0Y2hlcygpO1xyXG4gICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB2YXIgdGFyZ2V0O1xyXG4gICAgICBzd2l0Y2ggKGV2dC53aGljaCkge1xyXG4gICAgICAgIGNhc2UgMjc6IC8vIGVzY2FwZVxyXG4gICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xyXG4gICAgICAgICAgb3JpZ2luYWxTY29wZS4kZGlnZXN0KCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM4OiAvLyB1cCBhcnJvd1xyXG4gICAgICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gKHNjb3BlLmFjdGl2ZUlkeCA+IDAgPyBzY29wZS5hY3RpdmVJZHggOiBzY29wZS5tYXRjaGVzLmxlbmd0aCkgLSAxO1xyXG4gICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xyXG4gICAgICAgICAgdGFyZ2V0ID0gcG9wVXBFbFswXS5xdWVyeVNlbGVjdG9yQWxsKCcudWliLXR5cGVhaGVhZC1tYXRjaCcpW3Njb3BlLmFjdGl2ZUlkeF07XHJcbiAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5zY3JvbGxUb3AgPSB0YXJnZXQub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA0MDogLy8gZG93biBhcnJvd1xyXG4gICAgICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gKHNjb3BlLmFjdGl2ZUlkeCArIDEpICUgc2NvcGUubWF0Y2hlcy5sZW5ndGg7XHJcbiAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XHJcbiAgICAgICAgICB0YXJnZXQgPSBwb3BVcEVsWzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJy51aWItdHlwZWFoZWFkLW1hdGNoJylbc2NvcGUuYWN0aXZlSWR4XTtcclxuICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLnNjcm9sbFRvcCA9IHRhcmdldC5vZmZzZXRUb3A7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgaWYgKHNob3VsZFNlbGVjdCkge1xyXG4gICAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIoc2NvcGUuZGVib3VuY2VVcGRhdGUpIHx8IGFuZ3VsYXIuaXNPYmplY3Qoc2NvcGUuZGVib3VuY2VVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAkJGRlYm91bmNlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICBzY29wZS5zZWxlY3Qoc2NvcGUuYWN0aXZlSWR4LCBldnQpO1xyXG4gICAgICAgICAgICAgICAgfSwgYW5ndWxhci5pc051bWJlcihzY29wZS5kZWJvdW5jZVVwZGF0ZSkgPyBzY29wZS5kZWJvdW5jZVVwZGF0ZSA6IHNjb3BlLmRlYm91bmNlVXBkYXRlWydkZWZhdWx0J10pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5zZWxlY3Qoc2NvcGUuYWN0aXZlSWR4LCBldnQpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGVsZW1lbnQub24oJ2ZvY3VzJywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICBoYXNGb2N1cyA9IHRydWU7XHJcbiAgICAgIGlmIChtaW5MZW5ndGggPT09IDAgJiYgIW1vZGVsQ3RybC4kdmlld1ZhbHVlKSB7XHJcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBnZXRNYXRjaGVzQXN5bmMobW9kZWxDdHJsLiR2aWV3VmFsdWUsIGV2dCk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGVsZW1lbnQub24oJ2JsdXInLCBmdW5jdGlvbihldnQpIHtcclxuICAgICAgaWYgKGlzU2VsZWN0T25CbHVyICYmIHNjb3BlLm1hdGNoZXMubGVuZ3RoICYmIHNjb3BlLmFjdGl2ZUlkeCAhPT0gLTEgJiYgIXNlbGVjdGVkKSB7XHJcbiAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmIChhbmd1bGFyLmlzT2JqZWN0KHNjb3BlLmRlYm91bmNlVXBkYXRlKSAmJiBhbmd1bGFyLmlzTnVtYmVyKHNjb3BlLmRlYm91bmNlVXBkYXRlLmJsdXIpKSB7XHJcbiAgICAgICAgICAgICQkZGVib3VuY2UoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgc2NvcGUuc2VsZWN0KHNjb3BlLmFjdGl2ZUlkeCwgZXZ0KTtcclxuICAgICAgICAgICAgfSwgc2NvcGUuZGVib3VuY2VVcGRhdGUuYmx1cik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzY29wZS5zZWxlY3Qoc2NvcGUuYWN0aXZlSWR4LCBldnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaXNFZGl0YWJsZSAmJiBtb2RlbEN0cmwuJGVycm9yLmVkaXRhYmxlKSB7XHJcbiAgICAgICAgbW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoKTtcclxuICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAvLyBSZXNldCB2YWxpZGl0eSBhcyB3ZSBhcmUgY2xlYXJpbmdcclxuICAgICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgdHJ1ZSk7XHJcbiAgICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdwYXJzZScsIHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsZW1lbnQudmFsKCcnKTtcclxuICAgICAgfVxyXG4gICAgICBoYXNGb2N1cyA9IGZhbHNlO1xyXG4gICAgICBzZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gS2VlcCByZWZlcmVuY2UgdG8gY2xpY2sgaGFuZGxlciB0byB1bmJpbmQgaXQuXHJcbiAgICB2YXIgZGlzbWlzc0NsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAvLyBJc3N1ZSAjMzk3M1xyXG4gICAgICAvLyBGaXJlZm94IHRyZWF0cyByaWdodCBjbGljayBhcyBhIGNsaWNrIG9uIGRvY3VtZW50XHJcbiAgICAgIGlmIChlbGVtZW50WzBdICE9PSBldnQudGFyZ2V0ICYmIGV2dC53aGljaCAhPT0gMyAmJiBzY29wZS5tYXRjaGVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIHJlc2V0TWF0Y2hlcygpO1xyXG4gICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XHJcbiAgICAgICAgICBvcmlnaW5hbFNjb3BlLiRkaWdlc3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgJGRvY3VtZW50Lm9uKCdjbGljaycsIGRpc21pc3NDbGlja0hhbmRsZXIpO1xyXG5cclxuICAgIG9yaWdpbmFsU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAkZG9jdW1lbnQub2ZmKCdjbGljaycsIGRpc21pc3NDbGlja0hhbmRsZXIpO1xyXG4gICAgICBpZiAoYXBwZW5kVG9Cb2R5IHx8IGFwcGVuZFRvKSB7XHJcbiAgICAgICAgJHBvcHVwLnJlbW92ZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XHJcbiAgICAgICAgYW5ndWxhci5lbGVtZW50KCR3aW5kb3cpLm9mZigncmVzaXplJywgZmlyZVJlY2FsY3VsYXRpbmcpO1xyXG4gICAgICAgICRkb2N1bWVudC5maW5kKCdib2R5Jykub2ZmKCdzY3JvbGwnLCBmaXJlUmVjYWxjdWxhdGluZyk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gUHJldmVudCBqUXVlcnkgY2FjaGUgbWVtb3J5IGxlYWtcclxuICAgICAgcG9wVXBFbC5yZW1vdmUoKTtcclxuXHJcbiAgICAgIGlmIChzaG93SGludCkge1xyXG4gICAgICAgICAgaW5wdXRzQ29udGFpbmVyLnJlbW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgJHBvcHVwID0gJGNvbXBpbGUocG9wVXBFbCkoc2NvcGUpO1xyXG5cclxuICAgIGlmIChhcHBlbmRUb0JvZHkpIHtcclxuICAgICAgJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5hcHBlbmQoJHBvcHVwKTtcclxuICAgIH0gZWxzZSBpZiAoYXBwZW5kVG8pIHtcclxuICAgICAgYW5ndWxhci5lbGVtZW50KGFwcGVuZFRvKS5lcSgwKS5hcHBlbmQoJHBvcHVwKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsZW1lbnQuYWZ0ZXIoJHBvcHVwKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihfbW9kZWxDdHJsKSB7XHJcbiAgICAgIG1vZGVsQ3RybCA9IF9tb2RlbEN0cmw7XHJcbiAgICAgIG5nTW9kZWxPcHRpb25zID0gZXh0cmFjdE9wdGlvbnMobW9kZWxDdHJsKTtcclxuXHJcbiAgICAgIHNjb3BlLmRlYm91bmNlVXBkYXRlID0gJHBhcnNlKG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbignZGVib3VuY2UnKSkob3JpZ2luYWxTY29wZSk7XHJcblxyXG4gICAgICAvL3BsdWcgaW50byAkcGFyc2VycyBwaXBlbGluZSB0byBvcGVuIGEgdHlwZWFoZWFkIG9uIHZpZXcgY2hhbmdlcyBpbml0aWF0ZWQgZnJvbSBET01cclxuICAgICAgLy8kcGFyc2VycyBraWNrLWluIG9uIGFsbCB0aGUgY2hhbmdlcyBjb21pbmcgZnJvbSB0aGUgdmlldyBhcyB3ZWxsIGFzIG1hbnVhbGx5IHRyaWdnZXJlZCBieSAkc2V0Vmlld1ZhbHVlXHJcbiAgICAgIG1vZGVsQ3RybC4kcGFyc2Vycy51bnNoaWZ0KGZ1bmN0aW9uKGlucHV0VmFsdWUpIHtcclxuICAgICAgICBoYXNGb2N1cyA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmIChtaW5MZW5ndGggPT09IDAgfHwgaW5wdXRWYWx1ZSAmJiBpbnB1dFZhbHVlLmxlbmd0aCA+PSBtaW5MZW5ndGgpIHtcclxuICAgICAgICAgIGlmICh3YWl0VGltZSA+IDApIHtcclxuICAgICAgICAgICAgY2FuY2VsUHJldmlvdXNUaW1lb3V0KCk7XHJcbiAgICAgICAgICAgIHNjaGVkdWxlU2VhcmNoV2l0aFRpbWVvdXQoaW5wdXRWYWx1ZSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBnZXRNYXRjaGVzQXN5bmMoaW5wdXRWYWx1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XHJcbiAgICAgICAgICBjYW5jZWxQcmV2aW91c1RpbWVvdXQoKTtcclxuICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzRWRpdGFibGUpIHtcclxuICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpbnB1dFZhbHVlKSB7XHJcbiAgICAgICAgICAvLyBSZXNldCBpbiBjYXNlIHVzZXIgaGFkIHR5cGVkIHNvbWV0aGluZyBwcmV2aW91c2x5LlxyXG4gICAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZWRpdGFibGUnLCB0cnVlKTtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZWRpdGFibGUnLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBtb2RlbEN0cmwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbihtb2RlbFZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZVZpZXdWYWx1ZSwgZW1wdHlWaWV3VmFsdWU7XHJcbiAgICAgICAgdmFyIGxvY2FscyA9IHt9O1xyXG5cclxuICAgICAgICAvLyBUaGUgdmFsaWRpdHkgbWF5IGJlIHNldCB0byBmYWxzZSB2aWEgJHBhcnNlcnMgKHNlZSBhYm92ZSkgaWZcclxuICAgICAgICAvLyB0aGUgbW9kZWwgaXMgcmVzdHJpY3RlZCB0byBzZWxlY3RlZCB2YWx1ZXMuIElmIHRoZSBtb2RlbFxyXG4gICAgICAgIC8vIGlzIHNldCBtYW51YWxseSBpdCBpcyBjb25zaWRlcmVkIHRvIGJlIHZhbGlkLlxyXG4gICAgICAgIGlmICghaXNFZGl0YWJsZSkge1xyXG4gICAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZWRpdGFibGUnLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbnB1dEZvcm1hdHRlcikge1xyXG4gICAgICAgICAgbG9jYWxzLiRtb2RlbCA9IG1vZGVsVmFsdWU7XHJcbiAgICAgICAgICByZXR1cm4gaW5wdXRGb3JtYXR0ZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaXQgbWlnaHQgaGFwcGVuIHRoYXQgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggaW5mbyB0byBwcm9wZXJseSByZW5kZXIgaW5wdXQgdmFsdWVcclxuICAgICAgICAvL3dlIG5lZWQgdG8gY2hlY2sgZm9yIHRoaXMgc2l0dWF0aW9uIGFuZCBzaW1wbHkgcmV0dXJuIG1vZGVsIHZhbHVlIGlmIHdlIGNhbid0IGFwcGx5IGN1c3RvbSBmb3JtYXR0aW5nXHJcbiAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBtb2RlbFZhbHVlO1xyXG4gICAgICAgIGNhbmRpZGF0ZVZpZXdWYWx1ZSA9IHBhcnNlclJlc3VsdC52aWV3TWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XHJcbiAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZW1wdHlWaWV3VmFsdWUgPSBwYXJzZXJSZXN1bHQudmlld01hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlVmlld1ZhbHVlICE9PSBlbXB0eVZpZXdWYWx1ZSA/IGNhbmRpZGF0ZVZpZXdWYWx1ZSA6IG1vZGVsVmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBleHRyYWN0T3B0aW9ucyhuZ01vZGVsQ3RybCkge1xyXG4gICAgICB2YXIgbmdNb2RlbE9wdGlvbnM7XHJcblxyXG4gICAgICBpZiAoYW5ndWxhci52ZXJzaW9uLm1pbm9yIDwgNikgeyAvLyBpbiBhbmd1bGFyIDwgMS42ICRvcHRpb25zIGNvdWxkIGJlIG1pc3NpbmdcclxuICAgICAgICAvLyBndWFyYW50ZWUgYSB2YWx1ZVxyXG4gICAgICAgIG5nTW9kZWxPcHRpb25zID0gbmdNb2RlbEN0cmwuJG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgIC8vIG1pbWljIDEuNisgYXBpXHJcbiAgICAgICAgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgcmV0dXJuIG5nTW9kZWxPcHRpb25zW2tleV07XHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHsgLy8gaW4gYW5ndWxhciA+PTEuNiAkb3B0aW9ucyBpcyBhbHdheXMgcHJlc2VudFxyXG4gICAgICAgIG5nTW9kZWxPcHRpb25zID0gbmdNb2RlbEN0cmwuJG9wdGlvbnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuZ01vZGVsT3B0aW9ucztcclxuICAgIH1cclxuICB9XSlcclxuXHJcbiAgLmRpcmVjdGl2ZSgndWliVHlwZWFoZWFkJywgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb250cm9sbGVyOiAnVWliVHlwZWFoZWFkQ29udHJvbGxlcicsXHJcbiAgICAgIHJlcXVpcmU6IFsnbmdNb2RlbCcsICd1aWJUeXBlYWhlYWQnXSxcclxuICAgICAgbGluazogZnVuY3Rpb24ob3JpZ2luYWxTY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XHJcbiAgICAgICAgY3RybHNbMV0uaW5pdChjdHJsc1swXSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSlcclxuXHJcbiAgLmRpcmVjdGl2ZSgndWliVHlwZWFoZWFkUG9wdXAnLCBbJyQkZGVib3VuY2UnLCBmdW5jdGlvbigkJGRlYm91bmNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzY29wZToge1xyXG4gICAgICAgIG1hdGNoZXM6ICc9JyxcclxuICAgICAgICBxdWVyeTogJz0nLFxyXG4gICAgICAgIGFjdGl2ZTogJz0nLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnJicsXHJcbiAgICAgICAgbW92ZUluUHJvZ3Jlc3M6ICc9JyxcclxuICAgICAgICBzZWxlY3Q6ICcmJyxcclxuICAgICAgICBhc3NpZ25Jc09wZW46ICcmJyxcclxuICAgICAgICBkZWJvdW5jZTogJyYnXHJcbiAgICAgIH0sXHJcbiAgICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xyXG4gICAgICAgIHJldHVybiBhdHRycy5wb3B1cFRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1wb3B1cC5odG1sJztcclxuICAgICAgfSxcclxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgICAgc2NvcGUudGVtcGxhdGVVcmwgPSBhdHRycy50ZW1wbGF0ZVVybDtcclxuXHJcbiAgICAgICAgc2NvcGUuaXNPcGVuID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgaXNEcm9wZG93bk9wZW4gPSBzY29wZS5tYXRjaGVzLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICBzY29wZS5hc3NpZ25Jc09wZW4oeyBpc09wZW46IGlzRHJvcGRvd25PcGVuIH0pO1xyXG4gICAgICAgICAgcmV0dXJuIGlzRHJvcGRvd25PcGVuO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHNjb3BlLmlzQWN0aXZlID0gZnVuY3Rpb24obWF0Y2hJZHgpIHtcclxuICAgICAgICAgIHJldHVybiBzY29wZS5hY3RpdmUgPT09IG1hdGNoSWR4O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHNjb3BlLnNlbGVjdEFjdGl2ZSA9IGZ1bmN0aW9uKG1hdGNoSWR4KSB7XHJcbiAgICAgICAgICBzY29wZS5hY3RpdmUgPSBtYXRjaElkeDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBzY29wZS5zZWxlY3RNYXRjaCA9IGZ1bmN0aW9uKGFjdGl2ZUlkeCwgZXZ0KSB7XHJcbiAgICAgICAgICB2YXIgZGVib3VuY2UgPSBzY29wZS5kZWJvdW5jZSgpO1xyXG4gICAgICAgICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIoZGVib3VuY2UpIHx8IGFuZ3VsYXIuaXNPYmplY3QoZGVib3VuY2UpKSB7XHJcbiAgICAgICAgICAgICQkZGVib3VuY2UoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgc2NvcGUuc2VsZWN0KHthY3RpdmVJZHg6IGFjdGl2ZUlkeCwgZXZ0OiBldnR9KTtcclxuICAgICAgICAgICAgfSwgYW5ndWxhci5pc051bWJlcihkZWJvdW5jZSkgPyBkZWJvdW5jZSA6IGRlYm91bmNlWydkZWZhdWx0J10pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2NvcGUuc2VsZWN0KHthY3RpdmVJZHg6IGFjdGl2ZUlkeCwgZXZ0OiBldnR9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1dKVxyXG5cclxuICAuZGlyZWN0aXZlKCd1aWJUeXBlYWhlYWRNYXRjaCcsIFsnJHRlbXBsYXRlUmVxdWVzdCcsICckY29tcGlsZScsICckcGFyc2UnLCBmdW5jdGlvbigkdGVtcGxhdGVSZXF1ZXN0LCAkY29tcGlsZSwgJHBhcnNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzY29wZToge1xyXG4gICAgICAgIGluZGV4OiAnPScsXHJcbiAgICAgICAgbWF0Y2g6ICc9JyxcclxuICAgICAgICBxdWVyeTogJz0nXHJcbiAgICAgIH0sXHJcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xyXG4gICAgICAgIHZhciB0cGxVcmwgPSAkcGFyc2UoYXR0cnMudGVtcGxhdGVVcmwpKHNjb3BlLiRwYXJlbnQpIHx8ICd1aWIvdGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1tYXRjaC5odG1sJztcclxuICAgICAgICAkdGVtcGxhdGVSZXF1ZXN0KHRwbFVybCkudGhlbihmdW5jdGlvbih0cGxDb250ZW50KSB7XHJcbiAgICAgICAgICB2YXIgdHBsRWwgPSBhbmd1bGFyLmVsZW1lbnQodHBsQ29udGVudC50cmltKCkpO1xyXG4gICAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aCh0cGxFbCk7XHJcbiAgICAgICAgICAkY29tcGlsZSh0cGxFbCkoc2NvcGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1dKVxyXG5cclxuICAuZmlsdGVyKCd1aWJUeXBlYWhlYWRIaWdobGlnaHQnLCBbJyRzY2UnLCAnJGluamVjdG9yJywgJyRsb2cnLCBmdW5jdGlvbigkc2NlLCAkaW5qZWN0b3IsICRsb2cpIHtcclxuICAgIHZhciBpc1Nhbml0aXplUHJlc2VudDtcclxuICAgIGlzU2FuaXRpemVQcmVzZW50ID0gJGluamVjdG9yLmhhcygnJHNhbml0aXplJyk7XHJcblxyXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnZXhwKHF1ZXJ5VG9Fc2NhcGUpIHtcclxuICAgICAgLy8gUmVnZXg6IGNhcHR1cmUgdGhlIHdob2xlIHF1ZXJ5IHN0cmluZyBhbmQgcmVwbGFjZSBpdCB3aXRoIHRoZSBzdHJpbmcgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWF0Y2hcclxuICAgICAgLy8gdGhlIHJlc3VsdHMsIGZvciBleGFtcGxlIGlmIHRoZSBjYXB0dXJlIGlzIFwiYVwiIHRoZSByZXN1bHQgd2lsbCBiZSBcXGFcclxuICAgICAgcmV0dXJuIHF1ZXJ5VG9Fc2NhcGUucmVwbGFjZSgvKFsuPyorXiRbXFxdXFxcXCgpe318LV0pL2csICdcXFxcJDEnKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb250YWluc0h0bWwobWF0Y2hJdGVtKSB7XHJcbiAgICAgIHJldHVybiAvPC4qPi9nLnRlc3QobWF0Y2hJdGVtKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24obWF0Y2hJdGVtLCBxdWVyeSkge1xyXG4gICAgICBpZiAoIWlzU2FuaXRpemVQcmVzZW50ICYmIGNvbnRhaW5zSHRtbChtYXRjaEl0ZW0pKSB7XHJcbiAgICAgICAgJGxvZy53YXJuKCdVbnNhZmUgdXNlIG9mIHR5cGVhaGVhZCBwbGVhc2UgdXNlIG5nU2FuaXRpemUnKTsgLy8gV2FybiB0aGUgdXNlciBhYm91dCB0aGUgZGFuZ2VyXHJcbiAgICAgIH1cclxuICAgICAgbWF0Y2hJdGVtID0gcXVlcnkgPyAoJycgKyBtYXRjaEl0ZW0pLnJlcGxhY2UobmV3IFJlZ0V4cChlc2NhcGVSZWdleHAocXVlcnkpLCAnZ2knKSwgJzxzdHJvbmc+JCY8L3N0cm9uZz4nKSA6IG1hdGNoSXRlbTsgLy8gUmVwbGFjZXMgdGhlIGNhcHR1cmUgc3RyaW5nIHdpdGggYSB0aGUgc2FtZSBzdHJpbmcgaW5zaWRlIG9mIGEgXCJzdHJvbmdcIiB0YWdcclxuICAgICAgaWYgKCFpc1Nhbml0aXplUHJlc2VudCkge1xyXG4gICAgICAgIG1hdGNoSXRlbSA9ICRzY2UudHJ1c3RBc0h0bWwobWF0Y2hJdGVtKTsgLy8gSWYgJHNhbml0aXplIGlzIG5vdCBwcmVzZW50IHdlIHBhY2sgdGhlIHN0cmluZyBpbiBhICRzY2Ugb2JqZWN0IGZvciB0aGUgbmctYmluZC1odG1sIGRpcmVjdGl2ZVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBtYXRjaEl0ZW07XHJcbiAgICB9O1xyXG4gIH1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IHJvbGU9XFxcInRhYlxcXCIgaWQ9XFxcInt7OjpoZWFkaW5nSWR9fVxcXCIgYXJpYS1zZWxlY3RlZD1cXFwie3tpc09wZW59fVxcXCIgY2xhc3M9XFxcInBhbmVsLWhlYWRpbmdcXFwiIG5nLWtleXByZXNzPVxcXCJ0b2dnbGVPcGVuKCRldmVudClcXFwiPlxcblwiICtcclxuICAgIFwiICA8aDQgY2xhc3M9XFxcInBhbmVsLXRpdGxlXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICA8YSByb2xlPVxcXCJidXR0b25cXFwiIGRhdGEtdG9nZ2xlPVxcXCJjb2xsYXBzZVxcXCIgaHJlZiBhcmlhLWV4cGFuZGVkPVxcXCJ7e2lzT3Blbn19XFxcIiBhcmlhLWNvbnRyb2xzPVxcXCJ7ezo6cGFuZWxJZH19XFxcIiB0YWJpbmRleD1cXFwiMFxcXCIgY2xhc3M9XFxcImFjY29yZGlvbi10b2dnbGVcXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVPcGVuKClcXFwiIHVpYi1hY2NvcmRpb24tdHJhbnNjbHVkZT1cXFwiaGVhZGluZ1xcXCIgbmctZGlzYWJsZWQ9XFxcImlzRGlzYWJsZWRcXFwiIHVpYi10YWJpbmRleC10b2dnbGU+PHNwYW4gdWliLWFjY29yZGlvbi1oZWFkZXIgbmctY2xhc3M9XFxcInsndGV4dC1tdXRlZCc6IGlzRGlzYWJsZWR9XFxcIj57e2hlYWRpbmd9fTwvc3Bhbj48L2E+XFxuXCIgK1xyXG4gICAgXCIgIDwvaDQ+XFxuXCIgK1xyXG4gICAgXCI8L2Rpdj5cXG5cIiArXHJcbiAgICBcIjxkaXYgaWQ9XFxcInt7OjpwYW5lbElkfX1cXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwie3s6OmhlYWRpbmdJZH19XFxcIiBhcmlhLWhpZGRlbj1cXFwie3shaXNPcGVufX1cXFwiIHJvbGU9XFxcInRhYnBhbmVsXFxcIiBjbGFzcz1cXFwicGFuZWwtY29sbGFwc2UgY29sbGFwc2VcXFwiIHVpYi1jb2xsYXBzZT1cXFwiIWlzT3BlblxcXCI+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInBhbmVsLWJvZHlcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCI8L2Rpdj5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXCIsXHJcbiAgICBcIjxkaXYgcm9sZT1cXFwidGFibGlzdFxcXCIgY2xhc3M9XFxcInBhbmVsLWdyb3VwXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWxcIixcclxuICAgIFwiPGJ1dHRvbiBuZy1zaG93PVxcXCJjbG9zZWFibGVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBuZy1jbGljaz1cXFwiY2xvc2UoeyRldmVudDogJGV2ZW50fSlcXFwiPlxcblwiICtcclxuICAgIFwiICA8c3BhbiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvc3Bhbj5cXG5cIiArXHJcbiAgICBcIiAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPkNsb3NlPC9zcGFuPlxcblwiICtcclxuICAgIFwiPC9idXR0b24+XFxuXCIgK1xyXG4gICAgXCI8ZGl2IG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL2Nhcm91c2VsL2Nhcm91c2VsLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXCIsXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcImNhcm91c2VsLWlubmVyXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcclxuICAgIFwiPGEgcm9sZT1cXFwiYnV0dG9uXFxcIiBocmVmIGNsYXNzPVxcXCJsZWZ0IGNhcm91c2VsLWNvbnRyb2xcXFwiIG5nLWNsaWNrPVxcXCJwcmV2KClcXFwiIG5nLWNsYXNzPVxcXCJ7IGRpc2FibGVkOiBpc1ByZXZEaXNhYmxlZCgpIH1cXFwiIG5nLXNob3c9XFxcInNsaWRlcy5sZW5ndGggPiAxXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgPHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tbGVmdFxcXCI+PC9zcGFuPlxcblwiICtcclxuICAgIFwiICA8c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+cHJldmlvdXM8L3NwYW4+XFxuXCIgK1xyXG4gICAgXCI8L2E+XFxuXCIgK1xyXG4gICAgXCI8YSByb2xlPVxcXCJidXR0b25cXFwiIGhyZWYgY2xhc3M9XFxcInJpZ2h0IGNhcm91c2VsLWNvbnRyb2xcXFwiIG5nLWNsaWNrPVxcXCJuZXh0KClcXFwiIG5nLWNsYXNzPVxcXCJ7IGRpc2FibGVkOiBpc05leHREaXNhYmxlZCgpIH1cXFwiIG5nLXNob3c9XFxcInNsaWRlcy5sZW5ndGggPiAxXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgPHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tcmlnaHRcXFwiPjwvc3Bhbj5cXG5cIiArXHJcbiAgICBcIiAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPm5leHQ8L3NwYW4+XFxuXCIgK1xyXG4gICAgXCI8L2E+XFxuXCIgK1xyXG4gICAgXCI8b2wgY2xhc3M9XFxcImNhcm91c2VsLWluZGljYXRvcnNcXFwiIG5nLXNob3c9XFxcInNsaWRlcy5sZW5ndGggPiAxXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgPGxpIG5nLXJlcGVhdD1cXFwic2xpZGUgaW4gc2xpZGVzIHwgb3JkZXJCeTppbmRleE9mU2xpZGUgdHJhY2sgYnkgJGluZGV4XFxcIiBuZy1jbGFzcz1cXFwieyBhY3RpdmU6IGlzQWN0aXZlKHNsaWRlKSB9XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KHNsaWRlKVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPnNsaWRlIHt7ICRpbmRleCArIDEgfX0gb2Yge3sgc2xpZGVzLmxlbmd0aCB9fTxzcGFuIG5nLWlmPVxcXCJpc0FjdGl2ZShzbGlkZSlcXFwiPiwgY3VycmVudGx5IGFjdGl2ZTwvc3Bhbj48L3NwYW4+XFxuXCIgK1xyXG4gICAgXCIgIDwvbGk+XFxuXCIgK1xyXG4gICAgXCI8L29sPlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IG5nLXN3aXRjaD1cXFwiZGF0ZXBpY2tlck1vZGVcXFwiPlxcblwiICtcclxuICAgIFwiICA8ZGl2IHVpYi1kYXlwaWNrZXIgbmctc3dpdGNoLXdoZW49XFxcImRheVxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiIGNsYXNzPVxcXCJ1aWItZGF5cGlja2VyXFxcIj48L2Rpdj5cXG5cIiArXHJcbiAgICBcIiAgPGRpdiB1aWItbW9udGhwaWNrZXIgbmctc3dpdGNoLXdoZW49XFxcIm1vbnRoXFxcIiB0YWJpbmRleD1cXFwiMFxcXCIgY2xhc3M9XFxcInVpYi1tb250aHBpY2tlclxcXCI+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgdWliLXllYXJwaWNrZXIgbmctc3dpdGNoLXdoZW49XFxcInllYXJcXFwiIHRhYmluZGV4PVxcXCIwXFxcIiBjbGFzcz1cXFwidWliLXllYXJwaWNrZXJcXFwiPjwvZGl2PlxcblwiICtcclxuICAgIFwiPC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF5Lmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RheS5odG1sXCIsXHJcbiAgICBcIjx0YWJsZSByb2xlPVxcXCJncmlkXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9XFxcInt7YWN0aXZlRGF0ZUlkfX1cXFwiPlxcblwiICtcclxuICAgIFwiICA8dGhlYWQ+XFxuXCIgK1xyXG4gICAgXCIgICAgPHRyPlxcblwiICtcclxuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLWxlZnQgdWliLWxlZnRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKC0xKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1sZWZ0XFxcIj48L2k+PHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPnByZXZpb3VzPC9zcGFuPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGggY29sc3Bhbj1cXFwie3s6OjUgKyBzaG93V2Vla3N9fVxcXCI+PGJ1dHRvbiBpZD1cXFwie3s6OnVuaXF1ZUlkfX0tdGl0bGVcXFwiIHJvbGU9XFxcImhlYWRpbmdcXFwiIGFyaWEtbGl2ZT1cXFwiYXNzZXJ0aXZlXFxcIiBhcmlhLWF0b21pYz1cXFwidHJ1ZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSB1aWItdGl0bGVcXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVNb2RlKClcXFwiIG5nLWRpc2FibGVkPVxcXCJkYXRlcGlja2VyTW9kZSA9PT0gbWF4TW9kZVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3Ryb25nPnt7dGl0bGV9fTwvc3Ryb25nPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGg+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHB1bGwtcmlnaHQgdWliLXJpZ2h0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgxKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1yaWdodFxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5uZXh0PC9zcGFuPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xyXG4gICAgXCIgICAgPC90cj5cXG5cIiArXHJcbiAgICBcIiAgICA8dHI+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGggbmctaWY9XFxcInNob3dXZWVrc1xcXCIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj48L3RoPlxcblwiICtcclxuICAgIFwiICAgICAgPHRoIG5nLXJlcGVhdD1cXFwibGFiZWwgaW4gOjpsYWJlbHMgdHJhY2sgYnkgJGluZGV4XFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPjxzbWFsbCBhcmlhLWxhYmVsPVxcXCJ7ezo6bGFiZWwuZnVsbH19XFxcIj57ezo6bGFiZWwuYWJicn19PC9zbWFsbD48L3RoPlxcblwiICtcclxuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xyXG4gICAgXCIgIDwvdGhlYWQ+XFxuXCIgK1xyXG4gICAgXCIgIDx0Ym9keT5cXG5cIiArXHJcbiAgICBcIiAgICA8dHIgY2xhc3M9XFxcInVpYi13ZWVrc1xcXCIgbmctcmVwZWF0PVxcXCJyb3cgaW4gcm93cyB0cmFjayBieSAkaW5kZXhcXFwiIHJvbGU9XFxcInJvd1xcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGQgbmctaWY9XFxcInNob3dXZWVrc1xcXCIgY2xhc3M9XFxcInRleHQtY2VudGVyIGg2XFxcIj48ZW0+e3sgd2Vla051bWJlcnNbJGluZGV4XSB9fTwvZW0+PC90ZD5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0ZCBuZy1yZXBlYXQ9XFxcImR0IGluIHJvd1xcXCIgY2xhc3M9XFxcInVpYi1kYXkgdGV4dC1jZW50ZXJcXFwiIHJvbGU9XFxcImdyaWRjZWxsXFxcIlxcblwiICtcclxuICAgIFwiICAgICAgICBpZD1cXFwie3s6OmR0LnVpZH19XFxcIlxcblwiICtcclxuICAgIFwiICAgICAgICBuZy1jbGFzcz1cXFwiOjpkdC5jdXN0b21DbGFzc1xcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbVxcXCJcXG5cIiArXHJcbiAgICBcIiAgICAgICAgICB1aWItaXMtY2xhc3M9XFxcIlxcblwiICtcclxuICAgIFwiICAgICAgICAgICAgJ2J0bi1pbmZvJyBmb3Igc2VsZWN0ZWREdCxcXG5cIiArXHJcbiAgICBcIiAgICAgICAgICAgICdhY3RpdmUnIGZvciBhY3RpdmVEdFxcblwiICtcclxuICAgIFwiICAgICAgICAgICAgb24gZHRcXFwiXFxuXCIgK1xyXG4gICAgXCIgICAgICAgICAgbmctY2xpY2s9XFxcInNlbGVjdChkdC5kYXRlKVxcXCJcXG5cIiArXHJcbiAgICBcIiAgICAgICAgICBuZy1kaXNhYmxlZD1cXFwiOjpkdC5kaXNhYmxlZFxcXCJcXG5cIiArXHJcbiAgICBcIiAgICAgICAgICB0YWJpbmRleD1cXFwiLTFcXFwiPjxzcGFuIG5nLWNsYXNzPVxcXCI6OnsndGV4dC1tdXRlZCc6IGR0LnNlY29uZGFyeSwgJ3RleHQtaW5mbyc6IGR0LmN1cnJlbnR9XFxcIj57ezo6ZHQubGFiZWx9fTwvc3Bhbj48L2J1dHRvbj5cXG5cIiArXHJcbiAgICBcIiAgICAgIDwvdGQ+XFxuXCIgK1xyXG4gICAgXCIgICAgPC90cj5cXG5cIiArXHJcbiAgICBcIiAgPC90Ym9keT5cXG5cIiArXHJcbiAgICBcIjwvdGFibGU+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvbW9udGguaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvbW9udGguaHRtbFwiLFxyXG4gICAgXCI8dGFibGUgcm9sZT1cXFwiZ3JpZFxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgYXJpYS1hY3RpdmVkZXNjZW5kYW50PVxcXCJ7e2FjdGl2ZURhdGVJZH19XFxcIj5cXG5cIiArXHJcbiAgICBcIiAgPHRoZWFkPlxcblwiICtcclxuICAgIFwiICAgIDx0cj5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1sZWZ0IHVpYi1sZWZ0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgtMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tbGVmdFxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5wcmV2aW91czwvc3Bhbj48L2J1dHRvbj48L3RoPlxcblwiICtcclxuICAgIFwiICAgICAgPHRoIGNvbHNwYW49XFxcInt7Ojp5ZWFySGVhZGVyQ29sc3Bhbn19XFxcIj48YnV0dG9uIGlkPVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgcm9sZT1cXFwiaGVhZGluZ1xcXCIgYXJpYS1saXZlPVxcXCJhc3NlcnRpdmVcXFwiIGFyaWEtYXRvbWljPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHVpYi10aXRsZVxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU1vZGUoKVxcXCIgbmctZGlzYWJsZWQ9XFxcImRhdGVwaWNrZXJNb2RlID09PSBtYXhNb2RlXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxzdHJvbmc+e3t0aXRsZX19PC9zdHJvbmc+PC9idXR0b24+PC90aD5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1yaWdodCB1aWItcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKDEpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPm5leHQ8L3NwYW4+PC9pPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xyXG4gICAgXCIgICAgPC90cj5cXG5cIiArXHJcbiAgICBcIiAgPC90aGVhZD5cXG5cIiArXHJcbiAgICBcIiAgPHRib2R5PlxcblwiICtcclxuICAgIFwiICAgIDx0ciBjbGFzcz1cXFwidWliLW1vbnRoc1xcXCIgbmctcmVwZWF0PVxcXCJyb3cgaW4gcm93cyB0cmFjayBieSAkaW5kZXhcXFwiIHJvbGU9XFxcInJvd1xcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGQgbmctcmVwZWF0PVxcXCJkdCBpbiByb3dcXFwiIGNsYXNzPVxcXCJ1aWItbW9udGggdGV4dC1jZW50ZXJcXFwiIHJvbGU9XFxcImdyaWRjZWxsXFxcIlxcblwiICtcclxuICAgIFwiICAgICAgICBpZD1cXFwie3s6OmR0LnVpZH19XFxcIlxcblwiICtcclxuICAgIFwiICAgICAgICBuZy1jbGFzcz1cXFwiOjpkdC5jdXN0b21DbGFzc1xcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIlxcblwiICtcclxuICAgIFwiICAgICAgICAgIHVpYi1pcy1jbGFzcz1cXFwiXFxuXCIgK1xyXG4gICAgXCIgICAgICAgICAgICAnYnRuLWluZm8nIGZvciBzZWxlY3RlZER0LFxcblwiICtcclxuICAgIFwiICAgICAgICAgICAgJ2FjdGl2ZScgZm9yIGFjdGl2ZUR0XFxuXCIgK1xyXG4gICAgXCIgICAgICAgICAgICBvbiBkdFxcXCJcXG5cIiArXHJcbiAgICBcIiAgICAgICAgICBuZy1jbGljaz1cXFwic2VsZWN0KGR0LmRhdGUpXFxcIlxcblwiICtcclxuICAgIFwiICAgICAgICAgIG5nLWRpc2FibGVkPVxcXCI6OmR0LmRpc2FibGVkXFxcIlxcblwiICtcclxuICAgIFwiICAgICAgICAgIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gbmctY2xhc3M9XFxcIjo6eyd0ZXh0LWluZm8nOiBkdC5jdXJyZW50fVxcXCI+e3s6OmR0LmxhYmVsfX08L3NwYW4+PC9idXR0b24+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8L3RkPlxcblwiICtcclxuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xyXG4gICAgXCIgIDwvdGJvZHk+XFxuXCIgK1xyXG4gICAgXCI8L3RhYmxlPlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL3llYXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sXCIsXHJcbiAgICBcIjx0YWJsZSByb2xlPVxcXCJncmlkXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9XFxcInt7YWN0aXZlRGF0ZUlkfX1cXFwiPlxcblwiICtcclxuICAgIFwiICA8dGhlYWQ+XFxuXCIgK1xyXG4gICAgXCIgICAgPHRyPlxcblwiICtcclxuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLWxlZnQgdWliLWxlZnRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKC0xKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1sZWZ0XFxcIj48L2k+PHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPnByZXZpb3VzPC9zcGFuPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGggY29sc3Bhbj1cXFwie3s6OmNvbHVtbnMgLSAyfX1cXFwiPjxidXR0b24gaWQ9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiByb2xlPVxcXCJoZWFkaW5nXFxcIiBhcmlhLWxpdmU9XFxcImFzc2VydGl2ZVxcXCIgYXJpYS1hdG9taWM9XFxcInRydWVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gdWliLXRpdGxlXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlTW9kZSgpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZGF0ZXBpY2tlck1vZGUgPT09IG1heE1vZGVcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHN0cm9uZz57e3RpdGxlfX08L3N0cm9uZz48L2J1dHRvbj48L3RoPlxcblwiICtcclxuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSBwdWxsLXJpZ2h0IHVpYi1yaWdodFxcXCIgbmctY2xpY2s9XFxcIm1vdmUoMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tcmlnaHRcXFwiPjwvaT48c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+bmV4dDwvc3Bhbj48L2J1dHRvbj48L3RoPlxcblwiICtcclxuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xyXG4gICAgXCIgIDwvdGhlYWQ+XFxuXCIgK1xyXG4gICAgXCIgIDx0Ym9keT5cXG5cIiArXHJcbiAgICBcIiAgICA8dHIgY2xhc3M9XFxcInVpYi15ZWFyc1xcXCIgbmctcmVwZWF0PVxcXCJyb3cgaW4gcm93cyB0cmFjayBieSAkaW5kZXhcXFwiIHJvbGU9XFxcInJvd1xcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGQgbmctcmVwZWF0PVxcXCJkdCBpbiByb3dcXFwiIGNsYXNzPVxcXCJ1aWIteWVhciB0ZXh0LWNlbnRlclxcXCIgcm9sZT1cXFwiZ3JpZGNlbGxcXFwiXFxuXCIgK1xyXG4gICAgXCIgICAgICAgIGlkPVxcXCJ7ezo6ZHQudWlkfX1cXFwiXFxuXCIgK1xyXG4gICAgXCIgICAgICAgIG5nLWNsYXNzPVxcXCI6OmR0LmN1c3RvbUNsYXNzXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiXFxuXCIgK1xyXG4gICAgXCIgICAgICAgICAgdWliLWlzLWNsYXNzPVxcXCJcXG5cIiArXHJcbiAgICBcIiAgICAgICAgICAgICdidG4taW5mbycgZm9yIHNlbGVjdGVkRHQsXFxuXCIgK1xyXG4gICAgXCIgICAgICAgICAgICAnYWN0aXZlJyBmb3IgYWN0aXZlRHRcXG5cIiArXHJcbiAgICBcIiAgICAgICAgICAgIG9uIGR0XFxcIlxcblwiICtcclxuICAgIFwiICAgICAgICAgIG5nLWNsaWNrPVxcXCJzZWxlY3QoZHQuZGF0ZSlcXFwiXFxuXCIgK1xyXG4gICAgXCIgICAgICAgICAgbmctZGlzYWJsZWQ9XFxcIjo6ZHQuZGlzYWJsZWRcXFwiXFxuXCIgK1xyXG4gICAgXCIgICAgICAgICAgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBuZy1jbGFzcz1cXFwiOjp7J3RleHQtaW5mbyc6IGR0LmN1cnJlbnR9XFxcIj57ezo6ZHQubGFiZWx9fTwvc3Bhbj48L2J1dHRvbj5cXG5cIiArXHJcbiAgICBcIiAgICAgIDwvdGQ+XFxuXCIgK1xyXG4gICAgXCIgICAgPC90cj5cXG5cIiArXHJcbiAgICBcIiAgPC90Ym9keT5cXG5cIiArXHJcbiAgICBcIjwvdGFibGU+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXJQb3B1cC9wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlclBvcHVwL3BvcHVwLmh0bWxcIixcclxuICAgIFwiPHVsIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCIgY2xhc3M9XFxcInVpYi1kYXRlcGlja2VyLXBvcHVwIGRyb3Bkb3duLW1lbnUgdWliLXBvc2l0aW9uLW1lYXN1cmVcXFwiIGRyb3Bkb3duLW5lc3RlZCBuZy1pZj1cXFwiaXNPcGVuXFxcIiBuZy1rZXlkb3duPVxcXCJrZXlkb3duKCRldmVudClcXFwiIG5nLWNsaWNrPVxcXCIkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcXFwiPlxcblwiICtcclxuICAgIFwiICA8bGkgbmctdHJhbnNjbHVkZT48L2xpPlxcblwiICtcclxuICAgIFwiICA8bGkgbmctaWY9XFxcInNob3dCdXR0b25CYXJcXFwiIGNsYXNzPVxcXCJ1aWItYnV0dG9uLWJhclxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgPHNwYW4gY2xhc3M9XFxcImJ0bi1ncm91cCBwdWxsLWxlZnRcXFwiPlxcblwiICtcclxuICAgIFwiICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1pbmZvIHVpYi1kYXRlcGlja2VyLWN1cnJlbnRcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3QoJ3RvZGF5JywgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcImlzRGlzYWJsZWQoJ3RvZGF5JylcXFwiPnt7IGdldFRleHQoJ2N1cnJlbnQnKSB9fTwvYnV0dG9uPlxcblwiICtcclxuICAgIFwiICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1kYW5nZXIgdWliLWNsZWFyXFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KG51bGwsICRldmVudClcXFwiPnt7IGdldFRleHQoJ2NsZWFyJykgfX08L2J1dHRvbj5cXG5cIiArXHJcbiAgICBcIiAgICA8L3NwYW4+XFxuXCIgK1xyXG4gICAgXCIgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1zdWNjZXNzIHB1bGwtcmlnaHQgdWliLWNsb3NlXFxcIiBuZy1jbGljaz1cXFwiY2xvc2UoJGV2ZW50KVxcXCI+e3sgZ2V0VGV4dCgnY2xvc2UnKSB9fTwvYnV0dG9uPlxcblwiICtcclxuICAgIFwiICA8L2xpPlxcblwiICtcclxuICAgIFwiPC91bD5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvbW9kYWwvd2luZG93Lmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJtb2RhbC1kaWFsb2cge3tzaXplID8gJ21vZGFsLScgKyBzaXplIDogJyd9fVxcXCI+PGRpdiBjbGFzcz1cXFwibW9kYWwtY29udGVudFxcXCIgdWliLW1vZGFsLXRyYW5zY2x1ZGU+PC9kaXY+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3BhZ2VyL3BhZ2VyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9wYWdlci9wYWdlci5odG1sXCIsXHJcbiAgICBcIjxsaSBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub1ByZXZpb3VzKCl8fG5nRGlzYWJsZWQsIHByZXZpb3VzOiBhbGlnbn1cXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UocGFnZSAtIDEsICRldmVudClcXFwiIG5nLWRpc2FibGVkPVxcXCJub1ByZXZpb3VzKCl8fG5nRGlzYWJsZWRcXFwiIHVpYi10YWJpbmRleC10b2dnbGU+e3s6OmdldFRleHQoJ3ByZXZpb3VzJyl9fTwvYT48L2xpPlxcblwiICtcclxuICAgIFwiPGxpIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vTmV4dCgpfHxuZ0Rpc2FibGVkLCBuZXh0OiBhbGlnbn1cXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UocGFnZSArIDEsICRldmVudClcXFwiIG5nLWRpc2FibGVkPVxcXCJub05leHQoKXx8bmdEaXNhYmxlZFxcXCIgdWliLXRhYmluZGV4LXRvZ2dsZT57ezo6Z2V0VGV4dCgnbmV4dCcpfX08L2E+PC9saT5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFwiLFxyXG4gICAgXCI8bGkgcm9sZT1cXFwibWVudWl0ZW1cXFwiIG5nLWlmPVxcXCI6OmJvdW5kYXJ5TGlua3NcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vUHJldmlvdXMoKXx8bmdEaXNhYmxlZH1cXFwiIGNsYXNzPVxcXCJwYWdpbmF0aW9uLWZpcnN0XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKDEsICRldmVudClcXFwiIG5nLWRpc2FibGVkPVxcXCJub1ByZXZpb3VzKCl8fG5nRGlzYWJsZWRcXFwiIHVpYi10YWJpbmRleC10b2dnbGU+e3s6OmdldFRleHQoJ2ZpcnN0Jyl9fTwvYT48L2xpPlxcblwiICtcclxuICAgIFwiPGxpIHJvbGU9XFxcIm1lbnVpdGVtXFxcIiBuZy1pZj1cXFwiOjpkaXJlY3Rpb25MaW5rc1xcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9QcmV2aW91cygpfHxuZ0Rpc2FibGVkfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tcHJldlxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlIC0gMSwgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5vUHJldmlvdXMoKXx8bmdEaXNhYmxlZFxcXCIgdWliLXRhYmluZGV4LXRvZ2dsZT57ezo6Z2V0VGV4dCgncHJldmlvdXMnKX19PC9hPjwvbGk+XFxuXCIgK1xyXG4gICAgXCI8bGkgcm9sZT1cXFwibWVudWl0ZW1cXFwiIG5nLXJlcGVhdD1cXFwicGFnZSBpbiBwYWdlcyB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBwYWdlLmFjdGl2ZSxkaXNhYmxlZDogbmdEaXNhYmxlZCYmIXBhZ2UuYWN0aXZlfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tcGFnZVxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlLm51bWJlciwgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5nRGlzYWJsZWQmJiFwYWdlLmFjdGl2ZVxcXCIgdWliLXRhYmluZGV4LXRvZ2dsZT57e3BhZ2UudGV4dH19PC9hPjwvbGk+XFxuXCIgK1xyXG4gICAgXCI8bGkgcm9sZT1cXFwibWVudWl0ZW1cXFwiIG5nLWlmPVxcXCI6OmRpcmVjdGlvbkxpbmtzXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub05leHQoKXx8bmdEaXNhYmxlZH1cXFwiIGNsYXNzPVxcXCJwYWdpbmF0aW9uLW5leHRcXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UocGFnZSArIDEsICRldmVudClcXFwiIG5nLWRpc2FibGVkPVxcXCJub05leHQoKXx8bmdEaXNhYmxlZFxcXCIgdWliLXRhYmluZGV4LXRvZ2dsZT57ezo6Z2V0VGV4dCgnbmV4dCcpfX08L2E+PC9saT5cXG5cIiArXHJcbiAgICBcIjxsaSByb2xlPVxcXCJtZW51aXRlbVxcXCIgbmctaWY9XFxcIjo6Ym91bmRhcnlMaW5rc1xcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9OZXh0KCl8fG5nRGlzYWJsZWR9XFxcIiBjbGFzcz1cXFwicGFnaW5hdGlvbi1sYXN0XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHRvdGFsUGFnZXMsICRldmVudClcXFwiIG5nLWRpc2FibGVkPVxcXCJub05leHQoKXx8bmdEaXNhYmxlZFxcXCIgdWliLXRhYmluZGV4LXRvZ2dsZT57ezo6Z2V0VGV4dCgnbGFzdCcpfX08L2E+PC9saT5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXBvcHVwLmh0bWxcIixcclxuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1hcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWlubmVyXFxcIiBuZy1iaW5kLWh0bWw9XFxcImNvbnRlbnRFeHAoKVxcXCI+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWxcIixcclxuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1hcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWlubmVyXFxcIiBuZy1iaW5kPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXRlbXBsYXRlLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtdGVtcGxhdGUtcG9wdXAuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWFycm93XFxcIj48L2Rpdj5cXG5cIiArXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcInRvb2x0aXAtaW5uZXJcXFwiXFxuXCIgK1xyXG4gICAgXCIgIHVpYi10b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGU9XFxcImNvbnRlbnRFeHAoKVxcXCJcXG5cIiArXHJcbiAgICBcIiAgdG9vbHRpcC10ZW1wbGF0ZS10cmFuc2NsdWRlLXNjb3BlPVxcXCJvcmlnaW5TY29wZSgpXFxcIj48L2Rpdj5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLWh0bWwuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci1odG1sLmh0bWxcIixcclxuICAgIFwiPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcclxuICAgIFwiXFxuXCIgK1xyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWlubmVyXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICA8aDMgY2xhc3M9XFxcInBvcG92ZXItdGl0bGVcXFwiIG5nLWJpbmQ9XFxcInVpYlRpdGxlXFxcIiBuZy1pZj1cXFwidWliVGl0bGVcXFwiPjwvaDM+XFxuXCIgK1xyXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1jb250ZW50XFxcIiBuZy1iaW5kLWh0bWw9XFxcImNvbnRlbnRFeHAoKVxcXCI+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCI8L2Rpdj5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLXRlbXBsYXRlLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJhcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcXG5cIiArXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcInBvcG92ZXItaW5uZXJcXFwiPlxcblwiICtcclxuICAgIFwiICAgIDxoMyBjbGFzcz1cXFwicG9wb3Zlci10aXRsZVxcXCIgbmctYmluZD1cXFwidWliVGl0bGVcXFwiIG5nLWlmPVxcXCJ1aWJUaXRsZVxcXCI+PC9oMz5cXG5cIiArXHJcbiAgICBcIiAgICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWNvbnRlbnRcXFwiXFxuXCIgK1xyXG4gICAgXCIgICAgICB1aWItdG9vbHRpcC10ZW1wbGF0ZS10cmFuc2NsdWRlPVxcXCJjb250ZW50RXhwKClcXFwiXFxuXCIgK1xyXG4gICAgXCIgICAgICB0b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGUtc2NvcGU9XFxcIm9yaWdpblNjb3BlKClcXFwiPjwvZGl2PlxcblwiICtcclxuICAgIFwiPC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWxcIixcclxuICAgIFwiPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcclxuICAgIFwiXFxuXCIgK1xyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWlubmVyXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICA8aDMgY2xhc3M9XFxcInBvcG92ZXItdGl0bGVcXFwiIG5nLWJpbmQ9XFxcInVpYlRpdGxlXFxcIiBuZy1pZj1cXFwidWliVGl0bGVcXFwiPjwvaDM+XFxuXCIgK1xyXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1jb250ZW50XFxcIiBuZy1iaW5kPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cXG5cIiArXHJcbiAgICBcIjwvZGl2PlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sXCIsXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWJhclxcXCIgbmctY2xhc3M9XFxcInR5cGUgJiYgJ3Byb2dyZXNzLWJhci0nICsgdHlwZVxcXCIgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgYXJpYS12YWx1ZW1heD1cXFwie3ttYXh9fVxcXCIgbmctc3R5bGU9XFxcInt3aWR0aDogKHBlcmNlbnQgPCAxMDAgPyBwZXJjZW50IDogMTAwKSArICclJ31cXFwiIGFyaWEtdmFsdWV0ZXh0PVxcXCJ7e3BlcmNlbnQgfCBudW1iZXI6MH19JVxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dGl0bGV9fVxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWxcIixcclxuICAgIFwiPGRpdiBjbGFzcz1cXFwicHJvZ3Jlc3NcXFwiIG5nLXRyYW5zY2x1ZGUgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dGl0bGV9fVxcXCI+PC9kaXY+XCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzc1xcXCI+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWJhclxcXCIgbmctY2xhc3M9XFxcInR5cGUgJiYgJ3Byb2dyZXNzLWJhci0nICsgdHlwZVxcXCIgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgYXJpYS12YWx1ZW1heD1cXFwie3ttYXh9fVxcXCIgbmctc3R5bGU9XFxcInt3aWR0aDogKHBlcmNlbnQgPCAxMDAgPyBwZXJjZW50IDogMTAwKSArICclJ31cXFwiIGFyaWEtdmFsdWV0ZXh0PVxcXCJ7e3BlcmNlbnQgfCBudW1iZXI6MH19JVxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dGl0bGV9fVxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXHJcbiAgICBcIjwvZGl2PlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9yYXRpbmcvcmF0aW5nLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9yYXRpbmcvcmF0aW5nLmh0bWxcIixcclxuICAgIFwiPHNwYW4gbmctbW91c2VsZWF2ZT1cXFwicmVzZXQoKVxcXCIgbmcta2V5ZG93bj1cXFwib25LZXlkb3duKCRldmVudClcXFwiIHRhYmluZGV4PVxcXCIwXFxcIiByb2xlPVxcXCJzbGlkZXJcXFwiIGFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIGFyaWEtdmFsdWVtYXg9XFxcInt7cmFuZ2UubGVuZ3RofX1cXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCIgYXJpYS12YWx1ZXRleHQ9XFxcInt7dGl0bGV9fVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgPHNwYW4gbmctcmVwZWF0LXN0YXJ0PVxcXCJyIGluIHJhbmdlIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcInNyLW9ubHlcXFwiPih7eyAkaW5kZXggPCB2YWx1ZSA/ICcqJyA6ICcgJyB9fSk8L3NwYW4+XFxuXCIgK1xyXG4gICAgXCIgICAgPGkgbmctcmVwZWF0LWVuZCBuZy1tb3VzZWVudGVyPVxcXCJlbnRlcigkaW5kZXggKyAxKVxcXCIgbmctY2xpY2s9XFxcInJhdGUoJGluZGV4ICsgMSlcXFwiIGNsYXNzPVxcXCJnbHlwaGljb25cXFwiIG5nLWNsYXNzPVxcXCIkaW5kZXggPCB2YWx1ZSAmJiAoci5zdGF0ZU9uIHx8ICdnbHlwaGljb24tc3RhcicpIHx8IChyLnN0YXRlT2ZmIHx8ICdnbHlwaGljb24tc3Rhci1lbXB0eScpXFxcIiBuZy1hdHRyLXRpdGxlPVxcXCJ7e3IudGl0bGV9fVxcXCI+PC9pPlxcblwiICtcclxuICAgIFwiPC9zcGFuPlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS90YWJzL3RhYi5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvdGFicy90YWIuaHRtbFwiLFxyXG4gICAgXCI8bGkgbmctY2xhc3M9XFxcIlt7YWN0aXZlOiBhY3RpdmUsIGRpc2FibGVkOiBkaXNhYmxlZH0sIGNsYXNzZXNdXFxcIiBjbGFzcz1cXFwidWliLXRhYiBuYXYtaXRlbVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgIDxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdCgkZXZlbnQpXFxcIiBjbGFzcz1cXFwibmF2LWxpbmtcXFwiIHVpYi10YWItaGVhZGluZy10cmFuc2NsdWRlPnt7aGVhZGluZ319PC9hPlxcblwiICtcclxuICAgIFwiPC9saT5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWxcIixcclxuICAgIFwiPGRpdj5cXG5cIiArXHJcbiAgICBcIiAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXt7dGFic2V0LnR5cGUgfHwgJ3RhYnMnfX1cXFwiIG5nLWNsYXNzPVxcXCJ7J25hdi1zdGFja2VkJzogdmVydGljYWwsICduYXYtanVzdGlmaWVkJzoganVzdGlmaWVkfVxcXCIgbmctdHJhbnNjbHVkZT48L3VsPlxcblwiICtcclxuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudFxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiXFxuXCIgK1xyXG4gICAgXCIgICAgICAgICBuZy1yZXBlYXQ9XFxcInRhYiBpbiB0YWJzZXQudGFic1xcXCJcXG5cIiArXHJcbiAgICBcIiAgICAgICAgIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiB0YWJzZXQuYWN0aXZlID09PSB0YWIuaW5kZXh9XFxcIlxcblwiICtcclxuICAgIFwiICAgICAgICAgdWliLXRhYi1jb250ZW50LXRyYW5zY2x1ZGU9XFxcInRhYlxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgPC9kaXY+XFxuXCIgK1xyXG4gICAgXCIgIDwvZGl2PlxcblwiICtcclxuICAgIFwiPC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3RpbWVwaWNrZXIvdGltZXBpY2tlci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWxcIixcclxuICAgIFwiPHRhYmxlIGNsYXNzPVxcXCJ1aWItdGltZXBpY2tlclxcXCI+XFxuXCIgK1xyXG4gICAgXCIgIDx0Ym9keT5cXG5cIiArXHJcbiAgICBcIiAgICA8dHIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIiBuZy1zaG93PVxcXCI6OnNob3dTcGlubmVyc1xcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGQgY2xhc3M9XFxcInVpYi1pbmNyZW1lbnQgaG91cnNcXFwiPjxhIG5nLWNsaWNrPVxcXCJpbmNyZW1lbnRIb3VycygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0luY3JlbWVudEhvdXJzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9JbmNyZW1lbnRIb3VycygpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tdXBcXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0ZD4mbmJzcDs8L3RkPlxcblwiICtcclxuICAgIFwiICAgICAgPHRkIGNsYXNzPVxcXCJ1aWItaW5jcmVtZW50IG1pbnV0ZXNcXFwiPjxhIG5nLWNsaWNrPVxcXCJpbmNyZW1lbnRNaW51dGVzKClcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vSW5jcmVtZW50TWludXRlcygpfVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgbmctZGlzYWJsZWQ9XFxcIm5vSW5jcmVtZW50TWludXRlcygpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tdXBcXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93U2Vjb25kc1xcXCI+Jm5ic3A7PC90ZD5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93U2Vjb25kc1xcXCIgY2xhc3M9XFxcInVpYi1pbmNyZW1lbnQgc2Vjb25kc1xcXCI+PGEgbmctY2xpY2s9XFxcImluY3JlbWVudFNlY29uZHMoKVxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9JbmNyZW1lbnRTZWNvbmRzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9JbmNyZW1lbnRTZWNvbmRzKClcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi11cFxcXCI+PC9zcGFuPjwvYT48L3RkPlxcblwiICtcclxuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dNZXJpZGlhblxcXCI+PC90ZD5cXG5cIiArXHJcbiAgICBcIiAgICA8L3RyPlxcblwiICtcclxuICAgIFwiICAgIDx0cj5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0ZCBjbGFzcz1cXFwiZm9ybS1ncm91cCB1aWItdGltZSBob3Vyc1xcXCIgbmctY2xhc3M9XFxcInsnaGFzLWVycm9yJzogaW52YWxpZEhvdXJzfVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiSEhcXFwiIG5nLW1vZGVsPVxcXCJob3Vyc1xcXCIgbmctY2hhbmdlPVxcXCJ1cGRhdGVIb3VycygpXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHRleHQtY2VudGVyXFxcIiBuZy1yZWFkb25seT1cXFwiOjpyZWFkb25seUlucHV0XFxcIiBtYXhsZW5ndGg9XFxcIjJcXFwiIHRhYmluZGV4PVxcXCJ7ezo6dGFiaW5kZXh9fVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5vSW5jcmVtZW50SG91cnMoKVxcXCIgbmctYmx1cj1cXFwiYmx1cigpXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgIDwvdGQ+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGQgY2xhc3M9XFxcInVpYi1zZXBhcmF0b3JcXFwiPjo8L3RkPlxcblwiICtcclxuICAgIFwiICAgICAgPHRkIGNsYXNzPVxcXCJmb3JtLWdyb3VwIHVpYi10aW1lIG1pbnV0ZXNcXFwiIG5nLWNsYXNzPVxcXCJ7J2hhcy1lcnJvcic6IGludmFsaWRNaW51dGVzfVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiTU1cXFwiIG5nLW1vZGVsPVxcXCJtaW51dGVzXFxcIiBuZy1jaGFuZ2U9XFxcInVwZGF0ZU1pbnV0ZXMoKVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCB0ZXh0LWNlbnRlclxcXCIgbmctcmVhZG9ubHk9XFxcIjo6cmVhZG9ubHlJbnB1dFxcXCIgbWF4bGVuZ3RoPVxcXCIyXFxcIiB0YWJpbmRleD1cXFwie3s6OnRhYmluZGV4fX1cXFwiIG5nLWRpc2FibGVkPVxcXCJub0luY3JlbWVudE1pbnV0ZXMoKVxcXCIgbmctYmx1cj1cXFwiYmx1cigpXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgIDwvdGQ+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGQgbmctc2hvdz1cXFwic2hvd1NlY29uZHNcXFwiIGNsYXNzPVxcXCJ1aWItc2VwYXJhdG9yXFxcIj46PC90ZD5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0ZCBjbGFzcz1cXFwiZm9ybS1ncm91cCB1aWItdGltZSBzZWNvbmRzXFxcIiBuZy1jbGFzcz1cXFwieydoYXMtZXJyb3InOiBpbnZhbGlkU2Vjb25kc31cXFwiIG5nLXNob3c9XFxcInNob3dTZWNvbmRzXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJTU1xcXCIgbmctbW9kZWw9XFxcInNlY29uZHNcXFwiIG5nLWNoYW5nZT1cXFwidXBkYXRlU2Vjb25kcygpXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHRleHQtY2VudGVyXFxcIiBuZy1yZWFkb25seT1cXFwicmVhZG9ubHlJbnB1dFxcXCIgbWF4bGVuZ3RoPVxcXCIyXFxcIiB0YWJpbmRleD1cXFwie3s6OnRhYmluZGV4fX1cXFwiIG5nLWRpc2FibGVkPVxcXCJub0luY3JlbWVudFNlY29uZHMoKVxcXCIgbmctYmx1cj1cXFwiYmx1cigpXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgIDwvdGQ+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGQgbmctc2hvdz1cXFwic2hvd01lcmlkaWFuXFxcIiBjbGFzcz1cXFwidWliLXRpbWUgYW0tcG1cXFwiPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub1RvZ2dsZU1lcmlkaWFuKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IHRleHQtY2VudGVyXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlTWVyaWRpYW4oKVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5vVG9nZ2xlTWVyaWRpYW4oKVxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIj57e21lcmlkaWFufX08L2J1dHRvbj48L3RkPlxcblwiICtcclxuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xyXG4gICAgXCIgICAgPHRyIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCIgbmctc2hvdz1cXFwiOjpzaG93U3Bpbm5lcnNcXFwiPlxcblwiICtcclxuICAgIFwiICAgICAgPHRkIGNsYXNzPVxcXCJ1aWItZGVjcmVtZW50IGhvdXJzXFxcIj48YSBuZy1jbGljaz1cXFwiZGVjcmVtZW50SG91cnMoKVxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9EZWNyZW1lbnRIb3VycygpfVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgbmctZGlzYWJsZWQ9XFxcIm5vRGVjcmVtZW50SG91cnMoKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0ZD4mbmJzcDs8L3RkPlxcblwiICtcclxuICAgIFwiICAgICAgPHRkIGNsYXNzPVxcXCJ1aWItZGVjcmVtZW50IG1pbnV0ZXNcXFwiPjxhIG5nLWNsaWNrPVxcXCJkZWNyZW1lbnRNaW51dGVzKClcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vRGVjcmVtZW50TWludXRlcygpfVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgbmctZGlzYWJsZWQ9XFxcIm5vRGVjcmVtZW50TWludXRlcygpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tZG93blxcXCI+PC9zcGFuPjwvYT48L3RkPlxcblwiICtcclxuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dTZWNvbmRzXFxcIj4mbmJzcDs8L3RkPlxcblwiICtcclxuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dTZWNvbmRzXFxcIiBjbGFzcz1cXFwidWliLWRlY3JlbWVudCBzZWNvbmRzXFxcIj48YSBuZy1jbGljaz1cXFwiZGVjcmVtZW50U2Vjb25kcygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0RlY3JlbWVudFNlY29uZHMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiIG5nLWRpc2FibGVkPVxcXCJub0RlY3JlbWVudFNlY29uZHMoKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93TWVyaWRpYW5cXFwiPjwvdGQ+XFxuXCIgK1xyXG4gICAgXCIgICAgPC90cj5cXG5cIiArXHJcbiAgICBcIiAgPC90Ym9keT5cXG5cIiArXHJcbiAgICBcIjwvdGFibGU+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFwiLFxyXG4gICAgXCI8YSBocmVmXFxuXCIgK1xyXG4gICAgXCIgICB0YWJpbmRleD1cXFwiLTFcXFwiXFxuXCIgK1xyXG4gICAgXCIgICBuZy1iaW5kLWh0bWw9XFxcIm1hdGNoLmxhYmVsIHwgdWliVHlwZWFoZWFkSGlnaGxpZ2h0OnF1ZXJ5XFxcIlxcblwiICtcclxuICAgIFwiICAgbmctYXR0ci10aXRsZT1cXFwie3ttYXRjaC5sYWJlbH19XFxcIj48L2E+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiLFxyXG4gICAgXCI8dWwgY2xhc3M9XFxcImRyb3Bkb3duLW1lbnVcXFwiIG5nLXNob3c9XFxcImlzT3BlbigpICYmICFtb3ZlSW5Qcm9ncmVzc1xcXCIgbmctc3R5bGU9XFxcInt0b3A6IHBvc2l0aW9uKCkudG9wKydweCcsIGxlZnQ6IHBvc2l0aW9uKCkubGVmdCsncHgnfVxcXCIgcm9sZT1cXFwibGlzdGJveFxcXCIgYXJpYS1oaWRkZW49XFxcInt7IWlzT3BlbigpfX1cXFwiPlxcblwiICtcclxuICAgIFwiICAgIDxsaSBjbGFzcz1cXFwidWliLXR5cGVhaGVhZC1tYXRjaFxcXCIgbmctcmVwZWF0PVxcXCJtYXRjaCBpbiBtYXRjaGVzIHRyYWNrIGJ5ICRpbmRleFxcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6IGlzQWN0aXZlKCRpbmRleCkgfVxcXCIgbmctbW91c2VlbnRlcj1cXFwic2VsZWN0QWN0aXZlKCRpbmRleClcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3RNYXRjaCgkaW5kZXgsICRldmVudClcXFwiIHJvbGU9XFxcIm9wdGlvblxcXCIgaWQ9XFxcInt7OjptYXRjaC5pZH19XFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgICAgPGRpdiB1aWItdHlwZWFoZWFkLW1hdGNoIGluZGV4PVxcXCIkaW5kZXhcXFwiIG1hdGNoPVxcXCJtYXRjaFxcXCIgcXVlcnk9XFxcInF1ZXJ5XFxcIiB0ZW1wbGF0ZS11cmw9XFxcInRlbXBsYXRlVXJsXFxcIj48L2Rpdj5cXG5cIiArXHJcbiAgICBcIiAgICA8L2xpPlxcblwiICtcclxuICAgIFwiPC91bD5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmNhcm91c2VsJykucnVuKGZ1bmN0aW9uKCkgeyFhbmd1bGFyLiQkY3NwKCkubm9JbmxpbmVTdHlsZSAmJiAhYW5ndWxhci4kJHVpYkNhcm91c2VsQ3NzICYmIGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudCkuZmluZCgnaGVhZCcpLnByZXBlbmQoJzxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4ubmctYW5pbWF0ZS5pdGVtOm5vdCgubGVmdCk6bm90KC5yaWdodCl7LXdlYmtpdC10cmFuc2l0aW9uOjBzIGVhc2UtaW4tb3V0IGxlZnQ7dHJhbnNpdGlvbjowcyBlYXNlLWluLW91dCBsZWZ0fTwvc3R5bGU+Jyk7IGFuZ3VsYXIuJCR1aWJDYXJvdXNlbENzcyA9IHRydWU7IH0pO1xyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRhdGVwaWNrZXInKS5ydW4oZnVuY3Rpb24oKSB7IWFuZ3VsYXIuJCRjc3AoKS5ub0lubGluZVN0eWxlICYmICFhbmd1bGFyLiQkdWliRGF0ZXBpY2tlckNzcyAmJiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoJ2hlYWQnKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+LnVpYi1kYXRlcGlja2VyIC51aWItdGl0bGV7d2lkdGg6MTAwJTt9LnVpYi1kYXkgYnV0dG9uLC51aWItbW9udGggYnV0dG9uLC51aWIteWVhciBidXR0b257bWluLXdpZHRoOjEwMCU7fS51aWItbGVmdCwudWliLXJpZ2h0e3dpZHRoOjEwMCV9PC9zdHlsZT4nKTsgYW5ndWxhci4kJHVpYkRhdGVwaWNrZXJDc3MgPSB0cnVlOyB9KTtcclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbicpLnJ1bihmdW5jdGlvbigpIHshYW5ndWxhci4kJGNzcCgpLm5vSW5saW5lU3R5bGUgJiYgIWFuZ3VsYXIuJCR1aWJQb3NpdGlvbkNzcyAmJiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoJ2hlYWQnKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+LnVpYi1wb3NpdGlvbi1tZWFzdXJle2Rpc3BsYXk6YmxvY2sgIWltcG9ydGFudDt2aXNpYmlsaXR5OmhpZGRlbiAhaW1wb3J0YW50O3Bvc2l0aW9uOmFic29sdXRlICFpbXBvcnRhbnQ7dG9wOi05OTk5cHggIWltcG9ydGFudDtsZWZ0Oi05OTk5cHggIWltcG9ydGFudDt9LnVpYi1wb3NpdGlvbi1zY3JvbGxiYXItbWVhc3VyZXtwb3NpdGlvbjphYnNvbHV0ZSAhaW1wb3J0YW50O3RvcDotOTk5OXB4ICFpbXBvcnRhbnQ7d2lkdGg6NTBweCAhaW1wb3J0YW50O2hlaWdodDo1MHB4ICFpbXBvcnRhbnQ7b3ZlcmZsb3c6c2Nyb2xsICFpbXBvcnRhbnQ7fS51aWItcG9zaXRpb24tYm9keS1zY3JvbGxiYXItbWVhc3VyZXtvdmVyZmxvdzpzY3JvbGwgIWltcG9ydGFudDt9PC9zdHlsZT4nKTsgYW5ndWxhci4kJHVpYlBvc2l0aW9uQ3NzID0gdHJ1ZTsgfSk7XHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZGF0ZXBpY2tlclBvcHVwJykucnVuKGZ1bmN0aW9uKCkgeyFhbmd1bGFyLiQkY3NwKCkubm9JbmxpbmVTdHlsZSAmJiAhYW5ndWxhci4kJHVpYkRhdGVwaWNrZXJwb3B1cENzcyAmJiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoJ2hlYWQnKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+LnVpYi1kYXRlcGlja2VyLXBvcHVwLmRyb3Bkb3duLW1lbnV7ZGlzcGxheTpibG9jaztmbG9hdDpub25lO21hcmdpbjowO30udWliLWJ1dHRvbi1iYXJ7cGFkZGluZzoxMHB4IDlweCAycHg7fTwvc3R5bGU+Jyk7IGFuZ3VsYXIuJCR1aWJEYXRlcGlja2VycG9wdXBDc3MgPSB0cnVlOyB9KTtcclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50b29sdGlwJykucnVuKGZ1bmN0aW9uKCkgeyFhbmd1bGFyLiQkY3NwKCkubm9JbmxpbmVTdHlsZSAmJiAhYW5ndWxhci4kJHVpYlRvb2x0aXBDc3MgJiYgYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5maW5kKCdoZWFkJykucHJlcGVuZCgnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPlt1aWItdG9vbHRpcC1wb3B1cF0udG9vbHRpcC50b3AtbGVmdCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1wb3B1cF0udG9vbHRpcC50b3AtcmlnaHQgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtcG9wdXBdLnRvb2x0aXAuYm90dG9tLWxlZnQgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtcG9wdXBdLnRvb2x0aXAuYm90dG9tLXJpZ2h0ID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXBvcHVwXS50b29sdGlwLmxlZnQtdG9wID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXBvcHVwXS50b29sdGlwLmxlZnQtYm90dG9tID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXBvcHVwXS50b29sdGlwLnJpZ2h0LXRvcCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1wb3B1cF0udG9vbHRpcC5yaWdodC1ib3R0b20gPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtaHRtbC1wb3B1cF0udG9vbHRpcC50b3AtbGVmdCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1odG1sLXBvcHVwXS50b29sdGlwLnRvcC1yaWdodCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1odG1sLXBvcHVwXS50b29sdGlwLmJvdHRvbS1sZWZ0ID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLWh0bWwtcG9wdXBdLnRvb2x0aXAuYm90dG9tLXJpZ2h0ID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLWh0bWwtcG9wdXBdLnRvb2x0aXAubGVmdC10b3AgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtaHRtbC1wb3B1cF0udG9vbHRpcC5sZWZ0LWJvdHRvbSA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1odG1sLXBvcHVwXS50b29sdGlwLnJpZ2h0LXRvcCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1odG1sLXBvcHVwXS50b29sdGlwLnJpZ2h0LWJvdHRvbSA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cF0udG9vbHRpcC50b3AtbGVmdCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cF0udG9vbHRpcC50b3AtcmlnaHQgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtdGVtcGxhdGUtcG9wdXBdLnRvb2x0aXAuYm90dG9tLWxlZnQgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtdGVtcGxhdGUtcG9wdXBdLnRvb2x0aXAuYm90dG9tLXJpZ2h0ID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXRlbXBsYXRlLXBvcHVwXS50b29sdGlwLmxlZnQtdG9wID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXRlbXBsYXRlLXBvcHVwXS50b29sdGlwLmxlZnQtYm90dG9tID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXRlbXBsYXRlLXBvcHVwXS50b29sdGlwLnJpZ2h0LXRvcCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cF0udG9vbHRpcC5yaWdodC1ib3R0b20gPiAudG9vbHRpcC1hcnJvdyxbdWliLXBvcG92ZXItcG9wdXBdLnBvcG92ZXIudG9wLWxlZnQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXBvcHVwXS5wb3BvdmVyLnRvcC1yaWdodCA+IC5hcnJvdyxbdWliLXBvcG92ZXItcG9wdXBdLnBvcG92ZXIuYm90dG9tLWxlZnQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXBvcHVwXS5wb3BvdmVyLmJvdHRvbS1yaWdodCA+IC5hcnJvdyxbdWliLXBvcG92ZXItcG9wdXBdLnBvcG92ZXIubGVmdC10b3AgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXBvcHVwXS5wb3BvdmVyLmxlZnQtYm90dG9tID4gLmFycm93LFt1aWItcG9wb3Zlci1wb3B1cF0ucG9wb3Zlci5yaWdodC10b3AgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXBvcHVwXS5wb3BvdmVyLnJpZ2h0LWJvdHRvbSA+IC5hcnJvdyxbdWliLXBvcG92ZXItaHRtbC1wb3B1cF0ucG9wb3Zlci50b3AtbGVmdCA+IC5hcnJvdyxbdWliLXBvcG92ZXItaHRtbC1wb3B1cF0ucG9wb3Zlci50b3AtcmlnaHQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLWh0bWwtcG9wdXBdLnBvcG92ZXIuYm90dG9tLWxlZnQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLWh0bWwtcG9wdXBdLnBvcG92ZXIuYm90dG9tLXJpZ2h0ID4gLmFycm93LFt1aWItcG9wb3Zlci1odG1sLXBvcHVwXS5wb3BvdmVyLmxlZnQtdG9wID4gLmFycm93LFt1aWItcG9wb3Zlci1odG1sLXBvcHVwXS5wb3BvdmVyLmxlZnQtYm90dG9tID4gLmFycm93LFt1aWItcG9wb3Zlci1odG1sLXBvcHVwXS5wb3BvdmVyLnJpZ2h0LXRvcCA+IC5hcnJvdyxbdWliLXBvcG92ZXItaHRtbC1wb3B1cF0ucG9wb3Zlci5yaWdodC1ib3R0b20gPiAuYXJyb3csW3VpYi1wb3BvdmVyLXRlbXBsYXRlLXBvcHVwXS5wb3BvdmVyLnRvcC1sZWZ0ID4gLmFycm93LFt1aWItcG9wb3Zlci10ZW1wbGF0ZS1wb3B1cF0ucG9wb3Zlci50b3AtcmlnaHQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXRlbXBsYXRlLXBvcHVwXS5wb3BvdmVyLmJvdHRvbS1sZWZ0ID4gLmFycm93LFt1aWItcG9wb3Zlci10ZW1wbGF0ZS1wb3B1cF0ucG9wb3Zlci5ib3R0b20tcmlnaHQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXRlbXBsYXRlLXBvcHVwXS5wb3BvdmVyLmxlZnQtdG9wID4gLmFycm93LFt1aWItcG9wb3Zlci10ZW1wbGF0ZS1wb3B1cF0ucG9wb3Zlci5sZWZ0LWJvdHRvbSA+IC5hcnJvdyxbdWliLXBvcG92ZXItdGVtcGxhdGUtcG9wdXBdLnBvcG92ZXIucmlnaHQtdG9wID4gLmFycm93LFt1aWItcG9wb3Zlci10ZW1wbGF0ZS1wb3B1cF0ucG9wb3Zlci5yaWdodC1ib3R0b20gPiAuYXJyb3d7dG9wOmF1dG87Ym90dG9tOmF1dG87bGVmdDphdXRvO3JpZ2h0OmF1dG87bWFyZ2luOjA7fVt1aWItcG9wb3Zlci1wb3B1cF0ucG9wb3ZlcixbdWliLXBvcG92ZXItaHRtbC1wb3B1cF0ucG9wb3ZlcixbdWliLXBvcG92ZXItdGVtcGxhdGUtcG9wdXBdLnBvcG92ZXJ7ZGlzcGxheTpibG9jayAhaW1wb3J0YW50O308L3N0eWxlPicpOyBhbmd1bGFyLiQkdWliVG9vbHRpcENzcyA9IHRydWU7IH0pO1xyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRpbWVwaWNrZXInKS5ydW4oZnVuY3Rpb24oKSB7IWFuZ3VsYXIuJCRjc3AoKS5ub0lubGluZVN0eWxlICYmICFhbmd1bGFyLiQkdWliVGltZXBpY2tlckNzcyAmJiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoJ2hlYWQnKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+LnVpYi10aW1lIGlucHV0e3dpZHRoOjUwcHg7fTwvc3R5bGU+Jyk7IGFuZ3VsYXIuJCR1aWJUaW1lcGlja2VyQ3NzID0gdHJ1ZTsgfSk7XHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudHlwZWFoZWFkJykucnVuKGZ1bmN0aW9uKCkgeyFhbmd1bGFyLiQkY3NwKCkubm9JbmxpbmVTdHlsZSAmJiAhYW5ndWxhci4kJHVpYlR5cGVhaGVhZENzcyAmJiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoJ2hlYWQnKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+W3VpYi10eXBlYWhlYWQtcG9wdXBdLmRyb3Bkb3duLW1lbnV7ZGlzcGxheTpibG9jazt9PC9zdHlsZT4nKTsgYW5ndWxhci4kJHVpYlR5cGVhaGVhZENzcyA9IHRydWU7IH0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYW5ndWxhci11aS1ib290c3RyYXAvZGlzdC91aS1ib290c3RyYXAtdHBscy5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqICMgQW5ndWxhciAxIERpcmVjdGl2ZXNcclxuICpcclxuICogVGhlc2UgYXJlIHRoZSBkaXJlY3RpdmVzIGluY2x1ZGVkIGluIFVJLVJvdXRlciBmb3IgQW5ndWxhciAxLlxyXG4gKiBUaGVzZSBkaXJlY3RpdmVzIGFyZSB1c2VkIGluIHRlbXBsYXRlcyB0byBjcmVhdGUgdmlld3BvcnRzIGFuZCBsaW5rL25hdmlnYXRlIHRvIHN0YXRlcy5cclxuICpcclxuICogQG5nMWFwaVxyXG4gKiBAcHJlZmVycmVkXHJcbiAqIEBtb2R1bGUgZGlyZWN0aXZlc1xyXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXHJcbnZhciBhbmd1bGFyXzEgPSByZXF1aXJlKFwiLi4vYW5ndWxhclwiKTtcclxudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAdWlyb3V0ZXIvY29yZVwiKTtcclxuLyoqIEBoaWRkZW4gKi9cclxuZnVuY3Rpb24gcGFyc2VTdGF0ZVJlZihyZWYpIHtcclxuICAgIHZhciBwYXJhbXNPbmx5ID0gcmVmLm1hdGNoKC9eXFxzKih7W159XSp9KVxccyokLyksIHBhcnNlZDtcclxuICAgIGlmIChwYXJhbXNPbmx5KVxyXG4gICAgICAgIHJlZiA9ICcoJyArIHBhcmFtc09ubHlbMV0gKyAnKSc7XHJcbiAgICBwYXJzZWQgPSByZWYucmVwbGFjZSgvXFxuL2csIFwiIFwiKS5tYXRjaCgvXlxccyooW14oXSo/KVxccyooXFwoKC4qKVxcKSk/XFxzKiQvKTtcclxuICAgIGlmICghcGFyc2VkIHx8IHBhcnNlZC5sZW5ndGggIT09IDQpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZSByZWYgJ1wiICsgcmVmICsgXCInXCIpO1xyXG4gICAgcmV0dXJuIHsgc3RhdGU6IHBhcnNlZFsxXSB8fCBudWxsLCBwYXJhbUV4cHI6IHBhcnNlZFszXSB8fCBudWxsIH07XHJcbn1cclxuLyoqIEBoaWRkZW4gKi9cclxuZnVuY3Rpb24gc3RhdGVDb250ZXh0KGVsKSB7XHJcbiAgICB2YXIgJHVpVmlldyA9IGVsLnBhcmVudCgpLmluaGVyaXRlZERhdGEoJyR1aVZpZXcnKTtcclxuICAgIHZhciBwYXRoID0gY29yZV8xLnBhcnNlKCckY2ZnLnBhdGgnKSgkdWlWaWV3KTtcclxuICAgIHJldHVybiBwYXRoID8gY29yZV8xLnRhaWwocGF0aCkuc3RhdGUubmFtZSA6IHVuZGVmaW5lZDtcclxufVxyXG4vKiogQGhpZGRlbiAqL1xyXG5mdW5jdGlvbiBwcm9jZXNzZWREZWYoJHN0YXRlLCAkZWxlbWVudCwgZGVmKSB7XHJcbiAgICB2YXIgdWlTdGF0ZSA9IGRlZi51aVN0YXRlIHx8ICRzdGF0ZS5jdXJyZW50Lm5hbWU7XHJcbiAgICB2YXIgdWlTdGF0ZU9wdHMgPSBjb3JlXzEuZXh0ZW5kKGRlZmF1bHRPcHRzKCRlbGVtZW50LCAkc3RhdGUpLCBkZWYudWlTdGF0ZU9wdHMgfHwge30pO1xyXG4gICAgdmFyIGhyZWYgPSAkc3RhdGUuaHJlZih1aVN0YXRlLCBkZWYudWlTdGF0ZVBhcmFtcywgdWlTdGF0ZU9wdHMpO1xyXG4gICAgcmV0dXJuIHsgdWlTdGF0ZTogdWlTdGF0ZSwgdWlTdGF0ZVBhcmFtczogZGVmLnVpU3RhdGVQYXJhbXMsIHVpU3RhdGVPcHRzOiB1aVN0YXRlT3B0cywgaHJlZjogaHJlZiB9O1xyXG59XHJcbi8qKiBAaGlkZGVuICovXHJcbmZ1bmN0aW9uIGdldFR5cGVJbmZvKGVsKSB7XHJcbiAgICAvLyBTVkdBRWxlbWVudCBkb2VzIG5vdCB1c2UgdGhlIGhyZWYgYXR0cmlidXRlLCBidXQgcmF0aGVyIHRoZSAneGxpbmtIcmVmJyBhdHRyaWJ1dGUuXHJcbiAgICB2YXIgaXNTdmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWwucHJvcCgnaHJlZicpKSA9PT0gJ1tvYmplY3QgU1ZHQW5pbWF0ZWRTdHJpbmddJztcclxuICAgIHZhciBpc0Zvcm0gPSBlbFswXS5ub2RlTmFtZSA9PT0gXCJGT1JNXCI7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGF0dHI6IGlzRm9ybSA/IFwiYWN0aW9uXCIgOiAoaXNTdmcgPyAneGxpbms6aHJlZicgOiAnaHJlZicpLFxyXG4gICAgICAgIGlzQW5jaG9yOiBlbC5wcm9wKFwidGFnTmFtZVwiKS50b1VwcGVyQ2FzZSgpID09PSBcIkFcIixcclxuICAgICAgICBjbGlja2FibGU6ICFpc0Zvcm1cclxuICAgIH07XHJcbn1cclxuLyoqIEBoaWRkZW4gKi9cclxuZnVuY3Rpb24gY2xpY2tIb29rKGVsLCAkc3RhdGUsICR0aW1lb3V0LCB0eXBlLCBnZXREZWYpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciBidXR0b24gPSBlLndoaWNoIHx8IGUuYnV0dG9uLCB0YXJnZXQgPSBnZXREZWYoKTtcclxuICAgICAgICBpZiAoIShidXR0b24gPiAxIHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlbC5hdHRyKCd0YXJnZXQnKSkpIHtcclxuICAgICAgICAgICAgLy8gSEFDSzogVGhpcyBpcyB0byBhbGxvdyBuZy1jbGlja3MgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZSB0aGUgdHJhbnNpdGlvbiBpcyBpbml0aWF0ZWQ6XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgJHN0YXRlLmdvKHRhcmdldC51aVN0YXRlLCB0YXJnZXQudWlTdGF0ZVBhcmFtcywgdGFyZ2V0LnVpU3RhdGVPcHRzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXRlIGhhcyBubyBVUkwsIGlnbm9yZSBvbmUgcHJldmVudERlZmF1bHQgZnJvbSB0aGUgPGE+IGRpcmVjdGl2ZS5cclxuICAgICAgICAgICAgdmFyIGlnbm9yZVByZXZlbnREZWZhdWx0Q291bnQgPSB0eXBlLmlzQW5jaG9yICYmICF0YXJnZXQuaHJlZiA/IDEgOiAwO1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZVByZXZlbnREZWZhdWx0Q291bnQtLSA8PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0cmFuc2l0aW9uKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8qKiBAaGlkZGVuICovXHJcbmZ1bmN0aW9uIGRlZmF1bHRPcHRzKGVsLCAkc3RhdGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVsYXRpdmU6IHN0YXRlQ29udGV4dChlbCkgfHwgJHN0YXRlLiRjdXJyZW50LFxyXG4gICAgICAgIGluaGVyaXQ6IHRydWUsXHJcbiAgICAgICAgc291cmNlOiBcInNyZWZcIlxyXG4gICAgfTtcclxufVxyXG4vKiogQGhpZGRlbiAqL1xyXG5mdW5jdGlvbiBiaW5kRXZlbnRzKGVsZW1lbnQsIHNjb3BlLCBob29rRm4sIHVpU3RhdGVPcHRzKSB7XHJcbiAgICB2YXIgZXZlbnRzO1xyXG4gICAgaWYgKHVpU3RhdGVPcHRzKSB7XHJcbiAgICAgICAgZXZlbnRzID0gdWlTdGF0ZU9wdHMuZXZlbnRzO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjb3JlXzEuaXNBcnJheShldmVudHMpKSB7XHJcbiAgICAgICAgZXZlbnRzID0gWydjbGljayddO1xyXG4gICAgfVxyXG4gICAgdmFyIG9uID0gZWxlbWVudC5vbiA/ICdvbicgOiAnYmluZCc7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIGV2ZW50c18xID0gZXZlbnRzOyBfaSA8IGV2ZW50c18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBldmVudF8xID0gZXZlbnRzXzFbX2ldO1xyXG4gICAgICAgIGVsZW1lbnRbb25dKGV2ZW50XzEsIGhvb2tGbik7XHJcbiAgICB9XHJcbiAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvZmYgPSBlbGVtZW50Lm9mZiA/ICdvZmYnIDogJ3VuYmluZCc7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBldmVudHNfMiA9IGV2ZW50czsgX2kgPCBldmVudHNfMi5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50XzIgPSBldmVudHNfMltfaV07XHJcbiAgICAgICAgICAgIGVsZW1lbnRbb2ZmXShldmVudF8yLCBob29rRm4pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBgdWktc3JlZmA6IEEgZGlyZWN0aXZlIGZvciBsaW5raW5nIHRvIGEgc3RhdGVcclxuICpcclxuICogQSBkaXJlY3RpdmUgd2hpY2ggbGlua3MgdG8gYSBzdGF0ZSAoYW5kIG9wdGlvbmFsbHksIHBhcmFtZXRlcnMpLlxyXG4gKiBXaGVuIGNsaWNrZWQsIHRoaXMgZGlyZWN0aXZlIGFjdGl2YXRlcyB0aGUgbGlua2VkIHN0YXRlIHdpdGggdGhlIHN1cHBsaWVkIHBhcmFtZXRlciB2YWx1ZXMuXHJcbiAqXHJcbiAqICMjIyBMaW5rZWQgU3RhdGVcclxuICogVGhlIGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgYHVpLXNyZWZgIGlzIHRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0byBsaW5rIHRvLlxyXG4gKlxyXG4gKiAjIyMjIEV4YW1wbGU6XHJcbiAqIFRoaXMgd2lsbCBhY3RpdmF0ZSB0aGUgYGhvbWVgIHN0YXRlIHdoZW4gdGhlIGxpbmsgaXMgY2xpY2tlZC5cclxuICogYGBgaHRtbFxyXG4gKiA8YSB1aS1zcmVmPVwiaG9tZVwiPkhvbWU8L2E+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyMgUmVsYXRpdmUgTGlua3NcclxuICogWW91IGNhbiBhbHNvIHVzZSByZWxhdGl2ZSBzdGF0ZSBwYXRocyB3aXRoaW4gYHVpLXNyZWZgLCBqdXN0IGxpa2UgYSByZWxhdGl2ZSBwYXRoIHBhc3NlZCB0byBgJHN0YXRlLmdvKClgIChbW1N0YXRlU2VydmljZS5nb11dKS5cclxuICogWW91IGp1c3QgbmVlZCB0byBiZSBhd2FyZSB0aGF0IHRoZSBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBzdGF0ZSB0aGF0ICpjcmVhdGVkKiB0aGUgbGluay5cclxuICogVGhpcyBhbGxvd3MgYSBzdGF0ZSB0byBjcmVhdGUgYSByZWxhdGl2ZSBgdWktc3JlZmAgd2hpY2ggYWx3YXlzIHRhcmdldHMgdGhlIHNhbWUgZGVzdGluYXRpb24uXHJcbiAqXHJcbiAqICMjIyMgRXhhbXBsZTpcclxuICogQm90aCB0aGVzZSBsaW5rcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHBhcmVudCBzdGF0ZSwgZXZlbiB3aGVuIGEgY2hpbGQgc3RhdGUgaXMgY3VycmVudGx5IGFjdGl2ZS5cclxuICogYGBgaHRtbFxyXG4gKiA8YSB1aS1zcmVmPVwiLmNoaWxkMVwiPmNoaWxkIDEgc3RhdGU8L2E+XHJcbiAqIDxhIHVpLXNyZWY9XCIuY2hpbGQyXCI+Y2hpbGQgMiBzdGF0ZTwvYT5cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgbGluayBhY3RpdmF0ZXMgdGhlIHBhcmVudCBzdGF0ZS5cclxuICogYGBgaHRtbFxyXG4gKiA8YSB1aS1zcmVmPVwiXlwiPlJldHVybjwvYT5cclxuICogYGBgXHJcbiAqXHJcbiAqICMjIyBocmVmc1xyXG4gKiBJZiB0aGUgbGlua2VkIHN0YXRlIGhhcyBhIFVSTCwgdGhlIGRpcmVjdGl2ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYW5kXHJcbiAqIHVwZGF0ZSB0aGUgYGhyZWZgIGF0dHJpYnV0ZSAodXNpbmcgdGhlIFtbU3RhdGVTZXJ2aWNlLmhyZWZdXSAgbWV0aG9kKS5cclxuICpcclxuICogIyMjIyBFeGFtcGxlOlxyXG4gKiBBc3N1bWluZyB0aGUgYHVzZXJzYCBzdGF0ZSBoYXMgYSB1cmwgb2YgYC91c2Vycy9gXHJcbiAqIGBgYGh0bWxcclxuICogPGEgdWktc3JlZj1cInVzZXJzXCIgaHJlZj1cIi91c2Vycy9cIj5Vc2VyczwvYT5cclxuICogYGBgXHJcbiAqXHJcbiAqICMjIyBQYXJhbWV0ZXIgVmFsdWVzXHJcbiAqIEluIGFkZGl0aW9uIHRvIHRoZSBzdGF0ZSBuYW1lLCBhIGB1aS1zcmVmYCBjYW4gaW5jbHVkZSBwYXJhbWV0ZXIgdmFsdWVzIHdoaWNoIGFyZSBhcHBsaWVkIHdoZW4gYWN0aXZhdGluZyB0aGUgc3RhdGUuXHJcbiAqIFBhcmFtIHZhbHVlcyBjYW4gYmUgcHJvdmlkZWQgaW4gdGhlIGB1aS1zcmVmYCB2YWx1ZSBhZnRlciB0aGUgc3RhdGUgbmFtZSwgZW5jbG9zZWQgYnkgcGFyZW50aGVzZXMuXHJcbiAqIFRoZSBjb250ZW50IGluc2lkZSB0aGUgcGFyZW50aGVzZXMgaXMgYW4gZXhwcmVzc2lvbiwgZXZhbHVhdGVkIHRvIHRoZSBwYXJhbWV0ZXIgdmFsdWVzLlxyXG4gKlxyXG4gKiAjIyMjIEV4YW1wbGU6XHJcbiAqIFRoaXMgZXhhbXBsZSByZW5kZXJzIGEgbGlzdCBvZiBsaW5rcyB0byB1c2Vycy5cclxuICogVGhlIHN0YXRlJ3MgYHVzZXJJZGAgcGFyYW1ldGVyIHZhbHVlIGNvbWVzIGZyb20gZWFjaCB1c2VyJ3MgYHVzZXIuaWRgIHByb3BlcnR5LlxyXG4gKiBgYGBodG1sXHJcbiAqIDxsaSBuZy1yZXBlYXQ9XCJ1c2VyIGluIHVzZXJzXCI+XHJcbiAqICAgPGEgdWktc3JlZj1cInVzZXJzLmRldGFpbCh7IHVzZXJJZDogdXNlci5pZCB9KVwiPnt7IHVzZXIuZGlzcGxheU5hbWUgfX08L2E+XHJcbiAqIDwvbGk+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlOlxyXG4gKiBUaGUgcGFyYW1ldGVyIHZhbHVlcyBleHByZXNzaW9uIGlzIGAkd2F0Y2hgZWQgZm9yIHVwZGF0ZXMuXHJcbiAqXHJcbiAqICMjIyBUcmFuc2l0aW9uIE9wdGlvbnNcclxuICogWW91IGNhbiBzcGVjaWZ5IFtbVHJhbnNpdGlvbk9wdGlvbnNdXSB0byBwYXNzIHRvIFtbU3RhdGVTZXJ2aWNlLmdvXV0gYnkgdXNpbmcgdGhlIGB1aS1zcmVmLW9wdHNgIGF0dHJpYnV0ZS5cclxuICogT3B0aW9ucyBhcmUgcmVzdHJpY3RlZCB0byBgbG9jYXRpb25gLCBgaW5oZXJpdGAsIGFuZCBgcmVsb2FkYC5cclxuICpcclxuICogIyMjIyBFeGFtcGxlOlxyXG4gKiBgYGBodG1sXHJcbiAqIDxhIHVpLXNyZWY9XCJob21lXCIgdWktc3JlZi1vcHRzPVwieyByZWxvYWQ6IHRydWUgfVwiPkhvbWU8L2E+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyMgT3RoZXIgRE9NIEV2ZW50c1xyXG4gKlxyXG4gKiBZb3UgY2FuIGFsc28gY3VzdG9taXplIHdoaWNoIERPTSBldmVudHMgdG8gcmVzcG9uZCB0byAoaW5zdGVhZCBvZiBgY2xpY2tgKSBieVxyXG4gKiBwcm92aWRpbmcgYW4gYGV2ZW50c2AgYXJyYXkgaW4gdGhlIGB1aS1zcmVmLW9wdHNgIGF0dHJpYnV0ZS5cclxuICpcclxuICogIyMjIyBFeGFtcGxlOlxyXG4gKiBgYGBodG1sXHJcbiAqIDxpbnB1dCB0eXBlPVwidGV4dFwiIHVpLXNyZWY9XCJjb250YWN0c1wiIHVpLXNyZWYtb3B0cz1cInsgZXZlbnRzOiBbJ2NoYW5nZScsICdibHVyJ10gfVwiPlxyXG4gKiBgYGBcclxuICpcclxuICogIyMjIEhpZ2hsaWdodGluZyB0aGUgYWN0aXZlIGxpbmtcclxuICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBbW3VpU3JlZkFjdGl2ZV1dIHRvIGhpZ2hsaWdodCB0aGUgYWN0aXZlIGxpbmsuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlc1xyXG4gKiBJZiB5b3UgaGF2ZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlOlxyXG4gKlxyXG4gKiBgYGBodG1sXHJcbiAqIDxhIHVpLXNyZWY9XCJob21lXCI+SG9tZTwvYT5cclxuICogPGEgdWktc3JlZj1cImFib3V0XCI+QWJvdXQ8L2E+XHJcbiAqIDxhIHVpLXNyZWY9XCJ7cGFnZTogMn1cIj5OZXh0IHBhZ2U8L2E+XHJcbiAqXHJcbiAqIDx1bD5cclxuICogICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XHJcbiAqICAgICAgICAgPGEgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+e3sgY29udGFjdC5uYW1lIH19PC9hPlxyXG4gKiAgICAgPC9saT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZW4gKGFzc3VtaW5nIHRoZSBjdXJyZW50IHN0YXRlIGlzIGBjb250YWN0c2ApIHRoZSByZW5kZXJlZCBodG1sIGluY2x1ZGluZyBocmVmcyB3b3VsZCBiZTpcclxuICpcclxuICogYGBgaHRtbFxyXG4gKiA8YSBocmVmPVwiIy9ob21lXCIgdWktc3JlZj1cImhvbWVcIj5Ib21lPC9hPlxyXG4gKiA8YSBocmVmPVwiIy9hYm91dFwiIHVpLXNyZWY9XCJhYm91dFwiPkFib3V0PC9hPlxyXG4gKiA8YSBocmVmPVwiIy9jb250YWN0cz9wYWdlPTJcIiB1aS1zcmVmPVwie3BhZ2U6IDJ9XCI+TmV4dCBwYWdlPC9hPlxyXG4gKlxyXG4gKiA8dWw+XHJcbiAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxyXG4gKiAgICAgICAgIDxhIGhyZWY9XCIjL2NvbnRhY3RzLzFcIiB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj5Kb2U8L2E+XHJcbiAqICAgICA8L2xpPlxyXG4gKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cclxuICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8yXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+QWxpY2U8L2E+XHJcbiAqICAgICA8L2xpPlxyXG4gKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cclxuICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8zXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+Qm9iPC9hPlxyXG4gKiAgICAgPC9saT5cclxuICogPC91bD5cclxuICpcclxuICogPGEgaHJlZj1cIiMvaG9tZVwiIHVpLXNyZWY9XCJob21lXCIgdWktc3JlZi1vcHRzPVwie3JlbG9hZDogdHJ1ZX1cIj5Ib21lPC9hPlxyXG4gKiBgYGBcclxuICpcclxuICogIyMjIE5vdGVzXHJcbiAqXHJcbiAqIC0gWW91IGNhbiB1c2UgYHVpLXNyZWZgIHRvIGNoYW5nZSAqKm9ubHkgdGhlIHBhcmFtZXRlciB2YWx1ZXMqKiBieSBvbWl0dGluZyB0aGUgc3RhdGUgbmFtZSBhbmQgcGFyZW50aGVzZXMuXHJcbiAqICMjIyMgRXhhbXBsZTpcclxuICogU2V0cyB0aGUgYGxhbmdgIHBhcmFtZXRlciB0byBgZW5gIGFuZCByZW1haW5zIG9uIHRoZSBzYW1lIHN0YXRlLlxyXG4gKlxyXG4gKiBgYGBodG1sXHJcbiAqIDxhIHVpLXNyZWY9XCJ7IGxhbmc6ICdlbicgfVwiPkVuZ2xpc2g8L2E+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAtIEEgbWlkZGxlLWNsaWNrLCByaWdodC1jbGljaywgb3IgY3RybC1jbGljayBpcyBoYW5kbGVkIChuYXRpdmVseSkgYnkgdGhlIGJyb3dzZXIgdG8gb3BlbiB0aGUgaHJlZiBpbiBhIG5ldyB3aW5kb3csIGZvciBleGFtcGxlLlxyXG4gKlxyXG4gKiAtIFVubGlrZSB0aGUgcGFyYW1ldGVyIHZhbHVlcyBleHByZXNzaW9uLCB0aGUgc3RhdGUgbmFtZSBpcyBub3QgYCR3YXRjaGBlZCAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpLlxyXG4gKiBJZiB5b3UgbmVlZCB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhlIHN0YXRlIGJlaW5nIGxpbmtlZCB0bywgdXNlIHRoZSBmdWxseSBkeW5hbWljIFtbdWlTdGF0ZV1dIGRpcmVjdGl2ZS5cclxuICovXHJcbnZhciB1aVNyZWY7XHJcbnVpU3JlZiA9IFsnJHVpUm91dGVyJywgJyR0aW1lb3V0JyxcclxuICAgIGZ1bmN0aW9uICRTdGF0ZVJlZkRpcmVjdGl2ZSgkdWlSb3V0ZXIsICR0aW1lb3V0KSB7XHJcbiAgICAgICAgdmFyICRzdGF0ZSA9ICR1aVJvdXRlci5zdGF0ZVNlcnZpY2U7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgICAgICAgICAgcmVxdWlyZTogWyc/XnVpU3JlZkFjdGl2ZScsICc/XnVpU3JlZkFjdGl2ZUVxJ10sXHJcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIHVpU3JlZkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlSW5mbyhlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHZhciBhY3RpdmUgPSB1aVNyZWZBY3RpdmVbMV0gfHwgdWlTcmVmQWN0aXZlWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHVubGlua0luZm9GbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgaG9va0ZuO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhd0RlZiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGdldERlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb2Nlc3NlZERlZigkc3RhdGUsIGVsZW1lbnQsIHJhd0RlZik7IH07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVmID0gcGFyc2VTdGF0ZVJlZihhdHRycy51aVNyZWYpO1xyXG4gICAgICAgICAgICAgICAgcmF3RGVmLnVpU3RhdGUgPSByZWYuc3RhdGU7XHJcbiAgICAgICAgICAgICAgICByYXdEZWYudWlTdGF0ZU9wdHMgPSBhdHRycy51aVNyZWZPcHRzID8gc2NvcGUuJGV2YWwoYXR0cnMudWlTcmVmT3B0cykgOiB7fTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gZ2V0RGVmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVubGlua0luZm9GbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5saW5rSW5mb0ZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5saW5rSW5mb0ZuID0gYWN0aXZlLiQkYWRkU3RhdGVJbmZvKGRlZi51aVN0YXRlLCBkZWYudWlTdGF0ZVBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5ocmVmICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLiRzZXQodHlwZS5hdHRyLCBkZWYuaHJlZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVmLnBhcmFtRXhwcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChyZWYucGFyYW1FeHByLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0RlZi51aVN0YXRlUGFyYW1zID0gY29yZV8xLmV4dGVuZCh7fSwgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3RGVmLnVpU3RhdGVQYXJhbXMgPSBjb3JlXzEuZXh0ZW5kKHt9LCBzY29wZS4kZXZhbChyZWYucGFyYW1FeHByKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCAkdWlSb3V0ZXIuc3RhdGVSZWdpc3RyeS5vblN0YXRlc0NoYW5nZWQodXBkYXRlKSk7XHJcbiAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuY2xpY2thYmxlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGhvb2tGbiA9IGNsaWNrSG9vayhlbGVtZW50LCAkc3RhdGUsICR0aW1lb3V0LCB0eXBlLCBnZXREZWYpO1xyXG4gICAgICAgICAgICAgICAgYmluZEV2ZW50cyhlbGVtZW50LCBzY29wZSwgaG9va0ZuLCByYXdEZWYudWlTdGF0ZU9wdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1dO1xyXG4vKipcclxuICogYHVpLXN0YXRlYDogQSBmdWxseSBkeW5hbWljIGRpcmVjdGl2ZSBmb3IgbGlua2luZyB0byBhIHN0YXRlXHJcbiAqXHJcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGxpbmtzIHRvIGEgc3RhdGUgKGFuZCBvcHRpb25hbGx5LCBwYXJhbWV0ZXJzKS5cclxuICogV2hlbiBjbGlja2VkLCB0aGlzIGRpcmVjdGl2ZSBhY3RpdmF0ZXMgdGhlIGxpbmtlZCBzdGF0ZSB3aXRoIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXIgdmFsdWVzLlxyXG4gKlxyXG4gKiAqKlRoaXMgZGlyZWN0aXZlIGlzIHZlcnkgc2ltaWxhciB0byBbW3VpU3JlZl1dLCBidXQgaXQgYCRvYnNlcnZlYHMgYW5kIGAkd2F0Y2hgZXMvZXZhbHVhdGVzIGFsbCBpdHMgaW5wdXRzLioqXHJcbiAqXHJcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGxpbmtzIHRvIGEgc3RhdGUgKGFuZCBvcHRpb25hbGx5LCBwYXJhbWV0ZXJzKS5cclxuICogV2hlbiBjbGlja2VkLCB0aGlzIGRpcmVjdGl2ZSBhY3RpdmF0ZXMgdGhlIGxpbmtlZCBzdGF0ZSB3aXRoIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXIgdmFsdWVzLlxyXG4gKlxyXG4gKiAjIyMgTGlua2VkIFN0YXRlXHJcbiAqIFRoZSBhdHRyaWJ1dGUgdmFsdWUgb2YgYHVpLXN0YXRlYCBpcyBhbiBleHByZXNzaW9uIHdoaWNoIGlzIGAkd2F0Y2hgZWQgYW5kIGV2YWx1YXRlZCBhcyB0aGUgc3RhdGUgdG8gbGluayB0by5cclxuICogKipUaGlzIGlzIGluIGNvbnRyYXN0IHdpdGggYHVpLXNyZWZgLCB3aGljaCB0YWtlcyBhIHN0YXRlIG5hbWUgYXMgYSBzdHJpbmcgbGl0ZXJhbC4qKlxyXG4gKlxyXG4gKiAjIyMjIEV4YW1wbGU6XHJcbiAqIENyZWF0ZSBhIGxpc3Qgb2YgbGlua3MuXHJcbiAqIGBgYGh0bWxcclxuICogPGxpIG5nLXJlcGVhdD1cImxpbmsgaW4gbmF2bGlua3NcIj5cclxuICogICA8YSB1aS1zdGF0ZT1cImxpbmsuc3RhdGVcIj57eyBsaW5rLmRpc3BsYXlOYW1lIH19PC9hPlxyXG4gKiA8L2xpPlxyXG4gKiBgYGBcclxuICpcclxuICogIyMjIFJlbGF0aXZlIExpbmtzXHJcbiAqIElmIHRoZSBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBhIHJlbGF0aXZlIHBhdGgsIGl0IGlzIHByb2Nlc3NlZCBsaWtlIFtbdWlTcmVmXV0uXHJcbiAqIFlvdSBqdXN0IG5lZWQgdG8gYmUgYXdhcmUgdGhhdCB0aGUgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgc3RhdGUgdGhhdCAqY3JlYXRlZCogdGhlIGxpbmsuXHJcbiAqIFRoaXMgYWxsb3dzIGEgc3RhdGUgdG8gY3JlYXRlIHJlbGF0aXZlIGB1aS1zdGF0ZWAgd2hpY2ggYWx3YXlzIHRhcmdldHMgdGhlIHNhbWUgZGVzdGluYXRpb24uXHJcbiAqXHJcbiAqICMjIyBocmVmc1xyXG4gKiBJZiB0aGUgbGlua2VkIHN0YXRlIGhhcyBhIFVSTCwgdGhlIGRpcmVjdGl2ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYW5kXHJcbiAqIHVwZGF0ZSB0aGUgYGhyZWZgIGF0dHJpYnV0ZSAodXNpbmcgdGhlIFtbU3RhdGVTZXJ2aWNlLmhyZWZdXSAgbWV0aG9kKS5cclxuICpcclxuICogIyMjIFBhcmFtZXRlciBWYWx1ZXNcclxuICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YXRlIG5hbWUgZXhwcmVzc2lvbiwgYSBgdWktc3RhdGVgIGNhbiBpbmNsdWRlIHBhcmFtZXRlciB2YWx1ZXMgd2hpY2ggYXJlIGFwcGxpZWQgd2hlbiBhY3RpdmF0aW5nIHRoZSBzdGF0ZS5cclxuICogUGFyYW0gdmFsdWVzIHNob3VsZCBiZSBwcm92aWRlZCB1c2luZyB0aGUgYHVpLXN0YXRlLXBhcmFtc2AgYXR0cmlidXRlLlxyXG4gKiBUaGUgYHVpLXN0YXRlLXBhcmFtc2AgYXR0cmlidXRlIHZhbHVlIGlzIGAkd2F0Y2hgZWQgYW5kIGV2YWx1YXRlZCBhcyBhbiBleHByZXNzaW9uLlxyXG4gKlxyXG4gKiAjIyMjIEV4YW1wbGU6XHJcbiAqIFRoaXMgZXhhbXBsZSByZW5kZXJzIGEgbGlzdCBvZiBsaW5rcyB3aXRoIHBhcmFtIHZhbHVlcy5cclxuICogVGhlIHN0YXRlJ3MgYHVzZXJJZGAgcGFyYW1ldGVyIHZhbHVlIGNvbWVzIGZyb20gZWFjaCB1c2VyJ3MgYHVzZXIuaWRgIHByb3BlcnR5LlxyXG4gKiBgYGBodG1sXHJcbiAqIDxsaSBuZy1yZXBlYXQ9XCJsaW5rIGluIG5hdmxpbmtzXCI+XHJcbiAqICAgPGEgdWktc3RhdGU9XCJsaW5rLnN0YXRlXCIgdWktc3RhdGUtcGFyYW1zPVwibGluay5wYXJhbXNcIj57eyBsaW5rLmRpc3BsYXlOYW1lIH19PC9hPlxyXG4gKiA8L2xpPlxyXG4gKiBgYGBcclxuICpcclxuICogIyMjIFRyYW5zaXRpb24gT3B0aW9uc1xyXG4gKiBZb3UgY2FuIHNwZWNpZnkgW1tUcmFuc2l0aW9uT3B0aW9uc11dIHRvIHBhc3MgdG8gW1tTdGF0ZVNlcnZpY2UuZ29dXSBieSB1c2luZyB0aGUgYHVpLXN0YXRlLW9wdHNgIGF0dHJpYnV0ZS5cclxuICogT3B0aW9ucyBhcmUgcmVzdHJpY3RlZCB0byBgbG9jYXRpb25gLCBgaW5oZXJpdGAsIGFuZCBgcmVsb2FkYC5cclxuICogVGhlIHZhbHVlIG9mIHRoZSBgdWktc3RhdGUtb3B0c2AgaXMgYCR3YXRjaGBlZCBhbmQgZXZhbHVhdGVkIGFzIGFuIGV4cHJlc3Npb24uXHJcbiAqXHJcbiAqICMjIyMgRXhhbXBsZTpcclxuICogYGBgaHRtbFxyXG4gKiA8YSB1aS1zdGF0ZT1cInJldHVybnRvLnN0YXRlXCIgdWktc3RhdGUtb3B0cz1cInsgcmVsb2FkOiB0cnVlIH1cIj5Ib21lPC9hPlxyXG4gKiBgYGBcclxuICpcclxuICogIyMjIE90aGVyIERPTSBFdmVudHNcclxuICpcclxuICogWW91IGNhbiBhbHNvIGN1c3RvbWl6ZSB3aGljaCBET00gZXZlbnRzIHRvIHJlc3BvbmQgdG8gKGluc3RlYWQgb2YgYGNsaWNrYCkgYnlcclxuICogcHJvdmlkaW5nIGFuIGBldmVudHNgIGFycmF5IGluIHRoZSBgdWktc3RhdGUtb3B0c2AgYXR0cmlidXRlLlxyXG4gKlxyXG4gKiAjIyMjIEV4YW1wbGU6XHJcbiAqIGBgYGh0bWxcclxuICogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgdWktc3RhdGU9XCJjb250YWN0c1wiIHVpLXN0YXRlLW9wdHM9XCJ7IGV2ZW50czogWydjaGFuZ2UnLCAnYmx1ciddIH1cIj5cclxuICogYGBgXHJcbiAqXHJcbiAqICMjIyBIaWdobGlnaHRpbmcgdGhlIGFjdGl2ZSBsaW5rXHJcbiAqIFRoaXMgZGlyZWN0aXZlIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggW1t1aVNyZWZBY3RpdmVdXSB0byBoaWdobGlnaHQgdGhlIGFjdGl2ZSBsaW5rLlxyXG4gKlxyXG4gKiAjIyMgTm90ZXNcclxuICpcclxuICogLSBZb3UgY2FuIHVzZSBgdWktcGFyYW1zYCB0byBjaGFuZ2UgKipvbmx5IHRoZSBwYXJhbWV0ZXIgdmFsdWVzKiogYnkgb21pdHRpbmcgdGhlIHN0YXRlIG5hbWUgYW5kIHN1cHBseWluZyBvbmx5IGB1aS1zdGF0ZS1wYXJhbXNgLlxyXG4gKiAgIEhvd2V2ZXIsIGl0IG1pZ2h0IGJlIHNpbXBsZXIgdG8gdXNlIFtbdWlTcmVmXV0gcGFyYW1ldGVyLW9ubHkgbGlua3MuXHJcbiAqXHJcbiAqICMjIyMgRXhhbXBsZTpcclxuICogU2V0cyB0aGUgYGxhbmdgIHBhcmFtZXRlciB0byBgZW5gIGFuZCByZW1haW5zIG9uIHRoZSBzYW1lIHN0YXRlLlxyXG4gKlxyXG4gKiBgYGBodG1sXHJcbiAqIDxhIHVpLXN0YXRlPVwiXCIgdWktc3RhdGUtcGFyYW1zPVwieyBsYW5nOiAnZW4nIH1cIj5FbmdsaXNoPC9hPlxyXG4gKiBgYGBcclxuICpcclxuICogLSBBIG1pZGRsZS1jbGljaywgcmlnaHQtY2xpY2ssIG9yIGN0cmwtY2xpY2sgaXMgaGFuZGxlZCAobmF0aXZlbHkpIGJ5IHRoZSBicm93c2VyIHRvIG9wZW4gdGhlIGhyZWYgaW4gYSBuZXcgd2luZG93LCBmb3IgZXhhbXBsZS5cclxuICogYGBgXHJcbiAqL1xyXG52YXIgdWlTdGF0ZTtcclxudWlTdGF0ZSA9IFsnJHVpUm91dGVyJywgJyR0aW1lb3V0JyxcclxuICAgIGZ1bmN0aW9uICRTdGF0ZVJlZkR5bmFtaWNEaXJlY3RpdmUoJHVpUm91dGVyLCAkdGltZW91dCkge1xyXG4gICAgICAgIHZhciAkc3RhdGUgPSAkdWlSb3V0ZXIuc3RhdGVTZXJ2aWNlO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICAgICAgICAgIHJlcXVpcmU6IFsnP151aVNyZWZBY3RpdmUnLCAnP151aVNyZWZBY3RpdmVFcSddLFxyXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCB1aVNyZWZBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZUluZm8oZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlID0gdWlTcmVmQWN0aXZlWzFdIHx8IHVpU3JlZkFjdGl2ZVswXTtcclxuICAgICAgICAgICAgICAgIHZhciB1bmxpbmtJbmZvRm4gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhvb2tGbjtcclxuICAgICAgICAgICAgICAgIHZhciByYXdEZWYgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBnZXREZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9jZXNzZWREZWYoJHN0YXRlLCBlbGVtZW50LCByYXdEZWYpOyB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0QXR0cnMgPSBbJ3VpU3RhdGUnLCAndWlTdGF0ZVBhcmFtcycsICd1aVN0YXRlT3B0cyddO1xyXG4gICAgICAgICAgICAgICAgdmFyIHdhdGNoRGVyZWdGbnMgPSBpbnB1dEF0dHJzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyKSB7IHJldHVybiAoYWNjW2F0dHJdID0gY29yZV8xLm5vb3AsIGFjYyk7IH0sIHt9KTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gZ2V0RGVmKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVubGlua0luZm9GbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5saW5rSW5mb0ZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5saW5rSW5mb0ZuID0gYWN0aXZlLiQkYWRkU3RhdGVJbmZvKGRlZi51aVN0YXRlLCBkZWYudWlTdGF0ZVBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5ocmVmICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLiRzZXQodHlwZS5hdHRyLCBkZWYuaHJlZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnB1dEF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3RGVmW2ZpZWxkXSA9IGF0dHJzW2ZpZWxkXSA/IHNjb3BlLiRldmFsKGF0dHJzW2ZpZWxkXSkgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKGZpZWxkLCBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXRjaERlcmVnRm5zW2ZpZWxkXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXRjaERlcmVnRm5zW2ZpZWxkXSA9IHNjb3BlLiR3YXRjaChleHByLCBmdW5jdGlvbiAobmV3dmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdEZWZbZmllbGRdID0gbmV3dmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCAkdWlSb3V0ZXIuc3RhdGVSZWdpc3RyeS5vblN0YXRlc0NoYW5nZWQodXBkYXRlKSk7XHJcbiAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuY2xpY2thYmxlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGhvb2tGbiA9IGNsaWNrSG9vayhlbGVtZW50LCAkc3RhdGUsICR0aW1lb3V0LCB0eXBlLCBnZXREZWYpO1xyXG4gICAgICAgICAgICAgICAgYmluZEV2ZW50cyhlbGVtZW50LCBzY29wZSwgaG9va0ZuLCByYXdEZWYudWlTdGF0ZU9wdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1dO1xyXG4vKipcclxuICogYHVpLXNyZWYtYWN0aXZlYCBhbmQgYHVpLXNyZWYtYWN0aXZlLWVxYDogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIGEgQ1NTIGNsYXNzIHdoZW4gYSBgdWktc3JlZmAgaXMgYWN0aXZlXHJcbiAqXHJcbiAqIEEgZGlyZWN0aXZlIHdvcmtpbmcgYWxvbmdzaWRlIFtbdWlTcmVmXV0gYW5kIFtbdWlTdGF0ZV1dIHRvIGFkZCBjbGFzc2VzIHRvIGFuIGVsZW1lbnQgd2hlbiB0aGVcclxuICogcmVsYXRlZCBkaXJlY3RpdmUncyBzdGF0ZSBpcyBhY3RpdmUgKGFuZCByZW1vdmUgdGhlbSB3aGVuIGl0IGlzIGluYWN0aXZlKS5cclxuICpcclxuICogVGhlIHByaW1hcnkgdXNlLWNhc2UgaXMgdG8gaGlnaGxpZ2h0IHRoZSBhY3RpdmUgbGluayBpbiBuYXZpZ2F0aW9uIG1lbnVzLFxyXG4gKiBkaXN0aW5ndWlzaGluZyBpdCBmcm9tIHRoZSBpbmFjdGl2ZSBtZW51IGl0ZW1zLlxyXG4gKlxyXG4gKiAjIyMgTGlua2luZyB0byBhIGB1aS1zcmVmYCBvciBgdWktc3RhdGVgXHJcbiAqIGB1aS1zcmVmLWFjdGl2ZWAgY2FuIGxpdmUgb24gdGhlIHNhbWUgZWxlbWVudCBhcyBgdWktc3JlZmAvYHVpLXN0YXRlYCwgb3IgaXQgY2FuIGJlIG9uIGEgcGFyZW50IGVsZW1lbnQuXHJcbiAqIElmIGEgYHVpLXNyZWYtYWN0aXZlYCBpcyBhIHBhcmVudCB0byBtb3JlIHRoYW4gb25lIGB1aS1zcmVmYC9gdWktc3RhdGVgLCBpdCB3aWxsIGFwcGx5IHRoZSBDU1MgY2xhc3Mgd2hlbiAqKmFueSBvZiB0aGUgbGlua3MgYXJlIGFjdGl2ZSoqLlxyXG4gKlxyXG4gKiAjIyMgTWF0Y2hpbmdcclxuICpcclxuICogVGhlIGB1aS1zcmVmLWFjdGl2ZWAgZGlyZWN0aXZlIGFwcGxpZXMgdGhlIENTUyBjbGFzcyB3aGVuIHRoZSBgdWktc3JlZmAvYHVpLXN0YXRlYCdzIHRhcmdldCBzdGF0ZSAqKm9yIGFueSBjaGlsZCBzdGF0ZSBpcyBhY3RpdmUqKi5cclxuICogVGhpcyBpcyBhIFwiZnV6enkgbWF0Y2hcIiB3aGljaCB1c2VzIFtbU3RhdGVTZXJ2aWNlLmluY2x1ZGVzXV0uXHJcbiAqXHJcbiAqIFRoZSBgdWktc3JlZi1hY3RpdmUtZXFgIGRpcmVjdGl2ZSBhcHBsaWVzIHRoZSBDU1MgY2xhc3Mgd2hlbiB0aGUgYHVpLXNyZWZgL2B1aS1zdGF0ZWAncyB0YXJnZXQgc3RhdGUgaXMgZGlyZWN0bHkgYWN0aXZlIChub3Qgd2hlbiBjaGlsZCBzdGF0ZXMgYXJlIGFjdGl2ZSkuXHJcbiAqIFRoaXMgaXMgYW4gXCJleGFjdCBtYXRjaFwiIHdoaWNoIHVzZXMgW1tTdGF0ZVNlcnZpY2UuaXNdXS5cclxuICpcclxuICogIyMjIFBhcmFtZXRlciB2YWx1ZXNcclxuICogSWYgdGhlIGB1aS1zcmVmYC9gdWktc3RhdGVgIGluY2x1ZGVzIHBhcmFtZXRlciB2YWx1ZXMsIHRoZSBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMgbXVzdCBtYXRjaCB0aGUgbGluaydzIHZhbHVlcyBmb3IgdGhlIGxpbmsgdG8gYmUgaGlnaGxpZ2h0ZWQuXHJcbiAqIFRoaXMgYWxsb3dzIGEgbGlzdCBvZiBsaW5rcyB0byB0aGUgc2FtZSBzdGF0ZSB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXJzIHRvIGJlIHJlbmRlcmVkLCBhbmQgdGhlIGNvcnJlY3Qgb25lIGhpZ2hsaWdodGVkLlxyXG4gKlxyXG4gKiAjIyMjIEV4YW1wbGU6XHJcbiAqIGBgYGh0bWxcclxuICogPGxpIG5nLXJlcGVhdD1cInVzZXIgaW4gdXNlcnNcIiB1aS1zcmVmLWFjdGl2ZT1cImFjdGl2ZVwiPlxyXG4gKiAgIDxhIHVpLXNyZWY9XCJ1c2VyLmRldGFpbHMoeyB1c2VySWQ6IHVzZXIuaWQgfSlcIj57eyB1c2VyLmxhc3ROYW1lIH19PC9hPlxyXG4gKiA8L2xpPlxyXG4gKiBgYGBcclxuICpcclxuICogIyMjIEV4YW1wbGVzXHJcbiAqXHJcbiAqIEdpdmVuIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGU6XHJcbiAqICMjIyMgRXhhbXBsZTpcclxuICogYGBgaHRtbFxyXG4gKiA8dWw+XHJcbiAqICAgPGxpIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCIgY2xhc3M9XCJpdGVtXCI+XHJcbiAqICAgICA8YSBocmVmIHVpLXNyZWY9XCJhcHAudXNlcih7dXNlcjogJ2JpbGJvYmFnZ2lucyd9KVwiPkBiaWxib2JhZ2dpbnM8L2E+XHJcbiAqICAgPC9saT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqIFdoZW4gdGhlIGFwcCBzdGF0ZSBpcyBgYXBwLnVzZXJgIChvciBhbnkgY2hpbGQgc3RhdGUpLFxyXG4gKiBhbmQgY29udGFpbnMgdGhlIHN0YXRlIHBhcmFtZXRlciBcInVzZXJcIiB3aXRoIHZhbHVlIFwiYmlsYm9iYWdnaW5zXCIsXHJcbiAqIHRoZSByZXN1bHRpbmcgSFRNTCB3aWxsIGFwcGVhciBhcyAobm90ZSB0aGUgJ2FjdGl2ZScgY2xhc3MpOlxyXG4gKlxyXG4gKiBgYGBodG1sXHJcbiAqIDx1bD5cclxuICogICA8bGkgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiBjbGFzcz1cIml0ZW0gYWN0aXZlXCI+XHJcbiAqICAgICA8YSB1aS1zcmVmPVwiYXBwLnVzZXIoe3VzZXI6ICdiaWxib2JhZ2dpbnMnfSlcIiBocmVmPVwiL3VzZXJzL2JpbGJvYmFnZ2luc1wiPkBiaWxib2JhZ2dpbnM8L2E+XHJcbiAqICAgPC9saT5cclxuICogPC91bD5cclxuICogYGBgXHJcbiAqXHJcbiAqICMjIyBHbG9iIG1vZGVcclxuICpcclxuICogSXQgaXMgcG9zc2libGUgdG8gcGFzcyBgdWktc3JlZi1hY3RpdmVgIGFuIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZXMgdG8gYW4gb2JqZWN0LlxyXG4gKiBUaGUgb2JqZWN0cyBrZXlzIHJlcHJlc2VudCBhY3RpdmUgY2xhc3MgbmFtZXMgYW5kIHZhbHVlcyByZXByZXNlbnQgdGhlIHJlc3BlY3RpdmUgc3RhdGUgbmFtZXMvZ2xvYnMuXHJcbiAqIGB1aS1zcmVmLWFjdGl2ZWAgd2lsbCBtYXRjaCBpZiB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUgKippbmNsdWRlcyoqIGFueSBvZlxyXG4gKiB0aGUgc3BlY2lmaWVkIHN0YXRlIG5hbWVzL2dsb2JzLCBldmVuIHRoZSBhYnN0cmFjdCBvbmVzLlxyXG4gKlxyXG4gKiAjIyMjIEV4YW1wbGU6XHJcbiAqIEdpdmVuIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUsIHdpdGggXCJhZG1pblwiIGJlaW5nIGFuIGFic3RyYWN0IHN0YXRlOlxyXG4gKiBgYGBodG1sXHJcbiAqIDxkaXYgdWktc3JlZi1hY3RpdmU9XCJ7J2FjdGl2ZSc6ICdhZG1pbi4qKid9XCI+XHJcbiAqICAgPGEgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiB1aS1zcmVmPVwiYWRtaW4ucm9sZXNcIj5Sb2xlczwvYT5cclxuICogPC9kaXY+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBXaGVuIHRoZSBjdXJyZW50IHN0YXRlIGlzIFwiYWRtaW4ucm9sZXNcIiB0aGUgXCJhY3RpdmVcIiBjbGFzcyB3aWxsIGJlIGFwcGxpZWQgdG8gYm90aCB0aGUgPGRpdj4gYW5kIDxhPiBlbGVtZW50cy5cclxuICogSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCB0aGUgc3RhdGUgbmFtZXMvZ2xvYnMgcGFzc2VkIHRvIGB1aS1zcmVmLWFjdGl2ZWAgb3ZlcnJpZGUgYW55IHN0YXRlIHByb3ZpZGVkIGJ5IGEgbGlua2VkIGB1aS1zcmVmYC5cclxuICpcclxuICogIyMjIE5vdGVzOlxyXG4gKlxyXG4gKiAtIFRoZSBjbGFzcyBuYW1lIGlzIGludGVycG9sYXRlZCAqKm9uY2UqKiBkdXJpbmcgdGhlIGRpcmVjdGl2ZXMgbGluayB0aW1lIChhbnkgZnVydGhlciBjaGFuZ2VzIHRvIHRoZVxyXG4gKiBpbnRlcnBvbGF0ZWQgdmFsdWUgYXJlIGlnbm9yZWQpLlxyXG4gKlxyXG4gKiAtIE11bHRpcGxlIGNsYXNzZXMgbWF5IGJlIHNwZWNpZmllZCBpbiBhIHNwYWNlLXNlcGFyYXRlZCBmb3JtYXQ6IGB1aS1zcmVmLWFjdGl2ZT0nY2xhc3MxIGNsYXNzMiBjbGFzczMnYFxyXG4gKi9cclxudmFyIHVpU3JlZkFjdGl2ZTtcclxudWlTcmVmQWN0aXZlID0gWyckc3RhdGUnLCAnJHN0YXRlUGFyYW1zJywgJyRpbnRlcnBvbGF0ZScsICckdWlSb3V0ZXInLFxyXG4gICAgZnVuY3Rpb24gJFN0YXRlUmVmQWN0aXZlRGlyZWN0aXZlKCRzdGF0ZSwgJHN0YXRlUGFyYW1zLCAkaW50ZXJwb2xhdGUsICR1aVJvdXRlcikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlc3RyaWN0OiBcIkFcIixcclxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGF0dHJzJyxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVzID0gW10sIGFjdGl2ZUVxQ2xhc3MsIHVpU3JlZkFjdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBwcm9iYWJseSBpc24ndCBtdWNoIHBvaW50IGluICRvYnNlcnZpbmcgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVpU3JlZkFjdGl2ZSBhbmQgdWlTcmVmQWN0aXZlRXEgc2hhcmUgdGhlIHNhbWUgZGlyZWN0aXZlIG9iamVjdCB3aXRoIHNvbWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBzbGlnaHQgZGlmZmVyZW5jZSBpbiBsb2dpYyByb3V0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRXFDbGFzcyA9ICRpbnRlcnBvbGF0ZSgkYXR0cnMudWlTcmVmQWN0aXZlRXEgfHwgJycsIGZhbHNlKSgkc2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpU3JlZkFjdGl2ZSA9ICRzY29wZS4kZXZhbCgkYXR0cnMudWlTcmVmQWN0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZy4gdWlTcmVmQWN0aXZlIGlzIG5vdCBhIHZhbGlkIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byB1c2luZyAkaW50ZXJwb2xhdGUgYmVsb3dcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdWlTcmVmQWN0aXZlID0gdWlTcmVmQWN0aXZlIHx8ICRpbnRlcnBvbGF0ZSgkYXR0cnMudWlTcmVmQWN0aXZlIHx8ICcnLCBmYWxzZSkoJHNjb3BlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29yZV8xLmlzT2JqZWN0KHVpU3JlZkFjdGl2ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29yZV8xLmZvckVhY2godWlTcmVmQWN0aXZlLCBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIGFjdGl2ZUNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29yZV8xLmlzU3RyaW5nKHN0YXRlT3JOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSBwYXJzZVN0YXRlUmVmKHN0YXRlT3JOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTdGF0ZShyZWYuc3RhdGUsICRzY29wZS4kZXZhbChyZWYucGFyYW1FeHByKSwgYWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdWlTcmVmIHRvIGNvbW11bmljYXRlIHdpdGggdWlTcmVmQWN0aXZlW0VxdWFsc11cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiQkYWRkU3RhdGVJbmZvID0gZnVuY3Rpb24gKG5ld1N0YXRlLCBuZXdQYXJhbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYWxyZWFkeSBnb3QgYW4gZXhwbGljaXQgc3RhdGUgcHJvdmlkZWQgYnkgdWktc3JlZi1hY3RpdmUsIHNvIHdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNoYWRvdyB0aGUgb25lIHRoYXQgY29tZXMgZnJvbSB1aS1zcmVmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3JlXzEuaXNPYmplY3QodWlTcmVmQWN0aXZlKSAmJiBzdGF0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXJlZ2lzdGVyID0gYWRkU3RhdGUobmV3U3RhdGUsIG5ld1BhcmFtcywgdWlTcmVmQWN0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXJlZ2lzdGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlQWZ0ZXJUcmFuc2l0aW9uKHRyYW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLnByb21pc2UudGhlbih1cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdWNjZXNzJywgdXBkYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsICR1aVJvdXRlci50cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHt9LCB1cGRhdGVBZnRlclRyYW5zaXRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoJHVpUm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVBZnRlclRyYW5zaXRpb24oJHVpUm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFN0YXRlKHN0YXRlTmFtZSwgc3RhdGVQYXJhbXMsIGFjdGl2ZUNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9ICRzdGF0ZS5nZXQoc3RhdGVOYW1lLCBzdGF0ZUNvbnRleHQoJGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSB8fCB7IG5hbWU6IHN0YXRlTmFtZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBzdGF0ZVBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNsYXNzOiBhY3RpdmVDbGFzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZXMucHVzaChzdGF0ZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlU3RhdGUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlXzEucmVtb3ZlRnJvbShzdGF0ZXMpKHN0YXRlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSByb3V0ZSBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0Q2xhc3NlcyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHIuc3BsaXQoL1xccy8pLmZpbHRlcihjb3JlXzEuaWRlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChzdGF0ZUxpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZUxpc3QubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmFjdGl2ZUNsYXNzOyB9KS5tYXAoc3BsaXRDbGFzc2VzKS5yZWR1Y2UoY29yZV8xLnVubmVzdFIsIFtdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbENsYXNzZXMgPSBnZXRDbGFzc2VzKHN0YXRlcykuY29uY2F0KHNwbGl0Q2xhc3NlcyhhY3RpdmVFcUNsYXNzKSkucmVkdWNlKGNvcmVfMS51bmlxUiwgW10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnV6enlDbGFzc2VzID0gZ2V0Q2xhc3NlcyhzdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiAkc3RhdGUuaW5jbHVkZXMoeC5zdGF0ZS5uYW1lLCB4LnBhcmFtcyk7IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4YWN0bHlNYXRjaGVzQW55ID0gISFzdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiAkc3RhdGUuaXMoeC5zdGF0ZS5uYW1lLCB4LnBhcmFtcyk7IH0pLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4YWN0Q2xhc3NlcyA9IGV4YWN0bHlNYXRjaGVzQW55ID8gc3BsaXRDbGFzc2VzKGFjdGl2ZUVxQ2xhc3MpIDogW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRDbGFzc2VzID0gZnV6enlDbGFzc2VzLmNvbmNhdChleGFjdENsYXNzZXMpLnJlZHVjZShjb3JlXzEudW5pcVIsIFtdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZUNsYXNzZXMgPSBhbGxDbGFzc2VzLmZpbHRlcihmdW5jdGlvbiAoY2xzKSB7IHJldHVybiAhY29yZV8xLmluQXJyYXkoYWRkQ2xhc3NlcywgY2xzKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kZXZhbEFzeW5jKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiAkZWxlbWVudC5hZGRDbGFzcyhjbGFzc05hbWUpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiAkZWxlbWVudC5yZW1vdmVDbGFzcyhjbGFzc05hbWUpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfV1cclxuICAgICAgICB9O1xyXG4gICAgfV07XHJcbmFuZ3VsYXJfMS5uZy5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXHJcbiAgICAuZGlyZWN0aXZlKCd1aVNyZWYnLCB1aVNyZWYpXHJcbiAgICAuZGlyZWN0aXZlKCd1aVNyZWZBY3RpdmUnLCB1aVNyZWZBY3RpdmUpXHJcbiAgICAuZGlyZWN0aXZlKCd1aVNyZWZBY3RpdmVFcScsIHVpU3JlZkFjdGl2ZSlcclxuICAgIC5kaXJlY3RpdmUoJ3VpU3RhdGUnLCB1aVN0YXRlKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVEaXJlY3RpdmVzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL2RpcmVjdGl2ZXMvc3RhdGVEaXJlY3RpdmVzLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQG5nMWFwaVxyXG4gKiBAbW9kdWxlIGRpcmVjdGl2ZXNcclxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xyXG52YXIgYW5ndWxhcl8xID0gcmVxdWlyZShcIi4uL2FuZ3VsYXJcIik7XHJcbnZhciBhbmd1bGFyXzIgPSByZXF1aXJlKFwiYW5ndWxhclwiKTtcclxudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAdWlyb3V0ZXIvY29yZVwiKTtcclxudmFyIHZpZXdzXzEgPSByZXF1aXJlKFwiLi4vc3RhdGVidWlsZGVycy92aWV3c1wiKTtcclxudmFyIHNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vc2VydmljZXNcIik7XHJcbmV4cG9ydHMudWlWaWV3ID0gWyckdmlldycsICckYW5pbWF0ZScsICckdWlWaWV3U2Nyb2xsJywgJyRpbnRlcnBvbGF0ZScsICckcScsXHJcbiAgICBmdW5jdGlvbiAkVmlld0RpcmVjdGl2ZSgkdmlldywgJGFuaW1hdGUsICR1aVZpZXdTY3JvbGwsICRpbnRlcnBvbGF0ZSwgJHEpIHtcclxuICAgICAgICBmdW5jdGlvbiBnZXRSZW5kZXJlcihhdHRycywgc2NvcGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAoZWxlbWVudCwgdGFyZ2V0LCBjYikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyXzEubmcudmVyc2lvbi5taW5vciA+IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGUuZW50ZXIoZWxlbWVudCwgbnVsbCwgdGFyZ2V0KS50aGVuKGNiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIG51bGwsIHRhcmdldCwgY2IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXJfMS5uZy52ZXJzaW9uLm1pbm9yID4gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShlbGVtZW50KS50aGVuKGNiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRhbmltYXRlLmxlYXZlKGVsZW1lbnQsIGNiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGNvbmZpZ3NFcXVhbChjb25maWcxLCBjb25maWcyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb25maWcxID09PSBjb25maWcyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcm9vdERhdGEgPSB7XHJcbiAgICAgICAgICAgICRjZmc6IHsgdmlld0RlY2w6IHsgJGNvbnRleHQ6ICR2aWV3Ll9wbHVnaW5hcGkuX3Jvb3RWaWV3Q29udGV4dCgpIH0gfSxcclxuICAgICAgICAgICAgJHVpVmlldzoge31cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBkaXJlY3RpdmUgPSB7XHJcbiAgICAgICAgICAgIGNvdW50OiAwLFxyXG4gICAgICAgICAgICByZXN0cmljdDogJ0VDQScsXHJcbiAgICAgICAgICAgIHRlcm1pbmFsOiB0cnVlLFxyXG4gICAgICAgICAgICBwcmlvcml0eTogNDAwLFxyXG4gICAgICAgICAgICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXHJcbiAgICAgICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uICh0RWxlbWVudCwgdEF0dHJzLCAkdHJhbnNjbHVkZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgJGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzRWwsIGN1cnJlbnRFbCwgY3VycmVudFNjb3BlLCB1bnJlZ2lzdGVyLCBvbmxvYWRFeHAgPSBhdHRyc1snb25sb2FkJ10gfHwgJycsIGF1dG9TY3JvbGxFeHAgPSBhdHRyc1snYXV0b3Njcm9sbCddLCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGF0dHJzLCBzY29wZSksIHZpZXdDb25maWcgPSB1bmRlZmluZWQsIGluaGVyaXRlZCA9ICRlbGVtZW50LmluaGVyaXRlZERhdGEoJyR1aVZpZXcnKSB8fCByb290RGF0YSwgbmFtZSA9ICRpbnRlcnBvbGF0ZShhdHRyc1sndWlWaWV3J10gfHwgYXR0cnNbJ25hbWUnXSB8fCAnJykoc2NvcGUpIHx8ICckZGVmYXVsdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2ZVVJVmlldyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHR5cGU6ICduZzEnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZGlyZWN0aXZlLmNvdW50KyssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZxbjogaW5oZXJpdGVkLiR1aVZpZXcuZnFuID8gaW5oZXJpdGVkLiR1aVZpZXcuZnFuICsgXCIuXCIgKyBuYW1lIDogbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdVcGRhdGVkOiBjb25maWdVcGRhdGVkQ2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjcmVhdGlvbkNvbnRleHQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbVBhcmVudFRhZ0NvbmZpZyA9IGNvcmVfMS5wYXJzZSgnJGNmZy52aWV3RGVjbC4kY29udGV4dCcpKGluaGVyaXRlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyA8dWktdmlldyBuYW1lPVwiZm9vXCI+PHVpLXZpZXcgbmFtZT1cImJhclwiPjwvdWktdmlldz48L3VpLXZpZXc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvdWktcm91dGVyL2lzc3Vlcy8zMzU1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbVBhcmVudFRhZyA9IGNvcmVfMS5wYXJzZSgnJHVpVmlldy5jcmVhdGlvbkNvbnRleHQnKShpbmhlcml0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb21QYXJlbnRUYWdDb25maWcgfHwgZnJvbVBhcmVudFRhZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29yZV8xLnRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoXCJMaW5raW5nXCIsIGFjdGl2ZVVJVmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY29uZmlnVXBkYXRlZENhbGxiYWNrKGNvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnICYmICEoY29uZmlnIGluc3RhbmNlb2Ygdmlld3NfMS5OZzFWaWV3Q29uZmlnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3NFcXVhbCh2aWV3Q29uZmlnLCBjb25maWcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlXzEudHJhY2UudHJhY2VVSVZpZXdDb25maWdVcGRhdGVkKGFjdGl2ZVVJVmlldywgY29uZmlnICYmIGNvbmZpZy52aWV3RGVjbCAmJiBjb25maWcudmlld0RlY2wuJGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3Q29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWaWV3KGNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICRlbGVtZW50LmRhdGEoJyR1aVZpZXcnLCB7ICR1aVZpZXc6IGFjdGl2ZVVJVmlldyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVWaWV3KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3RlciA9ICR2aWV3LnJlZ2lzdGVyVUlWaWV3KGFjdGl2ZVVJVmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuJG9uKFwiJGRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlXzEudHJhY2UudHJhY2VVSVZpZXdFdmVudChcIkRlc3Ryb3lpbmcvVW5yZWdpc3RlcmluZ1wiLCBhY3RpdmVVSVZpZXcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xlYW51cExhc3RWaWV3KCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZV8xLnRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoXCJSZW1vdmluZyAocHJldmlvdXMpIGVsXCIsIHByZXZpb3VzRWwuZGF0YSgnJHVpVmlldycpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0VsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlXzEudHJhY2UudHJhY2VVSVZpZXdFdmVudChcIkRlc3Ryb3lpbmcgc2NvcGVcIiwgYWN0aXZlVUlWaWV3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3ZpZXdEYXRhXzEgPSBjdXJyZW50RWwuZGF0YSgnJHVpVmlld0FuaW0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVfMS50cmFjZS50cmFjZVVJVmlld0V2ZW50KFwiQW5pbWF0ZSBvdXRcIiwgX3ZpZXdEYXRhXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIubGVhdmUoY3VycmVudEVsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdEYXRhXzEuJCRhbmltTGVhdmUucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0VsID0gY3VycmVudEVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEVsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVWaWV3KGNvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2NvcGUgPSBzY29wZS4kbmV3KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltRW50ZXIgPSAkcS5kZWZlcigpLCBhbmltTGVhdmUgPSAkcS5kZWZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJHVpVmlld0RhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY2ZnOiBjb25maWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdWlWaWV3OiBhY3RpdmVVSVZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkdWlWaWV3QW5pbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhbmltRW50ZXI6IGFuaW1FbnRlci5wcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1MZWF2ZTogYW5pbUxlYXZlLnByb21pc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkJGFuaW1MZWF2ZTogYW5pbUxlYXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmdkb2MgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS12aWV3IyR2aWV3Q29udGVudExvYWRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50T2YgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS12aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBldmVudFR5cGUgZW1pdHMgb24gdWktdmlldyBkaXJlY3RpdmUgc2NvcGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEZpcmVkIG9uY2UgdGhlIHZpZXcgKipiZWdpbnMgbG9hZGluZyoqLCAqYmVmb3JlKiB0aGUgRE9NIGlzIHJlbmRlcmVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlld05hbWUgTmFtZSBvZiB0aGUgdmlldy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlLiRlbWl0KCckdmlld0NvbnRlbnRMb2FkaW5nJywgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZWQgPSAkdHJhbnNjbHVkZShuZXdTY29wZSwgZnVuY3Rpb24gKGNsb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZS5kYXRhKCckdWlWaWV3QW5pbScsICR1aVZpZXdBbmltKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lLmRhdGEoJyR1aVZpZXcnLCAkdWlWaWV3RGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5lbnRlcihjbG9uZSwgJGVsZW1lbnQsIGZ1bmN0aW9uIG9uVUlWaWV3RW50ZXIoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbUVudGVyLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3BlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUuJGVtaXQoJyR2aWV3Q29udGVudEFuaW1hdGlvbkVuZGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcmVfMS5pc0RlZmluZWQoYXV0b1Njcm9sbEV4cCkgJiYgIWF1dG9TY3JvbGxFeHAgfHwgc2NvcGUuJGV2YWwoYXV0b1Njcm9sbEV4cCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHVpVmlld1Njcm9sbChjbG9uZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwTGFzdFZpZXcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFbCA9IGNsb25lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbmV3U2NvcGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmdkb2MgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS12aWV3IyR2aWV3Q29udGVudExvYWRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnRPZiB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50VHlwZSBlbWl0cyBvbiB1aS12aWV3IGRpcmVjdGl2ZSBzY29wZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogRmlyZWQgb25jZSB0aGUgdmlldyBpcyAqKmxvYWRlZCoqLCAqYWZ0ZXIqIHRoZSBET00gaXMgcmVuZGVyZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBFdmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUuJGVtaXQoJyR2aWV3Q29udGVudExvYWRlZCcsIGNvbmZpZyB8fCB2aWV3Q29uZmlnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3BlLiRldmFsKG9ubG9hZEV4cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZTtcclxuICAgIH1dO1xyXG4kVmlld0RpcmVjdGl2ZUZpbGwuJGluamVjdCA9IFsnJGNvbXBpbGUnLCAnJGNvbnRyb2xsZXInLCAnJHRyYW5zaXRpb25zJywgJyR2aWV3JywgJyRxJywgJyR0aW1lb3V0J107XHJcbi8qKiBAaGlkZGVuICovXHJcbmZ1bmN0aW9uICRWaWV3RGlyZWN0aXZlRmlsbCgkY29tcGlsZSwgJGNvbnRyb2xsZXIsICR0cmFuc2l0aW9ucywgJHZpZXcsICRxLCAkdGltZW91dCkge1xyXG4gICAgdmFyIGdldENvbnRyb2xsZXJBcyA9IGNvcmVfMS5wYXJzZSgndmlld0RlY2wuY29udHJvbGxlckFzJyk7XHJcbiAgICB2YXIgZ2V0UmVzb2x2ZUFzID0gY29yZV8xLnBhcnNlKCd2aWV3RGVjbC5yZXNvbHZlQXMnKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFQ0EnLFxyXG4gICAgICAgIHByaW9yaXR5OiAtNDAwLFxyXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uICh0RWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgaW5pdGlhbCA9IHRFbGVtZW50Lmh0bWwoKTtcclxuICAgICAgICAgICAgdEVsZW1lbnQuZW1wdHkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgJGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gJGVsZW1lbnQuZGF0YSgnJHVpVmlldycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQuaHRtbChpbml0aWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAkY29tcGlsZSgkZWxlbWVudC5jb250ZW50cygpKShzY29wZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNmZyA9IGRhdGEuJGNmZyB8fCB7IHZpZXdEZWNsOiB7fSwgZ2V0VGVtcGxhdGU6IGFuZ3VsYXJfMi5ub29wIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZUN0eCA9IGNmZy5wYXRoICYmIG5ldyBjb3JlXzEuUmVzb2x2ZUNvbnRleHQoY2ZnLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgJGVsZW1lbnQuaHRtbChjZmcuZ2V0VGVtcGxhdGUoJGVsZW1lbnQsIHJlc29sdmVDdHgpIHx8IGluaXRpYWwpO1xyXG4gICAgICAgICAgICAgICAgY29yZV8xLnRyYWNlLnRyYWNlVUlWaWV3RmlsbChkYXRhLiR1aVZpZXcsICRlbGVtZW50Lmh0bWwoKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGluayA9ICRjb21waWxlKCRlbGVtZW50LmNvbnRlbnRzKCkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBjZmcuY29udHJvbGxlcjtcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9sbGVyQXMgPSBnZXRDb250cm9sbGVyQXMoY2ZnKTtcclxuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlQXMgPSBnZXRSZXNvbHZlQXMoY2ZnKTtcclxuICAgICAgICAgICAgICAgIHZhciBsb2NhbHMgPSByZXNvbHZlQ3R4ICYmIHNlcnZpY2VzXzEuZ2V0TG9jYWxzKHJlc29sdmVDdHgpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGVbcmVzb2x2ZUFzXSA9IGxvY2FscztcclxuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXJJbnN0YW5jZSA9ICRjb250cm9sbGVyKGNvbnRyb2xsZXIsIGNvcmVfMS5leHRlbmQoe30sIGxvY2FscywgeyAkc2NvcGU6IHNjb3BlLCAkZWxlbWVudDogJGVsZW1lbnQgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyQXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVbY29udHJvbGxlckFzXSA9IGNvbnRyb2xsZXJJbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVbY29udHJvbGxlckFzXVtyZXNvbHZlQXNdID0gbG9jYWxzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBVc2UgJHZpZXcgc2VydmljZSBhcyBhIGNlbnRyYWwgcG9pbnQgZm9yIHJlZ2lzdGVyaW5nIGNvbXBvbmVudC1sZXZlbCBob29rc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZW4sIHdoZW4gYSBjb21wb25lbnQgaXMgY3JlYXRlZCwgdGVsbCB0aGUgJHZpZXcgc2VydmljZSwgc28gaXQgY2FuIGludm9rZSBob29rc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICR2aWV3LmNvbXBvbmVudExvYWRlZChjb250cm9sbGVySW5zdGFuY2UsIHsgJHNjb3BlOiBzY29wZSwgJGVsZW1lbnQ6ICRlbGVtZW50IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNjb3BlLiRvbignJGRlc3Ryb3knLCAoKSA9PiAkdmlldy5jb21wb25lbnRVbmxvYWRlZChjb250cm9sbGVySW5zdGFuY2UsIHsgJHNjb3BlOiBzY29wZSwgJGVsZW1lbnQ6ICRlbGVtZW50IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5kYXRhKCckbmdDb250cm9sbGVyQ29udHJvbGxlcicsIGNvbnRyb2xsZXJJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQuY2hpbGRyZW4oKS5kYXRhKCckbmdDb250cm9sbGVyQ29udHJvbGxlcicsIGNvbnRyb2xsZXJJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJDb250cm9sbGVyQ2FsbGJhY2tzKCRxLCAkdHJhbnNpdGlvbnMsIGNvbnRyb2xsZXJJbnN0YW5jZSwgc2NvcGUsIGNmZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgY29tcG9uZW50IHRvIGFwcGVhciBpbiB0aGUgRE9NXHJcbiAgICAgICAgICAgICAgICBpZiAoY29yZV8xLmlzU3RyaW5nKGNmZy52aWV3RGVjbC5jb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNtcF8xID0gY2ZnLnZpZXdEZWNsLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2Vib2JOYW1lID0gY29yZV8xLmtlYm9iU3RyaW5nKGNtcF8xKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnUmVnZXhwXzEgPSBuZXcgUmVnRXhwKFwiXih4LXxkYXRhLSk/XCIgKyBrZWJvYk5hbWUgKyBcIiRcIiwgXCJpXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRDb21wb25lbnRDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlRWwgPSBbXS5zbGljZS5jYWxsKCRlbGVtZW50WzBdLmNoaWxkcmVuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsICYmIGVsLnRhZ05hbWUgJiYgdGFnUmVnZXhwXzEuZXhlYyhlbC50YWdOYW1lKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3RpdmVFbCAmJiBhbmd1bGFyXzEubmcuZWxlbWVudChkaXJlY3RpdmVFbCkuZGF0YShcIiRcIiArIGNtcF8xICsgXCJDb250cm9sbGVyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcmVnaXN0ZXJXYXRjaF8xID0gc2NvcGUuJHdhdGNoKGdldENvbXBvbmVudENvbnRyb2xsZXIsIGZ1bmN0aW9uIChjdHJsSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHJsSW5zdGFuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyQ29udHJvbGxlckNhbGxiYWNrcygkcSwgJHRyYW5zaXRpb25zLCBjdHJsSW5zdGFuY2UsIHNjb3BlLCBjZmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXJlZ2lzdGVyV2F0Y2hfMSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGluayhzY29wZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vKiogQGhpZGRlbiAqL1xyXG52YXIgaGFzQ29tcG9uZW50SW1wbCA9IHR5cGVvZiBhbmd1bGFyXzEubmcubW9kdWxlKCd1aS5yb3V0ZXInKVsnY29tcG9uZW50J10gPT09ICdmdW5jdGlvbic7XHJcbi8qKiBAaGlkZGVuIGluY3JlbWVudGluZyBpZCAqL1xyXG52YXIgX3VpQ2FuRXhpdElkID0gMDtcclxuLyoqIEBoaWRkZW4gVE9ETzogbW92ZSB0aGVzZSBjYWxsYmFja3MgdG8gJHZpZXcgYW5kL29yIGAvaG9va3MvY29tcG9uZW50cy50c2Agb3Igc29tZXRoaW5nICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQ29udHJvbGxlckNhbGxiYWNrcygkcSwgJHRyYW5zaXRpb25zLCBjb250cm9sbGVySW5zdGFuY2UsICRzY29wZSwgY2ZnKSB7XHJcbiAgICAvLyBDYWxsICRvbkluaXQoKSBBU0FQXHJcbiAgICBpZiAoY29yZV8xLmlzRnVuY3Rpb24oY29udHJvbGxlckluc3RhbmNlLiRvbkluaXQpICYmICEoY2ZnLnZpZXdEZWNsLmNvbXBvbmVudCAmJiBoYXNDb21wb25lbnRJbXBsKSkge1xyXG4gICAgICAgIGNvbnRyb2xsZXJJbnN0YW5jZS4kb25Jbml0KCk7XHJcbiAgICB9XHJcbiAgICB2YXIgdmlld1N0YXRlID0gY29yZV8xLnRhaWwoY2ZnLnBhdGgpLnN0YXRlLnNlbGY7XHJcbiAgICB2YXIgaG9va09wdGlvbnMgPSB7IGJpbmQ6IGNvbnRyb2xsZXJJbnN0YW5jZSB9O1xyXG4gICAgLy8gQWRkIGNvbXBvbmVudC1sZXZlbCBob29rIGZvciBvblBhcmFtc0NoYW5nZVxyXG4gICAgaWYgKGNvcmVfMS5pc0Z1bmN0aW9uKGNvbnRyb2xsZXJJbnN0YW5jZS51aU9uUGFyYW1zQ2hhbmdlZCkpIHtcclxuICAgICAgICB2YXIgcmVzb2x2ZUNvbnRleHQgPSBuZXcgY29yZV8xLlJlc29sdmVDb250ZXh0KGNmZy5wYXRoKTtcclxuICAgICAgICB2YXIgdmlld0NyZWF0aW9uVHJhbnNfMSA9IHJlc29sdmVDb250ZXh0LmdldFJlc29sdmFibGUoJyR0cmFuc2l0aW9uJCcpLmRhdGE7XHJcbiAgICAgICAgLy8gRmlyZSBjYWxsYmFjayBvbiBhbnkgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uXHJcbiAgICAgICAgdmFyIHBhcmFtc1VwZGF0ZWQgPSBmdW5jdGlvbiAoJHRyYW5zaXRpb24kKSB7XHJcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlICR0cmFuc2l0aW9uJCBpcyB0aGUgc2FtZSBhcyB0aGUgdmlldyB3YXMgY3JlYXRlZCB3aXRoaW4uXHJcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlICR0cmFuc2l0aW9uJCB3aWxsIGV4aXQgdGhlIHN0YXRlIHRoZSB2aWV3IGlzIGZvci5cclxuICAgICAgICAgICAgaWYgKCR0cmFuc2l0aW9uJCA9PT0gdmlld0NyZWF0aW9uVHJhbnNfMSB8fCAkdHJhbnNpdGlvbiQuZXhpdGluZygpLmluZGV4T2Yodmlld1N0YXRlKSAhPT0gLTEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciB0b1BhcmFtcyA9ICR0cmFuc2l0aW9uJC5wYXJhbXMoXCJ0b1wiKTtcclxuICAgICAgICAgICAgdmFyIGZyb21QYXJhbXMgPSAkdHJhbnNpdGlvbiQucGFyYW1zKFwiZnJvbVwiKTtcclxuICAgICAgICAgICAgdmFyIHRvU2NoZW1hID0gJHRyYW5zaXRpb24kLnRyZWVDaGFuZ2VzKCkudG8ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnBhcmFtU2NoZW1hOyB9KS5yZWR1Y2UoY29yZV8xLnVubmVzdFIsIFtdKTtcclxuICAgICAgICAgICAgdmFyIGZyb21TY2hlbWEgPSAkdHJhbnNpdGlvbiQudHJlZUNoYW5nZXMoKS5mcm9tLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5wYXJhbVNjaGVtYTsgfSkucmVkdWNlKGNvcmVfMS51bm5lc3RSLCBbXSk7XHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRvIHBhcmFtcyB0aGF0IGhhdmUgZGlmZmVyZW50IHZhbHVlcyB0aGFuIHRoZSBmcm9tIHBhcmFtc1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlZFRvUGFyYW1zID0gdG9TY2hlbWEuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGZyb21TY2hlbWEuaW5kZXhPZihwYXJhbSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4ID09PSAtMSB8fCAhZnJvbVNjaGVtYVtpZHhdLnR5cGUuZXF1YWxzKHRvUGFyYW1zW3BhcmFtLmlkXSwgZnJvbVBhcmFtc1twYXJhbS5pZF0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gT25seSB0cmlnZ2VyIGNhbGxiYWNrIGlmIGEgdG8gcGFyYW0gaGFzIGNoYW5nZWQgb3IgaXMgbmV3XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkVG9QYXJhbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZEtleXNfMSA9IGNoYW5nZWRUb1BhcmFtcy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIHRoZSBwYXJhbXMgdG8gb25seSBjaGFuZ2VkL25ldyB0byBwYXJhbXMuICBgJHRyYW5zaXRpb24kLnBhcmFtcygpYCBtYXkgYmUgdXNlZCB0byBnZXQgYWxsIHBhcmFtcy5cclxuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZXMgPSBjb3JlXzEuZmlsdGVyKHRvUGFyYW1zLCBmdW5jdGlvbiAodmFsLCBrZXkpIHsgcmV0dXJuIGNoYW5nZWRLZXlzXzEuaW5kZXhPZihrZXkpICE9PSAtMTsgfSk7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVySW5zdGFuY2UudWlPblBhcmFtc0NoYW5nZWQobmV3VmFsdWVzLCAkdHJhbnNpdGlvbiQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsICR0cmFuc2l0aW9ucy5vblN1Y2Nlc3Moe30sIHBhcmFtc1VwZGF0ZWQsIGhvb2tPcHRpb25zKSk7XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgY29tcG9uZW50LWxldmVsIGhvb2sgZm9yIHVpQ2FuRXhpdFxyXG4gICAgaWYgKGNvcmVfMS5pc0Z1bmN0aW9uKGNvbnRyb2xsZXJJbnN0YW5jZS51aUNhbkV4aXQpKSB7XHJcbiAgICAgICAgdmFyIGlkXzEgPSBfdWlDYW5FeGl0SWQrKztcclxuICAgICAgICB2YXIgY2FjaGVQcm9wXzEgPSAnX3VpQ2FuRXhpdElkcyc7XHJcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGEgcmVkaXJlY3QgdHJhbnNpdGlvbiBhbHJlYWR5IGFuc3dlcmVkIHRydXRoeVxyXG4gICAgICAgIHZhciBwcmV2VHJ1dGh5QW5zd2VyXzEgPSBmdW5jdGlvbiAodHJhbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhdHJhbnMgJiYgKHRyYW5zW2NhY2hlUHJvcF8xXSAmJiB0cmFuc1tjYWNoZVByb3BfMV1baWRfMV0gPT09IHRydWUgfHwgcHJldlRydXRoeUFuc3dlcl8xKHRyYW5zLnJlZGlyZWN0ZWRGcm9tKCkpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIElmIGEgdXNlciBhbnN3ZXJlZCB5ZXMsIGJ1dCB0aGUgdHJhbnNpdGlvbiB3YXMgbGF0ZXIgcmVkaXJlY3RlZCwgZG9uJ3QgYWxzbyBhc2sgZm9yIHRoZSBuZXcgcmVkaXJlY3QgdHJhbnNpdGlvblxyXG4gICAgICAgIHZhciB3cmFwcGVkSG9vayA9IGZ1bmN0aW9uICh0cmFucykge1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSwgaWRzID0gdHJhbnNbY2FjaGVQcm9wXzFdID0gdHJhbnNbY2FjaGVQcm9wXzFdIHx8IHt9O1xyXG4gICAgICAgICAgICBpZiAoIXByZXZUcnV0aHlBbnN3ZXJfMSh0cmFucykpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2UgPSAkcS53aGVuKGNvbnRyb2xsZXJJbnN0YW5jZS51aUNhbkV4aXQodHJhbnMpKTtcclxuICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsKSB7IHJldHVybiBpZHNbaWRfMV0gPSAodmFsICE9PSBmYWxzZSk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGNyaXRlcmlhID0geyBleGl0aW5nOiB2aWV3U3RhdGUubmFtZSB9O1xyXG4gICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgJHRyYW5zaXRpb25zLm9uQmVmb3JlKGNyaXRlcmlhLCB3cmFwcGVkSG9vaywgaG9va09wdGlvbnMpKTtcclxuICAgIH1cclxufVxyXG5hbmd1bGFyXzEubmcubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5kaXJlY3RpdmUoJ3VpVmlldycsIGV4cG9ydHMudWlWaWV3KTtcclxuYW5ndWxhcl8xLm5nLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykuZGlyZWN0aXZlKCd1aVZpZXcnLCAkVmlld0RpcmVjdGl2ZUZpbGwpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3RGlyZWN0aXZlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL2RpcmVjdGl2ZXMvdmlld0RpcmVjdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiAjIEFuZ3VsYXIgMSBpbmplY3RhYmxlIHNlcnZpY2VzXHJcbiAqXHJcbiAqIFRoaXMgaXMgYSBsaXN0IG9mIHRoZSBvYmplY3RzIHdoaWNoIGNhbiBiZSBpbmplY3RlZCB1c2luZyBhbmd1bGFyJ3MgaW5qZWN0b3IuXHJcbiAqXHJcbiAqIFRoZXJlIGFyZSB0aHJlZSBkaWZmZXJlbnQga2luZCBvZiBpbmplY3RhYmxlIG9iamVjdHM6XHJcbiAqXHJcbiAqICMjICoqUHJvdmlkZXIqKiBvYmplY3RzXHJcbiAqICMjIyMgaW5qZWN0YWJsZSBpbnRvIGEgYC5jb25maWcoKWAgYmxvY2sgZHVyaW5nIGNvbmZpZ3RpbWVcclxuICpcclxuICogLSBbWyR1aVJvdXRlclByb3ZpZGVyXV06IFRoZSBVSS1Sb3V0ZXIgaW5zdGFuY2VcclxuICogLSBbWyRzdGF0ZVByb3ZpZGVyXV06IFN0YXRlIHJlZ2lzdHJhdGlvblxyXG4gKiAtIFtbJHRyYW5zaXRpb25zUHJvdmlkZXJdXTogVHJhbnNpdGlvbiBob29rc1xyXG4gKiAtIFtbJHVybFNlcnZpY2VQcm92aWRlcl1dOiBBbGwgVVJMIHJlbGF0ZWQgcHVibGljIEFQSXNcclxuICpcclxuICogLSBbWyR1aVZpZXdTY3JvbGxQcm92aWRlcl1dOiBEaXNhYmxlIHVpLXJvdXRlciB2aWV3IHNjcm9sbGluZ1xyXG4gKiAtIFtbJHVybFJvdXRlclByb3ZpZGVyXV06IChkZXByZWNhdGVkKSBVcmwgbWF0Y2hpbmcgcnVsZXNcclxuICogLSBbWyR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyXV06IChkZXByZWNhdGVkKSBVcmwgcGFyc2luZyBjb25maWdcclxuICpcclxuICogIyMgKipTZXJ2aWNlKiogb2JqZWN0c1xyXG4gKiAjIyMjIGluamVjdGFibGUgZ2xvYmFsbHkgZHVyaW5nIHJ1bnRpbWVcclxuICpcclxuICogLSBbWyR1aVJvdXRlcl1dOiBUaGUgVUktUm91dGVyIGluc3RhbmNlXHJcbiAqIC0gW1skdHJhY2VdXTogRW5hYmxlIHRyYW5zaXRpb24gdHJhY2UvZGVidWdcclxuICogLSBbWyR0cmFuc2l0aW9uc11dOiBUcmFuc2l0aW9uIGhvb2tzXHJcbiAqIC0gW1skc3RhdGVdXTogSW1wZXJhdGl2ZSBzdGF0ZSByZWxhdGVkIEFQSXNcclxuICogLSBbWyRzdGF0ZVJlZ2lzdHJ5XV06IFN0YXRlIHJlZ2lzdHJhdGlvblxyXG4gKiAtIFtbJHVybFNlcnZpY2VdXTogQWxsIFVSTCByZWxhdGVkIHB1YmxpYyBBUElzXHJcbiAqIC0gW1skdWlSb3V0ZXJHbG9iYWxzXV06IEdsb2JhbCB2YXJpYWJsZXNcclxuICogLSBbWyR1aVZpZXdTY3JvbGxdXTogU2Nyb2xsIGFuIGVsZW1lbnQgaW50byB2aWV3XHJcbiAqXHJcbiAqIC0gW1skc3RhdGVQYXJhbXNdXTogKGRlcHJlY2F0ZWQpIEdsb2JhbCBzdGF0ZSBwYXJhbSB2YWx1ZXNcclxuICogLSBbWyR1cmxSb3V0ZXJdXTogKGRlcHJlY2F0ZWQpIFVSTCBzeW5jaHJvbml6YXRpb25cclxuICogLSBbWyR1cmxNYXRjaGVyRmFjdG9yeV1dOiAoZGVwcmVjYXRlZCkgVVJMIHBhcnNpbmcgY29uZmlnXHJcbiAqXHJcbiAqICMjICoqUGVyLVRyYW5zaXRpb24qKiBvYmplY3RzXHJcbiAqXHJcbiAqIC0gVGhlc2Uga2luZCBvZiBvYmplY3RzIGFyZSBpbmplY3RhYmxlIGludG86XHJcbiAqICAgLSBSZXNvbHZlcyAoW1tOZzFTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXSksXHJcbiAqICAgLSBUcmFuc2l0aW9uIEhvb2tzIChbW1RyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnRdXSwgZXRjKSxcclxuICogICAtIFJvdXRlZCBDb250cm9sbGVycyAoW1tOZzFWaWV3RGVjbGFyYXRpb24uY29udHJvbGxlcl1dKVxyXG4gKlxyXG4gKiAjIyMjIERpZmZlcmVudCBpbnN0YW5jZXMgYXJlIGluamVjdGVkIGJhc2VkIG9uIHRoZSBbW1RyYW5zaXRpb25dXVxyXG4gKlxyXG4gKiAtIFtbJHRyYW5zaXRpb24kXV06IFRoZSBjdXJyZW50IFRyYW5zaXRpb24gb2JqZWN0XHJcbiAqIC0gW1skc3RhdGVQYXJhbXNdXTogU3RhdGUgcGFyYW0gdmFsdWVzIGZvciBwZW5kaW5nIFRyYW5zaXRpb24gKGRlcHJlY2F0ZWQpXHJcbiAqIC0gQW55IHJlc29sdmUgZGF0YSBkZWZpbmVkIHVzaW5nIFtbTmcxU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV1cclxuICpcclxuICogQG5nMWFwaVxyXG4gKiBAcHJlZmVycmVkXHJcbiAqIEBtb2R1bGUgaW5qZWN0YWJsZXNcclxuICovIC8qKiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBUaGUgY3VycmVudCAob3IgcGVuZGluZykgU3RhdGUgUGFyYW1ldGVyc1xyXG4gKlxyXG4gKiBBbiBpbmplY3RhYmxlIGdsb2JhbCAqKlNlcnZpY2UgT2JqZWN0Kiogd2hpY2ggaG9sZHMgdGhlIHN0YXRlIHBhcmFtZXRlcnMgZm9yIHRoZSBsYXRlc3QgKipTVUNDRVNTRlVMKiogdHJhbnNpdGlvbi5cclxuICpcclxuICogVGhlIHZhbHVlcyBhcmUgbm90IHVwZGF0ZWQgdW50aWwgKmFmdGVyKiBhIGBUcmFuc2l0aW9uYCBzdWNjZXNzZnVsbHkgY29tcGxldGVzLlxyXG4gKlxyXG4gKiAqKkFsc286KiogYW4gaW5qZWN0YWJsZSAqKlBlci1UcmFuc2l0aW9uIE9iamVjdCoqIG9iamVjdCB3aGljaCBob2xkcyB0aGUgcGVuZGluZyBzdGF0ZSBwYXJhbWV0ZXJzIGZvciB0aGUgcGVuZGluZyBgVHJhbnNpdGlvbmAgY3VycmVudGx5IHJ1bm5pbmcuXHJcbiAqXHJcbiAqICMjIyBEZXByZWNhdGlvbiB3YXJuaW5nOlxyXG4gKlxyXG4gKiBUaGUgdmFsdWUgaW5qZWN0ZWQgZm9yIGAkc3RhdGVQYXJhbXNgIGlzIGRpZmZlcmVudCBkZXBlbmRpbmcgb24gd2hlcmUgaXQgaXMgaW5qZWN0ZWQuXHJcbiAqXHJcbiAqIC0gV2hlbiBpbmplY3RlZCBpbnRvIGFuIGFuZ3VsYXIgc2VydmljZSwgdGhlIG9iamVjdCBpbmplY3RlZCBpcyB0aGUgZ2xvYmFsICoqU2VydmljZSBPYmplY3QqKiB3aXRoIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGZvciB0aGUgbGF0ZXN0IHN1Y2Nlc3NmdWwgYFRyYW5zaXRpb25gLlxyXG4gKiAtIFdoZW4gaW5qZWN0ZWQgaW50byB0cmFuc2l0aW9uIGhvb2tzLCByZXNvbHZlcywgb3IgdmlldyBjb250cm9sbGVycywgdGhlIG9iamVjdCBpcyB0aGUgKipQZXItVHJhbnNpdGlvbiBPYmplY3QqKiB3aXRoIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGZvciB0aGUgcnVubmluZyBgVHJhbnNpdGlvbmAuXHJcbiAqXHJcbiAqIEJlY2F1c2Ugb2YgdGhlc2UgY29uZnVzaW5nIGRldGFpbHMsIHRoaXMgc2VydmljZSBpcyBkZXByZWNhdGVkLlxyXG4gKlxyXG4gKiAjIyMgSW5zdGVhZCBvZiB1c2luZyB0aGUgZ2xvYmFsIGAkc3RhdGVQYXJhbXNgIHNlcnZpY2Ugb2JqZWN0LFxyXG4gKiBpbmplY3QgW1skdWlSb3V0ZXJHbG9iYWxzXV0gYW5kIHVzZSBbW1VJUm91dGVyR2xvYmFscy5wYXJhbXNdXVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBNeVNlcnZpY2UuJGluamVjdCA9IFsnJHVpUm91dGVyR2xvYmFscyddO1xyXG4gKiBmdW5jdGlvbiBNeVNlcnZpY2UoJHVpUm91dGVyR2xvYmFscykge1xyXG4gKiAgIHJldHVybiB7XHJcbiAqICAgICBwYXJhbVZhbHVlczogZnVuY3Rpb24gKCkge1xyXG4gKiAgICAgICByZXR1cm4gJHVpUm91dGVyR2xvYmFscy5wYXJhbXM7XHJcbiAqICAgICB9XHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAjIyMgSW5zdGVhZCBvZiB1c2luZyB0aGUgcGVyLXRyYW5zaXRpb24gYCRzdGF0ZVBhcmFtc2Agb2JqZWN0LFxyXG4gKiBpbmplY3QgdGhlIGN1cnJlbnQgYFRyYW5zaXRpb25gIChhcyBbWyR0cmFuc2l0aW9uJF1dKSBhbmQgdXNlIFtbVHJhbnNpdGlvbi5wYXJhbXNdXVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBNeUNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHRyYW5zaXRpb24kJ107XHJcbiAqIGZ1bmN0aW9uIE15Q29udHJvbGxlcigkdHJhbnNpdGlvbiQpIHtcclxuICogICB2YXIgdXNlcm5hbWUgPSAkdHJhbnNpdGlvbiQucGFyYW1zKCkudXNlcm5hbWU7XHJcbiAqICAgLy8gLi4gZG8gc29tZXRoaW5nIHdpdGggdXNlcm5hbWVcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogLS0tXHJcbiAqXHJcbiAqIFRoaXMgb2JqZWN0IGNhbiBiZSBpbmplY3RlZCBpbnRvIG90aGVyIHNlcnZpY2VzLlxyXG4gKlxyXG4gKiAjIyMjIERlcHJlY2F0ZWQgRXhhbXBsZTpcclxuICogYGBganNcclxuICogU29tZVNlcnZpY2UuJGluamVjdCA9IFsnJGh0dHAnLCAnJHN0YXRlUGFyYW1zJ107XHJcbiAqIGZ1bmN0aW9uIFNvbWVTZXJ2aWNlKCRodHRwLCAkc3RhdGVQYXJhbXMpIHtcclxuICogICByZXR1cm4ge1xyXG4gKiAgICAgZ2V0VXNlcjogZnVuY3Rpb24oKSB7XHJcbiAqICAgICAgIHJldHVybiAkaHR0cC5nZXQoJy9hcGkvdXNlcnMvJyArICRzdGF0ZVBhcmFtcy51c2VybmFtZSk7XHJcbiAqICAgICB9XHJcbiAqICAgfVxyXG4gKiB9O1xyXG4gKiBhbmd1bGFyLnNlcnZpY2UoJ1NvbWVTZXJ2aWNlJywgU29tZVNlcnZpY2UpO1xyXG4gKiBgYGBcclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbnZhciAkc3RhdGVQYXJhbXM7XHJcbi8qKlxyXG4gKiBHbG9iYWwgVUktUm91dGVyIHZhcmlhYmxlc1xyXG4gKlxyXG4gKiBUaGUgcm91dGVyIGdsb2JhbCBzdGF0ZSBhcyBhICoqU2VydmljZSBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgcnVudGltZSkuXHJcbiAqXHJcbiAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGdsb2JhbHMgc3VjaCBhcyB0aGUgY3VycmVudCBzdGF0ZSBhbmQgY3VycmVudCBwYXJhbWV0ZXIgdmFsdWVzLlxyXG4gKi9cclxudmFyICR1aVJvdXRlckdsb2JhbHM7XHJcbi8qKlxyXG4gKiBUaGUgVUktUm91dGVyIGluc3RhbmNlXHJcbiAqXHJcbiAqIFRoZSBbW1VJUm91dGVyXV0gc2luZ2xldG9uICh0aGUgcm91dGVyIGluc3RhbmNlKSBhcyBhICoqU2VydmljZSBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgcnVudGltZSkuXHJcbiAqXHJcbiAqIFRoaXMgb2JqZWN0IGlzIHRoZSBVSS1Sb3V0ZXIgc2luZ2xldG9uIGluc3RhbmNlLCBjcmVhdGVkIGJ5IGFuZ3VsYXIgZGVwZW5kZW5jeSBpbmplY3Rpb24gZHVyaW5nIGFwcGxpY2F0aW9uIGJvb3RzdHJhcC5cclxuICogSXQgaGFzIHJlZmVyZW5jZXMgdG8gdGhlIG90aGVyIFVJLVJvdXRlciBzZXJ2aWNlc1xyXG4gKlxyXG4gKiAjIyMjIE5vdGU6IFRoaXMgb2JqZWN0IGlzIGFsc28gZXhwb3NlZCBhcyBbWyR1aVJvdXRlclByb3ZpZGVyXV0gZm9yIGluamVjdGlvbiBkdXJpbmcgYW5ndWxhciBjb25maWcgdGltZS5cclxuICovXHJcbnZhciAkdWlSb3V0ZXI7XHJcbi8qKlxyXG4gKiBUaGUgVUktUm91dGVyIGluc3RhbmNlXHJcbiAqXHJcbiAqIFRoZSBbW1VJUm91dGVyXV0gc2luZ2xldG9uICh0aGUgcm91dGVyIGluc3RhbmNlKSBhcyBhICoqUHJvdmlkZXIgT2JqZWN0KiogKGluamVjdGFibGUgZHVyaW5nIGNvbmZpZyBwaGFzZSkuXHJcbiAqXHJcbiAqIFRoaXMgb2JqZWN0IGlzIHRoZSBVSS1Sb3V0ZXIgc2luZ2xldG9uIGluc3RhbmNlLCBjcmVhdGVkIGJ5IGFuZ3VsYXIgZGVwZW5kZW5jeSBpbmplY3Rpb24gZHVyaW5nIGFwcGxpY2F0aW9uIGJvb3RzdHJhcC5cclxuICogSXQgaGFzIHJlZmVyZW5jZXMgdG8gdGhlIG90aGVyIFVJLVJvdXRlciBzZXJ2aWNlc1xyXG4gKlxyXG4gKiAjIyMjIE5vdGU6IFRoaXMgb2JqZWN0IGlzIGFsc28gZXhwb3NlZCBhcyBbWyR1aVJvdXRlcl1dIGZvciBpbmplY3Rpb24gZHVyaW5nIHJ1bnRpbWUuXHJcbiAqL1xyXG52YXIgJHVpUm91dGVyUHJvdmlkZXI7XHJcbi8qKlxyXG4gKiBUcmFuc2l0aW9uIGRlYnVnL3RyYWNpbmdcclxuICpcclxuICogVGhlIFtbVHJhY2VdXSBzaW5nbGV0b24gYXMgYSAqKlNlcnZpY2UgT2JqZWN0KiogKGluamVjdGFibGUgZHVyaW5nIHJ1bnRpbWUpLlxyXG4gKlxyXG4gKiBFbmFibGVzIG9yIGRpc2FibGVzIFRyYW5zaXRpb24gdHJhY2luZyB3aGljaCBjYW4gaGVscCB0byBkZWJ1ZyBpc3N1ZXMuXHJcbiAqL1xyXG52YXIgJHRyYWNlO1xyXG4vKipcclxuICogVGhlIFRyYW5zaXRpb24gU2VydmljZVxyXG4gKlxyXG4gKiBUaGUgW1tUcmFuc2l0aW9uU2VydmljZV1dIHNpbmdsZXRvbiBhcyBhICoqU2VydmljZSBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgcnVudGltZSkuXHJcbiAqXHJcbiAqIFRoaXMgYW5ndWxhciBzZXJ2aWNlIGV4cG9zZXMgdGhlIFtbVHJhbnNpdGlvblNlcnZpY2VdXSBzaW5nbGV0b24sIHdoaWNoIGlzIHByaW1hcmlseVxyXG4gKiB1c2VkIHRvIHJlZ2lzdGVyIGdsb2JhbCB0cmFuc2l0aW9uIGhvb2tzLlxyXG4gKlxyXG4gKiAjIyMjIE5vdGU6IFRoaXMgb2JqZWN0IGlzIGFsc28gZXhwb3NlZCBhcyBbWyR0cmFuc2l0aW9uc1Byb3ZpZGVyXV0gZm9yIGluamVjdGlvbiBkdXJpbmcgdGhlIGNvbmZpZyBwaGFzZS5cclxuICovXHJcbnZhciAkdHJhbnNpdGlvbnM7XHJcbi8qKlxyXG4gKiBUaGUgVHJhbnNpdGlvbiBTZXJ2aWNlXHJcbiAqXHJcbiAqIFRoZSBbW1RyYW5zaXRpb25TZXJ2aWNlXV0gc2luZ2xldG9uIGFzIGEgKipQcm92aWRlciBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgY29uZmlnIHBoYXNlKVxyXG4gKlxyXG4gKiBUaGlzIGFuZ3VsYXIgc2VydmljZSBleHBvc2VzIHRoZSBbW1RyYW5zaXRpb25TZXJ2aWNlXV0gc2luZ2xldG9uLCB3aGljaCBpcyBwcmltYXJpbHlcclxuICogdXNlZCB0byByZWdpc3RlciBnbG9iYWwgdHJhbnNpdGlvbiBob29rcy5cclxuICpcclxuICogIyMjIyBOb3RlOiBUaGlzIG9iamVjdCBpcyBhbHNvIGV4cG9zZWQgYXMgW1skdHJhbnNpdGlvbnNdXSBmb3IgaW5qZWN0aW9uIGR1cmluZyBydW50aW1lLlxyXG4gKi9cclxudmFyICR0cmFuc2l0aW9uc1Byb3ZpZGVyO1xyXG4vKipcclxuICogVGhlIGN1cnJlbnQgW1tUcmFuc2l0aW9uXV0gb2JqZWN0XHJcbiAqXHJcbiAqIFRoZSBjdXJyZW50IFtbVHJhbnNpdGlvbl1dIG9iamVjdCBhcyBhICoqUGVyLVRyYW5zaXRpb24gT2JqZWN0KiogKGluamVjdGFibGUgaW50byBSZXNvbHZlLCBIb29rcywgQ29udHJvbGxlcnMpXHJcbiAqXHJcbiAqIFRoaXMgb2JqZWN0IHJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiwgaW5jbHVkaW5nOlxyXG4gKlxyXG4gKiAtIFRvL2Zyb20gc3RhdGVzXHJcbiAqIC0gVG8vZnJvbSBwYXJhbWV0ZXJzXHJcbiAqIC0gVHJhbnNpdGlvbiBvcHRpb25zXHJcbiAqIC0gU3RhdGVzIGJlaW5nIGVudGVyZWQsIGV4aXRlZCwgYW5kIHJldGFpbmVkXHJcbiAqIC0gUmVzb2x2ZSBkYXRhXHJcbiAqIC0gQSBQcm9taXNlIGZvciB0aGUgdHJhbnNpdGlvblxyXG4gKiAtIEFueSB0cmFuc2l0aW9uIGZhaWx1cmUgaW5mb3JtYXRpb25cclxuICogLSBBbiBpbmplY3RvciBmb3IgYm90aCBTZXJ2aWNlIGFuZCBQZXItVHJhbnNpdGlvbiBPYmplY3RzXHJcbiAqL1xyXG52YXIgJHRyYW5zaXRpb24kO1xyXG4vKipcclxuICogVGhlIFN0YXRlIFNlcnZpY2VcclxuICpcclxuICogVGhlIFtbU3RhdGVTZXJ2aWNlXV0gc2luZ2xldG9uIGFzIGEgKipTZXJ2aWNlIE9iamVjdCoqIChpbmplY3RhYmxlIGR1cmluZyBydW50aW1lKS5cclxuICpcclxuICogVGhpcyBzZXJ2aWNlIHVzZWQgdG8gbWFuYWdlIGFuZCBxdWVyeSBpbmZvcm1hdGlvbiBvbiByZWdpc3RlcmVkIHN0YXRlcy5cclxuICogSXQgZXhwb3NlcyBzdGF0ZSByZWxhdGVkIEFQSXMgaW5jbHVkaW5nOlxyXG4gKlxyXG4gKiAtIFN0YXJ0IGEgW1tUcmFuc2l0aW9uXV1cclxuICogLSBJbXBlcmF0aXZlbHkgbGF6eSBsb2FkIHN0YXRlc1xyXG4gKiAtIENoZWNrIGlmIGEgc3RhdGUgaXMgY3VycmVudGx5IGFjdGl2ZVxyXG4gKiAtIExvb2sgdXAgc3RhdGVzIGJ5IG5hbWVcclxuICogLSBCdWlsZCBVUkxzIGZvciBhIHN0YXRlK3BhcmFtZXRlcnNcclxuICogLSBDb25maWd1cmUgdGhlIGdsb2JhbCBUcmFuc2l0aW9uIGVycm9yIGhhbmRsZXJcclxuICpcclxuICogVGhpcyBhbmd1bGFyIHNlcnZpY2UgZXhwb3NlcyB0aGUgW1tTdGF0ZVNlcnZpY2VdXSBzaW5nbGV0b24uXHJcbiAqL1xyXG52YXIgJHN0YXRlO1xyXG4vKipcclxuICogVGhlIFN0YXRlIFJlZ2lzdHJ5XHJcbiAqXHJcbiAqIFRoZSBbW1N0YXRlUmVnaXN0cnldXSBzaW5nbGV0b24gYXMgYSAqKlNlcnZpY2UgT2JqZWN0KiogKGluamVjdGFibGUgZHVyaW5nIHJ1bnRpbWUpLlxyXG4gKlxyXG4gKiBUaGlzIHNlcnZpY2UgaXMgdXNlZCB0byByZWdpc3Rlci9kZXJlZ2lzdGVyIHN0YXRlcy5cclxuICogSXQgaGFzIHN0YXRlIHJlZ2lzdHJhdGlvbiByZWxhdGVkIEFQSXMgaW5jbHVkaW5nOlxyXG4gKlxyXG4gKiAtIFJlZ2lzdGVyL2RlcmVnaXN0ZXIgc3RhdGVzXHJcbiAqIC0gTGlzdGVuIGZvciBzdGF0ZSByZWdpc3RyYXRpb24vZGVyZWdpc3RyYXRpb25cclxuICogLSBHZXQgc3RhdGVzIGJ5IG5hbWVcclxuICogLSBBZGQgc3RhdGUgZGVjb3JhdG9ycyAodG8gY3VzdG9taXplIHRoZSBzdGF0ZSBjcmVhdGlvbiBwcm9jZXNzKVxyXG4gKlxyXG4gKiAjIyMjIE5vdGU6IFRoaXMgb2JqZWN0IGlzIGFsc28gZXhwb3NlZCBhcyBbWyRzdGF0ZVJlZ2lzdHJ5UHJvdmlkZXJdXSBmb3IgaW5qZWN0aW9uIGR1cmluZyB0aGUgY29uZmlnIHBoYXNlLlxyXG4gKi9cclxudmFyICRzdGF0ZVJlZ2lzdHJ5O1xyXG4vKipcclxuICogVGhlIFN0YXRlIFJlZ2lzdHJ5XHJcbiAqXHJcbiAqIFRoZSBbW1N0YXRlUmVnaXN0cnldXSBzaW5nbGV0b24gYXMgYSAqKlByb3ZpZGVyIE9iamVjdCoqIChpbmplY3RhYmxlIGR1cmluZyBjb25maWcgdGltZSkuXHJcbiAqXHJcbiAqIFRoaXMgc2VydmljZSBpcyB1c2VkIHRvIHJlZ2lzdGVyL2RlcmVnaXN0ZXIgc3RhdGVzLlxyXG4gKiBJdCBoYXMgc3RhdGUgcmVnaXN0cmF0aW9uIHJlbGF0ZWQgQVBJcyBpbmNsdWRpbmc6XHJcbiAqXHJcbiAqIC0gUmVnaXN0ZXIvZGVyZWdpc3RlciBzdGF0ZXNcclxuICogLSBMaXN0ZW4gZm9yIHN0YXRlIHJlZ2lzdHJhdGlvbi9kZXJlZ2lzdHJhdGlvblxyXG4gKiAtIEdldCBzdGF0ZXMgYnkgbmFtZVxyXG4gKiAtIEFkZCBzdGF0ZSBkZWNvcmF0b3JzICh0byBjdXN0b21pemUgdGhlIHN0YXRlIGNyZWF0aW9uIHByb2Nlc3MpXHJcbiAqXHJcbiAqICMjIyMgTm90ZTogVGhpcyBvYmplY3QgaXMgYWxzbyBleHBvc2VkIGFzIFtbJHN0YXRlUmVnaXN0cnldXSBmb3IgaW5qZWN0aW9uIGR1cmluZyBydW50aW1lLlxyXG4gKi9cclxudmFyICRzdGF0ZVJlZ2lzdHJ5UHJvdmlkZXI7XHJcbi8qKlxyXG4gKiBUaGUgVmlldyBTY3JvbGwgcHJvdmlkZXJcclxuICpcclxuICogVGhlIFtbVUlWaWV3U2Nyb2xsUHJvdmlkZXJdXSBhcyBhICoqUHJvdmlkZXIgT2JqZWN0KiogKGluamVjdGFibGUgZHVyaW5nIGNvbmZpZyB0aW1lKS5cclxuICpcclxuICogVGhpcyBhbmd1bGFyIHNlcnZpY2UgZXhwb3NlcyB0aGUgW1tVSVZpZXdTY3JvbGxQcm92aWRlcl1dIHNpbmdsZXRvbiBhbmQgaXNcclxuICogdXNlZCB0byBkaXNhYmxlIFVJLVJvdXRlcidzIHNjcm9sbCBiZWhhdmlvci5cclxuICovXHJcbnZhciAkdWlWaWV3U2Nyb2xsUHJvdmlkZXI7XHJcbi8qKlxyXG4gKiBUaGUgVmlldyBTY3JvbGwgZnVuY3Rpb25cclxuICpcclxuICogVGhlIFZpZXcgU2Nyb2xsIGZ1bmN0aW9uIGFzIGEgKipTZXJ2aWNlIE9iamVjdCoqIChpbmplY3RhYmxlIGR1cmluZyBydW50aW1lKS5cclxuICpcclxuICogVGhpcyBpcyBhIGZ1bmN0aW9uIHRoYXQgc2Nyb2xscyBhbiBlbGVtZW50IGludG8gdmlldy5cclxuICogVGhlIGVsZW1lbnQgaXMgc2Nyb2xsZWQgYWZ0ZXIgYSBgJHRpbWVvdXRgIHNvIHRoZSBET00gaGFzIHRpbWUgdG8gcmVmcmVzaC5cclxuICpcclxuICogSWYgeW91IHByZWZlciB0byByZWx5IG9uIGAkYW5jaG9yU2Nyb2xsYCB0byBzY3JvbGwgdGhlIHZpZXcgdG8gdGhlIGFuY2hvcixcclxuICogdGhpcyBjYW4gYmUgZW5hYmxlZCBieSBjYWxsaW5nIFtbVUlWaWV3U2Nyb2xsUHJvdmlkZXIudXNlQW5jaG9yU2Nyb2xsXV0uXHJcbiAqXHJcbiAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSB0aGUgW1tkaXJlY3RpdmVzLnVpVmlld11dIHdoZW4gdGhlIGBhdXRvc2Nyb2xsYCBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlLlxyXG4gKi9cclxudmFyICR1aVZpZXdTY3JvbGw7XHJcbi8qKlxyXG4gKiBUaGUgU3RhdGVQcm92aWRlclxyXG4gKlxyXG4gKiBBbiBhbmd1bGFyMS1vbmx5IFtbU3RhdGVQcm92aWRlcl1dIGFzIGEgKipQcm92aWRlciBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgY29uZmlnIHRpbWUpLlxyXG4gKlxyXG4gKiBUaGlzIGFuZ3VsYXIgc2VydmljZSBleHBvc2VzIHRoZSBbW1N0YXRlUHJvdmlkZXJdXSBzaW5nbGV0b24uXHJcbiAqXHJcbiAqIFRoZSBgU3RhdGVQcm92aWRlcmAgaXMgcHJpbWFyaWx5IHVzZWQgdG8gcmVnaXN0ZXIgc3RhdGVzIG9yIGFkZCBjdXN0b20gc3RhdGUgZGVjb3JhdG9ycy5cclxuICpcclxuICogIyMjIyMgTm90ZTogVGhpcyBwcm92aWRlciBpcyBhIG5nMSB2ZXN0aWdlLlxyXG4gKiBJdCBpcyBhIHBhc3N0aHJvdWdoIHRvIFtbJHN0YXRlUmVnaXN0cnldXSBhbmQgW1skc3RhdGVdXS5cclxuICovXHJcbnZhciAkc3RhdGVQcm92aWRlcjtcclxuLyoqXHJcbiAqIFRoZSBVUkwgU2VydmljZSBQcm92aWRlclxyXG4gKlxyXG4gKiBUaGUgW1tVcmxTZXJ2aWNlXV0gc2luZ2xldG9uIGFzIGEgKipQcm92aWRlciBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgdGhlIGFuZ3VsYXIgY29uZmlnIHBoYXNlKS5cclxuICpcclxuICogQSBzZXJ2aWNlIHVzZWQgdG8gY29uZmlndXJlIGFuZCBpbnRlcmFjdCB3aXRoIHRoZSBVUkwuXHJcbiAqIEl0IGhhcyBVUkwgcmVsYXRlZCBBUElzIGluY2x1ZGluZzpcclxuICpcclxuICogLSByZWdpc3RlciBjdXN0b20gUGFyYW1ldGVyIHR5cGVzIGBVcmxTZXJ2aWNlLmNvbmZpZy50eXBlYCAoW1tVcmxDb25maWdBcGkudHlwZV1dKVxyXG4gKiAtIGFkZCBVUkwgcnVsZXM6IGBVcmxTZXJ2aWNlLnJ1bGVzLndoZW5gIChbW1VybFJ1bGVzQXBpLndoZW5dXSlcclxuICogLSBjb25maWd1cmUgYmVoYXZpb3Igd2hlbiBubyB1cmwgbWF0Y2hlczogYFVybFNlcnZpY2UucnVsZXMub3RoZXJ3aXNlYCAoW1tVcmxSdWxlc0FwaS5vdGhlcndpc2VdXSlcclxuICogLSBkZWxheSBpbml0aWFsIFVSTCBzeW5jaHJvbml6YXRpb24gW1tVcmxTZXJ2aWNlLmRlZmVySW50ZXJjZXB0XV0uXHJcbiAqIC0gZ2V0IG9yIHNldCB0aGUgY3VycmVudCB1cmw6IFtbVXJsU2VydmljZS51cmxdXVxyXG4gKlxyXG4gKiAjIyMjIyBOb3RlOiBUaGlzIHNlcnZpY2UgY2FuIGFsc28gYmUgaW5qZWN0ZWQgZHVyaW5nIHJ1bnRpbWUgYXMgW1skdXJsU2VydmljZV1dLlxyXG4gKi9cclxudmFyICR1cmxTZXJ2aWNlUHJvdmlkZXI7XHJcbi8qKlxyXG4gKiBUaGUgVVJMIFNlcnZpY2VcclxuICpcclxuICogVGhlIFtbVXJsU2VydmljZV1dIHNpbmdsZXRvbiBhcyBhICoqU2VydmljZSBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgcnVudGltZSkuXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgc2VydmljZSBjYW4gYWxzbyBiZSBpbmplY3RlZCBkdXJpbmcgdGhlIGNvbmZpZyBwaGFzZSBhcyBbWyR1cmxTZXJ2aWNlUHJvdmlkZXJdXS5cclxuICpcclxuICogVXNlZCB0byBjb25maWd1cmUgdGhlIFVSTC5cclxuICogSXQgaGFzIFVSTCByZWxhdGVkIEFQSXMgaW5jbHVkaW5nOlxyXG4gKlxyXG4gKiAtIHJlZ2lzdGVyIGN1c3RvbSBQYXJhbWV0ZXIgdHlwZXMgYFVybFNlcnZpY2UuY29uZmlnLnR5cGVgIChbW1VybENvbmZpZ0FwaS50eXBlXV0pXHJcbiAqIC0gYWRkIFVSTCBydWxlczogYFVybFNlcnZpY2UucnVsZXMud2hlbmAgKFtbVXJsUnVsZXNBcGkud2hlbl1dKVxyXG4gKiAtIGNvbmZpZ3VyZSBiZWhhdmlvciB3aGVuIG5vIHVybCBtYXRjaGVzOiBgVXJsU2VydmljZS5ydWxlcy5vdGhlcndpc2VgIChbW1VybFJ1bGVzQXBpLm90aGVyd2lzZV1dKVxyXG4gKiAtIGRlbGF5IGluaXRpYWwgVVJMIHN5bmNocm9uaXphdGlvbiBbW1VybFNlcnZpY2UuZGVmZXJJbnRlcmNlcHRdXS5cclxuICogLSBnZXQgb3Igc2V0IHRoZSBjdXJyZW50IHVybDogW1tVcmxTZXJ2aWNlLnVybF1dXHJcbiAqXHJcbiAqICMjIyMjIE5vdGU6IFRoaXMgc2VydmljZSBjYW4gYWxzbyBiZSBpbmplY3RlZCBkdXJpbmcgdGhlIGNvbmZpZyBwaGFzZSBhcyBbWyR1cmxTZXJ2aWNlUHJvdmlkZXJdXS5cclxuICovXHJcbnZhciAkdXJsU2VydmljZTtcclxuLyoqXHJcbiAqIFRoZSBVUkwgUm91dGVyIFByb3ZpZGVyXHJcbiAqXHJcbiAqICMjIyBEZXByZWNhdGlvbiB3YXJuaW5nOiBUaGlzIG9iamVjdCBpcyBub3cgY29uc2lkZXJlZCBpbnRlcm5hbC4gVXNlIFtbJHVybFNlcnZpY2VQcm92aWRlcl1dIGluc3RlYWQuXHJcbiAqXHJcbiAqIFRoZSBbW1VybFJvdXRlcl1dIHNpbmdsZXRvbiBhcyBhICoqUHJvdmlkZXIgT2JqZWN0KiogKGluamVjdGFibGUgZHVyaW5nIGNvbmZpZyB0aW1lKS5cclxuICpcclxuICogIyMjIyBOb3RlOiBUaGlzIG9iamVjdCBpcyBhbHNvIGV4cG9zZWQgYXMgW1skdXJsUm91dGVyXV0gZm9yIGluamVjdGlvbiBkdXJpbmcgcnVudGltZS5cclxuICpcclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbnZhciAkdXJsUm91dGVyUHJvdmlkZXI7XHJcbi8qKlxyXG4gKiBUaGUgVXJsIFJvdXRlclxyXG4gKlxyXG4gKiAjIyMgRGVwcmVjYXRpb24gd2FybmluZzogVGhpcyBvYmplY3QgaXMgbm93IGNvbnNpZGVyZWQgaW50ZXJuYWwuIFVzZSBbWyR1cmxTZXJ2aWNlXV0gaW5zdGVhZC5cclxuICpcclxuICogVGhlIFtbVXJsUm91dGVyXV0gc2luZ2xldG9uIGFzIGEgKipTZXJ2aWNlIE9iamVjdCoqIChpbmplY3RhYmxlIGR1cmluZyBydW50aW1lKS5cclxuICpcclxuICogIyMjIyBOb3RlOiBUaGlzIG9iamVjdCBpcyBhbHNvIGV4cG9zZWQgYXMgW1skdXJsUm91dGVyUHJvdmlkZXJdXSBmb3IgaW5qZWN0aW9uIGR1cmluZyBhbmd1bGFyIGNvbmZpZyB0aW1lLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKi9cclxudmFyICR1cmxSb3V0ZXI7XHJcbi8qKlxyXG4gKiBUaGUgVVJMIE1hdGNoZXIgRmFjdG9yeVxyXG4gKlxyXG4gKiAjIyMgRGVwcmVjYXRpb24gd2FybmluZzogVGhpcyBvYmplY3QgaXMgbm93IGNvbnNpZGVyZWQgaW50ZXJuYWwuIFVzZSBbWyR1cmxTZXJ2aWNlXV0gaW5zdGVhZC5cclxuICpcclxuICogVGhlIFtbVXJsTWF0Y2hlckZhY3RvcnldXSBzaW5nbGV0b24gYXMgYSAqKlNlcnZpY2UgT2JqZWN0KiogKGluamVjdGFibGUgZHVyaW5nIHJ1bnRpbWUpLlxyXG4gKlxyXG4gKiBUaGlzIHNlcnZpY2UgaXMgdXNlZCB0byBzZXQgdXJsIG1hcHBpbmcgb3B0aW9ucywgZGVmaW5lIGN1c3RvbSBwYXJhbWV0ZXIgdHlwZXMsIGFuZCBjcmVhdGUgW1tVcmxNYXRjaGVyXV0gb2JqZWN0cy5cclxuICpcclxuICogIyMjIyBOb3RlOiBUaGlzIG9iamVjdCBpcyBhbHNvIGV4cG9zZWQgYXMgW1skdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlcl1dIGZvciBpbmplY3Rpb24gZHVyaW5nIGFuZ3VsYXIgY29uZmlnIHRpbWUuXHJcbiAqXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqL1xyXG52YXIgJHVybE1hdGNoZXJGYWN0b3J5O1xyXG4vKipcclxuICogVGhlIFVSTCBNYXRjaGVyIEZhY3RvcnlcclxuICpcclxuICogIyMjIERlcHJlY2F0aW9uIHdhcm5pbmc6IFRoaXMgb2JqZWN0IGlzIG5vdyBjb25zaWRlcmVkIGludGVybmFsLiBVc2UgW1skdXJsU2VydmljZV1dIGluc3RlYWQuXHJcbiAqXHJcbiAqIFRoZSBbW1VybE1hdGNoZXJGYWN0b3J5XV0gc2luZ2xldG9uIGFzIGEgKipQcm92aWRlciBPYmplY3QqKiAoaW5qZWN0YWJsZSBkdXJpbmcgY29uZmlnIHRpbWUpLlxyXG4gKlxyXG4gKiBUaGlzIHNlcnZpY2UgaXMgdXNlZCB0byBzZXQgdXJsIG1hcHBpbmcgb3B0aW9ucywgZGVmaW5lIGN1c3RvbSBwYXJhbWV0ZXIgdHlwZXMsIGFuZCBjcmVhdGUgW1tVcmxNYXRjaGVyXV0gb2JqZWN0cy5cclxuICpcclxuICogIyMjIyBOb3RlOiBUaGlzIG9iamVjdCBpcyBhbHNvIGV4cG9zZWQgYXMgW1skdXJsTWF0Y2hlckZhY3RvcnldXSBmb3IgaW5qZWN0aW9uIGR1cmluZyBydW50aW1lLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKi9cclxudmFyICR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RhYmxlcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2FuZ3VsYXItdWktcm91dGVyL2xpYi9pbmplY3RhYmxlcy5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAdWlyb3V0ZXIvY29yZVwiKTtcclxuLyoqXHJcbiAqIEltcGxlbWVudHMgVUktUm91dGVyIExvY2F0aW9uU2VydmljZXMgYW5kIExvY2F0aW9uQ29uZmlnIHVzaW5nIEFuZ3VsYXIgMSdzICRsb2NhdGlvbiBzZXJ2aWNlXHJcbiAqL1xyXG52YXIgTmcxTG9jYXRpb25TZXJ2aWNlcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZzFMb2NhdGlvblNlcnZpY2VzKCRsb2NhdGlvblByb3ZpZGVyKSB7XHJcbiAgICAgICAgLy8gLm9uQ2hhbmdlKCkgcmVnaXN0cnlcclxuICAgICAgICB0aGlzLl91cmxMaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICB0aGlzLiRsb2NhdGlvblByb3ZpZGVyID0gJGxvY2F0aW9uUHJvdmlkZXI7XHJcbiAgICAgICAgdmFyIF9scCA9IGNvcmVfMS52YWwoJGxvY2F0aW9uUHJvdmlkZXIpO1xyXG4gICAgICAgIGNvcmVfMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhfbHAsIHRoaXMsIF9scCwgWydoYXNoUHJlZml4J10pO1xyXG4gICAgfVxyXG4gICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIE5nMUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl91cmxMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVfMS5yZW1vdmVGcm9tKF90aGlzLl91cmxMaXN0ZW5lcnMpKGNhbGxiYWNrKTsgfTtcclxuICAgIH07XHJcbiAgICBOZzFMb2NhdGlvblNlcnZpY2VzLnByb3RvdHlwZS5odG1sNU1vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGh0bWw1TW9kZSA9IHRoaXMuJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKCk7XHJcbiAgICAgICAgaHRtbDVNb2RlID0gY29yZV8xLmlzT2JqZWN0KGh0bWw1TW9kZSkgPyBodG1sNU1vZGUuZW5hYmxlZCA6IGh0bWw1TW9kZTtcclxuICAgICAgICByZXR1cm4gaHRtbDVNb2RlICYmIHRoaXMuJHNuaWZmZXIuaGlzdG9yeTtcclxuICAgIH07XHJcbiAgICBOZzFMb2NhdGlvblNlcnZpY2VzLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbiAobmV3VXJsLCByZXBsYWNlLCBzdGF0ZSkge1xyXG4gICAgICAgIGlmIChyZXBsYWNlID09PSB2b2lkIDApIHsgcmVwbGFjZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKG5ld1VybClcclxuICAgICAgICAgICAgdGhpcy4kbG9jYXRpb24udXJsKG5ld1VybCk7XHJcbiAgICAgICAgaWYgKHJlcGxhY2UpXHJcbiAgICAgICAgICAgIHRoaXMuJGxvY2F0aW9uLnJlcGxhY2UoKTtcclxuICAgICAgICBpZiAoc3RhdGUpXHJcbiAgICAgICAgICAgIHRoaXMuJGxvY2F0aW9uLnN0YXRlKHN0YXRlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy4kbG9jYXRpb24udXJsKCk7XHJcbiAgICB9O1xyXG4gICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUuX3J1bnRpbWVTZXJ2aWNlcyA9IGZ1bmN0aW9uICgkcm9vdFNjb3BlLCAkbG9jYXRpb24sICRzbmlmZmVyLCAkYnJvd3Nlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kbG9jYXRpb24gPSAkbG9jYXRpb247XHJcbiAgICAgICAgdGhpcy4kc25pZmZlciA9ICRzbmlmZmVyO1xyXG4gICAgICAgIC8vIEJpbmQgJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcyB0byB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgaW4gTG9jYXRpb25TZXJ2aWNlLm9uQ2hhbmdlXHJcbiAgICAgICAgJHJvb3RTY29wZS4kb24oXCIkbG9jYXRpb25DaGFuZ2VTdWNjZXNzXCIsIGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuIF90aGlzLl91cmxMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKGV2dCk7IH0pOyB9KTtcclxuICAgICAgICB2YXIgX2xvYyA9IGNvcmVfMS52YWwoJGxvY2F0aW9uKTtcclxuICAgICAgICB2YXIgX2Jyb3dzZXIgPSBjb3JlXzEudmFsKCRicm93c2VyKTtcclxuICAgICAgICAvLyBCaW5kIHRoZXNlIExvY2F0aW9uU2VydmljZSBmdW5jdGlvbnMgdG8gJGxvY2F0aW9uXHJcbiAgICAgICAgY29yZV8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9sb2MsIHRoaXMsIF9sb2MsIFtcInJlcGxhY2VcIiwgXCJwYXRoXCIsIFwic2VhcmNoXCIsIFwiaGFzaFwiXSk7XHJcbiAgICAgICAgLy8gQmluZCB0aGVzZSBMb2NhdGlvbkNvbmZpZyBmdW5jdGlvbnMgdG8gJGxvY2F0aW9uXHJcbiAgICAgICAgY29yZV8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9sb2MsIHRoaXMsIF9sb2MsIFsncG9ydCcsICdwcm90b2NvbCcsICdob3N0J10pO1xyXG4gICAgICAgIC8vIEJpbmQgdGhlc2UgTG9jYXRpb25Db25maWcgZnVuY3Rpb25zIHRvICRicm93c2VyXHJcbiAgICAgICAgY29yZV8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9icm93c2VyLCB0aGlzLCBfYnJvd3NlciwgWydiYXNlSHJlZiddKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5cyBuZzEtc3BlY2lmaWMgcGF0aCBwYXJhbWV0ZXIgZW5jb2RpbmdcclxuICAgICAqXHJcbiAgICAgKiBUaGUgQW5ndWxhciAxIGAkbG9jYXRpb25gIHNlcnZpY2UgaXMgYSBiaXQgd2VpcmQuXHJcbiAgICAgKiBJdCBkb2Vzbid0IGFsbG93IHNsYXNoZXMgdG8gYmUgZW5jb2RlZC9kZWNvZGVkIGJpLWRpcmVjdGlvbmFsbHkuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIHRoZSB3cml0ZXVwIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL3VpLXJvdXRlci9pc3N1ZXMvMjU5OFxyXG4gICAgICpcclxuICAgICAqIFRoaXMgY29kZSBwYXRjaGVzIHRoZSBgcGF0aGAgcGFyYW1ldGVyIHR5cGUgc28gaXQgZW5jb2RlZC9kZWNvZGVzIHNsYXNoZXMgYXMgfjJGXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJvdXRlclxyXG4gICAgICovXHJcbiAgICBOZzFMb2NhdGlvblNlcnZpY2VzLm1vbmtleVBhdGNoUGF0aFBhcmFtZXRlclR5cGUgPSBmdW5jdGlvbiAocm91dGVyKSB7XHJcbiAgICAgICAgdmFyIHBhdGhUeXBlID0gcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5LnR5cGUoJ3BhdGgnKTtcclxuICAgICAgICBwYXRoVHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWwgIT0gbnVsbCA/IHZhbC50b1N0cmluZygpLnJlcGxhY2UoLyh+fFxcLykvZywgZnVuY3Rpb24gKG0pIHsgcmV0dXJuICh7ICd+JzogJ35+JywgJy8nOiAnfjJGJyB9W21dKTsgfSkgOiB2YWw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwYXRoVHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWwgIT0gbnVsbCA/IHZhbC50b1N0cmluZygpLnJlcGxhY2UoLyh+fnx+MkYpL2csIGZ1bmN0aW9uIChtKSB7IHJldHVybiAoeyAnfn4nOiAnficsICd+MkYnOiAnLycgfVttXSk7IH0pIDogdmFsO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5nMUxvY2F0aW9uU2VydmljZXM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTmcxTG9jYXRpb25TZXJ2aWNlcyA9IE5nMUxvY2F0aW9uU2VydmljZXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2F0aW9uU2VydmljZXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9hbmd1bGFyLXVpLXJvdXRlci9saWIvbG9jYXRpb25TZXJ2aWNlcy5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKiBAbW9kdWxlIG5nMSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgYW5ndWxhcl8xID0gcmVxdWlyZShcIi4vYW5ndWxhclwiKTtcclxuLyoqXHJcbiAqIGBpc1N0YXRlYCBGaWx0ZXI6IHRydXRoeSBpZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB0aGUgcGFyYW1ldGVyXHJcbiAqXHJcbiAqIFRyYW5zbGF0ZXMgdG8gW1tTdGF0ZVNlcnZpY2UuaXNdXSBgJHN0YXRlLmlzKFwic3RhdGVOYW1lXCIpYC5cclxuICpcclxuICogIyMjIyBFeGFtcGxlOlxyXG4gKiBgYGBodG1sXHJcbiAqIDxkaXYgbmctaWY9XCInc3RhdGVOYW1lJyB8IGlzU3RhdGVcIj5zaG93IGlmIHN0YXRlIGlzICdzdGF0ZU5hbWUnPC9kaXY+XHJcbiAqIGBgYFxyXG4gKi9cclxuJElzU3RhdGVGaWx0ZXIuJGluamVjdCA9IFsnJHN0YXRlJ107XHJcbmZ1bmN0aW9uICRJc1N0YXRlRmlsdGVyKCRzdGF0ZSkge1xyXG4gICAgdmFyIGlzRmlsdGVyID0gZnVuY3Rpb24gKHN0YXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gJHN0YXRlLmlzKHN0YXRlLCBwYXJhbXMsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIGlzRmlsdGVyLiRzdGF0ZWZ1bCA9IHRydWU7XHJcbiAgICByZXR1cm4gaXNGaWx0ZXI7XHJcbn1cclxuZXhwb3J0cy4kSXNTdGF0ZUZpbHRlciA9ICRJc1N0YXRlRmlsdGVyO1xyXG4vKipcclxuICogYGluY2x1ZGVkQnlTdGF0ZWAgRmlsdGVyOiB0cnV0aHkgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaW5jbHVkZXMgdGhlIHBhcmFtZXRlclxyXG4gKlxyXG4gKiBUcmFuc2xhdGVzIHRvIFtbU3RhdGVTZXJ2aWNlLmluY2x1ZGVzXV1gICRzdGF0ZS5pcyhcImZ1bGxPclBhcnRpYWxTdGF0ZU5hbWVcIilgLlxyXG4gKlxyXG4gKiAjIyMjIEV4YW1wbGU6XHJcbiAqIGBgYGh0bWxcclxuICogPGRpdiBuZy1pZj1cIidmdWxsT3JQYXJ0aWFsU3RhdGVOYW1lJyB8IGluY2x1ZGVkQnlTdGF0ZVwiPnNob3cgaWYgc3RhdGUgaW5jbHVkZXMgJ2Z1bGxPclBhcnRpYWxTdGF0ZU5hbWUnPC9kaXY+XHJcbiAqIGBgYFxyXG4gKi9cclxuJEluY2x1ZGVkQnlTdGF0ZUZpbHRlci4kaW5qZWN0ID0gWyckc3RhdGUnXTtcclxuZnVuY3Rpb24gJEluY2x1ZGVkQnlTdGF0ZUZpbHRlcigkc3RhdGUpIHtcclxuICAgIHZhciBpbmNsdWRlc0ZpbHRlciA9IGZ1bmN0aW9uIChzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuICRzdGF0ZS5pbmNsdWRlcyhzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBpbmNsdWRlc0ZpbHRlci4kc3RhdGVmdWwgPSB0cnVlO1xyXG4gICAgcmV0dXJuIGluY2x1ZGVzRmlsdGVyO1xyXG59XHJcbmV4cG9ydHMuJEluY2x1ZGVkQnlTdGF0ZUZpbHRlciA9ICRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXI7XHJcbmFuZ3VsYXJfMS5uZy5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXHJcbiAgICAuZmlsdGVyKCdpc1N0YXRlJywgJElzU3RhdGVGaWx0ZXIpXHJcbiAgICAuZmlsdGVyKCdpbmNsdWRlZEJ5U3RhdGUnLCAkSW5jbHVkZWRCeVN0YXRlRmlsdGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVGaWx0ZXJzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL3N0YXRlRmlsdGVycy5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqIEBtb2R1bGUgbmcxICovIC8qKiAqL1xyXG52YXIgY29yZV8xID0gcmVxdWlyZShcIkB1aXJvdXRlci9jb3JlXCIpO1xyXG52YXIgc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9zZXJ2aWNlc1wiKTtcclxuLyoqXHJcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIGFuZ3VsYXIxIGBvbkVudGVyYCwgYG9uRXhpdGAsXHJcbiAqIGBvblJldGFpbmAgY2FsbGJhY2sgaG9va3Mgb24gYSBbW05nMVN0YXRlRGVjbGFyYXRpb25dXS5cclxuICpcclxuICogV2hlbiB0aGUgW1tTdGF0ZUJ1aWxkZXJdXSBidWlsZHMgYSBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGZyb20gYSByYXcgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoaXMgYnVpbGRlclxyXG4gKiBlbnN1cmVzIHRoYXQgdGhvc2UgaG9va3MgYXJlIGluamVjdGFibGUgZm9yIEB1aXJvdXRlci9hbmd1bGFyanMgKG5nMSkuXHJcbiAqL1xyXG5leHBvcnRzLmdldFN0YXRlSG9va0J1aWxkZXIgPSBmdW5jdGlvbiAoaG9va05hbWUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBzdGF0ZUhvb2tCdWlsZGVyKHN0YXRlLCBwYXJlbnRGbikge1xyXG4gICAgICAgIHZhciBob29rID0gc3RhdGVbaG9va05hbWVdO1xyXG4gICAgICAgIHZhciBwYXRobmFtZSA9IGhvb2tOYW1lID09PSAnb25FeGl0JyA/ICdmcm9tJyA6ICd0byc7XHJcbiAgICAgICAgZnVuY3Rpb24gZGVjb3JhdGVkTmcxSG9vayh0cmFucywgc3RhdGUpIHtcclxuICAgICAgICAgICAgdmFyIHJlc29sdmVDb250ZXh0ID0gbmV3IGNvcmVfMS5SZXNvbHZlQ29udGV4dCh0cmFucy50cmVlQ2hhbmdlcyhwYXRobmFtZSkpO1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxzID0gY29yZV8xLmV4dGVuZChzZXJ2aWNlc18xLmdldExvY2FscyhyZXNvbHZlQ29udGV4dCksIHsgJHN0YXRlJDogc3RhdGUsICR0cmFuc2l0aW9uJDogdHJhbnMgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb3JlXzEuc2VydmljZXMuJGluamVjdG9yLmludm9rZShob29rLCB0aGlzLCBsb2NhbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaG9vayA/IGRlY29yYXRlZE5nMUhvb2sgOiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbkVudGVyRXhpdFJldGFpbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2FuZ3VsYXItdWktcm91dGVyL2xpYi9zdGF0ZWJ1aWxkZXJzL29uRW50ZXJFeGl0UmV0YWluLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKiogQG1vZHVsZSB2aWV3ICovXHJcbi8qKiBmb3IgdHlwZWRvYyAqL1xyXG52YXIgYW5ndWxhcl8xID0gcmVxdWlyZShcIi4vYW5ndWxhclwiKTtcclxudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAdWlyb3V0ZXIvY29yZVwiKTtcclxuLyoqXHJcbiAqIFNlcnZpY2Ugd2hpY2ggbWFuYWdlcyBsb2FkaW5nIG9mIHRlbXBsYXRlcyBmcm9tIGEgVmlld0NvbmZpZy5cclxuICovXHJcbnZhciBUZW1wbGF0ZUZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVGYWN0b3J5KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fdXNlSHR0cCA9IGFuZ3VsYXJfMS5uZy52ZXJzaW9uLm1pbm9yIDwgMztcclxuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLiRnZXQgPSBbJyRodHRwJywgJyR0ZW1wbGF0ZUNhY2hlJywgJyRpbmplY3RvcicsIGZ1bmN0aW9uICgkaHR0cCwgJHRlbXBsYXRlQ2FjaGUsICRpbmplY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuJHRlbXBsYXRlUmVxdWVzdCA9ICRpbmplY3Rvci5oYXMgJiYgJGluamVjdG9yLmhhcygnJHRlbXBsYXRlUmVxdWVzdCcpICYmICRpbmplY3Rvci5nZXQoJyR0ZW1wbGF0ZVJlcXVlc3QnKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLiRodHRwID0gJGh0dHA7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy4kdGVtcGxhdGVDYWNoZSA9ICR0ZW1wbGF0ZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICB9XTtcclxuICAgIH1cclxuICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICBUZW1wbGF0ZUZhY3RvcnkucHJvdG90eXBlLnVzZUh0dHBTZXJ2aWNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlSHR0cCA9IHZhbHVlO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGZyb20gYSBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB3aGljaCB0byBsb2FkIGEgdGVtcGxhdGUuXHJcbiAgICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIHNlYXJjaCBpbiB0aGUgc3BlY2lmaWVkIG9yZGVyLCBhbmQgdGhlIGZpcnN0IG9uZVxyXG4gICAgICogdGhhdCBpcyBkZWZpbmVkIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSB0ZW1wbGF0ZTpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zICBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIHJlc29sdmUgY29udGV4dCBhc3NvY2lhdGVkIHdpdGggdGhlIHRlbXBsYXRlJ3Mgdmlld1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xvYmplY3R9ICBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIGZvclxyXG4gICAgICogdGhhdCBzdHJpbmcsb3IgYG51bGxgIGlmIG5vIHRlbXBsYXRlIGlzIGNvbmZpZ3VyZWQuXHJcbiAgICAgKi9cclxuICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcsIHBhcmFtcywgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBkZWZhdWx0VGVtcGxhdGUgPSBcIjx1aS12aWV3PjwvdWktdmlldz5cIjtcclxuICAgICAgICB2YXIgYXNUZW1wbGF0ZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIGNvcmVfMS5zZXJ2aWNlcy4kcS53aGVuKHJlc3VsdCkudGhlbihmdW5jdGlvbiAoc3RyKSB7IHJldHVybiAoeyB0ZW1wbGF0ZTogc3RyIH0pOyB9KTsgfTtcclxuICAgICAgICB2YXIgYXNDb21wb25lbnQgPSBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBjb3JlXzEuc2VydmljZXMuJHEud2hlbihyZXN1bHQpLnRoZW4oZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gKHsgY29tcG9uZW50OiBzdHIgfSk7IH0pOyB9O1xyXG4gICAgICAgIHJldHVybiAoY29yZV8xLmlzRGVmaW5lZChjb25maWcudGVtcGxhdGUpID8gYXNUZW1wbGF0ZSh0aGlzLmZyb21TdHJpbmcoY29uZmlnLnRlbXBsYXRlLCBwYXJhbXMpKSA6XHJcbiAgICAgICAgICAgIGNvcmVfMS5pc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlVXJsKSA/IGFzVGVtcGxhdGUodGhpcy5mcm9tVXJsKGNvbmZpZy50ZW1wbGF0ZVVybCwgcGFyYW1zKSkgOlxyXG4gICAgICAgICAgICAgICAgY29yZV8xLmlzRGVmaW5lZChjb25maWcudGVtcGxhdGVQcm92aWRlcikgPyBhc1RlbXBsYXRlKHRoaXMuZnJvbVByb3ZpZGVyKGNvbmZpZy50ZW1wbGF0ZVByb3ZpZGVyLCBwYXJhbXMsIGNvbnRleHQpKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgY29yZV8xLmlzRGVmaW5lZChjb25maWcuY29tcG9uZW50KSA/IGFzQ29tcG9uZW50KGNvbmZpZy5jb21wb25lbnQpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29yZV8xLmlzRGVmaW5lZChjb25maWcuY29tcG9uZW50UHJvdmlkZXIpID8gYXNDb21wb25lbnQodGhpcy5mcm9tQ29tcG9uZW50UHJvdmlkZXIoY29uZmlnLmNvbXBvbmVudFByb3ZpZGVyLCBwYXJhbXMsIGNvbnRleHQpKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc1RlbXBsYXRlKGRlZmF1bHRUZW1wbGF0ZSkpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGZyb20gYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdGVtcGxhdGUgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfG9iamVjdH0gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZSBmb3IgdGhhdFxyXG4gICAgICogc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBUZW1wbGF0ZUZhY3RvcnkucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBjb3JlXzEuaXNGdW5jdGlvbih0ZW1wbGF0ZSkgPyB0ZW1wbGF0ZShwYXJhbXMpIDogdGVtcGxhdGU7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIHRlbXBsYXRlIGZyb20gdGhlIGEgVVJMIHZpYSBgJGh0dHBgIGFuZCBgJHRlbXBsYXRlQ2FjaGVgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSB1cmwgdXJsIG9mIHRoZSB0ZW1wbGF0ZSB0byBsb2FkLCBvciBhIGZ1bmN0aW9uXHJcbiAgICAgKiB0aGF0IHJldHVybnMgYSB1cmwuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdXJsIGZ1bmN0aW9uLlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfFByb21pc2UuPHN0cmluZz59IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2VcclxuICAgICAqIGZvciB0aGF0IHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tVXJsID0gZnVuY3Rpb24gKHVybCwgcGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKGNvcmVfMS5pc0Z1bmN0aW9uKHVybCkpXHJcbiAgICAgICAgICAgIHVybCA9IHVybChwYXJhbXMpO1xyXG4gICAgICAgIGlmICh1cmwgPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMuX3VzZUh0dHApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGh0dHAuZ2V0KHVybCwgeyBjYWNoZTogdGhpcy4kdGVtcGxhdGVDYWNoZSwgaGVhZGVyczogeyBBY2NlcHQ6ICd0ZXh0L2h0bWwnIH0gfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy4kdGVtcGxhdGVSZXF1ZXN0KHVybCk7XHJcbiAgICB9O1xyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgdGVtcGxhdGUgYnkgaW52b2tpbmcgYW4gaW5qZWN0YWJsZSBwcm92aWRlciBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXIgRnVuY3Rpb24gdG8gaW52b2tlIHZpYSBgbG9jYWxzYFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW5qZWN0Rm4gYSBmdW5jdGlvbiB1c2VkIHRvIGludm9rZSB0aGUgdGVtcGxhdGUgcHJvdmlkZXJcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xQcm9taXNlLjxzdHJpbmc+fSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlXHJcbiAgICAgKiBmb3IgdGhhdCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUuZnJvbVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBwYXJhbXMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgZGVwcyA9IGNvcmVfMS5zZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUocHJvdmlkZXIpO1xyXG4gICAgICAgIHZhciBwcm92aWRlckZuID0gY29yZV8xLmlzQXJyYXkocHJvdmlkZXIpID8gY29yZV8xLnRhaWwocHJvdmlkZXIpIDogcHJvdmlkZXI7XHJcbiAgICAgICAgdmFyIHJlc29sdmFibGUgPSBuZXcgY29yZV8xLlJlc29sdmFibGUoXCJcIiwgcHJvdmlkZXJGbiwgZGVwcyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmFibGUuZ2V0KGNvbnRleHQpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNvbXBvbmVudCdzIHRlbXBsYXRlIGJ5IGludm9raW5nIGFuIGluamVjdGFibGUgcHJvdmlkZXIgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3ZpZGVyIEZ1bmN0aW9uIHRvIGludm9rZSB2aWEgYGxvY2Fsc2BcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGluamVjdEZuIGEgZnVuY3Rpb24gdXNlZCB0byBpbnZva2UgdGhlIHRlbXBsYXRlIHByb3ZpZGVyXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nOiBcIjxjb21wb25lbnQtbmFtZSBpbnB1dDE9Jzo6JHJlc29sdmUuZm9vJz48L2NvbXBvbmVudC1uYW1lPlwiLlxyXG4gICAgICovXHJcbiAgICBUZW1wbGF0ZUZhY3RvcnkucHJvdG90eXBlLmZyb21Db21wb25lbnRQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgcGFyYW1zLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGRlcHMgPSBjb3JlXzEuc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKHByb3ZpZGVyKTtcclxuICAgICAgICB2YXIgcHJvdmlkZXJGbiA9IGNvcmVfMS5pc0FycmF5KHByb3ZpZGVyKSA/IGNvcmVfMS50YWlsKHByb3ZpZGVyKSA6IHByb3ZpZGVyO1xyXG4gICAgICAgIHZhciByZXNvbHZhYmxlID0gbmV3IGNvcmVfMS5SZXNvbHZhYmxlKFwiXCIsIHByb3ZpZGVyRm4sIGRlcHMpO1xyXG4gICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldChjb250ZXh0KTtcclxuICAgIH07XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgY29tcG9uZW50J3MgbmFtZVxyXG4gICAgICpcclxuICAgICAqIFRoaXMgaW1wbGVtZW50cyByb3V0ZS10by1jb21wb25lbnQuXHJcbiAgICAgKiBJdCB3b3JrcyBieSByZXRyaWV2aW5nIHRoZSBjb21wb25lbnQgKGRpcmVjdGl2ZSkgbWV0YWRhdGEgZnJvbSB0aGUgaW5qZWN0b3IuXHJcbiAgICAgKiBJdCBhbmFseXNlcyB0aGUgY29tcG9uZW50J3MgYmluZGluZ3MsIHRoZW4gY29uc3RydWN0cyBhIHRlbXBsYXRlIHRoYXQgaW5zdGFudGlhdGVzIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiBUaGUgdGVtcGxhdGUgd2lyZXMgaW5wdXQgYW5kIG91dHB1dCBiaW5kaW5ncyB0byByZXNvbHZlcyBvciBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1aVZpZXcge29iamVjdH0gVGhlIHBhcmVudCB1aS12aWV3IChmb3IgYmluZGluZyBvdXRwdXRzIHRvIGNhbGxiYWNrcylcclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBSZXNvbHZlQ29udGV4dCAoZm9yIGJpbmRpbmcgb3V0cHV0cyB0byBjYWxsYmFja3MgcmV0dXJuZWQgZnJvbSByZXNvbHZlcylcclxuICAgICAqIEBwYXJhbSBjb21wb25lbnQge3N0cmluZ30gQ29tcG9uZW50J3MgbmFtZSBpbiBjYW1lbCBjYXNlLlxyXG4gICAgICogQHBhcmFtIGJpbmRpbmdzIEFuIG9iamVjdCBkZWZpbmluZyB0aGUgY29tcG9uZW50J3MgYmluZGluZ3M6IHtmb286ICc8J31cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRlbXBsYXRlIGFzIGEgc3RyaW5nOiBcIjxjb21wb25lbnQtbmFtZSBpbnB1dDE9Jzo6JHJlc29sdmUuZm9vJz48L2NvbXBvbmVudC1uYW1lPlwiLlxyXG4gICAgICovXHJcbiAgICBUZW1wbGF0ZUZhY3RvcnkucHJvdG90eXBlLm1ha2VDb21wb25lbnRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh1aVZpZXcsIGNvbnRleHQsIGNvbXBvbmVudCwgYmluZGluZ3MpIHtcclxuICAgICAgICBiaW5kaW5ncyA9IGJpbmRpbmdzIHx8IHt9O1xyXG4gICAgICAgIC8vIEJpbmQgb25jZSBwcmVmaXhcclxuICAgICAgICB2YXIgcHJlZml4ID0gYW5ndWxhcl8xLm5nLnZlcnNpb24ubWlub3IgPj0gMyA/IFwiOjpcIiA6IFwiXCI7XHJcbiAgICAgICAgLy8gQ29udmVydCB0byBrZWJvYiBuYW1lLiBBZGQgeC0gcHJlZml4IGlmIHRoZSBzdHJpbmcgc3RhcnRzIHdpdGggYHgtYCBvciBgZGF0YS1gXHJcbiAgICAgICAgdmFyIGtlYm9iID0gZnVuY3Rpb24gKGNhbWVsQ2FzZSkge1xyXG4gICAgICAgICAgICB2YXIga2Vib2JlZCA9IGNvcmVfMS5rZWJvYlN0cmluZyhjYW1lbENhc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gL14oeHxkYXRhKS0vLmV4ZWMoa2Vib2JlZCkgPyBcIngtXCIgKyBrZWJvYmVkIDoga2Vib2JlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVUcGwgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBpbnB1dC5uYW1lLCB0eXBlID0gaW5wdXQudHlwZTtcclxuICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0ga2Vib2IobmFtZSk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSB1aS12aWV3IGhhcyBhbiBhdHRyaWJ1dGUgd2hpY2ggbWF0Y2hlcyBhIGJpbmRpbmcgb24gdGhlIHJvdXRlZCBjb21wb25lbnRcclxuICAgICAgICAgICAgLy8gdGhlbiBwYXNzIHRoYXQgYXR0cmlidXRlIHRocm91Z2ggdG8gdGhlIHJvdXRlZCBjb21wb25lbnQgdGVtcGxhdGUuXHJcbiAgICAgICAgICAgIC8vIFByZWZlciB1aS12aWV3IHdpcmVkIG1hcHBpbmdzIHRvIHJlc29sdmUgZGF0YSwgdW5sZXNzIHRoZSByZXNvbHZlIHdhcyBleHBsaWNpdGx5IGJvdW5kIHVzaW5nIGBiaW5kaW5nczpgXHJcbiAgICAgICAgICAgIGlmICh1aVZpZXcuYXR0cihhdHRyTmFtZSkgJiYgIWJpbmRpbmdzW25hbWVdKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJOYW1lICsgXCI9J1wiICsgdWlWaWV3LmF0dHIoYXR0ck5hbWUpICsgXCInXCI7XHJcbiAgICAgICAgICAgIHZhciByZXNvbHZlTmFtZSA9IGJpbmRpbmdzW25hbWVdIHx8IG5hbWU7XHJcbiAgICAgICAgICAgIC8vIFByZS1ldmFsdWF0ZSB0aGUgZXhwcmVzc2lvbiBmb3IgXCJAXCIgYmluZGluZ3MgYnkgZW5jbG9zaW5nIGluIHt7IH19XHJcbiAgICAgICAgICAgIC8vIHNvbWUtYXR0cj1cInt7IDo6JHJlc29sdmUuc29tZVJlc29sdmVOYW1lIH19XCJcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdAJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZSArIFwiPSd7e1wiICsgcHJlZml4ICsgXCIkcmVzb2x2ZS5cIiArIHJlc29sdmVOYW1lICsgXCJ9fSdcIjtcclxuICAgICAgICAgICAgLy8gV2lyZSBcIiZcIiBjYWxsYmFja3MgdG8gcmVzb2x2ZXMgdGhhdCByZXR1cm4gYSBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJlc3VsdCBvZiB0aGUgcmVzb2x2ZSAoc2hvdWxkIGJlIGEgZnVuY3Rpb24pIGFuZCBhbm5vdGF0ZSBpdCB0byBnZXQgaXRzIGFyZ3VtZW50cy5cclxuICAgICAgICAgICAgLy8gc29tZS1hdHRyPVwiJHJlc29sdmUuc29tZVJlc29sdmVSZXN1bHROYW1lKGZvbywgYmFyKVwiXHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnJicpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBjb250ZXh0LmdldFJlc29sdmFibGUocmVzb2x2ZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZuID0gcmVzICYmIHJlcy5kYXRhO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBmbiAmJiBjb3JlXzEuc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKGZuKSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIGFycmF5IHN0eWxlIGluamVjdGlvbiwgaS5lLiwgWydmb28nLCBmdW5jdGlvbihmb28pIHt9XVxyXG4gICAgICAgICAgICAgICAgdmFyIGFycmF5SWR4U3RyID0gY29yZV8xLmlzQXJyYXkoZm4pID8gXCJbXCIgKyAoZm4ubGVuZ3RoIC0gMSkgKyBcIl1cIiA6ICcnO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJOYW1lICsgXCI9JyRyZXNvbHZlLlwiICsgcmVzb2x2ZU5hbWUgKyBhcnJheUlkeFN0ciArIFwiKFwiICsgYXJncy5qb2luKFwiLFwiKSArIFwiKSdcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzb21lLWF0dHI9XCI6OiRyZXNvbHZlLnNvbWVSZXNvbHZlTmFtZVwiXHJcbiAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZSArIFwiPSdcIiArIHByZWZpeCArIFwiJHJlc29sdmUuXCIgKyByZXNvbHZlTmFtZSArIFwiJ1wiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGF0dHJzID0gZ2V0Q29tcG9uZW50QmluZGluZ3MoY29tcG9uZW50KS5tYXAoYXR0cmlidXRlVHBsKS5qb2luKFwiIFwiKTtcclxuICAgICAgICB2YXIga2Vib2JOYW1lID0ga2Vib2IoY29tcG9uZW50KTtcclxuICAgICAgICByZXR1cm4gXCI8XCIgKyBrZWJvYk5hbWUgKyBcIiBcIiArIGF0dHJzICsgXCI+PC9cIiArIGtlYm9iTmFtZSArIFwiPlwiO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBUZW1wbGF0ZUZhY3Rvcnk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVGVtcGxhdGVGYWN0b3J5ID0gVGVtcGxhdGVGYWN0b3J5O1xyXG4vLyBHZXRzIGFsbCB0aGUgZGlyZWN0aXZlKHMpJyBpbnB1dHMgKCdAJywgJz0nLCBhbmQgJzwnKSBhbmQgb3V0cHV0cyAoJyYnKVxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnRCaW5kaW5ncyhuYW1lKSB7XHJcbiAgICB2YXIgY21wRGVmcyA9IGNvcmVfMS5zZXJ2aWNlcy4kaW5qZWN0b3IuZ2V0KG5hbWUgKyBcIkRpcmVjdGl2ZVwiKTsgLy8gY291bGQgYmUgbXVsdGlwbGVcclxuICAgIGlmICghY21wRGVmcyB8fCAhY21wRGVmcy5sZW5ndGgpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgY29tcG9uZW50IG5hbWVkICdcIiArIG5hbWUgKyBcIidcIik7XHJcbiAgICByZXR1cm4gY21wRGVmcy5tYXAoZ2V0QmluZGluZ3MpLnJlZHVjZShjb3JlXzEudW5uZXN0UiwgW10pO1xyXG59XHJcbi8vIEdpdmVuIGEgZGlyZWN0aXZlIGRlZmluaXRpb24sIGZpbmQgaXRzIG9iamVjdCBpbnB1dCBhdHRyaWJ1dGVzXHJcbi8vIFVzZSBkaWZmZXJlbnQgcHJvcGVydGllcywgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGRpcmVjdGl2ZSAoY29tcG9uZW50LCBiaW5kVG9Db250cm9sbGVyLCBub3JtYWwpXHJcbnZhciBnZXRCaW5kaW5ncyA9IGZ1bmN0aW9uIChkZWYpIHtcclxuICAgIGlmIChjb3JlXzEuaXNPYmplY3QoZGVmLmJpbmRUb0NvbnRyb2xsZXIpKVxyXG4gICAgICAgIHJldHVybiBzY29wZUJpbmRpbmdzKGRlZi5iaW5kVG9Db250cm9sbGVyKTtcclxuICAgIHJldHVybiBzY29wZUJpbmRpbmdzKGRlZi5zY29wZSk7XHJcbn07XHJcbi8vIGZvciBuZyAxLjIgc3R5bGUsIHByb2Nlc3MgdGhlIHNjb3BlOiB7IGlucHV0OiBcIj1mb29cIiB9XHJcbi8vIGZvciBuZyAxLjMgdGhyb3VnaCBuZyAxLjUsIHByb2Nlc3MgdGhlIGNvbXBvbmVudCdzIGJpbmRUb0NvbnRyb2xsZXI6IHsgaW5wdXQ6IFwiPWZvb1wiIH0gb2JqZWN0XHJcbnZhciBzY29wZUJpbmRpbmdzID0gZnVuY3Rpb24gKGJpbmRpbmdzT2JqKSB7IHJldHVybiBPYmplY3Qua2V5cyhiaW5kaW5nc09iaiB8fCB7fSlcclxuICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gW2tleSwgL14oWz08QCZdKVs/XT8oLiopLy5leGVjKGJpbmRpbmdzT2JqW2tleV0pXTsgfSlcclxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiBjb3JlXzEuaXNEZWZpbmVkKHR1cGxlKSAmJiBjb3JlXzEuaXNBcnJheSh0dXBsZVsxXSk7IH0pXHJcbiAgICAubWFwKGZ1bmN0aW9uICh0dXBsZSkgeyByZXR1cm4gKHsgbmFtZTogdHVwbGVbMV1bMl0gfHwgdHVwbGVbMF0sIHR5cGU6IHR1cGxlWzFdWzFdIH0pOyB9KTsgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGVGYWN0b3J5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL3RlbXBsYXRlRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqIEBtb2R1bGUgbmcxICovIC8qKiAqL1xyXG52YXIgYW5ndWxhcl8xID0gcmVxdWlyZShcIi4vYW5ndWxhclwiKTtcclxuLyoqIEBoaWRkZW4gKi9cclxuZnVuY3Rpb24gJFZpZXdTY3JvbGxQcm92aWRlcigpIHtcclxuICAgIHZhciB1c2VBbmNob3JTY3JvbGwgPSBmYWxzZTtcclxuICAgIHRoaXMudXNlQW5jaG9yU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHVzZUFuY2hvclNjcm9sbCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgdGhpcy4kZ2V0ID0gWyckYW5jaG9yU2Nyb2xsJywgJyR0aW1lb3V0JywgZnVuY3Rpb24gKCRhbmNob3JTY3JvbGwsICR0aW1lb3V0KSB7XHJcbiAgICAgICAgICAgIGlmICh1c2VBbmNob3JTY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAkYW5jaG9yU2Nyb2xsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoJGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAkdGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnRbMF0uc2Nyb2xsSW50b1ZpZXcoKTtcclxuICAgICAgICAgICAgICAgIH0sIDAsIGZhbHNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XTtcclxufVxyXG5hbmd1bGFyXzEubmcubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5wcm92aWRlcignJHVpVmlld1Njcm9sbCcsICRWaWV3U2Nyb2xsUHJvdmlkZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3U2Nyb2xsLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vYW5ndWxhci11aS1yb3V0ZXIvbGliL3ZpZXdTY3JvbGwuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBhbmd1bGFyIGZyb20gJ2FuZ3VsYXInO1xyXG5pbXBvcnQgYm9vdHN0cmFwIGZyb20gJ2FuZ3VsYXItdWktYm9vdHN0cmFwJztcclxuaW1wb3J0IHJvdXRlciBmcm9tICdhbmd1bGFyLXVpLXJvdXRlcic7XHJcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi9sYXlvdXQvbGF5b3V0Lm1vZHVsZSc7XHJcbmltcG9ydCB3aWRnZXRzIGZyb20gJy4vd2lkZ2V0L2NvbnN0YW50cy9jb25zdGFudHMubW9kdWxlJztcclxuXHJcblxyXG5cclxuYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFtcclxuICAgIHJvdXRlcixcclxuICAgIGJvb3RzdHJhcCxcclxuICAgIGxheW91dCxcclxuICAgIHdpZGdldHNcclxuXSkuY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyLCAkbG9jYXRpb25Qcm92aWRlcil7XHJcblxyXG4gICAgLy8kbG9jYXRpb25Qcm92aWRlci5oYXNoUHJlZml4KCcnKTtcclxuXHJcbiAgICB2YXIgc3RhdGVzID0gW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0hvbWUnLFxyXG4gICAgICAgICAgICB1cmw6ICcvJyxcclxuICAgICAgICAgICAgY29tcG9uZW50OiAnbHpIb21lJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ29udGFjdCcsXHJcbiAgICAgICAgICAgIHVybDogJy9jb250YWN0JyxcclxuICAgICAgICAgICAgY29tcG9uZW50OiAnbHpDb250YWN0J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQWJvdXQnLFxyXG4gICAgICAgICAgICB1cmw6ICcvYWJvdXQnLFxyXG4gICAgICAgICAgICBjb21wb25lbnQ6ICdsekFib3V0J1xyXG4gICAgICAgIH1cclxuICAgIF1cclxuXHJcbiAgICBzdGF0ZXMuZm9yRWFjaChmdW5jdGlvbihzdGF0ZSl7XHJcbiAgICAgICAgJHN0YXRlUHJvdmlkZXIuc3RhdGUoc3RhdGUpICAgICAgICAgICAgXHJcbiAgICB9KTtcclxuICAgIH0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC5tb2R1bGUuanMiLCJpbXBvcnQgdGVtcCBmcm9tICcuL2hlYWRlci5odG1sJztcclxuaW1wb3J0IGN0cmwgZnJvbSAnLi9oZWFkZXIuY29udHJvbGxlcic7XHJcblxyXG5leHBvcnQgbGV0IGhlYWRlckNvbXBvbmVudCA9IHtcclxuICAgIGJpbmRpbmdzOiB7XHJcbiAgICAgICAgLy9pbnB1dHNcclxuICAgICAgICB0aXRsZTogJ0AnLFxyXG4gICAgfSxcclxuICAgIHRlbXBsYXRlOiB0ZW1wLFxyXG4gICAgY29udHJvbGxlcjogY3RybFxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGF5b3V0L2hlYWRlci9oZWFkZXIuY29tcG9uZW50LmpzIiwiaW1wb3J0IHtoZWFkZXJDb21wb25lbnR9IGZyb20gJy4vaGVhZGVyLmNvbXBvbmVudCc7XHJcbmltcG9ydCBoZWFkZXJDdHJsIGZyb20gJy4vaGVhZGVyLmNvbnRyb2xsZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYW5ndWxhci5tb2R1bGUoJ2xheW91dC5oZWFkZXInLCBbXSlcclxuICAgIC5jb250cm9sbGVyKCdoZWFkZXJDdHJsJywgaGVhZGVyQ3RybClcclxuICAgIC5jb21wb25lbnQoJ2x6SGVhZGVyJywgaGVhZGVyQ29tcG9uZW50KVxyXG4gICAgLm5hbWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGF5b3V0L2hlYWRlci9oZWFkZXIubW9kdWxlLmpzIiwiaW1wb3J0IGN0cmwgZnJvbSAnLi9hYm91dC5jb250cm9sbGVyJztcclxuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4vYWJvdXQuaHRtbCc7XHJcblxyXG5leHBvcnQgY29uc3QgYWJvdXRDb21wb25lbnQgPSB7XHJcbiAgICBiaW5kaW5nczoge30sXHJcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICBjb250cm9sbGVyOiBjdHJsXHJcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGF5b3V0L25hdmlnYXRpb24vYWJvdXQvYWJvdXQuY29tcG9uZW50LmpzIiwiaW1wb3J0IHthYm91dENvbXBvbmVudH0gZnJvbSAnLi9hYm91dC5jb21wb25lbnQnO1xyXG5pbXBvcnQgY3RybCBmcm9tICcuL2Fib3V0LmNvbnRyb2xsZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYW5ndWxhci5tb2R1bGUoJ2xheW91dC5uYXZpZ2F0aW9uLmFib3V0JywgW10pXHJcbiAgICAuY29udHJvbGxlcignYWJvdXRDdHJsJywgY3RybClcclxuICAgIC5jb21wb25lbnQoJ2x6QWJvdXQnLCBhYm91dENvbXBvbmVudClcclxuICAgIC5uYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xheW91dC9uYXZpZ2F0aW9uL2Fib3V0L2Fib3V0Lm1vZHVsZS5qcyIsImltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuL2NvbnRhY3QuaHRtbCc7XHJcbmltcG9ydCBjdHJsIGZyb20gJy4vY29udGFjdC5jb250cm9sbGVyJztcclxuXHJcbmV4cG9ydCBjb25zdCBjb250YWN0Q29tcG9uZW50ID0ge1xyXG4gICAgYmluZGluZ3MgOiB7fSxcclxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcclxuICAgIGNvbnRyb2xsZXI6IGN0cmxcclxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9sYXlvdXQvbmF2aWdhdGlvbi9jb250YWN0L2NvbnRhY3QuY29tcG9uZW50LmpzIiwiaW1wb3J0IHtjb250YWN0Q29tcG9uZW50fSBmcm9tICcuL2NvbnRhY3QuY29tcG9uZW50JztcclxuaW1wb3J0IGNvbnRyb2xsZXIgZnJvbSAnLi9jb250YWN0LmNvbnRyb2xsZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYW5ndWxhci5tb2R1bGUoJ2xheW91dC5uYXZpZ2F0aW9uLmNvbnRhY3QnLCBbXSlcclxuICAgIC5jb250cm9sbGVyKCdjb250YWN0Q3RybCcsIGNvbnRyb2xsZXIpXHJcbiAgICAuY29tcG9uZW50KCdsekNvbnRhY3QnLCBjb250YWN0Q29tcG9uZW50KVxyXG4gICAgLm5hbWU7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xheW91dC9uYXZpZ2F0aW9uL2NvbnRhY3QvY29udGFjdC5tb2R1bGUuanMiLCJpbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi9ob21lLmh0bWwnO1xyXG5pbXBvcnQgY3RybCBmcm9tICcuL2hvbWUuY29udHJvbGxlcic7XHJcblxyXG5leHBvcnQgY29uc3QgaG9tZUNvbXBvbmVudCA9IHtcclxuICAgIGJpbmRpbmdzOiB7fSxcclxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcclxuICAgIGNvbnRyb2xsZXI6IGN0cmxcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xheW91dC9uYXZpZ2F0aW9uL2hvbWUvaG9tZS5jb21wb25lbnQuanMiLCJpbXBvcnQge2hvbWVDb21wb25lbnR9IGZyb20gJy4vaG9tZS5jb21wb25lbnQnO1xyXG5pbXBvcnQgY3RybCBmcm9tICcuL2hvbWUuY29udHJvbGxlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhbmd1bGFyLm1vZHVsZSgnbGF5b3V0Lm5hdmlnYXRpb24uaG9tZScsW10pXHJcbiAgICAuY29tcG9uZW50KCdsekhvbWUnLCBob21lQ29tcG9uZW50KVxyXG4gICAgLmNvbnRyb2xsZXIoJ2hvbWVDdHJsJywgY3RybClcclxuICAgIC5uYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xheW91dC9uYXZpZ2F0aW9uL2hvbWUvaG9tZS5tb2R1bGUuanMiLCJpbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi9uYXZpZ2F0aW9uLmh0bWwnO1xyXG5pbXBvcnQgY3RybCBmcm9tICcuL25hdmlnYXRpb24uY29udHJvbGxlcic7XHJcblxyXG5leHBvcnQgY29uc3QgbmF2aWdhdGlvbkNvbXBvbmVudCA9IHtcclxuICAgIGJpbmRpbmdzIDoge30sXHJcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICBjb250cm9sbGVyOiBjdHJsXHJcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGF5b3V0L25hdmlnYXRpb24vbmF2aWdhdGlvbi5jb21wb25lbnQuanMiLCJpbXBvcnQge25hdmlnYXRpb25Db21wb25lbnR9IGZyb20gJy4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xyXG5pbXBvcnQgY29udHJvbGxlciBmcm9tICcuL25hdmlnYXRpb24uY29udHJvbGxlcic7XHJcbmltcG9ydCBjb250YWN0IGZyb20gJy4vY29udGFjdC9jb250YWN0Lm1vZHVsZSc7XHJcbmltcG9ydCBhYm91dCBmcm9tICcuL2Fib3V0L2Fib3V0Lm1vZHVsZSc7XHJcbmltcG9ydCBob21lIGZyb20gJy4vaG9tZS9ob21lLm1vZHVsZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhbmd1bGFyLm1vZHVsZSgnbGF5b3V0Lm5hdmlnYXRpb24nLCBcclxuICAgIFtcclxuICAgICAgICBjb250YWN0LFxyXG4gICAgICAgIGFib3V0LFxyXG4gICAgICAgIGhvbWVcclxuICAgIF0pXHJcbiAgICAuY29udHJvbGxlcignbmF2aWdhdGlvbkN0cmwnLCBjb250cm9sbGVyKVxyXG4gICAgLmNvbXBvbmVudCgnbHpOYXZpZ2F0aW9uJywgbmF2aWdhdGlvbkNvbXBvbmVudClcclxuICAgIC5uYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xheW91dC9uYXZpZ2F0aW9uL25hdmlnYXRpb24ubW9kdWxlLmpzIiwiZXhwb3J0IGNvbnN0IHN0YXRlcyA9IHtcclxuICAgIG1haW5OYXY6IFsnSG9tZScsJ0NvbnRhY3QnLCAnQWJvdXQnXVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vd2lkZ2V0L2NvbnN0YW50cy9zdGF0ZXMvc3RhdGVzLmNvbnN0YW50cy5qcyIsImltcG9ydCB7c3RhdGVzfSBmcm9tICcuL3N0YXRlcy5jb25zdGFudHMnO1xyXG4gXHJcblxyXG5leHBvcnQgZGVmYXVsdCBhbmd1bGFyLm1vZHVsZSgnd2lkZ2V0LmNvbnN0YW50cy5zdGF0ZXMnLFtdKVxyXG4gICAgLmNvbnN0YW50KCdzdGF0ZXMnLCBzdGF0ZXMpXHJcbiAgICAubmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi93aWRnZXQvY29uc3RhbnRzL3N0YXRlcy9zdGF0ZXMubW9kdWxlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxoMT48YSB1aS1zcmVmPVxcXCJIb21lXFxcIj5SZXN1bWU8L2E+PC9oMT5cXHJcXG5cXHJcXG5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xheW91dC9oZWFkZXIvaGVhZGVyLmh0bWxcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxyXFxuPGRpdiBjbGFzcz1cXFwiYWJvdXQtYm9keVxcXCI+XFxyXFxuICAgIDxoMT5BYm91dDwvaDE+XFxyXFxuPC9kaXY+XFxyXFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sYXlvdXQvbmF2aWdhdGlvbi9hYm91dC9hYm91dC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCIgaWQ9XFxcImNvbnRhY3RcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcbiAgICAgICAgPGZvcm0+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiTmFtZVxcXCIgcmVxdWlyZWQgLz5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImVtYWlsXFxcIiBwbGFjZWhvbGRlcj1cXFwiRW1haWxcXFwiIHJlcXVpcmVkIC8+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBuYW1lPVxcXCJjb21tZW50c1xcXCIgcGxhY2Vob2xkZXI9XFxcIk1lc3NhZ2VcXFwiIHJlcXVpcmVkPjwvdGV4dGFyZWE+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiIHZhbHVlPVxcXCJHZXQgaW4gQ29udGFjdCFcXFwiIC8+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Zvcm0+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZGl2PlxcclxcblxcclxcblwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGF5b3V0L25hdmlnYXRpb24vY29udGFjdC9jb250YWN0Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXHJcXG4gICAgPHA+V2VsY29tZSB0byBteSBob21lZ3Jvd24gcmVzdW1lIHNpZ2h0LiBJIGtub3cgTGlua2VkSW4gaXMgZm9yIHRoZSBjb29sIGtpZHMgc28gSSdsbCBwcm92aWRlIG15IExpbmtlZEluIHByb2ZpbGUgYnV0IHBsZWFzZSBjaGVjayBvdXQgbXkgY29vbCBwcm9qZWN0cyE8L3A+XFxyXFxuPC9kaXY+XFxyXFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9sYXlvdXQvbmF2aWdhdGlvbi9ob21lL2hvbWUuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8bmF2IGNsYXNzPVxcXCJuYXZiYXIgbmF2YmFyLWRlZmF1bHRcXFwiIHJvbGU9XFxcIm5hdmlnYXRpb25cXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaGVhZGVyXFxcIj5cXHJcXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwibmF2YmFyLXRvZ2dsZVxcXCIgbmctY2xpY2s9XFxcImlzTmF2Q29sbGFwc2VkID0gIWlzTmF2Q29sbGFwc2VkXFxcIj5cXHJcXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+VG9nZ2xlIG5hdmlnYXRpb248L3NwYW4+XFxyXFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxyXFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxyXFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24tYmFyXFxcIj48L3NwYW4+XFxyXFxuICAgICAgICA8L2J1dHRvbj5cXHJcXG4gICAgICAgIDxhIGNsYXNzPVxcXCJuYXZiYXItYnJhbmRcXFwiIHVpLXNyZWY9XFxcIkhvbWVcXFwiPlRhbSBNYWk8L2E+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2xsYXBzZSBuYXZiYXItY29sbGFwc2UgcHVzaC1yaWdodFxcXCIgdWliLWNvbGxhcHNlPVxcXCJpc05hdkNvbGxhcHNlZFxcXCI+XFxyXFxuICAgICAgICA8dWwgY2xhc3M9XFxcIm5hdiBuYXZiYXItbmF2XFxcIiBuZy1yZXBlYXQ9XFxcIm5hdkl0ZW0gaW4gJGN0cmwubmF2SXRlbXNcXFwiPlxcclxcbiAgICAgICAgICAgIDxsaT48YSB1aS1zcmVmPVxcXCJ7e25hdkl0ZW19fVxcXCI+e3tuYXZJdGVtfX08L2E+PC9saT5cXHJcXG4gICAgICAgIDwvdWw+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvbmF2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGF5b3V0L25hdmlnYXRpb24vbmF2aWdhdGlvbi5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==